(function(/*! Brunch !*/) {
  'use strict';

  var globals = typeof window !== 'undefined' ? window : global;
  if (typeof globals.require === 'function') return;

  var modules = {};
  var cache = {};

  var has = function(object, name) {
    return ({}).hasOwnProperty.call(object, name);
  };

  var expand = function(root, name) {
    var results = [], parts, part;
    if (/^\.\.?(\/|$)/.test(name)) {
      parts = [root, name].join('/').split('/');
    } else {
      parts = name.split('/');
    }
    for (var i = 0, length = parts.length; i < length; i++) {
      part = parts[i];
      if (part === '..') {
        results.pop();
      } else if (part !== '.' && part !== '') {
        results.push(part);
      }
    }
    return results.join('/');
  };

  var dirname = function(path) {
    return path.split('/').slice(0, -1).join('/');
  };

  var localRequire = function(path) {
    return function(name) {
      var dir = dirname(path);
      var absolute = expand(dir, name);
      return globals.require(absolute, path);
    };
  };

  var initModule = function(name, definition) {
    var module = {id: name, exports: {}};
    cache[name] = module;
    definition(module.exports, localRequire(name), module);
    return module.exports;
  };

  var require = function(name, loaderPath) {
    var path = expand(name, '.');
    if (loaderPath == null) loaderPath = '/';

    if (has(cache, path)) return cache[path].exports;
    if (has(modules, path)) return initModule(path, modules[path]);

    var dirIndex = expand(path, './index');
    if (has(cache, dirIndex)) return cache[dirIndex].exports;
    if (has(modules, dirIndex)) return initModule(dirIndex, modules[dirIndex]);

    throw new Error('Cannot find module "' + name + '" from '+ '"' + loaderPath + '"');
  };

  var define = function(bundle, fn) {
    if (typeof bundle === 'object') {
      for (var key in bundle) {
        if (has(bundle, key)) {
          modules[key] = bundle[key];
        }
      }
    } else {
      modules[bundle] = fn;
    }
  };

  var list = function() {
    var result = [];
    for (var item in modules) {
      if (has(modules, item)) {
        result.push(item);
      }
    }
    return result;
  };

  globals.require = require;
  globals.require.define = define;
  globals.require.register = define;
  globals.require.list = list;
  globals.require.brunch = true;
})();
require.register("test/app_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');
require('models/host_component');
require('models/stack_service_component');
var modelSetup = require('test/init_model_test');

describe('App', function () {

  describe('#stackVersionURL', function () {

    App.QuickViewLinks.reopen({
      loadTags: function () {
      }
    });
    App.set('defaultStackVersion', "HDP-1.2.2");
    App.set('currentStackVersion', "HDP-1.2.2");

    var testCases = [
      {
        title: 'if currentStackVersion and defaultStackVersion are empty then stackVersionURL should contain prefix',
        currentStackVersion: '',
        defaultStackVersion: '',
        result: '/stacks/HDP/versions/'
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/versions/1.3.1"',
        currentStackVersion: 'HDP-1.3.1',
        defaultStackVersion: '',
        result: '/stacks/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion is "HDP-1.3.1" then stackVersionURL should be "/stacks/HDP/versions/1.3.1"',
        currentStackVersion: '',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/versions/1.3.1'
      },
      {
        title: 'if defaultStackVersion and currentStackVersion are different then stackVersionURL should have currentStackVersion value',
        currentStackVersion: 'HDP-1.3.2',
        defaultStackVersion: 'HDP-1.3.1',
        result: '/stacks/HDP/versions/1.3.2'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('defaultStackVersion', test.defaultStackVersion);
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('stackVersionURL')).to.equal(test.result);
        App.set('defaultStackVersion', "HDP-1.2.2");
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#falconServerURL', function () {

    var testCases = [
      {
        title: 'No services installed, url should be empty',
        service: Em.A([]),
        result: ''
      },
      {
        title: 'FALCON is not installed, url should be empty',
        service: Em.A([
          {
            serviceName: 'HDFS'
          }
        ]),
        result: ''
      },
      {
        title: 'FALCON is installed, url should be "host1"',
        service: Em.A([
          Em.Object.create({
            serviceName: 'FALCON',
            hostComponents: [
              Em.Object.create({
                componentName: 'FALCON_SERVER',
                hostName: 'host1'
              })
            ]
          })
        ]),
        result: 'host1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        sinon.stub(App.Service, 'find', function () {
          return test.service;
        });
        expect(App.get('falconServerURL')).to.equal(test.result);
        App.Service.find.restore();
      });
    });
  });

  describe('#currentStackVersionNumber', function () {

    var testCases = [
      {
        title: 'if currentStackVersion is empty then currentStackVersionNumber should be empty',
        currentStackVersion: '',
        result: ''
      },
      {
        title: 'if currentStackVersion is "HDP-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDP-1.3.1',
        result: '1.3.1'
      },
      {
        title: 'if currentStackVersion is "HDPLocal-1.3.1" then currentStackVersionNumber should be "1.3.1',
        currentStackVersion: 'HDPLocal-1.3.1',
        result: '1.3.1'
      }
    ];
    before(function () {
      App.set('defaultStackVersion', '');
    });
    after(function () {
      App.set('defaultStackVersion', 'HDP-2.0.5');
    });
    testCases.forEach(function (test) {
      it(test.title, function () {
        App.set('currentStackVersion', test.currentStackVersion);
        expect(App.get('currentStackVersionNumber')).to.equal(test.result);
        App.set('currentStackVersion', "HDP-1.2.2");
      });
    });
  });

  describe('#isHaEnabled when HDFS is installed:', function () {

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          {
            id: 'HDFS',
            serviceName: 'HDFS'
          }
        ];
      });
    });

    afterEach(function () {
      App.Service.find.restore();
    });

    it('if hadoop stack version higher than 2 then isHaEnabled should be true', function () {
      App.propertyDidChange('isHaEnabled');
      expect(App.get('isHaEnabled')).to.equal(true);
    });
    it('if cluster has SECONDARY_NAMENODE then isHaEnabled should be false', function () {
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.propertyDidChange('isHaEnabled');
      expect(App.get('isHaEnabled')).to.equal(false);
    });
  });

  describe('#isHaEnabled when HDFS is not installed:', function () {

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          {
            id: 'ZOOKEEPER',
            serviceName: 'ZOOKEEPER'
          }
        ];
      });
    });

    afterEach(function () {
      App.Service.find.restore();
    });

    it('if hadoop stack version higher than 2 but HDFS not installed then isHaEnabled should be false', function () {
      App.set('currentStackVersion', 'HDP-2.1');
      expect(App.get('isHaEnabled')).to.equal(false);
      App.set('currentStackVersion', "HDP-1.2.2");
    });

  });


  describe('#services', function () {
    var stackServices = [
      Em.Object.create({
        serviceName: 'S1',
        isClientOnlyService: true
      }),
      Em.Object.create({
        serviceName: 'S2',
        hasClient: true
      }),
      Em.Object.create({
        serviceName: 'S3',
        hasMaster: true
      }),
      Em.Object.create({
        serviceName: 'S4',
        hasSlave: true
      }),
      Em.Object.create({
        serviceName: 'S5',
        isNoConfigTypes: true
      }),
      Em.Object.create({
        serviceName: 'S6',
        isMonitoringService: true
      }),
      Em.Object.create({
        serviceName: 'S7'
      })
    ];

    it('distribute services by categories', function () {
      sinon.stub(App.StackService, 'find', function () {
        return stackServices;
      });

      expect(App.get('services.all')).to.eql(['S1', 'S2', 'S3', 'S4', 'S5', 'S6', 'S7']);
      expect(App.get('services.clientOnly')).to.eql(['S1']);
      expect(App.get('services.hasClient')).to.eql(['S2']);
      expect(App.get('services.hasMaster')).to.eql(['S3']);
      expect(App.get('services.hasSlave')).to.eql(['S4']);
      expect(App.get('services.noConfigTypes')).to.eql(['S5']);
      expect(App.get('services.monitoring')).to.eql(['S6']);
      App.StackService.find.restore();
    });
  });


  describe('#components', function () {
    var i = 0,
      testCases = [
        {
          key: 'allComponents',
          data: [
            Em.Object.create({
              componentName: 'C1'
            })
          ],
          result: ['C1']
        },
        {
          key: 'reassignable',
          data: [
            Em.Object.create({
              componentName: 'C2',
              isReassignable: true
            })
          ],
          result: ['C2']
        },
        {
          key: 'restartable',
          data: [
            Em.Object.create({
              componentName: 'C3',
              isRestartable: true
            })
          ],
          result: ['C3']
        },
        {
          key: 'deletable',
          data: [
            Em.Object.create({
              componentName: 'C4',
              isDeletable: true
            })
          ],
          result: ['C4']
        },
        {
          key: 'rollinRestartAllowed',
          data: [
            Em.Object.create({
              componentName: 'C5',
              isRollinRestartAllowed: true
            })
          ],
          result: ['C5']
        },
        {
          key: 'decommissionAllowed',
          data: [
            Em.Object.create({
              componentName: 'C6',
              isDecommissionAllowed: true
            })
          ],
          result: ['C6']
        },
        {
          key: 'refreshConfigsAllowed',
          data: [
            Em.Object.create({
              componentName: 'C7',
              isRefreshConfigsAllowed: true
            })
          ],
          result: ['C7']
        },
        {
          key: 'addableToHost',
          data: [
            Em.Object.create({
              componentName: 'C8',
              isAddableToHost: true
            })
          ],
          result: ['C8']
        },
        {
          key: 'addableMasterInstallerWizard',
          data: [
            Em.Object.create({
              componentName: 'C9',
              isMasterAddableInstallerWizard: true,
              showAddBtnInInstall: true
            })
          ],
          result: ['C9']
        },
        {
          key: 'multipleMasters',
          data: [
            Em.Object.create({
              componentName: 'C10',
              isMasterWithMultipleInstances: true
            })
          ],
          result: ['C10']
        },
        {
          key: 'slaves',
          data: [
            Em.Object.create({
              componentName: 'C11',
              isSlave: true
            })
          ],
          result: ['C11']
        },
        {
          key: 'clients',
          data: [
            Em.Object.create({
              componentName: 'C12',
              isClient: true
            })
          ],
          result: ['C12']
        }
      ];

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return testCases[i].data;
      });
    });

    afterEach(function () {
      i++;
      App.StackServiceComponent.find.restore();
    });

    testCases.forEach(function (test) {
      it(test.key + ' should contain ' + test.result, function () {
        expect(App.get('components.' + test.key)).to.eql(test.result);
      })
    })
  });

  describe("#isAccessible()", function() {

    beforeEach(function () {
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function () {
      this.mock.restore();
    });

    it("Upgrade running, element should be blocked", function() {
      App.set('upgradeState', "IN_PROGRESS");
      App.set('isAdmin', true);
      expect(App.isAccessible('ADMIN')).to.be.false;
    });
    it("Upgrade running, upgrade element should not be blocked", function() {
      App.set('upgradeState', "IN_PROGRESS");
      App.set('isAdmin', true);
      expect(App.isAccessible('upgrade_ADMIN')).to.be.true;
    });
    it("Upgrade running, upgrade element should not be blocked", function() {
      App.set('upgradeState', "IN_PROGRESS");
      App.set('isAdmin', true);
      App.set('supports.opsDuringRollingUpgrade', true);
      expect(App.isAccessible('ADMIN')).to.be.true;
      App.set('supports.opsDuringRollingUpgrade', false);
    });
    it("ADMIN type, isAdmin true", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', true);
      expect(App.isAccessible('ADMIN')).to.be.true;
    });
    it("ADMIN type, isAdmin false", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', false);
      expect(App.isAccessible('ADMIN')).to.be.false;
    });
    it("MANAGER type, isOperator false", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', true);
      App.set('isOperator', false);
      expect(App.isAccessible('MANAGER')).to.be.true;
    });
    it("MANAGER type, isAdmin false", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', false);
      App.set('isOperator', true);
      expect(App.isAccessible('MANAGER')).to.be.true;
    });
    it("MANAGER type, isAdmin and isOperator false", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', false);
      App.set('isOperator', false);
      expect(App.isAccessible('MANAGER')).to.be.false;
    });
    it("OPERATOR type, isOperator false", function() {
      App.set('upgradeState', "INIT");
      App.set('isOperator', false);
      expect(App.isAccessible('OPERATOR')).to.be.false;
    });
    it("OPERATOR type, isOperator false", function() {
      App.set('upgradeState', "INIT");
      App.set('isOperator', true);
      expect(App.isAccessible('OPERATOR')).to.be.true;
    });
    it("ONLY_ADMIN type, isAdmin false", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', false);
      expect(App.isAccessible('ONLY_ADMIN')).to.be.false;
    });
    it("ONLY_ADMIN type, isAdmin true, isOperator false", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', true);
      App.set('isOperator', false);
      expect(App.isAccessible('ONLY_ADMIN')).to.be.true;
    });
    it("ONLY_ADMIN type, isAdmin true, isOperator true", function() {
      App.set('upgradeState', "INIT");
      App.set('isAdmin', true);
      App.set('isOperator', true);
      expect(App.isAccessible('ONLY_ADMIN')).to.be.false;
    });
    it("unknown type", function() {
      App.set('upgradeState', "INIT");
      expect(App.isAccessible('')).to.be.false;
    });
    it("ONLY_ADMIN type, isAdmin true, isOperator true, isSuspended true", function() {
      App.set('upgradeState', "ABORTED");
      App.set('isAdmin', true);
      App.set('isOperator', false);
      this.mock.returns(true);
      expect(App.isAccessible('ONLY_ADMIN')).to.be.true;
    });
  });

  describe('#isHadoop20Stack', function () {

    Em.A([
      {
        currentStackVersion: 'HDP-2.2',
        e: false
      },
        {
          currentStackVersion: 'HDP-2.1',
          e: false
        },
        {
          currentStackVersion: 'HDP-2.0',
          e: true
        },
        {
          currentStackVersion: 'HDP-2.0.0',
          e: true
        },
        {
          currentStackVersion: 'HDP-2.0.6',
          e: true
        },
        {
          currentStackVersion: 'HDPLocal-2.2',
          e: false
        },
        {
          currentStackVersion: 'HDPLocal-2.1',
          e: false
        },
        {
          currentStackVersion: 'HDPLocal-2.0',
          e: true
        },
        {
          currentStackVersion: 'HDPLocal-2.0.0',
          e: true
        },
        {
          currentStackVersion: 'HDPLocal-2.0.6',
          e: true
        }
    ]).forEach(function (test) {
        it('for ' + test.currentStackVersion + ' isHadoop20Stack = ' + test.e.toString(), function () {
          App.set('currentStackVersion', test.currentStackVersion);
          expect(App.get('isHadoop20Stack')).to.equal(test.e);
        });
      });

  });

  describe('#upgradeIsRunning', function () {

    Em.A([
        {
          upgradeState: 'IN_PROGRESS',
          m: 'should be true (1)',
          e: true
        },
        {
          upgradeState: 'HOLDING',
          m: 'should be true (2)',
          e: true
        },
        {
          upgradeState: 'FAKE',
          m: 'should be false',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          App.set('upgradeState', test.upgradeState);
          expect(App.get('upgradeIsRunning')).to.equal(test.e);
        });
      });

  });

  describe('#upgradeAborted', function () {

    var cases = [
      {
        upgradeState: 'INIT',
        upgradeAborted: false
      },
      {
        upgradeState: 'INIT',
        upgradeAborted: false
      },
      {
        upgradeState: 'ABORTED',
        upgradeAborted: true
      }
    ];

    cases.forEach(function (item) {
      it(item.upgradeState + ", ", function () {
        App.set('upgradeState', item.upgradeState);
        App.propertyDidChange('upgradeAborted');
        expect(App.get('upgradeAborted')).to.equal(item.upgradeAborted);
      });
    });
  });

  describe('#upgradeIsNotFinished', function () {

    beforeEach(function () {
      this.mock = sinon.stub(App.router, 'get');
    });
    afterEach(function () {
      this.mock.restore();
    });

    var cases = [
      {
        upgradeState: 'INIT',
        isSuspended: false,
        upgradeIsNotFinished: false
      },
      {
        upgradeState: 'IN_PROGRESS',
        isSuspended: false,
        upgradeIsNotFinished: true
      },
      {
        upgradeState: 'HOLDING',
        isSuspended: false,
        upgradeIsNotFinished: true
      },
      {
        upgradeState: 'HOLDING_TIMEDOUT',
        isSuspended: false,
        upgradeIsNotFinished: true
      },
      {
        upgradeState: 'ABORTED',
        isSuspended: false,
        upgradeIsNotFinished: true
      },
      {
        upgradeState: 'ABORTED',
        isSuspended: true,
        upgradeIsNotFinished: true
      }
    ];

    cases.forEach(function (item) {
      it(item.upgradeState, function () {
        App.set('upgradeState', item.upgradeState);
        this.mock.returns(item.isSuspended);
        App.propertyDidChange('upgradeIsNotFinished');
        expect(App.get('upgradeIsNotFinished')).to.equal(item.upgradeIsNotFinished);
      });
    });
  });
});

});

;require.register("test/controllers/application_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');

describe('App.ApplicationController', function () {

  var applicationController = App.ApplicationController.create();

  describe('#showAboutPopup', function() {
    var dataToShowRes = {};
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', function(dataToShow){
        dataToShowRes = dataToShow;
      });
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it ('Should send correct data to popup', function() {
      applicationController.showAboutPopup();
      dataToShowRes = JSON.parse(JSON.stringify(dataToShowRes));
      expect(dataToShowRes).to.eql({
        "header": "About",
        "secondary": false
      });
    });
  });

  describe('#clusterName', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns('cl1');
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return cluster name', function() {
      expect(applicationController.get('clusterName')).to.equal('cl1');
    });
  });



  describe('#startKeepAlivePoller', function() {
    it ('Should change run poller state', function() {
      applicationController.set('isPollerRunning', false);
      applicationController.startKeepAlivePoller();
      expect(applicationController.get('isPollerRunning')).to.be.true;
    });
  });

  describe('#goToAdminView', function() {
    var result;
    beforeEach(function () {
      sinon.stub(App.router, 'route', function(data) {
        result = data;
        return false;
      });
    });
    afterEach(function () {
      App.router.route.restore();
    });
    it ('Should call route once', function() {
      applicationController.goToAdminView();
      expect(result).to.be.equal('adminView');
    });
  });

  describe('#getStack', function() {
    var res;
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', function(data) {
        res = data;
      });
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it ('Should return send value', function() {
      var callback = {
        'callback': true
      };
      applicationController.getStack(callback);
      res = JSON.parse(JSON.stringify(res));
      expect(res).to.be.eql({
        "name": "router.login.clusters",
        "sender": {
          "isPollerRunning": true
        },
        "callback": {
          "callback": true
        }
      });
    });
  });

  describe('#clusterDisplayName', function() {
    it ('Should return cluster display name', function() {
      applicationController.set('clusterName', '');
      expect(applicationController.get('clusterDisplayName')).to.equal('mycluster');
    });
  });

  describe('#isClusterDataLoaded', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns('cl1');
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return true, when data loaded', function() {
      expect(applicationController.get('isClusterDataLoaded')).to.be.equal('cl1');
    });
  });

});

});

;require.register("test/controllers/experimental_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/experimental');

var controller,
  transition,
  supports = {},
  transitionStubbed = false,
  controllerSupports = [
    Em.Object.create({
      name: 'sup0',
      selected: true
    }),
    Em.Object.create({
      name: 'sup1',
      selected: false
    })
  ],
  saveObject = {};

describe('App.ExperimentalController', function () {

  before(function () {
    controllerSupports.forEach(function(item) {
      supports[item.get('name')] = item.get('selected');
    });
    sinon.stub(App, 'get', function(k) {
      if (k === 'supports') return supports;
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    controller = App.ExperimentalController.create();
  });

  after(function () {
    App.get.restore();
  });

  describe('#supports', function () {
    it('should take data from App.supports', function () {
      expect(controller.get('supports')).to.eql(controllerSupports);
    });
  });

  describe('#doSave', function () {

    before(function () {
      sinon.stub(Ember, 'set', function (p, v) {
        if (p.indexOf('App.supports.' != -1)) {
          p = p.replace('App.supports.', '');
          saveObject[p] = v;
          return;
        }
        return Ember.set(p, v);
      });
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    after(function () {
      Em.set.restore();
      App.router.transitionTo.restore();
    });

    it('should pass data to App.supports', function () {
      controller.set('supports', controllerSupports);
      controller.doSave();
      expect(saveObject).to.eql(supports);
    });

  });

});

});

;require.register("test/controllers/global/background_operations_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('config');
require('utils/updater');
require('utils/ajax/ajax');

require('models/host_component');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/host_progress_popup');

describe('App.BackgroundOperationsController', function () {

  var controller = App.BackgroundOperationsController.create({
    isInitLoading: Em.K
  });

  describe('#getQueryParams', function () {
    /**
     * Predefined data
     *
     */
    App.set('clusterName', 'testName');
    App.bgOperationsUpdateInterval = 100;

    var tests = Em.A([
      {
        levelInfo: Em.Object.create({
          name: 'REQUESTS_LIST',
          requestId: null,
          taskId: null,
          sync: false
        }),
        e: {
          name: 'background_operations.get_most_recent',
          successCallback: 'callBackForMostRecent',
          data: {
            'operationsCount': 10
          }
        },
        response: {items: []},
        m: '"Get Most Recent"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASK_DETAILS',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_task',
          successCallback: 'callBackFilteredByTask',
          data: {
            taskId: 1,
            requestId: 1
          }
        },
        response: {items: {Tasks: {request_id: 0}}},
        m: '"Filtered By task"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'TASKS_LIST',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (TASKS_LIST)"'
      },
      {
        levelInfo: Em.Object.create({
          name: 'HOSTS_LIST',
          requestId: 1,
          taskId: 1
        }),
        e: {
          name: 'background_operations.get_by_request',
          successCallback: 'callBackFilteredByRequest',
          data: {
            requestId: 1
          }
        },
        response: {items: {Requests: {id: 0}}},
        m: '"Filtered By Request (HOSTS_LIST)"'
      }
    ]);

    beforeEach(function () {
      App.testMode = false;
    });
    afterEach(function () {
      App.testMode = true;
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('levelInfo', test.levelInfo);
        var r = controller.getQueryParams();
        expect(r.name).to.equal(test.e.name);
        expect(r.successCallback).to.equal(test.e.successCallback);
        expect(r.data).to.eql(test.e.data);
      });
    });
  });

  describe('#startPolling()', function () {

    beforeEach(function () {
      sinon.spy(App.updater, 'run');
      sinon.spy(controller, 'requestMostRecent');
    });
    afterEach(function () {
      App.updater.run.restore();
      controller.requestMostRecent.restore();
    });

    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.calledOnce).to.equal(false);
      expect(controller.requestMostRecent.calledOnce).to.equal(false);
    });
    it('isWorking = true', function () {
      controller.set('isWorking', true);
      expect(App.updater.run.calledOnce).to.equal(true);
      expect(controller.requestMostRecent.calledOnce).to.equal(true);
    });
  });

  describe('#isUpgradeRequest', function() {

    it('defines if request is upgrade task (true)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "upgrading"}})).to.be.true;
    });

    it('defines if request is upgrade task (true - with uppercase)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "UPGRADING"}})).to.be.true;
    });

    it('defines if request is downgrade task (true - with uppercase)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "downgrading"}})).to.be.true;
    });

    it('defines if request is upgrade task (false)', function() {
      expect(controller.isUpgradeRequest({Requests: {request_context: "install"}})).to.be.false;
    });

    it('defines if request is upgrade task (false - invalid param)', function() {
      expect(controller.isUpgradeRequest({Requests: {}})).to.be.false;
    });
  });

  describe('#callBackForMostRecent()', function () {
    it('No requests exists', function () {
      var data = {
        items: []
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services.length")).to.equal(0);
    });
    it('One non-running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 0,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });

    it('One request that is excluded', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: 'upgrading'
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([]);
    });

    it('One running request', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: '',
              task_count: 1,
              aborted_task_count: 0,
              completed_task_count: 0,
              failed_task_count: 0,
              timed_out_task_count: 0,
              queued_task_count: 0
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(1);
      expect(controller.get("services").mapProperty('id')).to.eql([1]);
    });
    it('Two requests in order', function () {
      var data = {
        items: [
          {
            Requests: {
              id: 1,
              request_context: ''
            }
          },
          {
            Requests: {
              id: 2,
              request_context: ''
            }
          }
        ]
      };
      controller.callBackForMostRecent(data);
      expect(controller.get("allOperationsCount")).to.equal(0);
      expect(controller.get("services").mapProperty('id')).to.eql([2, 1]);
    });
  });

  describe('#removeOldRequests()', function () {
    var testCases = [
      {
        title: 'No requests exist',
        content: {
          currentRequestIds: [],
          services: []
        },
        result: []
      },
      {
        title: 'One current request',
        content: {
          currentRequestIds: [1],
          services: [
            {id: 1}
          ]
        },
        result: [
          {id: 1}
        ]
      },
      {
        title: 'One old request',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1}
          ]
        },
        result: []
      },
      {
        title: 'One old request and one is current',
        content: {
          currentRequestIds: [2],
          services: [
            {id: 1},
            {id: 2}
          ]
        },
        result: [
          {id: 2}
        ]
      },
      {
        title: 'two old request and two current',
        content: {
          currentRequestIds: [3, 4],
          services: [
            {id: 1},
            {id: 2},
            {id: 3},
            {id: 4}
          ]
        },
        result: [
          {id: 3},
          {id: 4}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('services', test.content.services);
        controller.removeOldRequests(test.content.currentRequestIds);
        expect(controller.get('services')).to.eql(test.result);
      });
    });
  });

  describe('#isRequestRunning()', function () {
    var testCases = [
      {
        title: 'Counters are missing',
        request: {
          Requests: {}
        },
        result: false
      },
      {
        title: 'Request has zero tasks',
        request: {
          Requests: {
            task_count: 0,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in running status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in queued status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in aborted status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 1,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in completed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 1,
            failed_task_count: 0,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in failed status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 1,
            timed_out_task_count: 0,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status',
        request: {
          Requests: {
            task_count: 1,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      },
      {
        title: 'One task in timed out status and the second one in running',
        request: {
          Requests: {
            task_count: 2,
            aborted_task_count: 0,
            completed_task_count: 0,
            failed_task_count: 0,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'One task in each status',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 1
          }
        },
        result: true
      },
      {
        title: 'One task in each status except queued',
        request: {
          Requests: {
            task_count: 5,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: true
      },
      {
        title: 'No tasks in running status',
        request: {
          Requests: {
            task_count: 4,
            aborted_task_count: 1,
            completed_task_count: 1,
            failed_task_count: 1,
            timed_out_task_count: 1,
            queued_task_count: 0
          }
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isRequestRunning(test.request)).to.eql(test.result);
      });
    });
  });

  describe('#isOneHost()', function () {
    var testCases = [
      {
        title: 'inputs is null',
        inputs: null,
        result: false
      },
      {
        title: 'inputs is "null"',
        inputs: 'null',
        result: false
      },
      {
        title: 'inputs is empty object',
        inputs: '{}',
        result: false
      },
      {
        title: 'included_hosts is empty',
        inputs: '{"included_hosts": ""}',
        result: false
      },
      {
        title: 'included_hosts contain one host',
        inputs: '{"included_hosts": "host1"}',
        result: true
      },
      {
        title: 'included_hosts contain two hosts',
        inputs: '{"included_hosts": "host1,host2"}',
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.isOneHost(test.inputs)).to.eql(test.result);
      });
    });
  });

  describe('#assignScheduleId()', function () {
    var testCases = [
      {
        title: 'isOneHost is false',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: null
            }
          },
          requestParams: ''
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext is empty',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: ''
          }
        },
        result: 1
      },
      {
        title: 'isOneHost is true and requestContext contains "Recommission"',
        content: {
          request: {
            Requests: {
              request_schedule: {
                schedule_id: 1
              },
              inputs: '{"included_hosts": "host1"}'
            }
          },
          requestParams: {
            requestContext: 'Recommission'
          }
        },
        result: null
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.assignScheduleId(test.content.request, test.content.requestParams);
        expect(test.content.request.Requests.request_schedule.schedule_id).to.equal(test.result);
      });
    });
  });

  describe('#callBackFilteredByRequest()', function () {

    it('request haven\'t tasks and isRunning false', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: false,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request haven\'t tasks and isRunning true', function () {
      var data = {
        Requests: {id: 1},
        tasks: []
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 0,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({});
      expect(request.get('hostsMap')).to.eql({});
      expect(request.get('isRunning')).to.equal(true);
    });

    it('request has one completed task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED"});
      expect(request.get('hostsMap')['host1'].logTasks.length).to.equal(1);
      expect(request.get('isRunning')).to.equal(false);
    });

    it('request has one completed task and one running task', function () {
      var data = {
        Requests: {id: 1},
        tasks: [
          {
            Tasks: {
              id: 1,
              host_name: 'host1',
              status: 'COMPLETED'
            }
          },
          {
            Tasks: {
              id: 2,
              host_name: 'host1',
              status: 'IN_PROGRESS'
            }
          }
        ]
      };
      var request = Em.Object.create({
        id: 1,
        previousTaskStatusMap: {},
        isRunning: true,
        progress: 100,
        status:''
      });
      controller.set('services', [request]);
      controller.callBackFilteredByRequest(data);
      expect(request.get('previousTaskStatusMap')).to.eql({"1": "COMPLETED", "2": "IN_PROGRESS"});
      expect(request.get('hostsMap')['host1'].logTasks.length).to.equal(2);
      expect(request.get('isRunning')).to.equal(true);
    });
  });
});

});

;require.register("test/controllers/global/cluster_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
var credentialUtils = require('utils/credentials');
require('controllers/global/cluster_controller');
require('models/host_component');
require('utils/http_client');
require('models/service');
require('models/host');
require('utils/ajax/ajax');
require('utils/string_utils');

var modelSetup = require('test/init_model_test');

describe('App.clusterController', function () {
  var controller = App.ClusterController.create();
  App.Service.FIXTURES = [
    {service_name: 'GANGLIA'}
  ];

  describe('#updateLoadStatus()', function () {

    controller.set('dataLoadList', Em.Object.create({
      'item1': false,
      'item2': false
    }));

    it('when none item is loaded then width should be "width:0"', function () {
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:0');
    });
    it('when first item is loaded then isLoaded should be false', function () {
      controller.updateLoadStatus.call(controller, 'item1');
      expect(controller.get('isLoaded')).to.equal(false);
    });
    it('when first item is loaded then width should be "width:50%"', function () {
      controller.updateLoadStatus.call(controller, 'item1');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:50%');
    });

    it('when all items are loaded then isLoaded should be true', function () {
      controller.updateLoadStatus.call(controller, 'item2');
      expect(controller.get('isLoaded')).to.equal(true);
    });
    it('when all items are loaded then width should be "width:100%"', function () {
      controller.updateLoadStatus.call(controller, 'item2');
      expect(controller.get('clusterDataLoadedPercent')).to.equal('width:100%');
    });
  });

  describe('#loadClusterName()', function () {

    beforeEach(function () {
      modelSetup.setupStackVersion(this, 'HDP-2.0.5');
      sinon.stub(App.ajax, 'send', function () {
        return {
          complete: function (callback) {
            App.set('clusterName', 'clusterNameFromServer');
            App.set('currentStackVersion', 'HDP-2.0.5');
            callback();
          }
        }
      });
    });
    afterEach(function () {
      modelSetup.restoreStackVersion(this);
      App.ajax.send.restore();
    });

    it('if clusterName is "mycluster" and reload is false then clusterName stays the same', function () {
      App.set('clusterName', 'mycluster');
      controller.loadClusterName(false);
      expect(App.ajax.send.called).to.be.false;
      expect(App.get('clusterName')).to.equal('mycluster');
    });

    it('reload is true and clusterName is not empty', function () {
      controller.loadClusterName(true);
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(App.get('clusterName')).to.equal('clusterNameFromServer');
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });

    it('reload is false and clusterName is empty', function () {
      App.set('clusterName', '');
      controller.loadClusterName(false);
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(App.get('clusterName')).to.equal('clusterNameFromServer');
      expect(App.get('currentStackVersion')).to.equal('HDP-2.0.5');
    });


  });

  describe('#loadClusterNameSuccessCallback', function () {
    var test_data = {
      "items": [
        {
          "Clusters": {
            "cluster_name": "tdk",
            "version": "HDP-1.3.0"
          }
        }
      ]
    };
    it('Check cluster', function () {
      controller.loadClusterNameSuccessCallback(test_data);
      expect(App.get('clusterName')).to.equal('tdk');
      expect(App.get('currentStackVersion')).to.equal('HDP-1.3.0');
    });
  });

  describe('#loadClusterNameErrorCallback', function () {
    controller.loadClusterNameErrorCallback();
    it('', function () {
      expect(controller.get('isLoaded')).to.equal(true);
    });
  });

  describe('#getServerClockSuccessCallback()', function () {
    var testCases = [
      {
        title: 'if server clock is 1 then currentServerTime should be 1000',
        data: {
          RootServiceComponents: {
            server_clock: 1
          }
        },
        result: 1000
      },
      {
        title: 'if server clock is 0 then currentServerTime should be 0',
        data: {
          RootServiceComponents: {
            server_clock: 0
          }
        },
        result: 0
      },
      {
        title: 'if server clock is 111111111111 then currentServerTime should be 111111111111000',
        data: {
          RootServiceComponents: {
            server_clock: 111111111111
          }
        },
        result: 111111111111000
      },
      {
        title: 'if server clock is 1111111111113 then currentServerTime should be 1111111111113',
        data: {
          RootServiceComponents: {
            server_clock: 1111111111113
          }
        },
        result: 1111111111113
      }
    ];
    var currentServerTime = App.get('currentServerTime');
    var clockDistance = App.get('clockDistance');

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.getServerClockSuccessCallback(test.data);
        expect(App.get('currentServerTime')).to.equal(test.result);
        App.set('clockDistance', clockDistance);
        App.set('currentServerTime', currentServerTime);
      });
    });
  });

  describe('#getUrl', function () {
    controller.set('clusterName', 'tdk');
    var tests = ['test1', 'test2', 'test3'];
    it('testMode = true', function () {
      App.testMode = true;
      tests.forEach(function (test) {
        expect(controller.getUrl(test, test)).to.equal(test);
      });
    });
    it('testMode = false', function () {
      App.testMode = false;
      tests.forEach(function (test) {
        expect(controller.getUrl(test, test)).to.equal(App.apiPrefix + '/clusters/' + controller.get('clusterName') + test);
      });
    });
  });

  describe("#createKerberosAdminSession()", function() {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', function() {
        return {success: Em.K}
      });
      sinon.stub(credentialUtils, 'createOrUpdateCredentials', function() {
        return $.Deferred().resolve().promise();
      });
    });
    afterEach(function () {
      App.ajax.send.restore();
      credentialUtils.createOrUpdateCredentials.restore();
    });
    it("KDC Store supports disabled, credentials updated via kdc session call", function() {
      sinon.stub(App, 'get')
        .withArgs('supports.storeKDCCredentials').returns(false)
        .withArgs('clusterName').returns('test');
      controller.createKerberosAdminSession({
        principal: 'admin',
        key: 'pass',
        type: 'persistent'
      }, {});
      App.get.restore();
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'common.cluster.update',
        sender: controller,
        data: {
          clusterName: 'test',
          data: [{
            session_attributes: {
              kerberos_admin: {principal: "admin", password: "pass"}
            }
          }]
        }
      });
    });
    it("KDC Store supports enabled, credentials updated via credentials storage call", function() {
      sinon.stub(App, 'get')
        .withArgs('supports.storeKDCCredentials').returns(true)
        .withArgs('clusterName').returns('test');
      controller.createKerberosAdminSession({
        principal: 'admin',
        key: 'pass',
        type: 'persistent'
      }, {});
      App.get.restore();
      expect(App.ajax.send.called).to.be.eql(false);
      expect(credentialUtils.createOrUpdateCredentials.getCall(0).args).to.eql([
        'test', 'kdc.admin.credential', {
          principal: 'admin',
          key: 'pass',
          type: 'persistent'
        }
      ]);
    });
  });

  describe('#checkDetailedRepoVersion()', function () {

    var cases = [
      {
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.1',
        isStormMetricsSupported: false,
        title: 'HDP < 2.2'
      },
      {
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        isStormMetricsSupported: true,
        title: 'HDP > 2.2'
      },
      {
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        isStormMetricsSupported: true,
        title: 'not HDP'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.ajax, 'send').returns({
        promise: Em.K
      });
    });

    afterEach(function () {
      App.ajax.send.restore();
      App.get.restore();
    });

    it('should check detailed repo version for HDP 2.2', function () {
      sinon.stub(App, 'get').withArgs('currentStackName').returns('HDP').withArgs('currentStackVersionNumber').returns('2.2');
      controller.checkDetailedRepoVersion();
      expect(App.ajax.send.calledOnce).to.be.true;
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App, 'get', function (key) {
          return item[key] || Em.get(App, key);
        });
        controller.checkDetailedRepoVersion();
        expect(App.ajax.send.called).to.be.false;
        expect(App.get('isStormMetricsSupported')).to.equal(item.isStormMetricsSupported);
      });
    });

  });

  describe('#checkDetailedRepoVersionSuccessCallback()', function () {

    var cases = [
      {
        items: [
          {
            repository_versions: [
              {
                RepositoryVersions: {
                  repository_version: '2.1'
                }
              }
            ]
          }
        ],
        isStormMetricsSupported: false,
        title: 'HDP < 2.2.2'
      },
      {
        items: [
          {
            repository_versions: [
              {
                RepositoryVersions: {
                  repository_version: '2.2.2'
                }
              }
            ]
          }
        ],
        isStormMetricsSupported: true,
        title: 'HDP 2.2.2'
      },
      {
        items: [
          {
            repository_versions: [
              {
                RepositoryVersions: {
                  repository_version: '2.2.3'
                }
              }
            ]
          }
        ],
        isStormMetricsSupported: true,
        title: 'HDP > 2.2.2'
      },
      {
        items: null,
        isStormMetricsSupported: true,
        title: 'empty response'
      },
      {
        items: [],
        isStormMetricsSupported: true,
        title: 'no items'
      },
      {
        items: [{}],
        isStormMetricsSupported: true,
        title: 'empty item'
      },
      {
        items: [{
          repository_versions: []
        }],
        isStormMetricsSupported: true,
        title: 'no versions'
      },
      {
        items: [{
          repository_versions: [{}]
        }],
        isStormMetricsSupported: true,
        title: 'no version info'
      },
      {
        items: [{
          repository_versions: [
            {
              RepositoryVersions: {}
            }
          ]
        }],
        isStormMetricsSupported: true,
        title: 'empty version info'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.checkDetailedRepoVersionSuccessCallback({
          items: item.items
        });
        expect(App.get('isStormMetricsSupported')).to.equal(item.isStormMetricsSupported);
      });
    });

  });

  describe('#checkDetailedRepoVersionErrorCallback()', function () {
    it('should set isStormMetricsSupported to default value', function () {
      controller.checkDetailedRepoVersionErrorCallback();
      expect(App.get('isStormMetricsSupported')).to.be.true;
    });
  });

  describe('#getAllUpgrades()', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should send request to get upgrades data', function () {
      controller.getAllUpgrades();
      expect(App.ajax.send.calledOnce).to.be.true;
    });

  });

  describe("#restoreUpgradeState()", function() {
    var data = {upgradeData: {}};
    var mock = {done: function(callback) {
      callback(data.upgradeData);
    }};
    var upgradeController = Em.Object.create({
      restoreLastUpgrade: Em.K,
      initDBProperties: Em.K,
      loadUpgradeData: Em.K,
      loadStackVersionsToModel: function(){return {done: Em.K};}
    });

    beforeEach(function () {
      sinon.stub(controller, 'getAllUpgrades').returns(mock);
      sinon.spy(mock, 'done');
      sinon.stub(App.router, 'get').returns(upgradeController);
      sinon.stub(App.db, 'get').returns('PENDING');
      sinon.spy(upgradeController, 'restoreLastUpgrade');
      sinon.spy(upgradeController, 'initDBProperties');
      sinon.spy(upgradeController, 'loadUpgradeData');
      sinon.spy(upgradeController, 'loadStackVersionsToModel');
    });
    afterEach(function () {
      mock.done.restore();
      controller.getAllUpgrades.restore();
      App.router.get.restore();
      App.db.get.restore();
      upgradeController.restoreLastUpgrade.restore();
      upgradeController.initDBProperties.restore();
      upgradeController.loadUpgradeData.restore();
      upgradeController.loadStackVersionsToModel.restore();
    });
    it("has upgrade request", function() {
      data.upgradeData = {items: [
        {
          Upgrade: {
            request_id: 1
          }
        }
      ]};
      controller.restoreUpgradeState();
      expect(controller.getAllUpgrades.calledOnce).to.be.true;
      expect(App.get('upgradeState')).to.equal('PENDING');
      expect(upgradeController.restoreLastUpgrade.calledWith(data.upgradeData.items[0])).to.be.true;
      expect(upgradeController.loadStackVersionsToModel.calledWith(true)).to.be.true;
      expect(upgradeController.initDBProperties.called).to.be.false;
      expect(upgradeController.loadUpgradeData.called).to.be.false;
    });
    it("does not have upgrade request", function() {
      data.upgradeData = {items: []};
      controller.restoreUpgradeState();
      expect(controller.getAllUpgrades.calledOnce).to.be.true;
      expect(App.get('upgradeState')).to.equal('PENDING');
      expect(upgradeController.restoreLastUpgrade.called).to.be.false;
      expect(upgradeController.loadStackVersionsToModel.calledWith(true)).to.be.true;
      expect(upgradeController.initDBProperties.calledOnce).to.be.true;
      expect(upgradeController.loadUpgradeData.calledWith(true)).to.be.true;
    });
  });
});

});

;require.register("test/controllers/global/configuration_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/global/configuration_controller');


describe('App.ConfigurationController', function () {
  var controller = App.ConfigurationController.create();

  describe('#checkTagsChanges()', function () {
    var testCases = [
      {
        title: 'Tags haven\'t been uploaded',
        content: {
          tags: [],
          storedTags: []
        },
        result: false
      },
      {
        title: 'New tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: []
        },
        result: true
      },
      {
        title: 'Existing tag with with new tagName',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site1',
              tagName: 2
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags with different tagNames',
        content: {
          tags: [
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'One new tag uploaded',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            },
            {
              siteName: 'site1',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: true
      },
      {
        title: 'Tags haven\'t been changed',
        content: {
          tags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ],
          storedTags: [
            {
              siteName: 'site2',
              tagName: 1
            }
          ]
        },
        result: false
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.checkTagsChanges(test.content.tags, test.content.storedTags)).to.equal(test.result);
      });
    });
  });
});
});

;require.register("test/controllers/global/update_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/updater');
require('controllers/global/update_controller');

describe('App.UpdateController', function () {
  var controller = App.UpdateController.create({
    clusterName: '',
    location: '',
    updateServiceMetric: function(){}
  });

  describe('#getUrl()', function () {

    it('testMode = true', function () {
      App.set('testMode', true);
      expect(controller.getUrl('test', '/real')).to.equal('test');
    });

    it('testMode = false', function () {
      App.set('testMode', false);
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters//real');
    });

    it('testMode = false', function () {
      App.set('testMode', false);
      controller.set('clusterName', 'mycluster');
      expect(controller.getUrl('test', '/real')).to.equal('/api/v1/clusters/mycluster/real');
    });
  });

  describe('#updateAll()', function () {

    beforeEach(function () {
      sinon.stub(App.updater, 'run', Em.K);
    });
    afterEach(function () {
      App.updater.run.restore();
    });
    it('isWorking = false', function () {
      controller.set('isWorking', false);
      expect(App.updater.run.called).to.equal(false);
    });

    it('isWorking = true', function () {
      controller.set('isWorking', true);
      expect(App.updater.run.callCount).to.equal(11);
    });
  });

  describe('#getConditionalFields()', function () {

    var testCases = [
      {
        title: 'No services exist',
        services: [],
        result: ['metrics/1']
      },
      {
        title: 'HDFS service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HDFS'
            }
          }
        ],
        result: ['metrics/1']
      },
      {
        title: 'FLUME service',
        services: [
          {
            ServiceInfo: {
              service_name: 'FLUME'
            }
          }
        ],
        result: ['metrics/1', "host_components/processes/HostComponentProcess"]
      },
      {
        title: 'YARN service',
        services: [
          {
            ServiceInfo: {
              service_name: 'YARN'
            }
          }
        ],
        result: ['metrics/1', "host_components/metrics/yarn/Queue," +
        "host_components/metrics/yarn/ClusterMetrics/NumActiveNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumLostNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumUnhealthyNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumRebootedNMs," +
        "host_components/metrics/yarn/ClusterMetrics/NumDecommissionedNMs"]
      },
      {
        title: 'HBASE service',
        services: [
          {
            ServiceInfo: {
              service_name: 'HBASE'
            }
          }
        ],
        result: ['metrics/1', "host_components/metrics/hbase/master/IsActiveMaster," +
        "host_components/metrics/hbase/master/MasterStartTime," +
        "host_components/metrics/hbase/master/MasterActiveTime," +
        "host_components/metrics/hbase/master/AverageLoad," +
        "host_components/metrics/master/AssignmentManger/ritCount"]
      },
      {
        title: 'STORM service',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        result: ['metrics/1', "metrics/api/v1/cluster/summary," +
        "metrics/api/v1/topology/summary," +
        "metrics/api/v1/nimbus/summary"]
      }
    ];

    var testCasesByStackVersion = [
      {
        title: 'STORM service stack 2.1',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.1',
        result: ['metrics/1', "metrics/api/cluster/summary"]
      },
      {
        title: 'STORM service stack 2.2',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.2',
        result: ['metrics/1', "metrics/api/v1/cluster/summary,metrics/api/v1/topology/summary"]
      },
      {
        title: 'STORM service stack 2.3',
        services: [
          {
            ServiceInfo: {
              service_name: 'STORM'
            }
          }
        ],
        stackVersionNumber: '2.3',
        result: ['metrics/1', "metrics/api/v1/cluster/summary,metrics/api/v1/topology/summary,metrics/api/v1/nimbus/summary"]
      }
    ];

    beforeEach(function () {
      this.mock = sinon.stub(App, 'get');
      controller.set('serviceComponentMetrics', ['metrics/1']);
    });
    afterEach(function () {
      this.mock.restore();
    });
    testCases.forEach(function (test) {
      it(test.title, function () {
        App.cache['services'] = test.services;
        this.mock.withArgs('router.clusterController.isServiceMetricsLoaded').returns(true);
        expect(controller.getConditionalFields()).to.eql(test.result);
      });
    });

    testCasesByStackVersion.forEach(function (test) {
      it(test.title, function () {
        App.cache['services'] = test.services;
        this.mock.withArgs('currentStackVersionNumber').returns(test.stackVersionNumber);
        this.mock.withArgs('router.clusterController.isServiceMetricsLoaded').returns(true);
        expect(controller.getConditionalFields()).to.eql(test.result);
      });
    });

    it('FLUME service, first load', function () {
      App.cache['services'] = [
        {
          ServiceInfo: {
            service_name: 'FLUME'
          }
        }
      ];
      this.mock.withArgs('router.clusterController.isServiceMetricsLoaded').returns(false);
      expect(controller.getConditionalFields()).to.eql(["host_components/processes/HostComponentProcess"]);
    });
  });

  describe("#getComplexUrl()", function () {
    beforeEach(function () {
      sinon.stub(App, 'get').returns('mock');
      sinon.stub(controller, 'computeParameters').returns('params');
    });
    afterEach(function () {
      App.get.restore();
      controller.computeParameters.restore();
    });
    it("queryParams is empty", function () {
      expect(controller.getComplexUrl('<parameters>')).to.equal('mock/clusters/mock');
    });
    it("queryParams is present", function () {
      var queryParams = [
        {
          type: "EQUAL",
          key: "key",
          value: "value"
        }
      ];
      expect(controller.getComplexUrl('<parameters>', queryParams)).to.equal('mock/clusters/mockparams&');
    });
  });

  describe("#addParamsToHostsUrl()", function () {
    beforeEach(function () {
      sinon.stub(App, 'get').returns('mock');
      sinon.stub(controller, 'computeParameters').returns('params');
    });
    afterEach(function () {
      App.get.restore();
      controller.computeParameters.restore();
    });
    it("", function () {
      expect(controller.addParamsToHostsUrl([], [], 'url')).to.equal('mock/clusters/mockurl&params&params');
    });
  });

  describe("#loadHostsMetric()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.Service, 'find');
      sinon.stub(controller, 'computeParameters');
      sinon.stub(controller, 'addParamsToHostsUrl');
      sinon.stub(App.ajax, 'send');
    });
    afterEach(function () {
      App.Service.find.restore();
      controller.computeParameters.restore();
      controller.addParamsToHostsUrl.restore();
      App.ajax.send.restore();
    });
    it("AMBARI_METRICS is not started", function () {
      this.mock.returns(Em.Object.create({isStarted: false}));
      expect(controller.loadHostsMetric([])).to.be.null;
      expect(App.ajax.send.called).to.be.false;
    });
    it("AMBARI_METRICS is started", function () {
      this.mock.returns(Em.Object.create({isStarted: true}));
      expect(controller.loadHostsMetric([])).to.be.object;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe("#loadHostsMetricSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub(App.hostsMapper, 'setMetrics');
    });
    afterEach(function () {
      App.hostsMapper.setMetrics.restore();
    });
    it("", function () {
      controller.loadHostsMetricSuccessCallback({});
      expect(App.hostsMapper.setMetrics.calledWith({})).to.be.true;
    });
  });

  describe('#updateUpgradeState()', function () {

    var cases = [
        {
          currentStateName: 'versions',
          parentStateName: 'stackAndUpgrade',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'stack versions page'
        },
        {
          currentStateName: 'stackUpgrade',
          parentStateName: 'admin',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'upgrade popup open'
        },
        {
          currentStateName: 'versions',
          parentStateName: 'admin',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 1,
          callbackCallCount: 0,
          title: 'another page with \'versions\' name'
        },
        {
          currentStateName: 'versions',
          parentStateName: 'admin',
          upgradeIsNotFinished: false,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page with \'versions\' name, upgrade finished'
        },
        {
          currentStateName: 'versions',
          parentStateName: 'admin',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page with \'versions\' name, another update upgrade request not completed'
        },
        {
          currentStateName: 'services',
          parentStateName: 'stackAndUpgrade',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 1,
          callbackCallCount: 0,
          title: 'another page from \'Stack and Versions\' section'
        },
        {
          currentStateName: 'services',
          parentStateName: 'stackAndUpgrade',
          upgradeIsNotFinished: false,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page from \'Stack and Versions\' section, upgrade finished'
        },
        {
          currentStateName: 'services',
          parentStateName: 'stackAndUpgrade',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'another page from \'Stack and Versions\' section, another update upgrade request not completed'
        },
        {
          currentStateName: 'widgets',
          parentStateName: 'dashboard',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 1,
          callbackCallCount: 0,
          title: 'not \'Stack and Versions\' section'
        },
        {
          currentStateName: 'widgets',
          parentStateName: 'dashboard',
          upgradeIsNotFinished: false,
          isLoadUpgradeDataPending: false,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'not \'Stack and Versions\' section, upgrade finished'
        },
        {
          currentStateName: 'widgets',
          parentStateName: 'dashboard',
          upgradeIsNotFinished: true,
          isLoadUpgradeDataPending: true,
          loadUpgradeDataCallCount: 0,
          callbackCallCount: 1,
          title: 'not \'Stack and Versions\' section, another update upgrade request not completed'
        }
      ],
      mock = {
        callback: Em.K,
        loadUpgradeData: function () {
          return {
            done: Em.K
          };
        }
      },
      mainAdminStackAndUpgradeController = App.get('router.mainAdminStackAndUpgradeController'),
      appGetMock;

    beforeEach(function () {
      sinon.spy(mock, 'callback');
      sinon.spy(mock, 'loadUpgradeData');
      appGetMock = sinon.stub(App, 'get');
    });

    afterEach(function () {
      mock.callback.restore();
      mock.loadUpgradeData.restore();
      App.get.restore();
      appGetMock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        appGetMock.withArgs('router.mainAdminStackAndUpgradeController').returns(Em.Object.create({
          loadUpgradeData: mock.loadUpgradeData,
          isLoadUpgradeDataPending: item.isLoadUpgradeDataPending
        })).withArgs('upgradeIsNotFinished').returns(item.upgradeIsNotFinished)
          .withArgs('router.currentState.name').returns(item.currentStateName)
          .withArgs('router.currentState.parentState.name').returns(item.parentStateName);
        controller.updateUpgradeState(mock.callback);
        expect(mock.loadUpgradeData.callCount).to.equal(item.loadUpgradeDataCallCount);
        expect(mock.callback.callCount).to.equal(item.callbackCallCount);
      });
    });

  });

});

});

;require.register("test/controllers/global/user_settings_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var userSettingsController;

describe('App.UserSettingsController', function () {

  beforeEach(function () {
    userSettingsController = App.UserSettingsController.create();
  });

  describe('#userSettingsKeys', function () {
    it('should not be empty', function () {
      expect(Object.keys(userSettingsController.get('userSettingsKeys'))).to.have.length.gt(0);
    });
  });

  describe('#showSettingsPopup', function() {
    var dataToShowRes = {};

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', function(dataToShow){
        dataToShowRes = dataToShow;
      });
      sinon.stub(App, 'isAccessible').returns(true);
      var emulatorClass = function() {};
      emulatorClass.prototype.done = function(func) {
        if (func) {
          func();
        }
      };
      var emulator = new emulatorClass();
      sinon.stub(userSettingsController, 'dataLoading').returns(emulator);
    });
    afterEach(function () {
      App.isAccessible.restore();
      App.ModalPopup.show.restore();
      userSettingsController.dataLoading.restore();
    });
    it ('Should show settings popup', function() {
      userSettingsController.showSettingsPopup();
      dataToShowRes = JSON.parse(JSON.stringify(dataToShowRes));
      expect(dataToShowRes).to.eql({
        "header": "User Settings",
        "primary": "Save"
      });
    });
  });

  describe('#getUserPrefErrorCallback', function() {
    it ('Should set currentPrefObject', function() {
      applicationController.getUserPrefErrorCallback({status: 404}, {}, {});
      expect(applicationController.get('currentPrefObject')).to.be.true;
    });
  });

  describe('#getUserPrefSuccessCallback', function() {
    it ('Should set currentPrefObject', function() {
      applicationController.getUserPrefSuccessCallback({status: 200}, {}, {});
      expect(applicationController.get('currentPrefObject')).to.be.eql({status: 200});
    });
  });

  describe('#updateUserPrefWithDefaultValues', function () {

    beforeEach(function () {
      sinon.stub(userSettingsController, 'postUserPref', Em.K);
    });

    afterEach(function () {
      userSettingsController.postUserPref.restore();
    });

    it('should update user pref with default values', function () {
      userSettingsController.updateUserPrefWithDefaultValues(null, true);
      expect(userSettingsController.postUserPref.called).to.be.false;
    });

    it('should not update user pref with default values', function () {
      userSettingsController.updateUserPrefWithDefaultValues(null, false);
      expect(userSettingsController.postUserPref.called).to.be.true;
    });

  });

});
});

;require.register("test/controllers/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/installer');

describe('App.InstallerController', function () {

  var installerController = App.InstallerController.create();

  describe('#init', function () {
    var c;
    beforeEach(function () {
      c = App.InstallerController.create({});
    });
    it('all steps are disabled by default', function () {
      expect(c.get('isStepDisabled.length') > 0 ).to.be.ok;
      expect(c.get('isStepDisabled').everyProperty('value', true)).to.be.ok;
    });
  });

  describe('#loadStacksVersionsSuccessCallback', function() {
    beforeEach(function () {
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function () {
      App.store.commit.restore();
    });
    it ('Correct data', function() {
      installerController.set('loadStacksRequestsCounter', 1);
      installerController.loadStacksVersionsSuccessCallback(require('test/stack'));
      expect(installerController.get('content.stacks.length')).to.equal(2);
      expect(installerController.get('content.stacks').everyProperty('isSelected')).to.be.false;
      expect(installerController.get('content.stacks').mapProperty('id')).to.eql(['HDP-2.1','HDP-1.3']);
    });
  });

  describe('#getCluster', function() {
    it ('Should return merged clusterStatusTemplate', function() {
      installerController.set('clusterStatusTemplate', {
        name: 'template'
      });
      expect(installerController.getCluster()).to.eql({
        name: 'template'
      });
    });
  });

  describe('#getHosts', function() {
    it ('Should return empty array', function() {
      expect(installerController.getHosts()).to.eql([]);
    });
  });

  describe('#loadServices', function() {
    it ('Should resolve nothing', function() {
      var res = installerController.loadServices();
      res.then(function(data){
        expect(data).to.be.undefined;
      });
    });
  });

  describe('#checkRepoURL', function() {
     beforeEach(function () {
      sinon.stub(App.ajax, 'send', function(data){
        return null;
      });
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it ('Should reload installed stacks', function() {
      var stacks = Em.A([
        Em.Object.create({
          isSelected: false
        }),
        Em.Object.create({
          isSelected: true,
          reload: false,
          id: 'nn-cc',
          repositories: Em.A([
            Em.Object.create({
              isSelected: true
            })
          ]),
          operatingSystems: Em.A([
            Em.Object.create({
              isSelected: true,
              repositories: Em.A([
                Em.Object.create({
                  errorTitle: '1',
                  errorContent: '1',
                  validation: ''
                })
              ])
            })
          ]) 
        })
      ]);
      var wizard = Em.Object.create({
        skipValidationChecked: true
      });
      installerController.set('content.stacks', stacks);
      installerController.checkRepoURL(wizard);

      var expected = [
        {
          "isSelected": false
        },
        {
          "isSelected": true,
          "reload": true,
          "id": "nn-cc",
          "repositories": [
            {
              "isSelected": true
            }
          ],
          "operatingSystems": [
            {
              "isSelected": true,
              "repositories": [
                {
                  "errorTitle": "",
                  "errorContent": "",
                  "validation": "icon-repeat"
                }
              ]
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('content.stacks')));

      expect(res).to.be.eql(expected);
    });
  });

  describe('#checkRepoURLSuccessCallback', function() {
    it ('Should check stacks for sucess', function() {
      var stacks = Em.A([
        Em.Object.create({
          isSelected: false
        }),
        Em.Object.create({
          isSelected: true,
          reload: false,
          id: 'nn-cc',
          repositories: Em.A([
            Em.Object.create({
              repoId: 11,
              isSelected: true
            })
          ]),
          operatingSystems: Em.A([
            Em.Object.create({
              isSelected: true,
              id: 1,
              repositories: Em.A([
                Em.Object.create({
                  repoId: 11,
                  errorTitle: '1',
                  errorContent: '1',
                  validation: ''
                })
              ])
            })
          ]) 
        })
      ]);
      var resolve = false;
      var data = {
        osId: 1,
        repoId: 11,
        dfd: {
          resolve: function() {
            resolve = true;
          }
        }
      };
      installerController.set('content.stacks', stacks);
      installerController.checkRepoURLSuccessCallback(null,null,data);

      var expected = [
        {
          "isSelected": false
        },
        {
          "isSelected": true,
          "reload": false,
          "id": "nn-cc",
          "repositories": [
            {
              "repoId": 11,
              "isSelected": true
            }
          ],
          "operatingSystems": [
            {
              "isSelected": true,
              "id": 1,
              "repositories": [
                {
                  "repoId": 11,
                  "errorTitle": "1",
                  "errorContent": "1",
                  "validation": "icon-ok"
                }
              ]
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('content.stacks')));
      expect(resolve).to.be.true;
      expect(res).to.be.eql(expected);
    });
  });

  describe('#checkRepoURLErrorCallback', function() {
    it ('Should check stacks for error', function() {
      var stacks = Em.A([
        Em.Object.create({
          isSelected: false
        }),
        Em.Object.create({
          isSelected: true,
          reload: false,
          id: 'nn-cc',
          repositories: Em.A([
            Em.Object.create({
              repoId: 11,
              isSelected: true
            })
          ]),
          operatingSystems: Em.A([
            Em.Object.create({
              isSelected: true,
              id: 1,
              repositories: Em.A([
                Em.Object.create({
                  repoId: 11,
                  errorTitle: '1',
                  errorContent: '1',
                  validation: ''
                })
              ])
            })
          ]) 
        })
      ]);
      var resolve = false;
      var data = {
        osId: 1,
        repoId: 11,
        dfd: {
          reject: function() {
            resolve = true;
          }
        }
      };
      var req = {
        status: 500,
        statusText: 'error'
      };
      installerController.set('content.stacks', stacks);
      installerController.checkRepoURLErrorCallback(req,{},{},{},data);

      var expected = [
        {
          "isSelected": false
        },
        {
          "isSelected": true,
          "reload": false,
          "id": "nn-cc",
          "repositories": [
            {
              "repoId": 11,
              "isSelected": true
            }
          ],
          "operatingSystems": [
            {
              "isSelected": true,
              "id": 1,
              "repositories": [
                {
                  "repoId": 11,
                  "errorTitle": "500:error",
                  "errorContent": "",
                  "validation": "icon-exclamation-sign"
                }
              ]
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('content.stacks')));
      expect(resolve).to.be.true;
      expect(res).to.be.eql(expected);
    });
  });

  describe('#loadStacks', function() {
    it ('Should resolve promise with true', function() {
      installerController.set('content.stacks', Em.Object.create({
        length: 2
      }));
      var res = installerController.loadStacks();
      res.then(function(data){
        expect(data).to.be.true;
      });
    });
    it ('Should resolve promise with false', function() {
      installerController.set('content.stacks', null);
      var res = installerController.loadStacks();
      res.then(function(data){
        expect(data).to.be.false;
      });
    });
  });

  describe('#setLowerStepsDisable', function() {
    it ('Should disable lower steps', function() {
      var steps = Em.A([
        Em.Object.create({
          step: 0,
          value: false
        }),
        Em.Object.create({
          step: 1,
          value: false
        }),
        Em.Object.create({
          step: 2,
          value: false
        }),
        Em.Object.create({
          step: 3,
          value: false
        }),
        Em.Object.create({
          step: 4,
          value: false
        })
      ]);
      installerController.set('isStepDisabled', steps);
      installerController.setLowerStepsDisable(3);
      var expected = [
        {
          "step": 0,
          "value": true
        },
        {
          "step": 1,
          "value": true
        },
        {
          "step": 2,
          "value": true
        },
        {
          "step": 3,
          "value": false
        },
        {
          "step": 4,
          "value": false
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('isStepDisabled')));

      expect(res).to.eql(expected);
    });
  });

  describe('#setStepsEnable', function() {
    it ('Should enable next steps', function() {
      var steps = Em.A([
        Em.Object.create({
          step: 0,
          value: false
        }),
        Em.Object.create({
          step: 1,
          value: false
        }),
        Em.Object.create({
          step: 2,
          value: false
        }),
        Em.Object.create({
          step: 3,
          value: false
        }),
        Em.Object.create({
          step: 4,
          value: false
        })
      ]);
      installerController.set('isStepDisabled', steps);
      installerController.totalSteps = steps.length - 1;
      installerController.set('currentStep',2);
      var expected = [
        {
          "step": 0,
          "value": false
        },
        {
          "step": 1,
          "value": true
        },
        {
          "step": 2,
          "value": true
        },
        {
          "step": 3,
          "value": true
        },
        {
          "step": 4,
          "value": true
        }
      ];

      var res = JSON.parse(JSON.stringify(installerController.get('isStepDisabled')));

      expect(res).to.eql(expected);
    });
  });

  describe('#loadMap', function() {
    it ('Should load cluster', function() {
      var loadCluster = false;
      var checker = {
        load: function() {
          loadCluster = true;
        }
      };
      installerController.loadMap['0'][0].callback.call(checker);
      expect(loadCluster).to.be.true;
    });
    it ('Should load stacks', function() {
      var loadStacks = false;
      var checker = {
        loadStacks: function() {
          return {
            always: function() {
              loadStacks = true;
            }
          };
        }
      };
      installerController.loadMap['1'][0].callback.call(checker);
      expect(loadStacks).to.be.true;
    });
    it ('Should load stacks async', function() {
      var loadStacksVersions = false;
      var checker = {
        loadStacksVersions: function() {
          loadStacksVersions = true;
        }
      };
      installerController.loadMap['1'][1].callback.call(checker, true).then(function(data){
        expect(data).to.be.true;
      });
      expect(loadStacksVersions).to.be.false;
    });
    it ('Should load installOptions', function() {
      var loadStacks = false;
      var checker = {
        load: function() {
          loadStacks = true;
        }
      };
      installerController.loadMap['2'][0].callback.call(checker);
      expect(loadStacks).to.be.true;
    });
    it ('Should load loadConfirmedHosts', function() {
      var loadConfirmedHosts = false;
      var checker = {
        loadConfirmedHosts: function() {
          loadConfirmedHosts = true;
        }
      };
      installerController.loadMap['3'][0].callback.call(checker);
      expect(loadConfirmedHosts).to.be.true;
    });
    it ('Should load loadServices', function() {
      var loadServices = false;
      var checker = {
        loadServices: function() {
          loadServices = true;
        }
      };
      installerController.loadMap['4'][0].callback.call(checker);
      expect(loadServices).to.be.true;
    });
    it ('Should load loadServices', function() {
      var setSkipSlavesStep = false;
      var loadMasterComponentHosts = false;
      var loadConfirmedHosts = false;
      var loadRecommendations = false;

      var checker = {
        setSkipSlavesStep: function() {
          setSkipSlavesStep = true;
        },
        loadMasterComponentHosts: function() {
          loadMasterComponentHosts = true;
        },
        loadConfirmedHosts: function() {
          loadConfirmedHosts = true;
        },
        loadRecommendations: function() {
          loadRecommendations = true;
        }
      };
      installerController.loadMap['5'][0].callback.call(checker);
      expect(loadConfirmedHosts).to.be.true;
      expect(setSkipSlavesStep).to.be.true;
      expect(loadMasterComponentHosts).to.be.true;
      expect(loadRecommendations).to.be.true;

    });
    it ('Should load serviceConfigGroups', function() {
      var loadServiceConfigGroups = false;
      var loadServiceConfigProperties = false;
      var loadCurrentHostGroups = false;
      var loadRecommendationsConfigs = false;
      var loadConfigThemes = false;

      var checker = {
        loadServiceConfigGroups: function() {
          loadServiceConfigGroups = true;
        },
        loadServiceConfigProperties: function() {
          loadServiceConfigProperties = true;
        },
        loadCurrentHostGroups: function() {
          loadCurrentHostGroups = true;
        },
        loadRecommendationsConfigs: function() {
          loadRecommendationsConfigs = true;
        },
        loadConfigThemes: function() {
          loadConfigThemes = true;
        }
      };
      installerController.loadMap['7'][0].callback.call(checker);
      expect(loadServiceConfigGroups).to.be.true;
      expect(loadServiceConfigProperties).to.be.true;
      expect(loadCurrentHostGroups).to.be.true;
      expect(loadRecommendationsConfigs).to.be.true;
      expect(loadConfigThemes).to.be.true;
    });
    it ('Should load clients', function() {
      var loadSlaveComponentHosts = false;
      var loadClients = false;
      var loadRecommendations = false;

      var checker = {
        loadSlaveComponentHosts: function() {
          loadSlaveComponentHosts = true;
        },
        loadClients: function() {
          loadClients = true;
        },
        loadRecommendations: function() {
          loadRecommendations = true;
        }
      };
      installerController.loadMap['6'][0].callback.call(checker);
      expect(loadSlaveComponentHosts).to.be.true;
      expect(loadClients).to.be.true;
      expect(loadRecommendations).to.be.true;
    });
  });

  describe('#removeHosts', function() {
    var hostsDb = {
      'h1': {},
      'h2': {},
      'h3': {},
      'h4': {}
    };
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperty').returns(hostsDb);
    });
    afterEach(function () {
      installerController.getDBProperty.restore();
    });
    it ('Should remove hosts from the list', function() {
      var hosts = Em.A([
        {
          name: 'h1'
        },
        {
          name: 'h2'
        },
        {
          name: 'h3'
        }
      ]);
      installerController.removeHosts(hosts);
      expect(hostsDb).to.eql({
        'h4': {}
      });
    });
  });

  describe('#allHosts', function() {
    it ('Should return hosts', function() {
      var hosts = {
        'h1': {
          disk_info: Em.A([{
            available: 1,
            size: 10
          }]),
          hostComponents: Em.A([])
        }
      };
      var masterComponentHosts = Em.A([
        {
          hostName: 'h1',
          component: 'component',
          display_name: 'n1'
        }
      ]);
      var slaveComponentHosts = Em.A([
        {
          hosts: Em.A([
          {
            hostName: 'h1'
          }
          ])
        }
      ]);
      installerController.set('content.hosts', hosts);
      installerController.set('content.masterComponentHosts', masterComponentHosts);
      installerController.set('content.slaveComponentHosts', slaveComponentHosts);
      var res = JSON.parse(JSON.stringify(installerController.get('allHosts')));
      expect(res).to.eql([
        {
          "diskInfo": [
            {
              "available": 1,
              "size": 10
            }
          ],
          "diskTotal": 0.0000095367431640625,
          "diskFree": 9.5367431640625e-7,
          "hostComponents": [
            {
              "componentName": "component",
              "displayName": "n1"
            },
            {}
          ]
        }
      ]);
    });
  });

  describe('#loadServiceConfigProperties', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperty').returns({
        value: 2
      });
    });
    afterEach(function () {
      installerController.getDBProperty.restore();
    });
    it ('Should load service config property', function() {
      installerController.loadServiceConfigProperties();
      expect(installerController.get('content.serviceConfigProperties')).to.eql({
        "value": 2
      });
    });
  });

  describe('#saveServices', function() {
    it ('Should return correct names', function() {
      var stepController = Em.A([
        Em.Object.create({
          isInstalled: true,
          isSelected: true,
          serviceName: 'i1'
        }),
        Em.Object.create({
          isInstalled: false,
          isSelected: true,
          serviceName: 'i2'
        }),
        Em.Object.create({
          isInstalled: true,
          isSelected: false,
          serviceName: 'i3'
        })
      ]);
      installerController.saveServices(stepController);
      expect(installerController.get('content.selectedServiceNames')).to.eql(['i1','i2']);
      expect(installerController.get('content.installedServiceNames')).to.eql(['i1','i3']);
    });
  });

  describe('#saveClients', function() {
    it ('Should return correct clients names', function() {
      var stepController = Em.Object.create({
        content: Em.A([
          Em.Object.create({
            isInstalled: true,
            isSelected: true,
            serviceName: 'i1',
            serviceComponents: Em.A([
              Em.Object.create({
                isClient: true,
                componentName: 'name',
                displayName: 'dname'
              })
            ])
          }),
          Em.Object.create({
            isInstalled: false,
            isSelected: true,
            serviceName: 'i2',
            serviceComponents: Em.A([
              Em.Object.create({
                isClient: false
              })
            ])
          }),
          Em.Object.create({
            isInstalled: true,
            isSelected: false,
            serviceName: 'i3',
            serviceComponents: Em.A([
              Em.Object.create({
                isClient: false
              })
            ])
          })
        ])
      });
      installerController.saveClients(stepController);
      var res = JSON.parse(JSON.stringify(installerController.get('content.clients')));
      expect(res).to.eql([
        {
          "component_name": "name",
          "display_name": "dname",
          "isInstalled": false
        }
      ]);
    });
  });

  describe('#saveMasterComponentHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperty').returns({
        'h1': {
          id: 11
        },
        'h3': {
          id: 13
        },
        'h2': {
          id: 12
        }
      });
    });
    afterEach(function () {
      installerController.getDBProperty.restore();
    });
    it ('Should return hosts', function() {
      var stepController = Em.Object.create({
        selectedServicesMasters: Em.A([
          Em.Object.create({
            display_name: 'n1',
            component_name: 'c1',
            serviceId: 1,
            selectedHost: 'h1'
          })
        ])
      });
      installerController.saveMasterComponentHosts(stepController);
      expect(installerController.get('content.masterComponentHosts')).to.eql([
        {
          "display_name": "n1",
          "component": "c1",
          "serviceId": 1,
          "isInstalled": false,
          "host_id": 11
        }
      ]);
    });
  });

  describe('#loadConfirmedHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperty').returns({
        'h1': {
          id: 11
        },
        'h3': {
          id: 13
        },
        'h2': {
          id: 12
        }
      });
    });
    afterEach(function () {
      installerController.getDBProperty.restore();
    });
    it ('Should load hosts from db', function() {
      installerController.loadConfirmedHosts();
      expect(installerController.get('content.hosts')).to.eql({
        'h1': {
          id: 11
        },
        'h3': {
          id: 13
        },
        'h2': {
          id: 12
        }
      });
    });
  });

  describe('#loadMasterComponentHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperties', function(key) {
        return {
          masterComponentHosts: Em.A([
            {
              hostName: '',
              host_id: 11
            }
          ]),
          hosts: {
            'h1': {
              id: 11
            },
            'h3': {
              id: 13
            },
            'h2': {
              id: 12
            }
          }
        }
      });
    });
    afterEach(function () {
      installerController.getDBProperties.restore();
    });
    it ('Should load hosts', function() {
      installerController.loadMasterComponentHosts();
      expect(installerController.get('content.masterComponentHosts')).to.eql([
        {
          "hostName": "h1",
          "host_id": 11
        }
      ]);
    });
  });

  describe('#loadSlaveComponentHosts', function() {
    beforeEach(function () {
      sinon.stub(installerController, 'getDBProperties', function() {
        return {
          hosts: {
            'h1': {
              id: 11
            },
            'h3': {
              id: 13
            },
            'h2': {
              id: 12
            }
          },
          slaveComponentHosts: Em.A([
            {
              hosts: Em.A([
                {
                  hostName: '',
                  host_id: 11
                }
              ])
            }
          ])
        };
      });
    });
    afterEach(function () {
      installerController.getDBProperties.restore();
    });
    it ('Should load slave hosts', function() {
      installerController.loadSlaveComponentHosts();
      expect(installerController.get('content.slaveComponentHosts')).to.eql([
        {
          "hosts": [
            {
              "hostName": "h1",
              "host_id": 11
            }
          ]
        }
      ]);
    });
  });

  describe('#getServerVersionSuccessCallback', function () {

    var cases = [
        {
          osFamily: 'redhat5',
          expected: false
        },
        {
          osFamily: 'redhat6',
          expected: true
        },
        {
          osFamily: 'suse11',
          expected: false
        }
      ],
      title = 'App.isManagedMySQLForHiveEnabled should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osFamily), function () {
        installerController.getServerVersionSuccessCallback({
          'RootServiceComponents': {
            'component_version': '',
            'properties': {
              'server.os_family': item.osFamily
            }
          }
        });
        expect(App.get('isManagedMySQLForHiveEnabled')).to.equal(item.expected);
      });
    });

  });

  describe('#validateJDKVersion', function() {
    var tests = [
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.7',
          isSelected: true
        })],
        m: 'JDK 1.8, stack supports 1.6-1.7 popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.8, stack supports 1.7-1.8 procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports 1.6-1.8, popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: null,
          maxJdkVersion: null,
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max and min are null, procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: '1.5',
          maxJdkVersion: null,
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max is missed and min is 1.5, procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.6'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: '1.5',
          maxJdkVersion: null,
          isSelected: true
        })],
        m: 'JDK 1.6, stack supports max is missed and min is 1.5, popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: null,
          maxJdkVersion: '1.5',
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max 1.5 and min is missed, procceed installation without warning'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.5'
        },
        successCallbackCalled: false,
        popupCalled: true,
        stacks: [Em.Object.create({
          minJdkVersion: null,
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.5, stack supports max 1.8 and min is missed, popup should be displayed'
      },
      {
        isCustomJDK: false,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          isSelected: true
        })],
        m: 'JDK 1.8, min, max jdk missed in stack definition, procceed installation without warning'
      },
      {
        isCustomJDK: true,
        ambariProperties: {
          'java.version': '1.8'
        },
        successCallbackCalled: true,
        popupCalled: false,
        stacks: [Em.Object.create({
          minJdkVersion: '1.6',
          maxJdkVersion: '1.8',
          isSelected: true
        })],
        m: 'JDK 1.8, custom jdk location used, procceed installation without warning'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.stub(App.Stack, 'find').returns(test.stacks);
        sinon.stub(App.router, 'get').withArgs('clusterController.isCustomJDK').returns(test.isCustomJDK)
          .withArgs('clusterController.ambariProperties').returns(test.ambariProperties);
        sinon.stub(App, 'showConfirmationPopup', Em.K);
        var successCallback = sinon.spy();
        installerController.validateJDKVersion(successCallback);
        expect(successCallback.called).to.be.eql(test.successCallbackCalled);
        expect(App.showConfirmationPopup.called).to.be.eql(test.popupCalled);
        App.router.get.restore();
        App.Stack.find.restore();
        App.showConfirmationPopup.restore();
      });
    });
  });

});

});

;require.register("test/controllers/login_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/installer');

describe('App.LoginController', function () {

  var loginController = App.LoginController.create();

  describe('#postLogin', function() {
    it ('Should set error connect', function() {
      loginController.postLogin(false, false, false);
      expect(loginController.get('errorMessage')).to.be.equal('Unable to connect to Ambari Server. Confirm Ambari Server is running and you can reach Ambari Server from this machine.');
    });
    it ('Should set error login', function() {
      loginController.postLogin(true, false, 'User is disabled');
      expect(loginController.get('errorMessage')).to.be.equal('Unable to sign in. Invalid username/password combination.');
    });
    it ('Should set error', function() {
      loginController.postLogin(true, false, '');
      expect(loginController.get('errorMessage')).to.be.equal('Unable to sign in. Invalid username/password combination.');
    });
  });

});

});

;require.register("test/controllers/main/admin/highAvailability/hawq/activateStandby/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/hawq/activateStandby/step2_controller');

describe('App.ActivateHawqStandbyWizardStep2Controller', function () {

  describe('#isSubmitDisabled', function () {

    var controller = App.ActivateHawqStandbyWizardStep2Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });

  describe('#loadConfigTagsSuccessCallback', function () {

    var controller = App.ActivateHawqStandbyWizardStep2Controller.create();
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should send proper ajax request', function () {
      controller.loadConfigTagsSuccessCallback({
        'Clusters': {
          'desired_configs': {
            'hawq-site': {
              'tag': 1
            }
          }
        }
      }, {}, {
        'serviceConfig': {}
      });
      var data = App.ajax.send.args[0][0].data;
      expect(data.urlParams).to.equal('(type=hawq-site&tag=1)');
      expect(data.serviceConfig).to.eql({});
    });

  });

  describe('#loadConfigsSuccessCallback', function () {

    var controller = App.ActivateHawqStandbyWizardStep2Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          'items': [
            {
              'type': 'hawq-site',
              'properties': {
                'hawq_master_address_host' : 'h0',
                'hawq_master_address_host' : 'h1'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          }
        }
      ];

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.loadConfigsSuccessCallback({
          items: item.items
        }, {}, item.params);
        expect(controller.get('selectedService')).to.eql({});
        expect(controller.get('isLoaded')).to.be.true;
      });
    });

  });

  describe('#loadConfigsSuccessCallback=loadConfigsErrorCallback(we have one callback for both cases)', function () {

    var controller = App.ActivateHawqStandbyWizardStep2Controller.create({
      content: Em.Object.create({})
    });

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    it('should proceed with default value', function () {
      controller.loadConfigsSuccessCallback({}, {}, {});
      expect(controller.get('selectedService')).to.eql({});
      expect(controller.get('isLoaded')).to.be.true;
    });

  });


  describe('#setDynamicConfigValues', function () {

    var controller = App.ActivateHawqStandbyWizardStep2Controller.create({
        content: {
          hawqHosts: {
            hawqMaster: 'h0',
            hawqStandby: 'h1'
          }
        }
      }),
      configs = {
        configs: [
          Em.Object.create({
            name: 'hawq_master_address_host'
          })
        ]
      };


    it('hawq_master_address_host value', function () {
      controller.setDynamicConfigValues(configs);
      expect(configs.configs.findProperty('name', 'hawq_master_address_host').get('value')).to.equal('h1');
      expect(configs.configs.findProperty('name', 'hawq_master_address_host').get('recommendedValue')).to.equal('h1');
    });
  });

});

});

;require.register("test/controllers/main/admin/highAvailability/hawq/addStandby/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/hawq/addStandby/step3_controller');

describe('App.AddHawqStandbyWizardStep3Controller', function () {

  describe('#isSubmitDisabled', function () {

    var controller = App.AddHawqStandbyWizardStep3Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });

  describe('#loadConfigTagsSuccessCallback', function () {
/*
    var controller = App.AddHawqStandbyWizardStep3Controller.create({
      content: Em.Object.create({})
    });
*/
    var controller = App.AddHawqStandbyWizardStep3Controller.create();
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should send proper ajax request', function () {
      controller.loadConfigTagsSuccessCallback({
        'Clusters': {
          'desired_configs': {
            'hawq-site': {
              'tag': 1
            }
          }
        }
      }, {}, {
        'serviceConfig': {}
      });
      var data = App.ajax.send.args[0][0].data;
      expect(data.urlParams).to.equal('(type=hawq-site&tag=1)');
      expect(data.serviceConfig).to.eql({});
    });

  });

  describe('#loadConfigsSuccessCallback', function () {

    var controller = App.AddHawqStandbyWizardStep3Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          'items': [
            {
              'type': 'hawq-site',
              'properties': {
                'hawq_master_address_host' : 'h0'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          }
        }
      ];

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.loadConfigsSuccessCallback({
          items: item.items
        }, {}, item.params);
        expect(controller.get('selectedService')).to.eql({});
        expect(controller.get('isLoaded')).to.be.true;
      });
    });

  });

  describe('#loadConfigsSuccessCallback=loadConfigsErrorCallback(we have one callback for both cases)', function () {

    var controller = App.AddHawqStandbyWizardStep3Controller.create({
      content: Em.Object.create({})
    });

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    it('should proceed with default value', function () {
      controller.loadConfigsSuccessCallback({}, {}, {});
      expect(controller.get('selectedService')).to.eql({});
      expect(controller.get('isLoaded')).to.be.true;
    });

  });


  describe('#setDynamicConfigValues', function () {

    var data = {
      items: [
        {
          type: 'hawq-site',
          properties: {
           hawq_master_address_host : 'h0'
          }
        }
      ]
    };
    var controller =  App.AddHawqStandbyWizardStep3Controller.create({
      content: {
        hawqHosts: {
          hawqMaster: 'h0',
          newHawqStandby: 'h1'
        }
      }
    });
      configs = {
        configs: [
          Em.Object.create({
            name: 'hawq_standby_address_host'
          })
        ]
      };

    it('hawq_standby_address_host value', function () {
      controller.setDynamicConfigValues(configs, data);
      expect(configs.configs.findProperty('name', 'hawq_standby_address_host').get('value')).to.equal('h1');
      expect(configs.configs.findProperty('name', 'hawq_standby_address_host').get('recommendedValue')).to.equal('h1');
    });
  });

});

});

;require.register("test/controllers/main/admin/highAvailability/hawq/removeStandby/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/hawq/removeStandby/step2_controller');

describe('App.RemoveHawqStandbyWizardStep2Controller', function () {

  describe('#isSubmitDisabled', function () {

    var controller = App.RemoveHawqStandbyWizardStep2Controller.create({
        content: Em.Object.create({})
      }),
      cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });


});

});

;require.register("test/controllers/main/admin/highAvailability/nameNode/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.HighAvailabilityWizardStep2Controller', function () {
  var controller = App.HighAvailabilityWizardStep2Controller.create();

  describe('#sortMasterComponents', function () {

    it('should sort installed masters first', function() {
      expect(controller.sortMasterComponents([
        Em.Object.create({
          isInstalled: true
        }),
        Em.Object.create({
          isInstalled: false
        }),
        Em.Object.create({
          isInstalled: true
        }),
        Em.Object.create({
          isInstalled: false
        }),
        Em.Object.create({
          isInstalled: true
        })
      ])).to.eql([
            Em.Object.create({
              isInstalled: true
            }),
            Em.Object.create({
              isInstalled: true
            }),
            Em.Object.create({
              isInstalled: true
            }),
            Em.Object.create({
              isInstalled: false
            }),
            Em.Object.create({
              isInstalled: false
            })
          ]);
    });
  });

});
});

;require.register("test/controllers/main/admin/highAvailability/nameNode/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.HighAvailabilityWizardStep3Controller', function() {
  
  describe('#removeConfigs', function() {

    var tests = [
      {
        m: 'should not delete properties if configsToRemove is empty',
        configs: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        },
        toRemove: {},
        expected: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        }
      },
      {
        m: 'should delete properties from configsToRemove',
        configs: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        },
        toRemove: {
          'site1': ['property1', 'property3']
        },
        expected: {
          items: [
            {
              type: 'site1',
              properties: {
                property2: 'value2',
                property4: 'value4'
              }
            }
          ]
        }
      },
      {
        m: 'should delete properties from configsToRemove from different sites',
        configs: {
          items: [
            {
              type: 'site1',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            },
            {
              type: 'site2',
              properties: {
                property1: 'value1',
                property2: 'value2',
                property3: 'value3',
                property4: 'value4'
              }
            }
          ]
        },
        toRemove: {
          'site1': ['property1', 'property3'],
          'site2': ['property2', 'property4']
        },
        expected: {
          items: [
            {
              type: 'site1',
              properties: {
                property2: 'value2',
                property4: 'value4'
              }
            },
            {
              type: 'site2',
              properties: {
                property1: 'value1',
                property3: 'value3'
              }
            }
          ]
        }
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        var controller = App.HighAvailabilityWizardStep3Controller.create({
          configsToRemove: test.toRemove,
          serverConfigData: test.configs
        });
        var result = controller.removeConfigs(test.toRemove, controller.get('serverConfigData'));
        expect(JSON.stringify(controller.get('serverConfigData'))).to.equal(JSON.stringify(test.expected));
        expect(JSON.stringify(result)).to.equal(JSON.stringify(test.expected));
      });
    });
  });
});


});

;require.register("test/controllers/main/admin/highAvailability/nameNode/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.HighAvailabilityWizardStep4Controller', function() {
  
  describe('#checkNnCheckPointStatus', function() {
    beforeEach(function() {
      this.controller = App.HighAvailabilityWizardStep4Controller.create();
      this.clock = sinon.useFakeTimers();
      sinon.stub(this.controller, 'pullCheckPointStatus');
    });

    afterEach(function() {
      this.clock.restore();
      this.controller.pullCheckPointStatus.restore();
    });

    var tests = [
      {
        responseData: {
          HostRoles: { desired_state: 'STARTED' }
        },
        m: 'NameNode started, Safemode off, no journal node transaction. Polling should be performed and isNameNodeStarted should be true',
        e: {
          isPollingCalled: true,
          isNameNodeStarted: true,
          isNextEnabled: false
        }
      },
      {
        responseData: {
          HostRoles: { desired_state: 'STARTED' },
          metrics: { dfs: { namenode: {
            Safemode: 'ON',
            JournalTransactionInfo: "{\"LastAppliedOrWrittenTxId\":\"4\",\"MostRecentCheckpointTxId\":\"2\"}"
          }}}
        },
        m: 'NameNode started, Safemode on, journal node transaction invalid. Polling should be performed and isNameNodeStarted should be true',
        e: {
          isPollingCalled: true,
          isNameNodeStarted: true,
          isNextEnabled: false
        }
      },
      {
        responseData: {
          HostRoles: { desired_state: 'INSTALLED' },
          metrics: { dfs: { namenode: {
            Safemode: 'ON',
            JournalTransactionInfo: "{\"LastAppliedOrWrittenTxId\":\"15\",\"MostRecentCheckpointTxId\":\"14\"}"
          }}}
        },
        m: 'NameNode not started, Safemode on, journal node transaction present. Polling should not be performed and isNameNodeStarted should be false',
        e: {
          isPollingCalled: false,
          isNameNodeStarted: false,
          isNextEnabled: true
        }
      },
      {
        responseData: {
          HostRoles: { desired_state: 'STARTED' },
          metrics: { dfs: { namenode: {
            Safemode: "",
            JournalTransactionInfo: "{\"LastAppliedOrWrittenTxId\":\"15\",\"MostRecentCheckpointTxId\":\"14\"}"
          }}}
        },
        m: 'NameNode started, Safemode off, journal node transaction present. Polling should not be performed and isNameNodeStarted should be true',
        e: {
          isPollingCalled: true,
          isNameNodeStarted: true,
          isNextEnabled: false
        }
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        this.controller.set('isNameNodeStarted', !test.e.isNameNodeStarted);
        this.controller.checkNnCheckPointStatus(test.responseData);
        this.clock.tick(this.controller.get('POLL_INTERVAL'));
        expect(this.controller.get('isNameNodeStarted')).to.be.eql(test.e.isNameNodeStarted);
        expect(this.controller.get('isNextEnabled')).to.be.eql(test.e.isNextEnabled);
        expect(this.controller.pullCheckPointStatus.called).to.be.eql(test.e.isPollingCalled);
      });
    });
  });
});


});

;require.register("test/controllers/main/admin/highAvailability/progress_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability_controller');
require('models/host_component');
require('models/host');
require('utils/ajax/ajax');

describe('App.HighAvailabilityProgressPageController', function () {

  var controller = App.HighAvailabilityProgressPageController.create();

  describe('#reconfigureSites()', function () {
    var tests = [
      {
        siteNames: ["site1", "site2"],
        data: {
          items: [
            {
              type: "site1",
              properties: {
                site1_property1: "site1_property1_value",
                site1_property2: "site1_property2_value"
              },
              properties_attributes: {
                final: {
                  site1_property1: "true"
                }
              }
            },
            {
              type: "site2",
              properties: {
                site2_property1: "site2_property1_value",
                site2_property2: "site2_property2_value"
              }
            },
            {
              type: "site3",
              properties: {
                site3_property: "site3_property_value"
              }
            }
          ]
        },
        note: 'note1',
        result: [
          {
            type: "site1",
            tag: "version1",
            properties: {
              site1_property1: "site1_property1_value",
              site1_property2: "site1_property2_value"
            },
            service_config_version_note: 'note1',
            properties_attributes: {
              final: {
                site1_property1: "true"
              }
            }
          },
          {
            type: "site2",
            tag: "version1",
            properties: {
              site2_property1: "site2_property1_value",
              site2_property2: "site2_property2_value"
            },
            service_config_version_note: 'note1'
          }
        ]
      },
      {
        siteNames: ["site1"],
        data: {
          items: [
            {
              type: "site1",
              properties: {
                site1_property1: "site1_property1_value",
                site1_property2: "site1_property2_value"
              },
              properties_attributes: {
                final: {
                  site1_property1: "true"
                }
              }
            }
          ]
        },
        note: 'note2',
        result: [
          {
            type: "site1",
            tag: "version1",
            properties: {
              site1_property1: "site1_property1_value",
              site1_property2: "site1_property2_value"
            },
            service_config_version_note: 'note2',
            properties_attributes: {
              final: {
                site1_property1: "true"
              }
            }
          }
        ]
      }];
    beforeEach(function() {
      App.set('testMode', true);
    });
    afterEach(function() {
      App.set('testMode', false);
    });
    it("reconfigures configs after HA", function() {
      tests.forEach(function(t) {
        controller.set('content', t.content);
        expect(controller.reconfigureSites(t.siteNames, t.data, t.note)).to.eql(t.result);
      });
    });
  });

});

});

;require.register("test/controllers/main/admin/highAvailability/progress_popup_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/admin/highAvailability/progress_popup_controller');

describe('App.HighAvailabilityProgressPopupController', function () {

  var controller;

  beforeEach(function () {
    controller = App.HighAvailabilityProgressPopupController.create();
  });

  describe('#startTaskPolling', function () {

    beforeEach(function () {
      sinon.stub(App.updater, 'run', Em.K);
      sinon.stub(App.updater, 'immediateRun', Em.K);
    });

    afterEach(function () {
      App.updater.run.restore();
      App.updater.immediateRun.restore();
    });

    it('should start task polling', function () {
      controller.startTaskPolling(1, 2);
      expect(controller.get('isTaskPolling')).to.be.true;
      expect(controller.get('taskInfo.id'), 2);
      expect(controller.get('taskInfo.requestId'), 1);
      expect(App.updater.run.calledOnce).to.be.true;
      expect(App.updater.immediateRun.calledOnce).to.be.true;
    });

  });

  describe('#stopTaskPolling', function () {

    it('should stop task polling', function () {
      controller.stopTaskPolling();
      expect(controller.get('isTaskPolling')).to.be.false;
    });

  });

  describe('#updateTask', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should send polling request', function () {
      controller.updateTask();
      expect(App.ajax.send.calledOnce).to.be.true;
    });

  });

  describe('#updateTaskSuccessCallback', function () {

    beforeEach(function () {
      controller.reopen({
        taskInfo: {}
      });
    });

    var cases = [
        {
          status: 'FAILED',
          isTaskPolling: false
        },
        {
          status: 'COMPLETED',
          isTaskPolling: false
        },
        {
          status: 'TIMEDOUT',
          isTaskPolling: false
        },
        {
          status: 'ABORTED',
          isTaskPolling: false
        },
        {
          status: 'QUEUED',
          isTaskPolling: true
        },
        {
          status: 'IN_PROGRESS',
          isTaskPolling: true
        }
      ],
      tasks = {
        stderr: 'error',
        stdout: 'output',
        output_log: 'output-log.txt',
        error_log: 'error-log.txt'
      },
      title = '{0}polling task if it\'s status is {1}';

    cases.forEach(function (item) {
      var message = title.format(item.isTaskPolling ? '' : 'not ', item.status);
      it(message, function () {
        controller.updateTaskSuccessCallback({
          Tasks: $.extend(tasks, {
            status: item.status
          })
        });
        expect(controller.get('taskInfo.stderr')).to.equal('error');
        expect(controller.get('taskInfo.stdout')).to.equal('output');
        expect(controller.get('taskInfo.outputLog')).to.equal('output-log.txt');
        expect(controller.get('taskInfo.errorLog')).to.equal('error-log.txt');
        expect(controller.get('isTaskPolling')).to.equal(item.isTaskPolling);
      });
    });

  });

  describe('#getHosts', function () {

    var cases = [
      {
        name: 'background_operations.get_by_request',
        title: 'default background operation polling'
      },
      {
        stageId: 0,
        name: 'common.request.polling',
        stageIdPassed: '0',
        title: 'polling by stage, stageId = 0'
      },
      {
        stageId: 1,
        name: 'common.request.polling',
        stageIdPassed: 1,
        title: 'polling by stage'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.setProperties({
          requestIds: [1, 2],
          stageId: item.stageId
        });
        controller.getHosts();
        expect(App.ajax.send.calledTwice).to.be.true;
        expect(App.ajax.send.firstCall.args[0].name).to.equal(item.name);
        expect(App.ajax.send.secondCall.args[0].name).to.equal(item.name);
        expect(App.ajax.send.firstCall.args[0].data.stageId).to.eql(item.stageIdPassed);
        expect(App.ajax.send.secondCall.args[0].data.stageId).to.eql(item.stageIdPassed);
      });
    });

  });

});

});

;require.register("test/controllers/main/admin/highAvailability/resourceManager/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/admin/highAvailability/resourceManager/step3_controller');

describe('App.RMHighAvailabilityWizardStep3Controller', function () {

  describe('#isSubmitDisabled', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create(),
      cases = [
        {
          isLoaded: false,
          isSubmitDisabled: true,
          title: 'wizard step content not loaded'
        },
        {
          isLoaded: true,
          isSubmitDisabled: false,
          title: 'wizard step content loaded'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isLoaded', item.isLoaded);
        expect(controller.get('isSubmitDisabled')).to.equal(item.isSubmitDisabled);
      });
    });

  });

  describe('#loadConfigTagsSuccessCallback', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create();

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should send proper ajax request', function () {
      controller.loadConfigTagsSuccessCallback({
        'Clusters': {
          'desired_configs': {
            'zoo.cfg': {
              'tag': 1
            },
            'yarn-site': {
              'tag': 1
            },
            'yarn-env': {
              'tag': 1
            }
          }
        }
      }, {}, {
        'serviceConfig': {}
      });
      var data = App.ajax.send.args[0][0].data;
      expect(data.urlParams).to.equal('(type=zoo.cfg&tag=1)|(type=yarn-site&tag=1)|(type=yarn-env&tag=1)');
      expect(data.serviceConfig).to.eql({});
    });

  });

  describe('#loadConfigsSuccessCallback', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create(),
      cases = [
        {
          'items': [],
          'params': {
            'serviceConfig': {}
          },
          'port': '2181',
          'webAddressPort' : ':8088',
          'httpsWebAddressPort' : ':8090',
          'yarnUser': null,
          'title': 'empty response'
        },
        {
          'items': [
            {
              'type': 'zoo.cfg'
            },
            {
              'type': 'yarn-site'
            }
          ],
          'params': {
            'serviceConfig': {}
          },
          'port': '2181',
          'webAddressPort' : ':8088',
          'httpsWebAddressPort' : ':8090',
          'yarnUser': null,
          'title': 'no zoo.cfg properties received'
        },
        {
          'items': [
            {
              'type': 'zoo.cfg',
              'properties': {
                'n': 'v'
              }
            },
            {
              'type': 'yarn-site',
              'properties': {
                'n': 'v'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          },
          'port': '2181',
          'webAddressPort' : ':8088',
          'httpsWebAddressPort' : ':8090',
          'yarnUser': null,
          'title': 'no clientPort property received'
        },
        {
          'items': [
            {
              'type': 'zoo.cfg',
              'properties': {
                'n': 'v'
              }
            },
            {
              'type': 'yarn-site',
              'properties': {
                'n': 'v'
              }
            },
            {
              'type': 'yarn-env',
              'properties': {
                'yarn_user': 'yarn'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          },
          'port': '2181',
          'webAddressPort' : ':8088',
          'httpsWebAddressPort' : ':8090',
          'yarnUser': 'yarn',
          'title': 'set yarn user'
        },
        {
          'items': [
            {
              'type': 'zoo.cfg',
              'properties': {
                'clientPort': '2182'
              }
            },
            {
              'type': 'yarn-site',
              'properties': {
                'yarn.resourcemanager.webapp.address' : 'c6402.ambari.apache.org:7777',
                'yarn.resourcemanager.webapp.https.address' : 'c6402.ambari.apache.org:8888'
              }
            }
          ],
          'params': {
            'serviceConfig': {}
          },
          'port': '2182',
          'webAddressPort' : ':7777',
          'httpsWebAddressPort' : ':8888',
          'yarnUser': null,
          'title': 'clientPort property received'
        }
      ];

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.loadConfigsSuccessCallback({
          items: item.items
        }, {}, item.params);
        expect(controller.setDynamicConfigValues.args[0]).to.eql([{}, item.port, item.webAddressPort, item.httpsWebAddressPort, item.yarnUser]);
        expect(controller.get('selectedService')).to.eql({});
        expect(controller.get('isLoaded')).to.be.true;
      });
    });

  });

  describe('#loadConfigsSuccessCallback=loadConfigsErrorCallback(we have one callback for bouth cases)', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create();

    beforeEach(function () {
      sinon.stub(controller, 'setDynamicConfigValues', Em.K);
    });

    afterEach(function () {
      controller.setDynamicConfigValues.restore();
    });

    it('should proceed with default value', function () {
      controller.loadConfigsSuccessCallback({}, {}, {}, {}, {
        serviceConfig: {}
      });
      console.error("test_alex!!!!!",controller.setDynamicConfigValues.args[0]);
      expect(controller.setDynamicConfigValues.args[0]).to.eql([{}, '2181', ':8088', ':8090', null]);
      expect(controller.get('selectedService')).to.eql({});
      expect(controller.get('isLoaded')).to.be.true;
    });

  });

  describe('#setDynamicConfigValues', function () {

    var controller = App.RMHighAvailabilityWizardStep3Controller.create({
        content: {
          rmHosts: {
            currentRM: 'h0',
            additionalRM: 'h1'
          }
        }
      }),
      configs = {
        configs: [
          Em.Object.create({
            name: 'yarn.resourcemanager.hostname.rm1'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.hostname.rm2'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.zk-address'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.address.rm1'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.address.rm2'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.https.address.rm1'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.webapp.https.address.rm2'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.ha'
          }),
          Em.Object.create({
            name: 'yarn.resourcemanager.scheduler.ha'
          })
        ]
      };

    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
              hostName: 'h2'
          }),
          Em.Object.create({
            componentName: 'ZOOKEEPER_SERVER',
              hostName: 'h3'
          }),
          Em.Object.create({
            componentName: 'RESOURCEMANAGER',
              hostName: 'h4'
          })
        ];
      });

      sinon.stub(App.Service, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 'HAWQ'
          })
        ];
      });
    });

    afterEach(function () {
      App.HostComponent.find.restore();
      App.Service.find.restore();
    });

    it('setting new RM properties values', function () {
      controller.setDynamicConfigValues(configs, '2181', ':8088', ':8090');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm1').get('value')).to.equal('h0');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm1').get('recommendedValue')).to.equal('h0');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm2').get('value')).to.equal('h1');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.hostname.rm2').get('recommendedValue')).to.equal('h1');

      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm1').get('value')).to.equal('h0:8088');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm1').get('recommendedValue')).to.equal('h0:8088');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm2').get('value')).to.equal('h1:8088');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.address.rm2').get('recommendedValue')).to.equal('h1:8088');

      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm1').get('value')).to.equal('h0:8090');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm1').get('recommendedValue')).to.equal('h0:8090');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm2').get('value')).to.equal('h1:8090');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.webapp.https.address.rm2').get('recommendedValue')).to.equal('h1:8090');

      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.zk-address').get('value')).to.equal('h2:2181,h3:2181');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.zk-address').get('recommendedValue')).to.equal('h2:2181,h3:2181');

      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.ha').get('value')).to.equal('h0:8032,h1:8032');
      expect(configs.configs.findProperty('name', 'yarn.resourcemanager.scheduler.ha').get('recommendedValue')).to.equal('h0:8030,h1:8030');
    });

  });

});

});

;require.register("test/controllers/main/admin/highAvailability_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/highAvailability_controller');
require('models/host_component');
require('models/host');
require('utils/ajax/ajax');

describe('App.MainAdminHighAvailabilityController', function () {

  var controller = App.MainAdminHighAvailabilityController.create();

  describe('#enableHighAvailability()', function () {

    var hostComponents = [];

    beforeEach(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.stub(App.HostComponent, 'find', function(){
        return hostComponents;
      });
      sinon.spy(controller, "showErrorPopup");
    });
    afterEach(function () {
      App.router.transitionTo.restore();
      controller.showErrorPopup.restore();
      App.HostComponent.find.restore();
    });

    it('NAMENODE in INSTALLED state', function () {
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        })
      ];

      sinon.stub(App.router, 'get', function(){
        return 3;
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
      App.router.get.restore();
    });
    it('Cluster has less than 3 ZOOKEPER_SERVER components', function () {
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        })
      ];

      sinon.stub(App.router, 'get', function(){
        return 3;
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.called).to.be.true;
      App.router.get.restore();
    });
    it('total hosts number less than 3', function () {
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        })
      ];
      sinon.stub(App.router, 'get', function () {
        return 1;
      });
      expect(controller.enableHighAvailability()).to.be.false;
      expect(controller.showErrorPopup.calledOnce).to.be.true;
      App.router.get.restore();
    });
    it('All checks passed', function () {
      hostComponents = [
        Em.Object.create({
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        }),
        Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INSTALLED'
        })
      ];
      sinon.stub(App.router, 'get', function(){
        return 3;
      });
      expect(controller.enableHighAvailability()).to.be.true;
      expect(App.router.transitionTo.calledWith('main.services.enableHighAvailability')).to.be.true;
      expect(controller.showErrorPopup.calledOnce).to.be.false;
      App.router.get.restore();
    });
  });

  describe('#joinMessage()', function () {
    it('message is empty', function () {
      var message = [];
      expect(controller.joinMessage(message)).to.be.empty;
    });
    it('message is array from two strings', function () {
      var message = ['yes', 'no'];
      expect(controller.joinMessage(message)).to.equal('yes<br/>no');
    });
    it('message is string', function () {
      var message = 'hello';
      expect(controller.joinMessage(message)).to.equal('<p>hello</p>');
    });
  });

});

});

;require.register("test/controllers/main/admin/kerberos/kerberos_wizard_controler_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.KerberosWizardController', function() {
  var controller = App.KerberosWizardController.create({});

  describe('#warnBeforeExitPopup()', function () {
    beforeEach(function () {
      sinon.stub(App, "showConfirmationPopup", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });
    it('should open warning confirmation popup', function () {
      var f = Em.K;
      controller.warnBeforeExitPopup(f, false);
      expect(App.showConfirmationPopup.calledWith(f, Em.I18n.t('admin.kerberos.wizard.exit.warning.msg'), null, null, Em.I18n.t('common.exitAnyway'), false)).to.be.true;
    });

    it('should open critical confirmation popup', function () {
      var f = Em.K;
      controller.warnBeforeExitPopup(f, true);
      expect(App.showConfirmationPopup.calledWith(f, Em.I18n.t('admin.kerberos.wizard.exit.critical.msg'), null, null, Em.I18n.t('common.exitAnyway'), true)).to.be.true;
    });
  });

});



});

;require.register("test/controllers/main/admin/kerberos/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var setups = require('test/init_model_test');

describe('App.KerberosWizardStep2Controller', function() {

  describe('#createKerberosSiteObj', function() {
    var controller;

    beforeEach(function() {
      setups.setupStackVersion(this, 'HDP-2.3');
      controller = App.KerberosWizardStep2Controller.create({});
      sinon.stub(controller, 'tweakKdcTypeValue', Em.K);
      sinon.stub(controller, 'tweakManualKdcProperties', Em.K);
    });

    after(function() {
      setups.restoreStackVersion(this);
      controller.tweakKdcTypeValue.restore();
      controller.tweakManualKdcProperties.restore();
    });

    var _createProperty = function(name, value, displayType) {
      var preDefProp = App.config.get('preDefinedSiteProperties').findProperty('name', name);
      if (preDefProp) {
        return App.ServiceConfigProperty.create(
          $.extend(true, {}, preDefProp, {
            value: value, filename: 'some-site.xml',
            'displayType': displayType,
            isRequiredByAgent: preDefProp.isRequiredByAgent == undefined ? true : preDefProp.isRequiredByAgent
          }));
      } else {
        return App.ServiceConfigProperty.create({name: name, value: value, isRequiredByAgent: true, filename: 'some-site.xml'});
      }
    };

    var tests = [
      {
        stepConfigs: [
          ['realm', ' SPACES ', 'host'],
          ['admin_server_host', ' space_left', 'host'],
          ['kdc_host', ' space_left_and_right ', 'host'],
          ['ldap_url', 'space_right ', 'host']
        ],
        e: {
          realm: 'SPACES',
          admin_server_host: 'space_left',
          kdc_host: 'space_left_and_right',
          ldap_url: 'space_right'
        }
      }
    ];

    tests.forEach(function(test) {
      it('Should trim values for properties ' + Em.keys(test.e).join(','), function() {
        sinon.stub(App.StackService, 'find').returns([Em.Object.create({serviceName: 'KERBEROS'})]);
        controller.set('stepConfigs', [
          App.ServiceConfig.create({
            configs: test.stepConfigs.map(function(item) { return _createProperty(item[0], item[1], item[2]); })
          })
        ]);
        var result = controller.createKerberosSiteObj('some-site', 'random-tag');
        App.StackService.find.restore();
        Em.keys(test.e).forEach(function(propertyName) {
          expect(result.properties[propertyName]).to.be.eql(test.e[propertyName]);
        });
      });
    });
  });
});

});

;require.register("test/controllers/main/admin/kerberos/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.KerberosWizardStep3Controller', function() {
  
  describe('#onTestKerberosError', function() {
    var controller = App.KerberosWizardStep3Controller.create({});

    beforeEach(function(){
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
      sinon.stub(controller, 'onTaskError', Em.K);
    });

    afterEach(function(){
      App.ajax.defaultErrorHandler.restore();
      controller.onTaskError.restore();
    });

    it('should call App.ajax.defaultErrorHandler and onTaskError', function () {
      controller.onTestKerberosError({status: 3}, null, null, {url: 1, type: 2});
      expect(App.ajax.defaultErrorHandler.calledWith({status: 3}, 1, 2, 3)).to.be.true;
      expect(controller.onTaskError.calledOnce).to.be.true;
    });
  });

});
});

;require.register("test/controllers/main/admin/kerberos/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.KerberosWizardStep4Controller', function() {

  describe('#isSubmitDisabled', function() {
    var controller = App.KerberosWizardStep4Controller.create({});
    var configs = Em.A([
      App.ServiceConfigProperty.create({ name: 'prop1', value: 'someVal1', identityType: 'user', category: 'Ambari Principals', serviceName: 'Cluster'})
    ]);
    controller.set('stepConfigs', controller.createServiceConfig(configs));

    it('configuration errors are absent, submit should be not disabled', function() {
      expect(controller.get('stepConfigs')[0].get('errorCount')).to.be.eql(0);
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });

    it('config has invalid value, submit should be disabled', function() {
      var serviceConfig = controller.get('stepConfigs')[0];
      serviceConfig.get('configs').findProperty('name', 'prop1').set('value', '');
      expect(serviceConfig.get('errorCount')).to.be.eql(1);
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
  });

  describe('#createServiceConfig', function() {
    var controller = App.KerberosWizardStep4Controller.create({});
    it('should create instance of App.ServiceConfig', function() {
      controller.createServiceConfig([], []).forEach(function(item){
        expect(item).be.instanceof(App.ServiceConfig);
      });
    });
  });

  describe('#prepareConfigProperties', function() {

    before(function() {
      var controller = App.KerberosWizardStep4Controller.create({
        wizardController: {
          getDBProperty: function() {
            return Em.A([
              Em.Object.create({ name: 'realm', value: 'realm_value' })
            ]);
          },
          loadCachedStepConfigValues: function() {
            return null;
          }
        }
      });
      sinon.stub(App.Service, 'find').returns(Em.A([
        { serviceName: 'HDFS' }
      ]));
      sinon.stub(App.config, 'get').withArgs('preDefinedSiteProperties').returns([
        {
          name: 'hadoop.security.auth_to_local',
          displayType: 'multiLine'
        }
      ]);
      sinon.stub(App.router, 'get').withArgs('mainAdminKerberosController.isManualKerberos').returns(false);
      this.result = controller.prepareConfigProperties(properties);
    });

    after(function() {
      App.Service.find.restore();
      App.config.get.restore();
      App.router.get.restore();
    });

    var properties = Em.A([
      Em.Object.create({ name: 'realm', value: '', serviceName: 'Cluster' }),
      Em.Object.create({ name: 'spnego_keytab', value: 'spnego_keytab_value', serviceName: 'Cluster' }),
      Em.Object.create({ name: 'hdfs_keytab', value: '', serviceName: 'HDFS', identityType: 'user', observesValueFrom: 'spnego_keytab' }),
      Em.Object.create({ name: 'falcon_keytab', value: 'falcon_keytab_value', serviceName: 'FALCON' }),
      Em.Object.create({ name: 'mapreduce_keytab', value: 'mapreduce_keytab_value', serviceName: 'MAPREDUCE2' }),
      Em.Object.create({ name: 'hdfs_principal', value: 'hdfs_principal_value', identityType: 'user', serviceName: 'HDFS' }),
      Em.Object.create({ name: 'hadoop.security.auth_to_local', serviceName: 'HDFS' })
    ]);

    var propertyValidationCases = [
      {
        property: 'spnego_keytab',
        e: [
          { key: 'category', value: 'Global' },
          { key: 'observesValueFrom', absent: true }
        ]
      },
      {
        property: 'realm',
        e: [
          { key: 'category', value: 'Global' },
          { key: 'value', value: 'realm_value' }
        ]
      },
      {
        property: 'hdfs_keytab',
        e: [
          { key: 'category', value: 'Ambari Principals' },
          { key: 'value', value: 'spnego_keytab_value' },
          { key: 'observesValueFrom', value: 'spnego_keytab' }
        ]
      },
      {
        property: 'hadoop.security.auth_to_local',
        e: [
          { key: 'displayType', value: 'multiLine' }
        ]
      }
    ];

    var absentPropertiesTest = ['falcon_keytab', 'mapreduce_keytab'];

    it('should contains properties only for installed services', function() {
      expect(this.result.mapProperty('serviceName').uniq()).to.be.eql(['Cluster', 'HDFS']);
    });

    absentPropertiesTest.forEach(function(item) {
      it('property `{0}` should be absent'.format(item), function() {
        expect(this.result.findProperty('name', item)).to.be.undefined;
      });
    }, this);

    propertyValidationCases.forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(this.result.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          if (!!expected.absent) {
            expect(this.result.findProperty('name', test.property)).to.not.have.deep.property(expected.key);
          } else {
            expect(this.result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
          }
        }, this);
      }, this);
    });
  });

  describe('#setStepConfigs', function() {
    describe('Add Service Wizard', function() {
      var res;
      var controller;
      before(function() {
        sinon.stub(App.StackService, 'find').returns([
          Em.Object.create({
            serviceName: 'KERBEROS',
            configCategories: []
          }),
          Em.Object.create({
            serviceName: 'HDFS',
            configCategories: []
          }),
          Em.Object.create({
            serviceName: 'MAPREDUCE2'
          })
        ]);
        sinon.stub(App.Service, 'find').returns([
          Em.Object.create({
            serviceName: 'HDFS'
          }),
          Em.Object.create({
            serviceName: 'KERBEROS'
          })
        ]);
        controller = App.KerberosWizardStep4Controller.create({
          selectedServiceNames: ['FALCON', 'MAPREDUCE2'],
          installedServiceNames: ['HDFS', 'KERBEROS'],
          wizardController: Em.Object.create({
            name: 'addServiceController',
            getDBProperty: function() {
              return Em.A([
                Em.Object.create({ name: 'realm', value: 'realm_value' }),
              ]);
            },
            loadCachedStepConfigValues : function() {
              return null;
            }
          })
        });
        sinon.stub(App.router, 'get').withArgs('mainAdminKerberosController.isManualKerberos').returns(false);
        controller.setStepConfigs(properties);
        res = controller.get('stepConfigs')[0].get('configs').concat(controller.get('stepConfigs')[1].get('configs'));
      });

      var properties = Em.A([
        Em.Object.create({ name: 'realm', value: '', serviceName: 'Cluster' }),
        Em.Object.create({ name: 'spnego_keytab', value: 'spnego_keytab_value', serviceName: 'Cluster', isEditable: true }),
        Em.Object.create({ name: 'hdfs_keytab', value: '', serviceName: 'HDFS', observesValueFrom: 'spnego_keytab', isEditable: true }),
        Em.Object.create({ name: 'falcon_keytab', value: 'falcon_keytab_value', serviceName: 'FALCON', isEditable: true }),
        Em.Object.create({ name: 'mapreduce_keytab', value: 'mapreduce_keytab_value', serviceName: 'MAPREDUCE2', isEditable: true })
      ]);

      var propertiesEditableTests = [
        { name: 'spnego_keytab', e: false },
        { name: 'falcon_keytab', e: true },
        { name: 'hdfs_keytab', e: false },
        { name: 'mapreduce_keytab', e: true }
      ];

      propertiesEditableTests.forEach(function(test) {
        it('Add Service: property `{0}` should be {1} editable'.format(test.name, !!test.e ? '' : 'not '), function() {
          expect(res.findProperty('name', test.name).get('isEditable')).to.eql(test.e);
        });
      });

      after(function() {
        controller.destroy();
        controller = null;
        App.StackService.find.restore();
        App.Service.find.restore();
        App.router.get.restore();
      });
    });
  });

  describe("#createCategoryForServices()", function() {
    var controller = App.KerberosWizardStep4Controller.create({
      wizardController: {
        name: 'addServiceController'
      }
    });
    beforeEach(function() {
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS',
          displayName: 'HDFS'
        })
      ]);
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS',
          displayName: 'HDFS',
          isInstalled: true
        }),
        Em.Object.create({
          serviceName: 'MAPREDUCE2',
          displayName: 'MapReduce 2',
          isInstalled: false,
          isSelected: true
        })
      ]);
    });

    afterEach(function() {
      App.Service.find.restore();
      App.StackService.find.restore();
    });

    it('for add service', function() {
      expect(controller.createCategoryForServices()).to.eql([App.ServiceConfigCategory.create({ name: 'HDFS', displayName: 'HDFS', collapsedByDefault: true}),
        App.ServiceConfigCategory.create({ name: 'MAPREDUCE2', displayName: 'MapReduce 2', collapsedByDefault: true})]);
    });

    it('for kerberos wizard', function() {
      controller.set('wizardController.name', 'KerberosWizard');
      expect(controller.createCategoryForServices()).to.eql([App.ServiceConfigCategory.create({ name: 'HDFS', displayName: 'HDFS', collapsedByDefault: true})]);
    });
  });

  describe('#loadStep', function() {
    var controller;
    describe('skip "Configure Identities" step. ', function() {
      beforeEach(function() {
        controller = App.KerberosWizardStep4Controller.create({});
        this.wizardController = App.AddServiceController.create({});
        controller.set('wizardController', this.wizardController);
        sinon.stub(controller, 'clearStep').returns(true);
        sinon.stub(controller, 'getDescriptorConfigs').returns((new $.Deferred()).resolve(true).promise());
        sinon.stub(controller, 'setStepConfigs').returns(true);
        sinon.stub(App.router, 'send').withArgs('next');
      });

      afterEach(function() {
        controller.clearStep.restore();
        controller.getDescriptorConfigs.restore();
        controller.setStepConfigs.restore();
        App.router.send.restore();
      });

      var tests = [
        {
          securityEnabled: true,
          stepSkipped: false
        },
        {
          securityEnabled: false,
          stepSkipped: true
        }
      ];

      tests.forEach(function(test) {
        it('Security {0} configure identities step should be {1}'.format(!!test.securityEnabled ? 'enabled' : 'disabled', !!test.stepSkipped ? 'skipped' : 'not skipped'), function() {
          sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(test.securityEnabled);
          this.wizardController.checkSecurityStatus();
          App.get.restore();
          controller.loadStep();
          expect(App.router.send.calledWith('next')).to.be.eql(test.stepSkipped);
        });
      }, this);

      it('step should not be disabled for Add Kerberos wizard', function() {
        controller.set('wizardController', App.KerberosWizardController.create({}));
        controller.loadStep();
        expect(App.router.send.calledWith('next')).to.be.false;
      });
    });
  });

  describe('#getDescriptorConfigs', function() {
    describe('Within Add Service', function () {
      var controller;
      beforeEach(function () {
        controller = App.KerberosWizardStep4Controller.create({
          wizardController: Em.Object.create({
            name: 'addServiceController',
            setDBProperty: sinon.spy()
          })
        });
        this.loadStackDescriptorStub = sinon.stub(controller, 'loadStackDescriptorConfigs').returns($.Deferred().resolve().promise());
        this.loadClusterDescriptorStub = sinon.stub(controller, 'loadClusterDescriptorConfigs');
        sinon.stub(controller, 'createServicesStackDescriptorConfigs', Em.K);
      });

      afterEach(function() {
        this.loadStackDescriptorStub.restore();
        this.loadClusterDescriptorStub.restore();
        controller.createServicesStackDescriptorConfigs.restore();
        controller.destroy();
        controller = null;
      });

      var cases = [
        {
          wizardController: 'addServiceController',
          clusterDescriptorExists: false,
          m: 'Within Add Service, Cluster Descriptor not exists. Should be reflected in wizard controller',
          e: {
            setDBPropertyCalled: true,
            setDBPropertyCalledWith: ['isClusterDescriptorExists', false]
          }
        },
        {
          wizardController: 'addServiceController',
          clusterDescriptorExists: true,
          m: 'Within Add Service, Cluster Descriptor is present. Should be reflected in wizard controller',
          e: {
            setDBPropertyCalled: true,
            setDBPropertyCalledWith: ['isClusterDescriptorExists', true]
          }
        },
        {
          wizardController: 'notAddService',
          clusterDescriptorExists: true,
          m: 'Within another controller, nothing to store',
          e: {
            setDBPropertyCalled: false,
          }
        }
      ];

      cases.forEach(function(test) {
        it(test.m, function () {
          controller.get('wizardController').set('name', test.wizardController);
          this.loadClusterDescriptorStub.returns(test.clusterDescriptorExists ?
             $.Deferred().resolve().promise() :
             $.Deferred().reject().promise());
          controller.getDescriptorConfigs();
          expect(controller.get('wizardController').setDBProperty.called).to.be.eql(test.e.setDBPropertyCalled);
          if (test.e.setDBPropertyCalled) {
            expect(controller.get('wizardController').setDBProperty.args[0]).to.be.eql(test.e.setDBPropertyCalledWith);
          }
        })
      })
    });
  });
});

});

;require.register("test/controllers/main/admin/kerberos/step6_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.KerberosWizardStep6Controller', function() {
  describe('#checkComponentsRemoval', function() {

    var tests = [
      { yarnInstalled: true, doesATSSupportKerberos: false, commands: ['stopServices', 'deleteATS'], ATSInstalled: true},
      { yarnInstalled: false, doesATSSupportKerberos: true, commands: ['stopServices'], ATSInstalled: true},
      { yarnInstalled: false, doesATSSupportKerberos: false, commands: ['stopServices'], ATSInstalled: true},
      { yarnInstalled: true, doesATSSupportKerberos: true, commands: ['stopServices'], ATSInstalled: false},
      { yarnInstalled: true, doesATSSupportKerberos: true, commands: ['stopServices'], ATSInstalled: true}
    ];

    tests.forEach(function(test) {
      it('YARN installed: {0}, ATS supported: {1} list of commands should be {2}'.format(test.yarnInstalled, test.doesATSSupportKerberos, test.commands.toString()), function () {
        var controller = App.KerberosWizardStep6Controller.create({ commands: ['stopServices'] });
        sinon.stub(App, 'get').withArgs('doesATSSupportKerberos').returns(test.doesATSSupportKerberos);
        sinon.stub(App.Service, 'find').returns(test.yarnInstalled ? [Em.Object.create({ serviceName: 'YARN'})] : []);
        sinon.stub(App.HostComponent, 'find').returns(test.ATSInstalled ? [Em.Object.create({ componentName: 'APP_TIMELINE_SERVER'})] : []);
        controller.checkComponentsRemoval();
        App.get.restore();
        App.Service.find.restore();
        App.HostComponent.find.restore();
        expect(controller.get('commands').toArray()).to.eql(test.commands);
      });
    });
  });
});

});

;require.register("test/controllers/main/admin/kerberos_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.MainAdminKerberosController', function() {

  var controller = App.MainAdminKerberosController.create({});

  describe('#prepareConfigProperties', function() {
    beforeEach(function() {
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({ serviceName: 'KERBEROS'}),
        Em.Object.create({ serviceName: 'HDFS' })
      ]);
      this.result = controller.prepareConfigProperties([
        Em.Object.create({ name: 'prop1', isEditable: true, serviceName: 'SERVICE1'}),
        Em.Object.create({ name: 'prop2', isEditable: true, serviceName: 'KERBEROS'}),
        Em.Object.create({ name: 'prop3', isEditable: true, serviceName: 'HDFS'}),
        Em.Object.create({ name: 'prop4', isEditable: true, serviceName: 'Cluster'}),
        Em.Object.create({ name: 'prop5', isEditable: true, serviceName: 'SERVICE1'}),
      ]);
    });

    afterEach(function() {
      App.Service.find.restore();
    });

    ['prop1', 'prop5'].forEach(function(item) {
      it('property `{0}` should be absent'.format(item), function() {
        expect(this.result.findProperty('name', item)).to.be.undefined;
      });
    });

    ['prop2', 'prop3', 'prop4'].forEach(function(item) {
      it('property `{0}` should be present and not editable'.format(item), function() {
        var prop = this.result.findProperty('name', item);
        expect(prop).to.be.ok;
        expect(prop.get('isEditable')).to.be.false;
      });
    });

    it('should take displayType from predefinedSiteProperties', function () {
      sinon.stub(App.config, 'get').withArgs('preDefinedSiteProperties').returns([
        {
          name: 'hadoop.security.auth_to_local',
          displayType: 'multiLine'
        }
      ]);
      expect(controller.prepareConfigProperties([
        Em.Object.create({
          name: 'hadoop.security.auth_to_local',
          serviceName: 'HDFS'
        })
      ])[0].get('displayType')).to.equal('multiLine');
      App.config.get.restore();
    });
  });

  describe("#runSecurityCheckSuccess()", function () {
    beforeEach(function () {
      sinon.stub(App, 'showClusterCheckPopup', Em.K);
      sinon.stub(controller, 'startKerberosWizard', Em.K);
    });
    afterEach(function () {
      App.showClusterCheckPopup.restore();
      controller.startKerberosWizard.restore();
    });
    it("shows popup", function () {
      var check =  { items: [{
        UpgradeChecks: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "FAIL",
          "reason": "FAIL",
          "failed_on": [],
          "check_type": "SERVICE"
        }
      }]};
      controller.runSecurityCheckSuccess(check,null,{label: "name"});
      expect(controller.startKerberosWizard.called).to.be.false;
      expect(App.showClusterCheckPopup.called).to.be.true;
    });
    it("runs startKerberosWizard", function () {
      var check = { items: [{
        UpgradeChecks: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "PASS",
          "reason": "OK",
          "failed_on": [],
          "check_type": "SERVICE"
        }
      }]};
      controller.runSecurityCheckSuccess(check,null,{label: "name"});
      expect(controller.startKerberosWizard.called).to.be.true;
      expect(App.showClusterCheckPopup.called).to.be.false;
    });
  });

  describe('#regenerateKeytabs()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.spy(controller, 'restartServicesAfterRegenerate');
      sinon.spy(controller, 'restartAllServices');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      App.ajax.send.restore();
      controller.restartServicesAfterRegenerate.restore();
      controller.restartAllServices.restore();
    });

    it('both confirmation popups should be displayed', function () {
      var popup = controller.regenerateKeytabs();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.restartServicesAfterRegenerate.calledOnce).to.be.true;
      expect(App.ModalPopup.show.calledTwice).to.be.true;
    });

    it('user checked regeneration only for missing host/components', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', true);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', true)
      popup2.onPrimary();

      expect(App.ajax.send.args[0][0].data.type).to.equal('missing');
    });

    it('user didn\'t check regeneration only for missing host/components', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', false);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', true)
      popup2.onPrimary();

      expect(App.ajax.send.args[0][0].data.type).to.equal('all');
    });

    it('user checked restart services automatically', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', true);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', true)
      popup2.onPrimary();

      expect(App.ajax.send.args[0][0].data.withAutoRestart).to.be.true;
    });

    it('user didn\'t check restart services automatically', function () {
      var popup = controller.regenerateKeytabs();
      popup.set('regenerateKeytabsOnlyForMissing', true);

      var popup2 = popup.onPrimary();
      popup2.set('restartComponents', false)
      popup2.onPrimary();

      expect(App.ajax.send.args[0][0].data.withAutoRestart).to.be.false;
    });
  });

  describe('#getKDCSessionState()', function () {

    var mock = {callback: Em.K};

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.spy(mock, 'callback');
      sinon.stub(controller, 'getSecurityType', function (c) {
        c();
      });
    });

    afterEach(function () {
      App.ajax.send.restore();
      mock.callback.restore();
      controller.getSecurityType.restore();
    });

    [
      {
        m: 'Skip request, as securityEnabled and isKerberosEnabled are false',
        securityEnabled: false,
        isKerberosEnabled: false,
        kdc_type: 'not_none',
        result: false
      },
      {
        m: 'Skip request, as isManualKerberos is true',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: 'none',
        result: false
      },
      {
        m: 'Make request',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: 'not_none',
        result: true
      }
    ].forEach(function (test) {
          it(test.m, function () {
            sinon.stub(App, 'get').returns(test.isKerberosEnabled);
            controller.set('securityEnabled', test.securityEnabled);
            controller.set('kdc_type', test.kdc_type);
            controller.getKDCSessionState(mock.callback);
            App.get.restore();
            if (test.result) {
              expect(mock.callback.calledOnce).to.be.false;
              expect(App.ajax.send.calledOnce).to.be.true;
            } else {
              expect(mock.callback.calledOnce).to.be.true;
              expect(App.ajax.send.calledOnce).to.be.false;
            }
          });
        });
  });

  describe('#getSecurityType()', function () {

    var mock = {callback: Em.K};

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.spy(mock, 'callback');
    });

    afterEach(function () {
      App.ajax.send.restore();
      mock.callback.restore();
    });

    [
      {
        m: 'Skip request, as securityEnabled and isKerberosEnabled are false',
        securityEnabled: false,
        isKerberosEnabled: false,
        kdc_type: '',
        result: false
      },
      {
        m: 'Skip request, as kdc_type exists',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: 'none',
        result: false
      },
      {
        m: 'Make request',
        securityEnabled: true,
        isKerberosEnabled: true,
        kdc_type: '',
        result: true
      }
    ].forEach(function (test) {
          it(test.m, function () {
            sinon.stub(App, 'get').returns(test.isKerberosEnabled);
            controller.set('securityEnabled', test.securityEnabled);
            controller.set('kdc_type', test.kdc_type);
            controller.getSecurityType(mock.callback);
            App.get.restore();
            if (test.result) {
              expect(mock.callback.calledOnce).to.be.false;
              expect(App.ajax.send.calledOnce).to.be.true;
            } else {
              expect(mock.callback.calledOnce).to.be.true;
              expect(App.ajax.send.calledOnce).to.be.false;
            }
          });
        });
  });

  describe('#getSecurityTypeSuccess', function() {
    [
      {
        data: { },
        e: 'none'
      },
      {
        data: {
          items: []
        },
        e: 'none'
      },
      {
        data: {
          items: [
            {
              configurations: []
            }
          ]
        },
        e: 'none'
      },
      {
        data: {
          items: [
            {
              configurations: [
                {
                  type: 'krb-conf',
                  properties: {
                    'kdc_type': 'mit'
                  }
                }
              ]
            }
          ]
        },
        e: 'none'
      },
      {
        data: {
          items: [
            {
              configurations: [
                {
                  type: 'kerberos-env',
                  properties: {
                    'kdc_type': 'mit'
                  }
                }
              ]
            }
          ]
        },
        e: 'mit'
      },
      {
        data: {
          items: [
            {
              configurations: [
                {
                  type: 'kerberos-env',
                  properties: {
                    'kdc_type': 'none'
                  }
                }
              ]
            }
          ]
        },
        e: 'none'
      }
    ].forEach(function(test) {
      it('json is ' + JSON.stringify(test.data) + ' kdc type should be ' + test.e, function() {
        controller.set('isManualKerberos', undefined);
        controller.getSecurityTypeSuccess(test.data, {}, {});
        expect(controller.get('kdc_type')).to.eql(test.e);
      });
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/addSecurity_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('mixins/common/localStorage');
require('controllers/wizard');
require('controllers/main/admin/security/add/addSecurity_controller');
require('models/cluster');
require('models/service');

describe('App.AddSecurityController', function () {

  var controller = App.AddSecurityController.create({
    currentStep: null,
    content: Em.Object.create({
      isATSInstalled: true,
      services: [],
      isNnHa: 'false',
      serviceConfigProperties: null
    })
  });

  describe('#installedServices', function () {

    afterEach(function () {
      App.Service.find.restore();
    });

    it('No installed services', function () {
      sinon.stub(App.Service, 'find', function () {
        return [];
      });
      expect(controller.get('installedServices')).to.eql([]);
    });
    it('One service installed', function () {
      sinon.stub(App.Service, 'find', function () {
        return [Em.Object.create({serviceName: 'HDFS'})];
      });
      Em.propertyDidChange(controller, 'installedServices');
      expect(controller.get('installedServices')).to.eql(['HDFS']);
    });
  });

  describe('#loadAllPriorSteps()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'loadServiceConfigs', Em.K);
      sinon.stub(controller, 'loadServices', Em.K);
      sinon.stub(controller, 'loadNnHaStatus', Em.K);
    });
    afterEach(function () {
      controller.loadServiceConfigs.restore();
      controller.loadServices.restore();
      controller.loadNnHaStatus.restore();
    });

    var commonSteps = ['4', '3', '2'];
    commonSteps.forEach(function (step) {
      it('Current step - ' + step, function () {
        controller.set('currentStep', step);
        controller.loadAllPriorSteps();
        expect(controller.loadServiceConfigs.calledOnce).to.be.true;
        expect(controller.loadServices.calledOnce).to.be.true;
        expect(controller.loadNnHaStatus.calledOnce).to.be.true;
      });
    });
    it('Current step - 1', function () {
      controller.set('currentStep', '1');
      controller.loadAllPriorSteps();
      expect(controller.loadServiceConfigs.called).to.be.false;
      expect(controller.loadServices.calledOnce).to.be.true;
      expect(controller.loadNnHaStatus.calledOnce).to.be.true;
    });
  });

  describe('#loadServices()', function () {
    it('No installed services', function () {
      controller.reopen({
        installedServices: [],
        secureServices: [
          {serviceName: 'GENERAL'}
        ]
      });
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL']);
    });
    it('Installed service does not match the secure one', function () {
      controller.set('installedServices', ["HDFS"]);
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL']);
    });
    it('Installed service matches the secure one', function () {
      controller.set('secureServices', [
        {serviceName: 'GENERAL'},
        {serviceName: 'HDFS'}
      ]);
      controller.loadServices();
      expect(controller.get('content.services').mapProperty('serviceName')).to.eql(['GENERAL', 'HDFS']);
    });
  });

  describe('#loadNnHaStatus()', function () {
    afterEach(function () {
      App.db.getIsNameNodeHa.restore();
    });
    it('NameNode HA is off', function () {
      sinon.stub(App.db, 'getIsNameNodeHa', function () {
        return false;
      });
      controller.loadNnHaStatus();
      expect(controller.get('content.isNnHa')).to.be.false;
    });
    it('NameNode HA is on', function () {
      sinon.stub(App.db, 'getIsNameNodeHa', function () {
        return true;
      });
      controller.loadNnHaStatus();
      expect(controller.get('content.isNnHa')).to.be.true;
    });
  });

  describe('#loadServiceConfigs()', function () {
    afterEach(function () {
      App.db.getSecureConfigProperties.restore();
    });
    it('SecureConfigProperties is empty', function () {
      sinon.stub(App.db, 'getSecureConfigProperties', function () {
        return [];
      });
      controller.loadServiceConfigs();
      expect(controller.get('content.serviceConfigProperties')).to.eql([]);
    });
    it('SecureConfigProperties has one config', function () {
      sinon.stub(App.db, 'getSecureConfigProperties', function () {
        return [{}];
      });
      controller.loadServiceConfigs();
      expect(controller.get('content.serviceConfigProperties')).to.eql([{}]);
    });
  });

  describe('#getConfigOverrides()', function () {
    var testCases = [
      {
        title: 'overrides is null',
        configProperty: Em.Object.create({overrides: null}),
        result: null
      },
      {
        title: 'overrides is empty',
        configProperty: Em.Object.create({overrides: []}),
        result: null
      },
      {
        title: 'overrides has one override',
        configProperty: Em.Object.create({
          overrides: [
            Em.Object.create({
              value: 'value1',
              selectedHostOptions: []
            })
          ]
        }),
        result: [{
          value: 'value1',
          hosts: []
        }]
      },
      {
        title: 'overrides has one override with hosts',
        configProperty: Em.Object.create({
          overrides: [
            Em.Object.create({
              value: 'value1',
              selectedHostOptions: ['host1']
            })
          ]
        }),
        result: [{
          value: 'value1',
          hosts: ['host1']
        }]
      }
    ];

    testCases.forEach(function(test){
      it(test.title, function () {
        expect(controller.getConfigOverrides(test.configProperty)).to.eql(test.result);
      });
    });
  });

  describe('#saveServiceConfigProperties()', function () {
    var testCases = [
      {
        title: 'stepConfigs is empty',
        stepController: Em.Object.create({
          stepConfigs: []
        }),
        result: []
      },
      {
        title: 'No configs in service',
        stepController: Em.Object.create({
          stepConfigs: [
            Em.Object.create({configs: []})
          ]
        }),
        result: []
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        sinon.stub(App.db, 'setSecureConfigProperties', Em.K);
        controller.saveServiceConfigProperties(test.stepController);
        expect(App.db.setSecureConfigProperties.calledWith(test.result)).to.be.true;
        expect(controller.get('content.serviceConfigProperties')).to.eql(test.result);
        App.db.setSecureConfigProperties.restore();
      });
    });
    it('Service has config', function () {
      var  stepController = Em.Object.create({
        stepConfigs: [
          Em.Object.create({configs: [
            Em.Object.create({
              name: 'config1',
              value: 'value1'
            })
          ]})
        ]
      });
      sinon.stub(App.db, 'setSecureConfigProperties', Em.K);
      controller.saveServiceConfigProperties(stepController);
      expect(App.db.setSecureConfigProperties.calledOnce).to.be.true;
      expect(controller.get('content.serviceConfigProperties').mapProperty('name')).to.eql(['config1']);
      App.db.setSecureConfigProperties.restore();
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step1_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step1');
require('models/service');
var controller;
describe('App.MainAdminSecurityAddStep1Controller', function () {

  beforeEach(function () {
    controller = App.MainAdminSecurityAddStep1Controller.create({
      content: {}
    });
  });

  describe('#shouldRemoveATS()', function () {

    var tests = Em.A([
      {
        doesATSSupportKerberos: true,
        isATSInstalled: true,
        e: false
      },
      {
        doesATSSupportKerberos: true,
        isATSInstalled: false,
        e: false
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: true,
        e: true
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: false,
        e: false
      }
    ]);

    tests.forEach(function (test) {
      it('', function () {
        controller.set('content.isATSInstalled', test.isATSInstalled);
        sinon.stub(App, 'get', function (k) {
          if ('doesATSSupportKerberos' === k) return test.doesATSSupportKerberos;
          return Em.get(App, k);
        });
        var result = controller.shouldRemoveATS();
        App.get.restore();
        expect(result).to.equal(test.e);
      });
    });

  });
});

});

;require.register("test/controllers/main/admin/security/add/step2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step2');
require('models/service');

describe('App.MainAdminSecurityAddStep2Controller', function () {

  var controller = App.MainAdminSecurityAddStep2Controller.create({
    content: {}
  });

  describe('#clearStep()', function () {
    it('Info is empty', function () {
      controller.set('stepConfigs', []);
      controller.set('securityUsers', []);
      controller.clearStep();
      expect(controller.get('stepConfigs')).to.be.empty;
      expect(controller.get('securityUsers')).to.be.empty;
    });
    it('Info filled', function () {
      controller.set('stepConfigs', [1]);
      controller.set('securityUsers', [1]);
      controller.clearStep();
      expect(controller.get('stepConfigs')).to.be.empty;
      expect(controller.get('securityUsers')).to.be.empty;
    });
  });

  describe('#isSubmitDisabled', function () {
    var tests = [
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          }
        ],
        m: 'All show configs, nothing with errors',
        e: false
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          },
          {
            showConfig: true,
            errorCount: 1
          }
        ],
        m: 'All show configs, 1 with errors',
        e: true
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 0
          },
          {
            showConfig: false,
            errorCount: 1
          }
        ],
        m: '1 has errors but not visible',
        e: false
      },
      {
        config: [
          {
            showConfig: false,
            errorCount: 0
          },
          {
            showConfig: false,
            errorCount: 1
          }
        ],
        m: '1 has errors, all not visible',
        e: false
      },
      {
        config: [
          {
            showConfig: true,
            errorCount: 1
          },
          {
            showConfig: true,
            errorCount: 1
          }
        ],
        m: 'All has errors, all not visible',
        e: true
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('stepConfigs', test.config);
        expect(controller.get('isSubmitDisabled')).to.equal(test.e);
      });
    });
  });

  describe('#loadStep()', function () {
    it('load step', function () {
      controller.set('stepConfigs', [
        {}
      ]);
      controller.set('securityUsers', ['user1']);
      controller.set('content.services', ['service1']);
      controller.set('content.serviceConfigProperties', ['config1']);
      sinon.stub(controller, 'clearStep', Em.K);
      sinon.stub(controller, 'loadUsers', Em.K);
      sinon.stub(controller, 'addUserPrincipals', Em.K);
      sinon.stub(controller, 'renderServiceConfigs', Em.K);
      sinon.stub(controller, 'changeCategoryOnHa', Em.K);
      sinon.stub(controller, 'setStoredConfigsValue', Em.K);
      sinon.stub(controller, 'addHostPrincipals', Em.K);
      sinon.stub(App.Service, 'find', function () {
        return [
          {serviceName: 'HDFS'}
        ];
      });

      controller.loadStep();
      expect(controller.get('installedServices')).to.eql(['HDFS']);
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.loadUsers.calledOnce).to.be.true;
      expect(controller.addUserPrincipals.calledWith(['service1'], ['user1'])).to.be.true;
      expect(controller.addHostPrincipals.calledOnce).to.be.true;
      expect(controller.renderServiceConfigs.calledWith(['service1'])).to.be.true;
      expect(controller.changeCategoryOnHa.calledWith(['service1'], [{}])).to.be.true;
      expect(controller.setStoredConfigsValue.calledWith(['config1'])).to.be.true;

      controller.clearStep.restore();
      controller.loadUsers.restore();
      controller.addUserPrincipals.restore();
      controller.renderServiceConfigs.restore();
      controller.changeCategoryOnHa.restore();
      controller.setStoredConfigsValue.restore();
      controller.addHostPrincipals.restore();
      App.Service.find.restore();
    });
  });

  describe('#setStoredConfigsValue()', function () {
    it('storedConfigProperties is null', function () {
      expect(controller.setStoredConfigsValue(null)).to.be.false;
    });
    it('stepConfigs is empty', function () {
      controller.set('stepConfigs', []);
      expect(controller.setStoredConfigsValue([])).to.be.true;
      expect(controller.get('stepConfigs')).to.be.empty;
    });
    it('stepConfig has no configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: []
      })]);
      expect(controller.setStoredConfigsValue([])).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs')).to.be.empty;
    });
    it('stepConfig has no stored configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [Em.Object.create({
          name: 'config1',
          value: 'value1'
        })]
      })]);
      var storedConfigProperties = [
        {
          name: 'config2',
          value: "value2"
        }
      ];
      expect(controller.setStoredConfigsValue(storedConfigProperties)).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs').findProperty('name', 'config1').get('value')).to.equal('value1');
    });
    it('stepConfig has stored configs', function () {
      controller.set('stepConfigs', [Em.Object.create({
        configs: [Em.Object.create({
          name: 'config2',
          value: 'value1'
        })]
      })]);
      var storedConfigProperties = [
        {
          name: 'config2',
          value: "value2"
        }
      ];
      expect(controller.setStoredConfigsValue(storedConfigProperties)).to.be.true;
      expect(controller.get('stepConfigs')[0].get('configs').findProperty('name', 'config2').get('value')).to.equal('value2');
    });
  });

  describe('#renderServiceConfigs()', function () {
    it('serviceConfigs and stepConfigs are empty', function () {
      controller.set('stepConfigs', []);
      controller.renderServiceConfigs([]);
      expect(controller.get('selectedService')).to.be.undefined;
    });
    it('serviceConfigs is empty', function () {
      controller.set('stepConfigs', [
        {showConfig: true}
      ]);
      controller.renderServiceConfigs([]);
      expect(controller.get('selectedService')).to.eql({showConfig: true});
    });
    it('serviceConfigs has service', function () {
      var serviceConfigs = [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ];
      sinon.stub(controller, 'wrapConfigProperties', function () {
        return [];
      });
      controller.set('stepConfigs', []);
      controller.renderServiceConfigs(serviceConfigs);
      expect(controller.get('selectedService').get('serviceName')).to.equal('HDFS');
      expect(controller.get('selectedService').get('showConfig')).to.be.true;
      expect(controller.get('selectedService').get('configs')).to.be.empty;
      expect(controller.wrapConfigProperties.calledWith({
        serviceName: 'HDFS',
        configs: []
      })).to.be.true;
      controller.wrapConfigProperties.restore();
    });
  });

  describe('#wrapConfigProperties()', function () {
    it('_componentConfig is empty', function () {
      expect(controller.wrapConfigProperties({configs: []})).to.be.empty;
    });
    it('serviceConfigs has service', function () {
      var mock = Em.Object.create({
        validate: Em.K,
        isReconfigurable: true,
        isEditable: false
      });
      var _componentConfig = {configs: [
        {name: 'config1'}
      ]};
      sinon.stub(App.ServiceConfigProperty, 'create', function () {
        return mock;
      });
      sinon.spy(mock, 'validate');
      expect(controller.wrapConfigProperties(_componentConfig)[0].get('isEditable')).to.be.true;
      expect(App.ServiceConfigProperty.create.calledWith({name: 'config1'})).to.be.true;
      expect(mock.validate.calledOnce).to.be.true;
      mock.validate.restore();
      App.ServiceConfigProperty.create.restore();
    });
  });

  describe('#setHostsToConfig()', function () {
    it('service is null', function () {
      expect(controller.setHostsToConfig(null)).to.be.false;
    });
    it('service.configs is empty', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ]);
      expect(controller.setHostsToConfig('HDFS')).to.be.false;
    });
    it('No such config name in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1'
            }
          ]
        }
      ]);
      expect(controller.setHostsToConfig('HDFS', 'config2')).to.be.false;
    });
    it('Correct config in service.configs', function () {
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({
          hostComponents: [
            Em.Object.create({
              componentName: 'comp1',
              hostName: 'host1'
            })
          ]
        });
      });
      expect(controller.setHostsToConfig('HDFS', 'config1', ['comp1'])).to.be.true;
      expect(controller.get('content.services')[0].configs[0].defaultValue).to.eql(['host1']);
      App.Service.find.restore();
    });
  });

  describe('#setHostToPrincipal()', function () {
    it('service is null', function () {
      expect(controller.setHostToPrincipal(null)).to.be.false;
    });
    it('service.configs is empty', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: []
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS')).to.be.false;
    });
    it('No such hostConfigName name in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config2', 'config1')).to.be.false;
    });
    it('No such principalConfigName name in service.configs', function () {
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'config2')).to.be.false;
    });
    it('Correct config in service.configs', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1',
              defaultValue: 'value1'
            },
            {
              name: 'principal1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'principal1', 'name1')).to.be.true;
      expect(controller.get('content.services')[0].configs[0].defaultValue).to.equal('value1');
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('name1value1');
    });
    it('Correct config in service.configs, defaultValue is array', function () {
      controller.set('content.services', [
        {
          serviceName: 'HDFS',
          configs: [
            {
              name: 'config1',
              defaultValue: ['Value1']
            },
            {
              name: 'principal1'
            }
          ]
        }
      ]);
      expect(controller.setHostToPrincipal('HDFS', 'config1', 'principal1', 'name1')).to.be.true;
     // expect(controller.get('content.services')[0].configs[0].defaultValue).to.equal('Value1');
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('name1Value1');
    });
    it('stack 2.2 `storm_principal_name` config should be set to `storm`', function() {
      sinon.stub(App, 'get').withArgs('currentStackVersionNumber').returns('2.2');
      controller.set('content.services', [
        {
          serviceName: 'STORM',
          configs: [
            {
              name: 'nimbus_host',
              defaultValue: 'Value1'
            },
            {
              name: 'storm_principal_name'
            }
          ]
        }
      ]);
      controller.setHostToPrincipal('STORM', 'nimbus_host', 'storm_principal_name', 'storm');
      App.get.restore();
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('storm');
    });
    it('stack 2.1 `oozie_http_principal_name` value should contains OOZIE_SERVER host', function() {
      sinon.stub(App, 'get').withArgs('currentStackVersionNumber').returns('2.1');
      controller.set('content.services', [
        {
          serviceName: 'OOZIE',
          configs: [
            {
              name: 'oozie_servername',
              defaultValue: 'host1.com'
            },
            {
              name: 'oozie_http_principal_name'
            }
          ]
        }
      ]);
      controller.setHostToPrincipal('OOZIE', 'oozie_servername', 'oozie_http_principal_name', 'HTTP/');
      App.get.restore();
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('HTTP/host1.com');
    });
    it('stack 2.2 `oozie_http_principal_name` value should be set to HTTP/_HOST', function() {
      sinon.stub(App, 'get').withArgs('currentStackVersionNumber').returns('2.2');
      controller.set('content.services', [
        {
          serviceName: 'OOZIE',
          configs: [
            {
              name: 'oozie_servername',
              defaultValue: 'host1.com'
            },
            {
              name: 'oozie_http_principal_name'
            }
          ]
        }
      ]);
      controller.setHostToPrincipal('OOZIE', 'oozie_servername', 'oozie_http_principal_name', 'HTTP/');
      App.get.restore();
      expect(controller.get('content.services')[0].configs[1].defaultValue).to.equal('HTTP/_HOST');
    });
  });

  describe('#loadUsers()', function () {

    afterEach(function () {
      App.router.get.restore();
    });

    it('serviceUsers is correct', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: [
          {}
        ]})
      });
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
    });
    it('serviceUsers is null, testMode = true', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: null})
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers').mapProperty('name')).to.eql(["hdfs_user",
        "mapred_user",
        "hbase_user",
        "hive_user",
        "smokeuser"
      ]);
      App.get.restore();
    });
    it('serviceUsers is empty, testMode = true', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: []})
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers').mapProperty('name')).to.eql(["hdfs_user",
        "mapred_user",
        "hbase_user",
        "hive_user",
        "smokeuser"
      ]);
      App.get.restore();
    });
    it('serviceUsers is null, testMode = false', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: null})
      });
      sinon.stub(App.db, 'getSecureUserInfo', function () {
        return [
          {}
        ];
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      App.db.getSecureUserInfo.restore();
      App.get.restore();
    });
    it('serviceUsers is empty, testMode = false', function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({serviceUsers: []})
      });
      sinon.stub(App.db, 'getSecureUserInfo', function () {
        return [
          {}
        ];
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      controller.loadUsers();
      expect(controller.get('securityUsers')).to.eql([
        {}
      ]);
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      App.db.getSecureUserInfo.restore();
      App.get.restore();
    });
  });

  describe('#addUserPrincipals()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'setUserPrincipalValue', function () {
        return true;
      });
    });
    afterEach(function () {
      controller.setUserPrincipalValue.restore();
    });

    var generalConfigs = [
      {
        serviceName: 'GENERAL',
        configs: [
          {
            name: 'hbase_principal_name',
            isVisible: false
          },
          {
            name: 'hbase_user_keytab',
            isVisible: false
          },
          {
            name: 'hdfs_principal_name',
            isVisible: false
          },
          {
            name: 'hdfs_user_keytab',
            isVisible: false
          }
        ]
      }
    ];
    var securityUsers = [];

    it('HBASE or HDFS services are not installed neither', function () {
      var serviceConfigs = generalConfigs.slice(0);
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_principal_name').isVisible).to.be.false;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_user_keytab').isVisible).to.be.false;
    });
    it('HBASE service is installed', function () {
      var serviceConfigs = generalConfigs.slice(0);
      serviceConfigs.push({serviceName: 'HBASE'});
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_user_keytab').isVisible).to.be.true;
    });
    it('HDFS service is installed', function () {
      var serviceConfigs = generalConfigs.slice(0);
      serviceConfigs.push({serviceName: 'HDFS'});
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_user_keytab').isVisible).to.be.true;
    });
    it('HDFS and HBASE services are installed', function () {
      var serviceConfigs = generalConfigs.slice(0);
      serviceConfigs.push({serviceName: 'HDFS'});
      serviceConfigs.push({serviceName: 'HBASE'});
      controller.addUserPrincipals(serviceConfigs, securityUsers);
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hdfs_user_keytab').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_principal_name').isVisible).to.be.true;
      expect(serviceConfigs[0].configs.findProperty('name', 'hbase_user_keytab').isVisible).to.be.true;
    });
  });

  describe('#setUserPrincipalValue()', function () {
    it('user and userPrincipal are null', function () {
      expect(controller.setUserPrincipalValue(null, null)).to.be.false;
    });
    it('user is null', function () {
      expect(controller.setUserPrincipalValue(null, {})).to.be.false;
    });
    it('userPrincipal is null', function () {
      expect(controller.setUserPrincipalValue({}, null)).to.be.false;
    });
    it('user and userPrincipal are correct', function () {
      var user = {value: 'value1'};
      var userPrincipal = {};
      expect(controller.setUserPrincipalValue(user, userPrincipal)).to.be.true;
      expect(userPrincipal.defaultValue).to.equal('value1');
    });
  });

  describe('#addHostPrincipals()', function () {
    it('hostToPrincipalMap is empty', function () {
      sinon.stub(controller, 'setHostToPrincipal', Em.K);
      controller.set('hostToPrincipalMap', []);
      controller.addHostPrincipals();
      expect(controller.setHostToPrincipal.called).to.be.false;
      controller.setHostToPrincipal.restore();
    });
    it('Correct data', function () {
      sinon.stub(controller, 'setHostToPrincipal', Em.K);
      controller.set('hostToPrincipalMap', [
        {
          serviceName: 'HDFS',
          configName: 'datanode_hosts',
          principalName: 'principal1',
          primaryName: 'name1'
        }
      ]);
      controller.addHostPrincipals();
      expect(controller.setHostToPrincipal.calledWith('HDFS', 'datanode_hosts', 'principal1', 'name1')).to.be.true;
      controller.setHostToPrincipal.restore();
    });
  });

  describe('#changeCategoryOnHa()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'removeConfigCategory', Em.K);
    });
    afterEach(function () {
      controller.removeConfigCategory.restore();
    });

    var serviceConfigs = [{
      serviceName: 'HDFS',
      configCategories: []
    }];
    var stepConfigs = [Em.Object.create({
      serviceName: 'HDFS',
      configs: []
    })];

    it('HDFS service is absent', function () {
      expect(controller.changeCategoryOnHa([], [])).to.be.false;
    });
    it('HDFS service installed, App.testMode and App.testNameNodeHA - true', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        if ('testNameNodeHA' === k) return true;
        return Em.get(App, k);
      });
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'SNameNode')).to.be.true;
      App.get.restore();
    });
    it('HDFS service installed, content.isNnHa = true', function () {
      controller.set('content.isNnHa', 'true');
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'SNameNode')).to.be.true;
    });
    it('HDFS service installed, HA disabled', function () {
      controller.set('content.isNnHa', 'false');
      expect(controller.changeCategoryOnHa(serviceConfigs, stepConfigs)).to.be.true;
      expect(controller.removeConfigCategory.calledWith([], [], 'JournalNode')).to.be.true;
    });
  });

  describe('#removeConfigCategory()', function () {
    it('properties should be hidden', function () {
      var properties = [
        Em.Object.create({
          category: 'comp1',
          isVisible: true
        })
      ];
      controller.removeConfigCategory(properties, [], 'comp1');
      expect(properties[0].isVisible).to.be.false;
    });
    it('category should be removed', function () {
      var configCategories = [
        Em.Object.create({
          name: 'comp1'
        })
      ];
      controller.removeConfigCategory([], configCategories, 'comp1');
      expect(configCategories).to.be.empty;
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step3_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/admin/security/add/step3');
var stringUtils = require('utils/string_utils');
var modelSetup = require('test/init_model_test');

describe('App.MainAdminSecurityAddStep3Controller', function () {

  var controller = App.MainAdminSecurityAddStep3Controller.create({
    content: {}
  });

  describe('#openInfoInNewTab()', function() {
    it('Correct data', function() {
      var mock = {
        document: {
          write: function(){}
        },
        focus: function(){}
      };
      sinon.stub(window, 'open', function () {
        return mock;
      });
      sinon.stub(stringUtils, 'arrayToCSV', function () {
        return 'CSV_CONTENT';
      });
      sinon.spy(mock.document, 'write');
      sinon.spy(mock, 'focus');
      controller.set('hostComponents', ['comp1']);

      controller.openInfoInNewTab();
      expect(window.open.calledWith('')).to.be.true;
      expect(stringUtils.arrayToCSV.calledWith(['comp1'])).to.be.true;
      expect(mock.document.write.calledWith('CSV_CONTENT')).to.be.true;
      expect(mock.focus.calledOnce).to.be.true;
      window.open.restore();
      stringUtils.arrayToCSV.restore();
    });
  });

  describe('#loadStep()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'getSecurityUsers', function () {
        return [{
          name: 'user_group',
          value: 'value1'
        }];
      });
    });
    afterEach(function(){
      controller.getSecurityUsers.restore();
    });

    it('No hosts installed', function() {
      controller.set('hosts', []);
      controller.loadStep();
      expect(controller.get('hostComponents')).to.be.empty;
    });
    it('One host installed', function () {
      controller.set('hosts', [Em.Object.create({hostName: 'host1'})]);
      sinon.stub(controller, 'setMandatoryConfigs', function (result) {
        return result.push('setMandatoryConfigs');
      });
      sinon.stub(controller, 'setComponentsConfig', function (result) {
        return result.push('setComponentsConfig');
      });
      sinon.stub(controller, 'setHostComponentsSecureValue', function (result) {
        return result.push('setHostComponentsSecureValue');
      });

      controller.loadStep();
      expect(controller.setMandatoryConfigs.calledOnce).to.be.true;
      expect(controller.setComponentsConfig.calledOnce).to.be.true;
      expect(controller.setHostComponentsSecureValue.calledOnce).to.be.true;
      expect(controller.get('hostComponents')).to.eql(["setMandatoryConfigs", "setComponentsConfig", "setHostComponentsSecureValue"]);

      controller.setMandatoryConfigs.restore();
      controller.setComponentsConfig.restore();
      controller.setHostComponentsSecureValue.restore();
    });
  });

  describe('#buildComponentToOwnerMap()', function() {
    beforeEach(function(){
      sinon.stub(controller, 'getSecurityUsers', function () {
        return [{
          name: 'storm_user',
          value: 'storm'
        }];
      });
    });
    afterEach(function(){
      controller.getSecurityUsers.restore();
    });

    it('componentToUserMap is empty', function() {
      sinon.stub(controller, 'get').withArgs('componentToUserMap').returns({});
      expect(controller.buildComponentToOwnerMap([])).to.eql({});
      controller.get.restore();
    });
    it('componentToUserMap has properties', function() {
      var securityUsers = [{
        name: 'config1',
        value: 'value1'
      }];
      sinon.stub(controller, 'get').withArgs('componentToUserMap').returns({'COMP1': 'config1'});
      expect(controller.buildComponentToOwnerMap(securityUsers)).to.eql({'COMP1': 'value1'});
      controller.get.restore();
    });
  });

  describe('#setComponentsConfig()', function() {

    beforeEach(function(){
      modelSetup.setupStackServiceComponent();
      controller.set('content.serviceConfigProperties', [
        {
          serviceName: 'HDFS',
          name: 'principal1',
          value: '_HOST'
        },
        {
          serviceName: 'HDFS',
          name: 'keytab1',
          value: 'value1'
        }
      ]);
    });

    afterEach(function() {
      modelSetup.cleanStackServiceComponent();
    });

    it('componentToConfigMap is empty', function() {
      controller.reopen({
        componentToConfigMap: []
      });
      var result = [];
      controller.setComponentsConfig(result, Em.Object.create({hostName: 'c6401',hostComponents: []}), 'hadoopGroupId');
      expect(result).to.be.empty;
    });
    it('when component from stack2', function() {
      sinon.stub(App, 'get', function () {
        return true;
      });
      controller.reopen({
        componentToConfigMap: [{
          componentName: 'DATANODE',
          principal: 'principal1',
          keytab: 'keytab1',
          displayName: 'displayName1'
        }]
      });
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result.length).to.equal(1);
      App.get.restore();
    });
    it('Component does not match host-component', function() {
      controller.reopen({
        componentToConfigMap: [{
          componentName: 'DATANODE',
          principal: 'principal1',
          keytab: 'keytab1',
          displayName: 'displayName1'
        }]
      });
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE1'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result).to.be.empty;
    });
    it('Component matches host-component', function() {
      controller.reopen({
        componentToConfigMap: [{
          componentName: 'DATANODE',
          principal: 'principal1',
          keytab: 'keytab1',
          displayName: 'displayName1'
        }]
      });
      var host = Em.Object.create({
        hostComponents: [{componentName: 'DATANODE'}],
        hostName: 'host1'
      });
      var result = [];
      controller.setComponentsConfig(result, host, 'hadoopGroupId');
      expect(result.length).to.equal(1);
    });
  });

  describe('#setMandatoryConfigs()', function() {

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return [
          {serviceName: 'SERVICE1'}
        ];
      });
      controller.set('content.serviceConfigProperties', [
        {
          serviceName: 'GENERAL',
          name: 'kerberos_domain',
          value: 'realm1'
        }
      ]);
    });
    afterEach(function () {
      App.Service.find.restore();
    });

    it('mandatoryConfigs is empty', function() {
      var result = [];
      controller.set('mandatoryConfigs', []);

      controller.setMandatoryConfigs(result, [], '', '');
      expect(result).to.be.empty;
    });
    it('config has unknown service to check', function() {
      var result = [];
      controller.set('mandatoryConfigs', [{
        userConfig: 'kerberos_domain',
        keytab: 'kerberos_domain',
        displayName: '',
        checkService: 'HBASE'
      }]);

      controller.setMandatoryConfigs(result, [], '', '');
      expect(result).to.be.empty;
    });
    it('config should be added', function() {
      var result = [];
      controller.set('mandatoryConfigs', [{
        userConfig: 'userConfig1',
        keytab: 'kerberos_domain',
        displayName: ''
      }]);
      var securityUsers = [{
        name: 'userConfig1',
        value: 'value1'
      }];

      controller.setMandatoryConfigs(result, securityUsers, '', '');
      expect(result.length).to.equal(1);
    });
  });

  describe('#setHostComponentsSecureValue()', function() {

    beforeEach(function () {
      sinon.stub(controller, 'buildComponentToOwnerMap', Em.K);
      sinon.stub(controller, 'changeDisplayName', Em.K);
      sinon.stub(controller, 'getSecureProperties', function(){
        return {principal: '', keytab: ''};
      });
    });
    afterEach(function () {
      controller.buildComponentToOwnerMap.restore();
      controller.changeDisplayName.restore();
      controller.getSecureProperties.restore();
    });

    it('host.hostComponents is empty', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: []
      });

      controller.setHostComponentsSecureValue(result, host);
      expect(result).to.be.empty;
    });
    it('host-component does not match component to display', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'UNKNOWN'
        })]
      });

      controller.setHostComponentsSecureValue(result, host);
      expect(result).to.be.empty;
    });
    it('host-component matches component to display', function() {
      var result = [];
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'DATANODE'
        })]
      });

      controller.setHostComponentsSecureValue(result, host, {}, [], '');
      expect(result.length).to.equal(1);
    });
    it('addedPrincipalsHost already contain such config', function() {
      var result = [];
      var host = Em.Object.create({
        hostName: 'host1',
        hostComponents: [Em.Object.create({
          componentName: 'DATANODE'
        })]
      });

      controller.setHostComponentsSecureValue(result, host, {'host1--': true}, [], '');
      expect(result.length).to.be.empty;
    });
  });

  describe('#setHostComponentsSecureValue()', function () {

    it('DRPC Server principal should point to Nimbus host for HDP-2.2 stack', function () {
      sinon.stub(App, 'get').withArgs('isHadoop22Stack').returns(true);
      sinon.stub(controller, 'get').withArgs('content.serviceConfigProperties').returns([]);
      sinon.stub(controller, 'getNimbusHostName').returns('nimbus_host');
      sinon.stub(controller, 'buildComponentToOwnerMap').returns({'DRPC_SERVER': 'storm'});
      sinon.stub(controller, 'getSecureProperties').returns({
        "keytab": "/etc/security/keytabs/nimbus.service.keytab",
        "principal": "nimbus/nimbus_host"
      });
      sinon.stub(controller, 'getSecurityUsers', function () {
        return [
          {
            name: 'storm_user',
            value: 'storm'
          }
        ];
      });
      var host = Em.Object.create({
        hostComponents: [Em.Object.create({
          componentName: 'DRPC_SERVER',
          displayName: 'DRPC Server'
        })]
      });

      var result = [];
      controller.setHostComponentsSecureValue(result, host, {}, [], 'hadoopId');
      expect(result).to.be.not.empty;
      expect(controller.getSecureProperties.args[0][2]).to.equal('nimbus_host');

      var hostComponent = result[0];
      expect(hostComponent.principal).to.equal('nimbus/nimbus_host');
      expect(hostComponent.owner).to.equal('storm');

      App.get.restore();
      controller.get.restore();
      controller.getNimbusHostName.restore();
      controller.buildComponentToOwnerMap.restore();
      controller.getSecureProperties.restore();
      controller.getSecurityUsers.restore();
    });
  });

  describe('#getSecureProperties()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'getPrincipal', function () {
        return 'principal';
      });
    });
    afterEach(function () {
      controller.getPrincipal.restore();
    });

    var testCases = [
      {
        title: 'serviceConfigs is empty',
        content: {
          serviceConfigs: [],
          componentName: ''
        },
        result: {}
      },
      {
        title: 'Config has component that does not match component name',
        content: {
          serviceConfigs: [{
            component: 'comp1'
          }],
          componentName: 'comp2'
        },
        result: {}
      },
      {
        title: 'Config has components that does not match component name',
        content: {
          serviceConfigs: [{
            components: ['comp1']
          }],
          componentName: 'comp2'
        },
        result: {}
      },
      {
        title: 'Config has component that matches component name',
        content: {
          serviceConfigs: [{
            name: 'C_principal_name',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          principal: 'principal'
        }
      },
      {
        title: 'Config has components that matches component name',
        content: {
          serviceConfigs: [{
            name: 'C_principal_name',
            components: ['comp1'],
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          principal: 'principal'
        }
      },
      {
        title: 'Config name without correct postfix',
        content: {
          serviceConfigs: [{
            name: 'config1',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {}
      },
      {
        title: 'Config name with "_keytab" postfix',
        content: {
          serviceConfigs: [{
            name: 'c_keytab',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          keytab: 'value1'
        }
      },
      {
        title: 'Config name with "_keytab_path" postfix',
        content: {
          serviceConfigs: [{
            name: 'c_keytab_path',
            component: 'comp1',
            value: 'value1'
          }],
          componentName: 'comp1'
        },
        result: {
          keytab: 'value1'
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getSecureProperties(test.content.serviceConfigs, test.content.componentName, '')).to.eql(test.result);
      });
    });
  });

  describe('#getPrincipal()', function () {

    var testCases = [
      {
        title: 'Config value missing "_HOST" string, unit is empty',
        content: {
          config: {
            value: 'value1',
            unit: ''
          },
          hostName: ''
        },
        result: 'value1'
      },
      {
        title: 'Config value missing "_HOST" string, unit is correct',
        content: {
          config: {
            value: 'value1',
            unit: 'unit1'
          },
          hostName: ''
        },
        result: 'value1unit1'
      },
      {
        title: 'Config value contains "_HOST" string, host name in lowercase',
        content: {
          config: {
            value: '_HOST',
            unit: 'unit1'
          },
          hostName: 'host1'
        },
        result: 'host1unit1'
      },
      {
        title: 'Config value contains "_HOST" string, host name in uppercase',
        content: {
          config: {
            value: '_HOST',
            unit: 'unit1'
          },
          hostName: 'HOST1'
        },
        result: 'host1unit1'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getPrincipal(test.content.config, test.content.hostName)).to.equal(test.result);
      });
    });
  });

  describe('#changeDisplayName()', function() {
    it('name is HiveServer2', function() {
      expect(controller.changeDisplayName('HiveServer2')).to.equal('Hive Metastore and HiveServer2');
    });
    it('name is not HiveServer2', function() {
      expect(controller.changeDisplayName('something')).to.equal('something');
    });
  });
});

});

;require.register("test/controllers/main/admin/security/add/step4_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/security_progress_controller');
require('controllers/main/admin/security/add/step4');
require('mixins/wizard/addSecurityConfigs');
require('utils/polling');
require('models/cluster_states');
require('models/service');

var controller;

describe('App.MainAdminSecurityAddStep4Controller', function () {

  beforeEach(function () {
    controller = App.MainAdminSecurityAddStep4Controller.create({
      content: {},
      commands: [],
      enableSubmit: function () {
        this._super()
      },
      secureMapping: [],
      secureProperties: [],
      secureServices: []
    });
  });

  describe('#isBackBtnDisabled', function () {
    it('commands have error', function () {
      controller.set('commands', [Em.Object.create({
        isError: true
      })]);
      expect(controller.get('isBackBtnDisabled')).to.be.false;
    });
    it('commands do not have error', function () {
      controller.set('commands', [Em.Object.create({
        isError: false
      })]);
      expect(controller.get('isBackBtnDisabled')).to.be.true;
    });
  });

  describe('#isSecurityApplied', function () {
    var testCases = [
      {
        title: 'No START_SERVICES command',
        commands: [],
        result: false
      },
      {
        title: 'START_SERVICES is not success',
        commands: [Em.Object.create({
          name: 'START_SERVICES',
          isSuccess: false
        })],
        result: false
      },
      {
        title: 'START_SERVICES is success',
        commands: [Em.Object.create({
          name: 'START_SERVICES',
          isSuccess: true
        })],
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', test.commands);
        expect(controller.get('isSecurityApplied')).to.equal(test.result);
      });
    });
  });

  describe('#enableSubmit()', function () {
    var mock = {
      setStepsEnable: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
      sinon.spy(mock, 'setStepsEnable');
      sinon.spy(mock, 'setLowerStepsDisable');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.setStepsEnable.restore();
      mock.setLowerStepsDisable.restore();
    });

    it('Command has error', function () {
      controller.set('commands', [Em.Object.create({
        isError: true
      })]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.false;
      expect(mock.setStepsEnable.calledOnce).to.be.true;
    });
    it('Command is successful', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: true
      })]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it('Command is in progress', function () {
      controller.set('commands', [Em.Object.create()]);
      controller.enableSubmit();
      expect(controller.get('isSubmitDisabled')).to.be.true;
      expect(mock.setLowerStepsDisable.calledWith(4)).to.be.true;
    });
  });

  describe('#clearStep()', function () {
    it('Clear step info', function () {
      controller.set('commands', [Em.Object.create()]);
      controller.set('isSubmitDisabled', false);
      controller.set('serviceConfigTags', [
        {}
      ]);
      controller.clearStep();
      expect(controller.get('isSubmitDisabled')).to.be.true;
      expect(controller.get('commands')).to.be.empty;
      expect(controller.get('serviceConfigTags')).to.be.empty;
    });
  });

  describe('#loadCommands()', function () {

    before(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
    });

    after(function () {
      App.clusterStatus.setClusterStatus.restore();
    });

    var tests = Em.A([
      {
        doesATSSupportKerberos: true,
        isATSInstalled: true,
        e: {
          l: 3,
          d: false
        }
      },
      {
        doesATSSupportKerberos: true,
        isATSInstalled: false,
        e: {
          l: 3,
          d: false
        }
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: true,
        e: {
          l: 4,
          d: true
        }
      },
      {
        doesATSSupportKerberos: false,
        isATSInstalled: false,
        e: {
          l: 3,
          d: false
        }
      }
    ]);

    tests.forEach(function (test) {
      it('doesATSSupportKerberos ' + test.doesATSSupportKerberos.toString() + ', isATSInstalled ' + test.isATSInstalled.toString(), function () {
        sinon.stub(App, 'get', function (k) {
          if ('doesATSSupportKerberos' === k) return test.doesATSSupportKerberos;
          return Em.get(App, k);
        });
        controller.set('content.isATSInstalled', test.isATSInstalled);
        controller.loadCommands();
        App.get.restore();
        expect(controller.get('commands.length')).to.equal(test.e.l);
        expect(controller.get('commands').someProperty('name', 'DELETE_ATS')).to.equal(test.e.d);
      });
    });

  });

  describe('#loadStep()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'clearStep', Em.K);
      sinon.stub(controller, 'prepareSecureConfigs', Em.K);
    });
    afterEach(function () {
      controller.clearStep.restore();
      controller.prepareSecureConfigs.restore();
      controller.resumeSavedCommands.restore();
    });

    it('Resume saved commands', function () {
      sinon.stub(controller, 'resumeSavedCommands', function () {
        return true;
      });

      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.prepareSecureConfigs.calledOnce).to.be.true;
      expect(controller.resumeSavedCommands.calledOnce).to.be.true;
    });
    it('No saved commands', function () {
      sinon.stub(controller, 'resumeSavedCommands', function () {
        return false;
      });
      sinon.stub(controller, 'loadCommands', Em.K);
      sinon.stub(controller, 'addInfoToCommands', Em.K);
      sinon.stub(controller, 'syncStopServicesOperation', Em.K);
      sinon.stub(controller, 'addObserverToCommands', Em.K);
      sinon.stub(controller, 'moveToNextCommand', Em.K);

      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
      expect(controller.prepareSecureConfigs.calledOnce).to.be.true;
      expect(controller.resumeSavedCommands.calledOnce).to.be.true;

      controller.loadCommands.restore();
      controller.addInfoToCommands.restore();
      controller.syncStopServicesOperation.restore();
      controller.addObserverToCommands.restore();
      controller.moveToNextCommand.restore();
    });
  });

  describe('#syncStopServicesOperation()', function () {

    afterEach(function () {
      App.router.get.restore();
    });

    it('No running operations', function () {
      sinon.stub(App.router, 'get', function () {
        return [];
      });

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('Running operation is not Stop All Services', function () {
      sinon.stub(App.router, 'get', function () {
        return [Em.Object.create({isRunning: true})];
      });

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('No STOP_SERVICES in commands', function () {
      sinon.stub(App.router, 'get', function () {
        return [Em.Object.create({
          isRunning: true,
          name: 'Stop All Services'
        })];
      });
      controller.set('commands', []);

      expect(controller.syncStopServicesOperation()).to.be.false;
    });
    it('Sync stop services commands', function () {
      sinon.stub(App.router, 'get', function () {
        return [Em.Object.create({
          isRunning: true,
          name: 'Stop All Services',
          id: 1
        })];
      });
      controller.set('commands', [Em.Object.create({
        name: 'STOP_SERVICES'
      })]);

      expect(controller.syncStopServicesOperation()).to.be.true;
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
  });

  describe('#resumeSavedCommands()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'addObserverToCommands', Em.K);
      sinon.stub(controller, 'moveToNextCommand', Em.K);
      controller.set('commands', []);
    });
    afterEach(function () {
      controller.moveToNextCommand.restore();
      controller.addObserverToCommands.restore();
      App.db.getSecurityDeployCommands.restore();
    });


    it('Commands is null', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return null;
      });
      expect(controller.resumeSavedCommands()).to.be.false;
    });
    it('Commands is empty', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [];
      });
      expect(controller.resumeSavedCommands()).to.be.false;
    });
    it('Command has error', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [
          {
            isError: true,
            name: 'command1'
          }
        ];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
    });
    it('Command in progress', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [
          {
            isStarted: true,
            isCompleted: false,
            name: 'command1'
          }
        ];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.false;
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
      expect(controller.moveToNextCommand.calledOnce).to.be.true;
    });
    it('Command completed', function () {
      sinon.stub(App.db, 'getSecurityDeployCommands', function () {
        return [
          {
            isCompleted: true,
            name: 'command1'
          }
        ];
      });
      expect(controller.resumeSavedCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.addObserverToCommands.calledOnce).to.be.true;
      expect(controller.moveToNextCommand.calledOnce).to.be.true;
    });
  });

  describe('#manageSecureConfigs()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'setPrincipalValue', Em.K);
    });
    afterEach(function () {
      controller.setPrincipalValue.restore();
    });

    it('serviceConfigTags is null', function () {
      sinon.stub(controller, 'onJsError', Em.K);
      controller.set('serviceConfigTags', null);
      controller.set('configs', [
        {}
      ]);
      controller.set('commands', [Em.Object.create({
        name: 'APPLY_CONFIGURATIONS'
      })]);

      expect(controller.manageSecureConfigs()).to.be.false;
      expect(controller.onJsError.calledOnce).to.be.true;
      expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isSuccess')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isError')).to.be.true;

      controller.onJsError.restore();
    });
    it('Add configs from site-*.xml', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'site1',
          configs: {}
        }
      ]);
      controller.set('configs', [
        {
          name: 'config1',
          value: "value1",
          filename: 'site1.xml'
        }
      ]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags')[0].configs).to.eql({'config1': 'value1'});
    });
    it('Add configs from global.xml, config matches "_hosts"', function () {
      controller.reopen({
        secureConfigs: [
          {
            serviceName: 'service1',
            name: 'config1'
          }
        ]
      });

      controller.set('serviceConfigTags', [
        {
          siteName: 'global',
          configs: {}
        }
      ]);
      controller.set('globalProperties', [
        {
          name: 'config1_hosts',
          value: "value1",
          filename: 'site1.xml'
        }
      ]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags')[0].configs).to.eql({});
      expect(controller.setPrincipalValue.calledWith('service1', 'config1')).to.be.true;
    });
  });

  describe('#deleteComponents()', function () {
    it('Send ajax', function () {
      sinon.stub(App.ajax, 'send', Em.K);

      controller.deleteComponents('comp1', 'host1');
      expect(App.ajax.send.calledOnce).to.be.true;

      App.ajax.send.restore();
    });
  });

  describe('#onDeleteComplete()', function () {
    it('', function () {
      controller.set('commands', [Em.Object.create({
        name: 'DELETE_ATS'
      })]);

      controller.onDeleteComplete();
      expect(controller.get('commands').findProperty('name', 'DELETE_ATS').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'DELETE_ATS').get('isSuccess')).to.be.true;
    });
  });

  describe('#onJsError()', function () {
    it('Show popup', function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);

      controller.onJsError();
      expect(App.ModalPopup.show.calledOnce).to.be.true;

      App.ModalPopup.show.restore();
    });
  });

});

});

;require.register("test/controllers/main/admin/security/disable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/disable');


describe('App.MainAdminSecurityDisableController', function () {

  var controller = App.MainAdminSecurityDisableController.create({
    serviceConfigTags: null,
    secureProperties: null,
    secureMapping: null
  });


  describe('#resumeCommands()', function () {
    var context = {
      getSecurityDeployCommands: function () {
        return this.testData;
      }
    };

    var mock = {
      setStepsEnable: Em.K,
      setLowerStepsDisable: Em.K
    };

    beforeEach(function () {
      sinon.stub(App.db, "getSecurityDeployCommands", context.getSecurityDeployCommands);
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
    });
    afterEach(function () {
      App.db.getSecurityDeployCommands.restore();
      App.router.get.restore();
    });

    it('commands are absent in local storage', function () {
      App.db.testData = null;
      expect(controller.resumeCommands()).to.be.false;
    });
    it('zero commands in local storage', function () {
      App.db.testData = [];
      expect(controller.resumeCommands()).to.be.false;
    });
    it('one command is present', function () {
      App.db.testData = [
        {
          name: 'command1'
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
    });
    it('command is started and completed', function () {
      App.db.testData = [
        {
          name: 'command1',
          isStarted: true,
          isCompleted: true
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.true;
    });
    it('command is started but not completed', function () {
      App.db.testData = [
        {
          name: 'command1',
          isStarted: true,
          isCompleted: false
        }
      ];
      controller.get('commands').clear();
      expect(controller.resumeCommands()).to.be.true;
      expect(controller.get('commands').mapProperty('name')).to.eql(['command1']);
      expect(controller.get('commands').findProperty('name', 'command1').get('isStarted')).to.be.false;
    });
  });

  describe('#isSubmitDisabled', function () {
    var testCases = [
      {
        title: 'commands is empty',
        commands: [],
        result: false
      },
      {
        title: 'one started command',
        commands: [Em.Object.create({
          isStarted: true
        })],
        result: true
      },
      {
        title: 'one failed command',
        commands: [Em.Object.create({
          isError: true
        })],
        result: false
      },
      {
        title: 'one success command',
        commands: [Em.Object.create({
          isSuccess: true
        })],
        result: false
      },
      {
        title: 'not all commands are success',
        commands: [
          Em.Object.create({
            isSuccess: true
          }),
          Em.Object.create({
            isSuccess: false
          })
        ],
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', test.commands);
        expect(controller.get('isSubmitDisabled')).to.equal(test.result);
      });
    });
  });

  describe('#syncStopServicesCommand()', function () {

    it('No background operations', function () {
      controller.set('commands', [Em.Object.create({
        name: 'STOP_SERVICES',
        requestId: 1
      })]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('background operation is not running', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          isRunning: false
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('background operation is running but not "Stop All Services"', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          isRunning: true
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(1);
    });
    it('"Stop All Services" operation is running', function () {
      App.router.set('backgroundOperationsController.services', [
        Em.Object.create({
          name: 'Stop All Services',
          isRunning: true,
          id: 2
        })
      ]);
      controller.syncStopServicesCommand.apply(controller);
      expect(controller.get('commands').findProperty('name', 'STOP_SERVICES').get('requestId')).to.equal(2);
    });
  });

  describe('#manageSecureConfigs()', function () {

    beforeEach(function () {
      sinon.stub(controller, "modifySiteConfigs", Em.K);
    });
    afterEach(function () {
      controller.modifySiteConfigs.restore();
    });

    var testCases = [
      {
        title: 'serviceConfigTags, secureProperties, secureMapping are null',
        content: {
          serviceConfigTags: null,
          secureProperties: null,
          secureMapping: null
        }
      },
      {
        title: 'serviceConfigTags is null',
        content: {
          serviceConfigTags: null,
          secureProperties: [],
          secureMapping: []
        }
      },
      {
        title: 'secureProperties is null',
        content: {
          serviceConfigTags: [],
          secureProperties: null,
          secureMapping: []
        }
      },
      {
        title: 'secureMapping is null',
        content: {
          serviceConfigTags: [],
          secureProperties: [],
          secureMapping: null
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('commands', [Em.Object.create({
          name: 'APPLY_CONFIGURATIONS'
        })]);
        controller.set('serviceConfigTags', test.content.serviceConfigTags);
        controller.set('secureProperties', test.content.secureProperties);
        controller.set('secureMapping', test.content.secureMapping);

        expect(controller.manageSecureConfigs()).to.be.false;
        expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isSuccess')).to.be.false;
        expect(controller.get('commands').findProperty('name', 'APPLY_CONFIGURATIONS').get('isError')).to.be.true;
      });
    });
    it('serviceConfigTags is empty', function () {
      controller.set('serviceConfigTags', []);
      controller.set('secureProperties', []);
      controller.set('secureMapping', []);

      expect(controller.manageSecureConfigs()).to.be.true;
    });
    it('serviceConfigTags has cluster-env site', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'cluster-env',
          configs: {}
        }
      ]);

      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.get('serviceConfigTags').findProperty('siteName', 'cluster-env').configs.security_enabled).to.equal('false');
    });
    it('serviceConfigTags has site.xml', function () {
      controller.set('serviceConfigTags', [
        {
          siteName: 'site'
        }
      ]);
      expect(controller.manageSecureConfigs()).to.be.true;
      expect(controller.modifySiteConfigs.calledOnce).to.be.true;
    });
  });

  describe('#modifySiteConfigs()', function () {
    var testCases = [
      {
        title: '_serviceConfigTags and secureMapping are null',
        content: {
          secureMapping: null,
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: '_serviceConfigTags is null',
        content: {
          secureMapping: [],
          _serviceConfigTags: null
        },
        result: false
      },
      {
        title: 'secureMapping is null',
        content: {
          secureMapping: null,
          _serviceConfigTags: {}
        },
        result: false
      },
      {
        title: 'secureMapping and _serviceConfigTags are empty',
        content: {
          secureMapping: [],
          _serviceConfigTags: {
            configs: {}
          }
        },
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.modifySiteConfigs(test.content.secureMapping, test.content._serviceConfigTags)).to.equal(test.result);
      });
    });
    it('secureMapping doesn\'t contain passed siteName', function () {
      var secureMapping = [];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.true;
    });
    it('secureMapping contain passed siteName but doesn\'t match config name', function () {
      var secureMapping = [
        {
          filename: 'site1.xml'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.true;
    });
    it('secureMapping contain passed siteName and match config name', function () {
      var secureMapping = [
        {
          filename: 'site1.xml',
          name: 'config2'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.be.undefined;
    });
    it('secureMapping contain passed siteName and included in secureConfigValuesMap', function () {
      var secureMapping = [
        {
          filename: 'site1.xml',
          name: 'config2',
          nonSecureValue: 'nonSecureValue'
        }
      ];
      var _serviceConfigTags = {
        configs: {
          'config2': true
        },
        siteName: 'site1'
      };
      controller.set('secureConfigValuesMap', {
        'config2': 'value'
      });
      expect(controller.modifySiteConfigs(secureMapping, _serviceConfigTags)).to.be.true;
      expect(_serviceConfigTags.configs.config2).to.equal('nonSecureValue');
    });
  });
});

});

;require.register("test/controllers/main/admin/security/security_progress_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security/security_progress_controller');
require('models/host_component');
require('models/host');

describe('App.MainAdminSecurityProgressController', function () {

  var controller = App.MainAdminSecurityProgressController.create({
    loadClusterConfigs: function () {},
    deleteComponents: function () {}
  });

  describe('#retry()', function () {

    beforeEach(function () {
      sinon.spy(controller, "startCommand");
    });
    afterEach(function () {
      controller.startCommand.restore();
    });

    it('commands are empty', function () {
      controller.set('commands', []);
      controller.retry();
      expect(controller.startCommand.called).to.be.false;
    });

    it('command is successful', function () {
      controller.set('commands', [
        Em.Object.create({
          name: 'test',
          isSuccess: true,
          isError: false,
          isStarted: true
        })
      ]);
      controller.retry();
      expect(controller.startCommand.calledOnce).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isStarted')).to.be.true;
    });

    it('command is failed', function () {
      controller.set('commands', [
        Em.Object.create({
          name: 'test',
          isSuccess: true,
          isError: true,
          isStarted: true
        })
      ]);
      controller.retry();
      expect(controller.startCommand.calledOnce).to.be.true;
      expect(controller.get('commands').findProperty('name', 'test').get('isError')).to.be.false;
      expect(controller.get('commands').findProperty('name', 'test').get('isStarted')).to.be.false;
    });
  });

  describe('#updateServices()', function () {

    it('commands are empty', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', []);
      controller.updateServices();
      expect(controller.get('services')).to.be.empty;
    });

    it('command doesn\'t have polledData', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', [Em.Object.create({
        label: 'label'
      })]);
      controller.updateServices();
      expect(controller.get('services')).to.be.empty;
    });

    it('command has polledData', function () {
      controller.set('services', [
        {}
      ]);
      controller.set('commands', [Em.Object.create({
        label: 'service1',
        polledData: [
          {
            Tasks: {
              host_name: 'host1'
            }
          }
        ]
      })]);
      controller.updateServices();
      expect(controller.get('services').findProperty('name', 'service1').get('hosts')).to.eql([
        {
          name: 'host1',
          publicName: 'host1',
          logTasks: [
            {
              Tasks: {host_name: 'host1'}
            }
          ]
        }
      ]);
    });
  });

  describe('#setIndex()', function () {
    it('commandArray is empty', function () {
      var commandArray = [];
      controller.setIndex(commandArray);
      expect(commandArray).to.be.empty;
      expect(controller.get('totalSteps')).to.equal(0);
    });
    it('one command in commandArray', function () {
      var commandArray = [
        Em.Object.create({name: 'command1'})
      ];
      controller.setIndex(commandArray);
      expect(commandArray[0].get('index')).to.equal(1);
      expect(controller.get('totalSteps')).to.equal(1);
    });
    it('commands with random indexes', function () {
      var commandArray = [];
      commandArray[3] = Em.Object.create({name: 'command3'});
      commandArray[11] = Em.Object.create({name: 'command11'});
      controller.setIndex(commandArray);
      expect(commandArray[3].get('index')).to.equal(4);
      expect(commandArray[11].get('index')).to.equal(12);
      expect(controller.get('totalSteps')).to.equal(12);
    });
  });

  describe('#startCommand()', function () {

    var command = Em.Object.create({
      start: Em.K
    });

    beforeEach(function () {
      sinon.spy(command, "start");
      sinon.spy(controller, "loadClusterConfigs");
      sinon.spy(controller, "deleteComponents");
      sinon.stub(controller, "saveCommands", Em.K);
    });

    afterEach(function () {
      command.start.restore();
      controller.loadClusterConfigs.restore();
      controller.deleteComponents.restore();
      controller.saveCommands.restore();
    });

    it('number of commands doesn\'t match totalSteps', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.false;
    });

    it('commands is empty', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 0);
      expect(controller.startCommand()).to.be.false;
    });

    it('command is started and completed', function () {
      controller.set('commands', [Em.Object.create({
        isStarted: true,
        isCompleted: true
      })]);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.false;
    });

    it('command is started and incompleted', function () {
      controller.set('commands', [Em.Object.create({
        isStarted: true,
        isCompleted: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.startCommand()).to.be.true;
    });

    it('command parameter passed, isPolling is true', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 0);
      command.set('isPolling', true);
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(command.start.calledOnce).to.be.true;
      command.set('isPolling', false);
    });

    it('command parameter passed, name is "APPLY_CONFIGURATIONS"', function () {
      command.set('name', 'APPLY_CONFIGURATIONS');
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(controller.loadClusterConfigs.calledOnce).to.be.true;
    });

    it('command parameter passed, name is "DELETE_ATS"', function () {
      command.set('name', 'DELETE_ATS');

      sinon.stub(App.HostComponent, 'find', function() {
        return [Em.Object.create({
          id: 'APP_TIMELINE_SERVER_ats_host',
          componentName: 'APP_TIMELINE_SERVER',
          hostName: 'ats_host'
        })];
      });
      expect(controller.startCommand(command)).to.be.true;
      expect(command.get('isStarted')).to.be.true;
      expect(controller.deleteComponents.calledWith('APP_TIMELINE_SERVER', 'ats_host')).to.be.true;

      App.HostComponent.find.restore();
    });

  });

  describe('#onCompleteCommand()', function () {

    beforeEach(function () {
      sinon.spy(controller, "moveToNextCommand");
      sinon.stub(controller, "saveCommands", Em.K);
    });
    afterEach(function () {
      controller.moveToNextCommand.restore();
      controller.saveCommands.restore();

    });

    it('number of commands doesn\'t match totalSteps', function () {
      controller.set('commands', []);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('No successful commands', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('No successful commands', function () {
      controller.set('commands', [Em.Object.create({
        isSuccess: false
      })]);
      controller.set('totalSteps', 1);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('Last command is successful', function () {
      controller.set('commands', [
        Em.Object.create({
          isSuccess: false
        }),
        Em.Object.create({
          isSuccess: true
        })
      ]);
      controller.set('totalSteps', 2);
      expect(controller.onCompleteCommand()).to.be.false;
    });
    it('all commands are successful', function () {
      controller.set('commands', [
        Em.Object.create({
          isSuccess: true,
          name: 'command1'
        }),
        Em.Object.create({
          isSuccess: false,
          name: 'command2'
        })
      ]);
      controller.set('totalSteps', 2);
      expect(controller.onCompleteCommand()).to.be.true;
      expect(controller.moveToNextCommand.calledWith(Em.Object.create({
        isSuccess: false,
        name: 'command2'
      }))).to.be.true;
    });
  });

  describe('#moveToNextCommand()', function () {

    beforeEach(function () {
      sinon.spy(controller, "startCommand");
    });
    afterEach(function () {
      controller.startCommand.restore();
    });

    it('No commands present', function () {
      controller.set('commands', []);
      expect(controller.moveToNextCommand()).to.be.false;
    });
    it('Only started command present', function () {
      controller.set('commands', [
        Em.Object.create({
          isStarted: true
        })
      ]);
      expect(controller.moveToNextCommand()).to.be.false;
    });
    it('Command is not started', function () {
      controller.set('commands', [
        Em.Object.create({
          isStarted: false,
          name: 'command1'
        })
      ]);
      expect(controller.moveToNextCommand()).to.be.true;
      expect(controller.startCommand.calledWith(Em.Object.create({
        isStarted: false,
        name: 'command1'
      }))).to.be.true;
    });
    it('Next command provide as argument', function () {
      var nextCommand = Em.Object.create({
        isStarted: false,
        name: 'command2'
      });
      expect(controller.moveToNextCommand(nextCommand)).to.be.true;
      expect(controller.startCommand.calledWith(Em.Object.create({
        isStarted: false,
        name: 'command2'
      }))).to.be.true;
    });
  });

  describe('#setServiceTagNames()', function () {
    var testCases = [
      {
        title: 'configs is empty object',
        content: {
          secureService: {},
          configs: {}
        },
        result: undefined
      },
      {
        title: 'secureService.sites is null',
        content: {
          secureService: {
            sites: null
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites doesn\'t contain required config tag',
        content: {
          secureService: {
            sites: []
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites contains required config tag',
        content: {
          secureService: {
            sites: ['site1']
          },
          configs: {
            site1: {
              tag: 'tag1'
            }
          }
        },
        result: {
          siteName: 'site1',
          tagName: 'tag1',
          newTagName: null,
          configs: {}
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.setServiceTagNames(test.content.secureService, test.content.configs)).to.eql(test.result);
      });
    });
  });

  describe('#modifyConfigsForSecure', function () {
    var cfg = {
      properties: {
        'ui.childopts': 'value1',
        'supervisor.childopts': 'value2',
        'common_property': 'value4'
      }
    };
    var siteName = 'storm-site';
    var result = {
      'ui.childopts': 'value1 -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf',
      'supervisor.childopts': 'value2 -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf',
      'common_property': 'value4'
    };
    var propertiesToUpdate = [
      {
        siteName: 'storm-site',
        name: 'ui.childopts',
        append: ' -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf'
      },
      {
        siteName: 'storm-site',
        name: 'supervisor.childopts',
        append: ' -Djava.security.auth.login.config=/etc/storm/conf/storm_jaas.conf'
      }
    ];
    it("should change some storm sonfigs", function () {
      controller.set('propertiesToUpdate', propertiesToUpdate);
      expect(controller.modifyConfigsForSecure(siteName, cfg)).to.eql(result);
    });
  });
});

});

;require.register("test/controllers/main/admin/security_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/security');


describe('App.MainAdminSecurityController', function () {

  var controller = App.MainAdminSecurityController.create({
    getServiceConfigsFromServer: function () {
    } ,
    services: [{serviceName: 'HDFS'}]
  });

  describe('#setServiceTagNames()', function () {
    var testCases = [
      {
        title: 'configs is empty object',
        content: {
          secureService: {},
          configs: {}
        },
        result: undefined
      },
      {
        title: 'secureService.sites is null',
        content: {
          secureService: {
            sites: null
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites doesn\'t contain required config tag',
        content: {
          secureService: {
            sites: []
          },
          configs: {
            site1: {}
          }
        },
        result: undefined
      },
      {
        title: 'secureService.sites contains required config tag',
        content: {
          secureService: {
            sites: ['site1']
          },
          configs: {
            site1: {
              tag: 'tag1'
            }
          }
        },
        result: {
          siteName: 'site1',
          tagName: 'tag1',
          newTagName: null,
          configs: {}
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.setServiceTagNames(test.content.secureService, test.content.configs)).to.eql(test.result);
      });
    });
  });

  describe('#getSecurityStatusFromServerSuccessCallback()', function () {

    beforeEach(function () {
      sinon.spy(controller, 'showSecurityErrorPopup');
      sinon.spy(controller, 'getServiceConfigsFromServer');
    });
    afterEach(function () {
      controller.showSecurityErrorPopup.restore();
      controller.getServiceConfigsFromServer.restore();
    });

    it('desired_configs is empty', function () {
      var data = {Clusters: {
        desired_configs: {}
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showSecurityErrorPopup.called).to.equal(true);
    });

    it('cluster-env is missing', function () {
      var data = {Clusters: {
        desired_configs: {
          'hdfs-site': {}
        }
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.showSecurityErrorPopup.called).to.equal(true);
    });

    it('cluster-env and hdfs-site are correct', function () {
      var data = {Clusters: {
        desired_configs: {
          'hdfs-site': {
            tag: 1
          },
          'cluster-env': {
            tag: 2
          },
          'hadoop-env': {
            tag: 3
          }
        }
      }};
      controller.getSecurityStatusFromServerSuccessCallback(data);
      expect(controller.get('tag.cluster-env')).to.equal(2);
      expect(controller.get('tag.hdfs-site')).to.equal(1);
      expect(controller.getServiceConfigsFromServer.called).to.equal(true);
    });
  });


  describe('#setNnHaStatus()', function () {

    beforeEach(function () {
      sinon.stub(App.db, "setIsNameNodeHa", Em.K);
    });
    afterEach(function () {
      App.db.setIsNameNodeHa.restore();
    });


    it('hdfsConfigs is null', function () {
      var hdfsConfigs = null;
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('"dfs.nameservices" is absent in hdfsConfigs', function () {
      var hdfsConfigs = {};
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('namenodesKey is absent in hdfsConfigs', function () {
      var hdfsConfigs = {
        'dfs.nameservices': 'key'
      };
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('false').called).to.equal(true);
    });

    it('namenodesKey is present in hdfsConfigs', function () {
      var hdfsConfigs = {
        'dfs.nameservices': 'key',
        'dfs.ha.namenodes.key': 'true'
      };
      controller.setNnHaStatus(hdfsConfigs);
      expect(App.db.setIsNameNodeHa.withArgs('true').called).to.equal(true);
    });
  });

  describe('#loadUsers()', function () {

    beforeEach(function () {
      sinon.stub(App.db, "setSecureUserInfo", Em.K);
    });
    afterEach(function () {
      App.db.setSecureUserInfo.restore();
    });

    it('if defaultUserNameMap is empty then serviceUsers stays the same', function () {
      var configs = {};
      controller.set('serviceUsers', []);
      controller.set('userNameMap', {});
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.be.empty;
    });

    it('if user config value is missing then use default', function () {
      var configs = {};
      controller.set('serviceUsers', []);
      controller.set('userNameMap', {
        test_user: {defaultValue: 'test', siteName: 'test-env', serviceName: 'TEST'
      }});
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.eql([
        {
          "name": "test_user",
          "value": "test"
        }
      ]);
    });

    it('user config value has value', function () {
      var configs = {
        'test_user': 'config-value'
      };
      controller.set('serviceUsers', []);
      controller.set('defaultUserNameMap', {
        test_user: {defaultValue: 'test', siteName: 'test-env', serviceName: 'TEST'
        }});
      controller.loadUsers(configs);
      expect(controller.get('serviceUsers')).to.eql([
        {
          "name": "test_user",
          "value": "config-value"
        }
      ]);
    });
  });
});
});

;require.register("test/controllers/main/admin/serviceAccounts_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/serviceAccounts_controller');


describe('App.MainAdminServiceAccountsController', function () {

  var controller = App.MainAdminServiceAccountsController.create();

  describe('#setContentProperty()', function () {
    var testCases = [
      {
        title: 'key is null',
        content: {
          key: null,
          configName: 'cc',
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'configName is null',
        content: {
          key: 'key',
          configName: null,
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'misc configs array doesn\'t contain such a config',
        content: {
          key: 'key',
          configName: 'config1',
          miscConfigs: []
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'content doesn\'t contain such a key',
        content: {
          key: 'key',
          configName: 'config1',
          miscConfigs: [
            Em.Object.create({
              name: 'test_key'
            })
          ]
        },
        result: {
          output: false,
          configValue: 'test'
        }
      },
      {
        title: 'content property match config',
        content: {
          key: 'testKey',
          configName: 'test_key',
          miscConfigs: [
            Em.Object.create({
              name: 'test_key',
              value: 'testValue'
            })
          ]
        },
        result: {
          output: true,
          configValue: 'testValue'
        }
      }
    ];
    controller.set('content', Em.Object.create({testKey: 'test'}));
    testCases.forEach(function (test) {
      it(test.title, function () {
        var content = controller.get('content');
        expect(controller.setContentProperty(test.content.key, test.content.configName, test.content.miscConfigs)).to.equal(test.result.output);
        expect(content.get('testKey')).to.equal(test.result.configValue);
      });
    });
  });

  describe('#sortByOrder()', function () {
    var testCases = [
      {
        title: 'sortOrder is null',
        content: {
          sortOrder: null,
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder is empty',
        content: {
          sortOrder: [],
          arrayToSort: [
            {
              name: 'one',
              displayName: 'one'
            }
          ]
        },
        result: ['one']
      },
      {
        title: 'sortOrder items don\'t match items of array',
        content: {
          sortOrder: ['one'],
          arrayToSort: [
            {name: 'two'}
          ]
        },
        result: []
      },
      {
        title: 'sort items in reverse order',
        content: {
          sortOrder: ['two', 'one'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['two', 'one']
      },
      {
        title: 'sort items in correct order',
        content: {
          sortOrder: ['one', 'two'],
          arrayToSort: [
            Em.Object.create({
              name: 'one',
              displayName: 'one'
            }),
            Em.Object.create({
              name: 'two',
              displayName: 'two'
            })
          ]
        },
        result: ['one', 'two']
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.sortByOrder(test.content.sortOrder, test.content.arrayToSort).mapProperty('displayName')).to.eql(test.result);
      });
    });
  });
});

});

;require.register("test/controllers/main/admin/stack_and_upgrade_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/admin/stack_and_upgrade_controller');
require('utils/string_utils');

describe('App.MainAdminStackAndUpgradeController', function() {

  var controller = App.MainAdminStackAndUpgradeController.create({
    getDBProperty: Em.K,
    setDBProperty: Em.K
  });

  describe("#realRepoUrl", function() {
    before(function () {
      this.mock = sinon.stub(App, 'get');
    });
    after(function () {
      this.mock.restore();
    });
    it("", function() {
      this.mock.withArgs('apiPrefix').returns('apiPrefix');
      this.mock.withArgs('stackVersionURL').returns('stackVersionURL');
      controller.propertyDidChange('realRepoUrl');
      expect(controller.get('realRepoUrl')).to.equal('apiPrefixstackVersionURL/compatible_repository_versions?fields=*,operating_systems/*,operating_systems/repositories/*');
    });
  });

  describe("#realStackUrl", function() {
    before(function () {
      this.mock = sinon.stub(App, 'get');
    });
    after(function () {
      this.mock.restore();
    });
    it("", function() {
      this.mock.withArgs('apiPrefix').returns('apiPrefix');
      this.mock.withArgs('clusterName').returns('clusterName');
      controller.propertyDidChange('realStackUrl');
      expect(controller.get('realStackUrl')).to.equal('apiPrefix/clusters/clusterName/stack_versions?fields=*,repository_versions/*,repository_versions/operating_systems/repositories/*');
    });
  });

  describe("#realUpdateUrl", function() {
    before(function () {
      this.mock = sinon.stub(App, 'get');
    });
    after(function () {
      this.mock.restore();
    });
    it("", function() {
      this.mock.withArgs('apiPrefix').returns('apiPrefix');
      this.mock.withArgs('clusterName').returns('clusterName');
      controller.propertyDidChange('realUpdateUrl');
      expect(controller.get('realUpdateUrl')).to.equal('apiPrefix/clusters/clusterName/stack_versions?fields=ClusterStackVersions/*');
    });
  });

  describe("#requestStatus", function() {
    it("state ABORTED", function() {
      controller.set('upgradeData', { Upgrade: {request_status: 'ABORTED'}});
      controller.propertyDidChange('requestStatus');
      expect(controller.get('requestStatus')).to.equal('SUSPENDED');
    });
    it("state not ABORTED", function() {
      controller.set('upgradeData', { Upgrade: {request_status: 'INIT'}});
      controller.propertyDidChange('requestStatus');
      expect(controller.get('requestStatus')).to.equal('INIT');
    });
  });

  describe("#load()", function() {
    before(function(){
      sinon.stub(controller, 'loadUpgradeData').returns({
        done: function(callback) {callback();}
      });
      sinon.stub(controller, 'loadStackVersionsToModel').returns({
        done: function(callback) {callback();}
      });
      sinon.stub(controller, 'loadRepoVersionsToModel').returns({
        done: function(callback) {callback();}
      });
      sinon.stub(App.StackVersion, 'find').returns([Em.Object.create({
        state: 'CURRENT',
        repositoryVersion: {
          repositoryVersion: '2.2',
          displayName: 'HDP-2.2'
        }
      })]);
    });
    after(function(){
      controller.loadUpgradeData.restore();
      controller.loadStackVersionsToModel.restore();
      controller.loadRepoVersionsToModel.restore();
      App.StackVersion.find.restore();
    });
    it("", function() {
      controller.load();
      expect(controller.loadUpgradeData.calledWith(true)).to.be.true;
      expect(controller.loadStackVersionsToModel.calledWith(true)).to.be.true;
      expect(controller.loadRepoVersionsToModel.calledOnce).to.be.true;
      expect(controller.get('currentVersion')).to.eql({
        "repository_version": "2.2",
        "repository_name": "HDP-2.2"
      });
    });
  });

  describe("#loadUpgradeData()", function() {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send').returns({
        then: Em.K,
        complete: Em.K
      });
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it("get entire data", function() {
      controller.set('upgradeId', 1);
      controller.loadUpgradeData();
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'admin.upgrade.data',
        sender: controller,
        data: {
          id: 1
        },
        success: 'loadUpgradeDataSuccessCallback'
      })
    });
    it("get only state", function() {
      controller.set('upgradeId', 1);
      controller.loadUpgradeData(true);
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'admin.upgrade.state',
        sender: controller,
        data: {
          id: 1
        },
        success: 'loadUpgradeDataSuccessCallback'
      })
    });
    it("upgrade id is null", function() {
      controller.set('upgradeId', null);
      controller.loadUpgradeData();
      expect(App.ajax.send.called).to.be.false;
    });
  });

  describe("#loadUpgradeDataSuccessCallback()", function() {
    var retryCases = [
      {
        isRetryPendingInitial: true,
        status: 'ABORTED',
        isRetryPending: true,
        requestInProgress: true,
        title: 'retry request not yet applied'
      },
      {
        isRetryPendingInitial: true,
        status: 'UPGRADING',
        isRetryPending: false,
        requestInProgress: false,
        title: 'retry request applied'
      },
      {
        isRetryPendingInitial: false,
        status: 'ABORTED',
        isRetryPending: false,
        requestInProgress: true,
        title: 'no retry request sent'
      },
      {
        isRetryPendingInitial: false,
        status: 'UPGRADING',
        isRetryPending: false,
        requestInProgress: true,
        title: 'upgrade wasn\'t aborted'
      }
    ];
    beforeEach(function () {
      sinon.stub(controller, 'updateUpgradeData', Em.K);
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    afterEach(function () {
      controller.updateUpgradeData.restore();
      controller.setDBProperty.restore();
    });
    it("correct data", function() {
      var data = {
        "Upgrade": {
          "request_status": "UPGRADED"
        },
        "upgrade_groups": [
          {
            "UpgradeGroup": {
              "id": 1
            },
            "upgrade_items": []
          }
        ]};
      controller.loadUpgradeDataSuccessCallback(data);
      expect(App.get('upgradeState')).to.equal('UPGRADED');
      expect(controller.updateUpgradeData.calledOnce).to.be.true;
      expect(controller.setDBProperty.calledWith('upgradeState', 'UPGRADED')).to.be.true;
    });
    it("data is null", function() {
      var data = null;
      controller.loadUpgradeDataSuccessCallback(data);
      expect(controller.updateUpgradeData.called).to.be.false;
      expect(controller.setDBProperty.called).to.be.false;
    });
    retryCases.forEach(function (item) {
      it(item.title, function () {
        var data = {
          "Upgrade": {
            "request_status": item.status
          }
        };
        controller.setProperties({
          isRetryPending: item.isRetryPendingInitial,
          requestInProgress: true
        });
        controller.loadUpgradeDataSuccessCallback(data);
        expect(controller.getProperties(['isRetryPending', 'requestInProgress'])).to.eql({
          isRetryPending: item.isRetryPending,
          requestInProgress: item.requestInProgress
        });
      });
    });
  });

  describe("#getUpgradeItem()", function() {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it("default callback", function() {
      var item = Em.Object.create({
        request_id: 1,
        group_id: 2,
        stage_id: 3
      });
      controller.getUpgradeItem(item);
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'admin.upgrade.upgrade_item',
        sender: controller,
        data: {
          upgradeId: 1,
          groupId: 2,
          stageId: 3
        },
        success: 'getUpgradeItemSuccessCallback'
      });
    });
    it("custom callback", function() {
      var item = Em.Object.create({
        request_id: 1,
        group_id: 2,
        stage_id: 3
      });
      controller.getUpgradeItem(item, 'customCallback');
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'admin.upgrade.upgrade_item',
        sender: controller,
        data: {
          upgradeId: 1,
          groupId: 2,
          stageId: 3
        },
        success: 'customCallback'
      });
    });
  });

  describe("#openUpgradeDialog()", function () {
    before(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
    });
    after(function () {
      App.router.transitionTo.restore();
    });
    it("should open dialog", function () {
      controller.openUpgradeDialog();
      expect(App.router.transitionTo.calledWith('admin.stackUpgrade')).to.be.true;
    });
  });

  describe("#runPreUpgradeCheck()", function() {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it("make ajax call", function() {
      controller.runPreUpgradeCheck(Em.Object.create({
        repositoryVersion: '2.2',
        displayName: 'HDP-2.2',
        upgradeType: 'ROLLING',
        skipComponentFailures: false,
        skipSCFailures: false
      }));
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: "admin.upgrade.pre_upgrade_check",
        sender: controller,
        data: {
          value: '2.2',
          label: 'HDP-2.2',
          type: 'ROLLING',
          skipComponentFailures: 'false',
          skipSCFailures: 'false'
        },
        success: "runPreUpgradeCheckSuccess",
        error: "runPreUpgradeCheckError"
      });
    });
  });

  describe("#runPreUpgradeCheckSuccess()", function () {
    var cases = [
      {
        check: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "FAIL",
          "reason": "FAIL",
          "failed_on": [],
          "check_type": "SERVICE"
        },
        showClusterCheckPopupCalledCount: 1,
        upgradeCalledCount: 0,
        title: 'popup is displayed if fails are present'
      },
      {
        check: {
          "check": "Configuration Merge Check",
          "status": "WARNING",
          "reason": "Conflict",
          "failed_on": [],
          "failed_detail": [
            {
              type: 't0',
              property: 'p0',
              current: 'c0',
              new_stack_value: 'n0',
              result_value: 'n0'
            },
            {
              type: 't1',
              property: 'p1',
              current: 'c1',
              new_stack_value: null,
              result_value: 'c1'
            },
            {
              type: 't2',
              property: 'p2',
              current: 'c2',
              new_stack_value: null,
              result_value: null
            }
          ],
          "check_type": "CLUSTER",
          "id": "CONFIG_MERGE"
        },
        showClusterCheckPopupCalledCount: 1,
        upgradeCalledCount: 0,
        configs: [
          {
            type: 't0',
            name: 'p0',
            currentValue: 'c0',
            recommendedValue: 'n0',
            resultingValue: 'n0',
            isDeprecated: false,
            willBeRemoved: false
          },
          {
            type: 't1',
            name: 'p1',
            currentValue: 'c1',
            recommendedValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.deprecated'),
            resultingValue: 'c1',
            isDeprecated: true,
            willBeRemoved: false
          },
          {
            type: 't2',
            name: 'p2',
            currentValue: 'c2',
            recommendedValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.deprecated'),
            resultingValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.willBeRemoved'),
            isDeprecated: true,
            willBeRemoved: true
          }
        ],
        title: 'popup is displayed if warnings are present; configs merge conflicts'
      },
      {
        check: {
          "check": "Work-preserving RM/NM restart is enabled in YARN configs",
          "status": "PASS",
          "reason": "OK",
          "failed_on": [],
          "check_type": "SERVICE"
        },
        showClusterCheckPopupCalledCount: 0,
        upgradeCalledCount: 1,
        title: 'upgrade is started if fails and warnings are absent'
      }
    ];
    beforeEach(function () {
      sinon.stub(App, 'showClusterCheckPopup', Em.K);
      sinon.stub(controller, 'upgrade', Em.K);
    });
    afterEach(function () {
      App.showClusterCheckPopup.restore();
      controller.upgrade.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        controller.runPreUpgradeCheckSuccess(
          {
            items: [
              {
                UpgradeChecks: item.check
              }
            ]
          }, null, {
            label: 'name'
          }
        );
        expect(controller.upgrade.callCount).to.equal(item.upgradeCalledCount);
        expect(App.showClusterCheckPopup.callCount).to.equal(item.showClusterCheckPopupCalledCount);
        if (item.check.id == 'CONFIG_MERGE') {
          expect(App.showClusterCheckPopup.firstCall.args[2]).to.eql(item.configs);
        }
      });
    });
  });

  describe("#initDBProperties()", function() {
    before(function () {
      this.mock = sinon.stub(controller, 'getDBProperties');
    });
    after(function () {
      this.mock.restore();
    });
    it("set string properties", function () {
      this.mock.returns({prop: 'string'});
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal('string');
    });
    it("set number properties", function () {
      this.mock.returns({prop: 0});
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal(0);
    });
    it("set boolean properties", function () {
      this.mock.returns({prop: false});
      controller.initDBProperties();
      expect(controller.get('prop')).to.be.false;
    });
    it("set undefined properties", function () {
      this.mock.returns({prop: undefined});
      controller.set('prop', 'value');
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal('value');
    });
    it("set null properties", function () {
      this.mock.returns({prop: null});
      controller.set('prop', 'value');
      controller.initDBProperties();
      expect(controller.get('prop')).to.equal('value');
    });
  });

  describe("#init()", function() {
    before(function () {
      sinon.stub(controller, 'initDBProperties', Em.K);
    });
    after(function () {
      controller.initDBProperties.restore();
    });
    it("call initDBProperties", function () {
      controller.init();
      expect(controller.initDBProperties.calledOnce).to.be.true;
    });
  });

  describe("#upgrade()", function() {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
      controller.setDBProperty.restore();
    });
    it("make ajax call", function() {
      controller.set('currentVersion', {
        repository_version: '2.2'
      });
      controller.upgrade({
        value: '2.2',
        label: 'HDP-2.2'
      });
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({"value": '2.2', "label": 'HDP-2.2'});
      expect(App.ajax.send.getCall(0).args[0].name).to.eql('admin.upgrade.start');
      expect(App.ajax.send.getCall(0).args[0].sender).to.eql(controller);
      expect(App.ajax.send.getCall(0).args[0].success).to.eql('upgradeSuccessCallback');
      expect(App.ajax.send.getCall(0).args[0].callback).to.be.called;
      expect(controller.setDBProperty.calledWith('currentVersion', {
        repository_version: '2.2'
      })).to.be.true;
    });
  });

  describe("#upgradeSuccessCallback()", function() {
    before(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(controller, 'openUpgradeDialog', Em.K);
      sinon.stub(controller, 'setDBProperties', Em.K);
      sinon.stub(controller, 'load', Em.K);
    });
    after(function () {
      App.clusterStatus.setClusterStatus.restore();
      controller.openUpgradeDialog.restore();
      controller.setDBProperties.restore();
      controller.load.restore();
    });
    it("open upgrade dialog", function() {
      var data = {
        resources: [
          {
            Upgrade: {
              request_id: 1
            }
          }
        ]
      };
      controller.upgradeSuccessCallback(data, {}, {label: 'HDP-2.2.1', isDowngrade: true});
      expect(controller.load.calledOnce).to.be.true;
      expect(controller.get('upgradeVersion')).to.equal('HDP-2.2.1');
      expect(controller.get('upgradeData')).to.be.null;
      expect(controller.get('isDowngrade')).to.be.true;
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
      expect(controller.openUpgradeDialog.calledOnce).to.be.true;
    });
  });

  describe("#updateUpgradeData()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'initUpgradeData', Em.K);
    });
    afterEach(function () {
      controller.initUpgradeData.restore();
    });
    it("data loaded first time", function() {
      controller.set('upgradeData', null);
      controller.updateUpgradeData({});
      expect(controller.initUpgradeData.calledWith({})).to.be.true;
    });
    it("update loaded data", function() {
      var oldData = Em.Object.create({
        upgradeGroups: [
          Em.Object.create({
            group_id: 1,
            upgradeItems: [
              Em.Object.create({
                stage_id: 1
              })
            ]
          }),
          Em.Object.create({
            group_id: 2,
            upgradeItems: [
              Em.Object.create({
                stage_id: 2
              }),
              Em.Object.create({
                stage_id: 3
              })
            ]
          })
        ]
      });
      var newData = {
        Upgrade: {
          request_id: 1
        },
        upgrade_groups: [
          {
            UpgradeGroup: {
              group_id: 1,
              status: 'COMPLETED',
              display_status: 'COMPLETED',
              progress_percent: 100,
              completed_task_count: 3
            },
            upgrade_items: [
              {
                UpgradeItem: {
                  stage_id: 1,
                  status: 'COMPLETED',
                  display_status: 'COMPLETED',
                  progress_percent: 100
                }
              }
            ]
          },
          {
            UpgradeGroup: {
              group_id: 2,
              status: 'ABORTED',
              display_status: 'ABORTED',
              progress_percent: 50,
              completed_task_count: 1
            },
            upgrade_items: [
              {
                UpgradeItem: {
                  stage_id: 2,
                  status: 'ABORTED',
                  display_status: 'ABORTED',
                  progress_percent: 99
                }
              },
              {
                UpgradeItem: {
                  stage_id: 3,
                  status: 'PENDING',
                  display_status: 'PENDING',
                  progress_percent: 0
                }
              }
            ]
          }
        ]
      };
      controller.set('upgradeData', oldData);
      controller.updateUpgradeData(newData);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('status')).to.equal('COMPLETED');
      expect(controller.get('upgradeData.upgradeGroups')[0].get('display_status')).to.equal('COMPLETED');
      expect(controller.get('upgradeData.upgradeGroups')[0].get('progress_percent')).to.equal(100);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('completed_task_count')).to.equal(3);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('status')).to.equal('COMPLETED');
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('display_status')).to.equal('COMPLETED');
      expect(controller.get('upgradeData.upgradeGroups')[0].get('upgradeItems')[0].get('progress_percent')).to.equal(100);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('hasExpandableItems')).to.be.true;
      expect(controller.get('upgradeData.upgradeGroups')[1].get('status')).to.equal('ABORTED');
      expect(controller.get('upgradeData.upgradeGroups')[1].get('display_status')).to.equal('ABORTED');
      expect(controller.get('upgradeData.upgradeGroups')[1].get('progress_percent')).to.equal(50);
      expect(controller.get('upgradeData.upgradeGroups')[1].get('completed_task_count')).to.equal(1);
      expect(controller.get('upgradeData.upgradeGroups')[1].get('upgradeItems')[0].get('status')).to.equal('ABORTED');
      expect(controller.get('upgradeData.upgradeGroups')[1].get('upgradeItems')[0].get('display_status')).to.equal('ABORTED');
      expect(controller.get('upgradeData.upgradeGroups')[1].get('upgradeItems')[1].get('status')).to.equal('PENDING');
      expect(controller.get('upgradeData.upgradeGroups')[1].get('upgradeItems')[1].get('display_status')).to.equal('PENDING');
      expect(controller.get('upgradeData.upgradeGroups')[1].get('upgradeItems')[0].get('progress_percent')).to.equal(99);
      expect(controller.get('upgradeData.upgradeGroups')[1].get('upgradeItems')[1].get('progress_percent')).to.equal(0);
      expect(controller.get('upgradeData.upgradeGroups')[1].get('hasExpandableItems')).to.be.false;
    });
  });

  describe("#initUpgradeData()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'setDBProperty');
    });
    afterEach(function () {
      controller.setDBProperty.restore();
    });
    it("", function() {
      var newData = {
        Upgrade: {
          request_id: 1,
          downgrade_allowed: false
        },
        upgrade_groups: [
          {
            UpgradeGroup: {
              group_id: 1
            },
            upgrade_items: [
              {
                UpgradeItem: {
                  stage_id: 1,
                  status: 'IN_PROGRESS'
                }
              },
              {
                UpgradeItem: {
                  stage_id: 2
                }
              }
            ]
          },
          {
            UpgradeGroup: {
              group_id: 2
            },
            upgrade_items: []
          },
          {
            UpgradeGroup: {
              group_id: 3
            },
            upgrade_items: [
              {
                UpgradeItem: {
                  stage_id: 3,
                  status: 'ABORTED'
                }
              },
              {
                UpgradeItem: {
                  stage_id: 4,
                  status: 'PENDING'
                }
              }
            ]
          }
        ]
      };
      controller.initUpgradeData(newData);
      expect(controller.setDBProperty.calledWith('downgradeAllowed', false)).to.be.true;
      expect(controller.get('downgradeAllowed')).to.be.false;
      expect(controller.get('upgradeData.Upgrade.request_id')).to.equal(1);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('group_id')).to.equal(3);
      expect(controller.get('upgradeData.upgradeGroups')[1].get('group_id')).to.equal(2);
      expect(controller.get('upgradeData.upgradeGroups')[2].get('group_id')).to.equal(1);
      expect(controller.get('upgradeData.upgradeGroups')[2].get('upgradeItems')[0].get('stage_id')).to.equal(2);
      expect(controller.get('upgradeData.upgradeGroups')[2].get('upgradeItems')[1].get('stage_id')).to.equal(1);
      expect(controller.get('upgradeData.upgradeGroups')[0].get('hasExpandableItems')).to.be.false;
      expect(controller.get('upgradeData.upgradeGroups')[1].get('hasExpandableItems')).to.be.false;
      expect(controller.get('upgradeData.upgradeGroups')[2].get('hasExpandableItems')).to.be.true;
    });
  });

  describe.skip("#finish()", function() {
    before(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    after(function () {
      App.clusterStatus.setClusterStatus.restore();
      controller.setDBProperty.restore();
    });
    it("upgradeState is not COMPLETED", function() {
      App.set('upgradeState', 'UPGRADING');
      controller.finish();
      expect(App.clusterStatus.setClusterStatus.called).to.be.false;
    });
    it("upgradeState is COMPLETED", function() {
      App.set('upgradeState', 'COMPLETED');
      controller.finish();
      expect(controller.setDBProperty.calledWith('upgradeId', undefined)).to.be.true;
      expect(controller.setDBProperty.calledWith('upgradeVersion', undefined)).to.be.true;
      expect(controller.setDBProperty.calledWith('upgradeState', 'INIT')).to.be.true;
      expect(controller.setDBProperty.calledWith('currentVersion', undefined)).to.be.true;
      expect(App.get('upgradeState')).to.equal('INIT');
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe("#confirmDowngrade()", function() {
    before(function () {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.stub(controller, 'downgrade', Em.K);
    });
    after(function () {
      App.showConfirmationPopup.restore();
      controller.downgrade.restore();
    });
    it("show confirmation popup", function() {
      controller.set('currentVersion', Em.Object.create({
        repository_version: '2.2',
        repository_name: 'HDP-2.2'
      }));
      var popup = controller.confirmDowngrade();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.downgrade.calledWith(Em.Object.create({
        repository_version: '2.2',
        repository_name: 'HDP-2.2'
      }))).to.be.true;
    });
  });

  describe("#upgradeOptions()", function() {
    before(function () {
      sinon.spy(App, 'ModalPopup');
      sinon.spy(App, 'showConfirmationFeedBackPopup');
      sinon.stub(controller, 'getSupportedUpgradeTypes').returns({
        done: function (callback) {
          callback([1]);
          return {
            always: function (alwaysCallback) {
              alwaysCallback();
              return {};
            }
          };
        }
      });
      sinon.stub(controller, 'runPreUpgradeCheck', Em.K);
      sinon.stub(App.RepositoryVersion, 'find').returns([
        Em.Object.create({
          status: 'CURRENT'
        })
      ]);
    });
    beforeEach(function () {
      controller.get('runningCheckRequests').clear();
    });
    after(function () {
      App.ModalPopup.restore();
      App.showConfirmationFeedBackPopup.restore();
      controller.runPreUpgradeCheck.restore();
      controller.getSupportedUpgradeTypes.restore();
      controller.get('upgradeMethods').setEach('selected', false);
      App.RepositoryVersion.find.restore();
    });
    it("show confirmation popup", function() {
      var version = Em.Object.create({displayName: 'HDP-2.2'});
      controller.set('isDowngrade', false);
      var popup = controller.upgradeOptions(false, version);
      expect(App.ModalPopup.calledOnce).to.be.true;
      expect(controller.get('upgradeMethods').everyProperty('isCheckRequestInProgress')).to.be.true;
      expect(controller.get('upgradeMethods').someProperty('selected')).to.be.false;
      controller.get('upgradeMethods')[0].set('selected', true);
      var confirmPopup = popup.onPrimary();
      expect(App.showConfirmationFeedBackPopup.calledOnce).to.be.true;
      confirmPopup.onPrimary();
      expect(controller.runPreUpgradeCheck.calledWith(version)).to.be.true;
      expect( controller.get('runningCheckRequests')).to.have.length(1);
    });
    it("NOT show confirmation popup on Downgrade", function() {
      var version = Em.Object.create({displayName: 'HDP-2.2'});
      controller.set('isDowngrade', true);
      controller.upgradeOptions(false, version);
      expect(App.ModalPopup.calledOnce).to.be.false;
      expect( controller.get('runningCheckRequests')).to.have.length(1);
    });
  });

  describe("#confirmUpgrade()", function() {
    before(function () {
      sinon.stub(controller, 'upgradeOptions', Em.K);
    });
    after(function () {
      controller.upgradeOptions.restore();
    });
    it("show show upgrade options popup window", function() {
      var version = Em.Object.create({displayName: 'HDP-2.2'});
      controller.confirmUpgrade(version);
      expect(controller.upgradeOptions.calledWith(false, version)).to.be.true;
    });
  });

  describe("#downgrade()", function() {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.stub(controller, 'abortUpgrade');
      sinon.stub(App.RepositoryVersion, 'find').returns([
        Em.Object.create({
          displayName: 'HDP-2.3',
          repositoryVersion: '2.3'
        })
      ]);
    });
    after(function () {
      App.ajax.send.restore();
      controller.abortUpgrade.restore();
      App.RepositoryVersion.find.restore();
    });
    it("make ajax call", function() {
      controller.set('upgradeVersion', 'HDP-2.3');
      controller.set('upgradeType', 'NON_ROLLING');
      controller.downgrade(Em.Object.create({
        repository_version: '2.2',
        repository_name: 'HDP-2.2'
      }), {context: 'context'});
      expect(controller.abortUpgrade.calledOnce).to.be.true;
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        from: '2.3',
        value: '2.2',
        label: 'HDP-2.2',
        isDowngrade: true,
        upgradeType: "NON_ROLLING"
      });
      expect(App.ajax.send.getCall(0).args[0].name).to.eql('admin.downgrade.start');
      expect(App.ajax.send.getCall(0).args[0].sender).to.eql(controller);
      expect(App.ajax.send.getCall(0).args[0].success).to.eql('upgradeSuccessCallback');
      expect(App.ajax.send.getCall(0).args[0].callback).to.be.called;
    });
  });

  describe("#installRepoVersionConfirmation()", function () {
    before(function () {
      sinon.stub(controller, 'installRepoVersion', Em.K);
    });
    after(function () {
      controller.installRepoVersion.restore();
    });
    it("show popup", function () {
      var repo = Em.Object.create({'displayName': 'HDP-2.2'});
      var popup = controller.installRepoVersionConfirmation(repo);
      popup.onPrimary();
      expect(controller.installRepoVersion.calledWith(repo)).to.be.true;
    });
  });

  describe("#installRepoVersion()", function () {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it("make ajax call", function () {
      var repo = Em.Object.create({
        stackVersionType: 'HDP',
        stackVersionNumber: '2.2',
        repositoryVersion: '2.2.1',
        repoId: 1
      });
      controller.installRepoVersion(repo);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe("#installRepoVersionSuccess()", function() {
    var mock = Em.Object.create({
      id: 1,
      defaultStatus: 'INIT',
      stackVersion: {}
    });
    before(function () {
      sinon.spy(mock, 'set');
      sinon.stub(App.db, 'set', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(App.RepositoryVersion, 'find').returns(mock);
    });
    after(function () {
      App.db.set.restore();
      App.clusterStatus.setClusterStatus.restore();
      App.RepositoryVersion.find.restore();
    });
    it("", function() {
      controller.installRepoVersionSuccess({Requests: {id: 1}}, {}, {id: 1});
      expect(App.db.set.calledWith('repoVersionInstall', 'id', [1])).to.be.true;
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
      expect(App.RepositoryVersion.find.calledWith(1)).to.be.true;
      expect(App.RepositoryVersion.find(1).get('defaultStatus')).to.equal('INSTALLING');
      expect(App.RepositoryVersion.find(1).get('stackVersion.state')).to.equal('INSTALLING');
    });
  });

  describe("#setUpgradeItemStatus()", function () {
    before(function () {
      sinon.stub(App.ajax, 'send', function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      });
    });
    after(function () {
      App.ajax.send.restore();
    });
    it("", function () {
      var item = Em.Object.create({
        request_id: 1,
        stage_id: 1,
        group_id: 1
      });
      controller.setUpgradeItemStatus(item, 'PENDING');
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({upgradeId: 1, itemId: 1, groupId: 1, status: 'PENDING'});
      expect(App.ajax.send.getCall(0).args[0].name).to.eql('admin.upgrade.upgradeItem.setState');
      expect(App.ajax.send.getCall(0).args[0].sender).to.eql(controller);
      expect(App.ajax.send.getCall(0).args[0].callback).to.be.called;
      expect(item.get('status')).to.equal('PENDING');
    });
  });

  describe("#prepareRepoForSaving()", function () {
    it("prepare date for saving", function () {
      var repo = Em.Object.create({
        operatingSystems: [
          Em.Object.create({
            osType: "redhat6",
            isDisabled: Ember.computed.not('isSelected'),
            repositories: [Em.Object.create({
                "baseUrl": "111121",
                "repoId": "HDP-2.2",
                "repoName": "HDP",
                hasError: false
            }),
              Em.Object.create({
                "baseUrl": "1",
                "repoId": "HDP-UTILS-1.1.0.20",
                "repoName": "HDP-UTILS",
                hasError: false
              })]
           })
        ]
      });
      var result = {
        "operating_systems": [
          {
            "OperatingSystems": {
              "os_type": "redhat6"
            },
            "repositories": [
              {
                "Repositories": {
                  "base_url": "111121",
                  "repo_id": "HDP-2.2",
                  "repo_name": "HDP"
                }
              },
              {
                "Repositories": {
                  "base_url": "1",
                  "repo_id": "HDP-UTILS-1.1.0.20",
                  "repo_name": "HDP-UTILS"
                }
              }
            ]
          }
        ]};
      expect(controller.prepareRepoForSaving(repo)).to.eql(result);
    });
  });

  describe("#getStackVersionNumber()", function(){
    it("get stack version number", function(){
      var repo = Em.Object.create({
        "stackVersionType": 'HDP',
        "stackVersion": '2.3',
        "repositoryVersion": '2.2.1'
      });
      
      var stackVersion = controller.getStackVersionNumber(repo);
      expect(stackVersion).to.equal('2.3');
    });
    
    it("get default stack version number", function(){
      App.set('currentStackVersion', '1.2.3');
      var repo = Em.Object.create({
        "stackVersionType": 'HDP',
        "repositoryVersion": '2.2.1'
      });
      
      var stackVersion = controller.getStackVersionNumber(repo);
      expect(stackVersion).to.equal('1.2.3');
    });
  });
  
  describe("#saveRepoOS()", function() {
    before(function(){
      this.mock = sinon.stub(controller, 'validateRepoVersions');
      sinon.stub(controller, 'prepareRepoForSaving', Em.K);
      sinon.stub(App.ajax, 'send').returns({success: Em.K});
    });
    after(function(){
      this.mock.restore();
      controller.prepareRepoForSaving.restore();
      App.ajax.send.restore();
    });
    it("validation errors present", function() {
      this.mock.returns({
        done: function(callback) {callback([1]);}
      });
      controller.saveRepoOS(Em.Object.create({repoVersionId: 1}), true);
      expect(controller.validateRepoVersions.calledWith(Em.Object.create({repoVersionId: 1}), true)).to.be.true;
      expect(controller.prepareRepoForSaving.called).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it("no validation errors", function() {
      this.mock.returns({
        done: function(callback) {callback([]);}
      });
      controller.saveRepoOS(Em.Object.create({repoVersionId: 1}), true);
      expect(controller.validateRepoVersions.calledWith(Em.Object.create({repoVersionId: 1}), true)).to.be.true;
      expect(controller.prepareRepoForSaving.calledWith(Em.Object.create({repoVersionId: 1}))).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe("#validateRepoVersions()", function () {
    before(function () {
      sinon.stub(App.ajax, 'send').returns({success: Em.K, error: Em.K});
    });
    after(function () {
      App.ajax.send.restore();
    });
    it("skip validation", function () {
      controller.validateRepoVersions(Em.Object.create({repoVersionId: 1}), true);
      expect(App.ajax.send.called).to.be.false;
    });
    it("do validation", function () {
      var repo = Em.Object.create({
        repoVersionId: 1,
        operatingSystems: [
          Em.Object.create({
            isSelected: true,
            repositories: [
              Em.Object.create()
            ]
          })
        ]
      });
      controller.validateRepoVersions(repo, false);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe("#showProgressPopup()", function () {
    var mock = {
      initPopup: Em.K
    };
    before(function () {
      sinon.stub(App.router, 'get').withArgs('highAvailabilityProgressPopupController').returns(mock);
      sinon.spy(mock, 'initPopup');
    });
    after(function () {
      App.router.get.restore();
      mock.initPopup.restore();
    });
    it("", function () {
      controller.showProgressPopup(Em.Object.create());
      expect(mock.initPopup.calledOnce).to.be.true;
    });
  });

  describe("#getUrl()", function() {
    beforeEach(function(){
      controller.reopen({
        realStackUrl: 'realStackUrl',
        realRepoUrl: 'realRepoUrl',
        realUpdateUrl: 'realUpdateUrl'
      });
    });
    it("full load is true, stack is null", function() {
      expect(controller.getUrl(null, true)).to.equal('realRepoUrl');
    });
    it("full load is true, stack is valid", function() {
      expect(controller.getUrl({}, true)).to.equal('realStackUrl');
    });
    it("full load is false, stack is valid", function() {
      expect(controller.getUrl({}, false)).to.equal('realUpdateUrl');
    });
  });

  describe("#loadStackVersionsToModel()", function () {
    before(function () {
      sinon.stub(App.HttpClient, 'get');
    });
    after(function () {
      App.HttpClient.get.restore();
    });
    it("", function () {
      controller.loadStackVersionsToModel();
      expect(App.HttpClient.get.calledOnce).to.be.true;
    });
  });

  describe("#loadRepoVersionsToModel()", function () {
    before(function () {
      sinon.stub(App.HttpClient, 'get');
    });
    after(function () {
      App.HttpClient.get.restore();
    });
    it("", function () {
      controller.loadRepoVersionsToModel();
      expect(App.HttpClient.get.calledOnce).to.be.true;
    });
  });

  describe('#currentVersionObserver()', function () {

    var cases = [
      {
        stackVersionType: 'HDP',
        repoVersion: '2.2.1.1.0-1',
        isStormMetricsSupported: false,
        title: 'HDP < 2.2.2'
      },
      {
        stackVersionType: 'HDP',
        repoVersion: '2.2.2.1.0-1',
        isStormMetricsSupported: true,
        title: 'HDP 2.2.2'
      },
      {
        stackVersionType: 'HDP',
        repoVersion: '2.2.3.1.0-1',
        isStormMetricsSupported: true,
        title: 'HDP > 2.2.2'
      },
      {
        stackVersionType: 'BIGTOP',
        repoVersion: '0.8.1.1.0-1',
        isStormMetricsSupported: true,
        title: 'not HDP'
      }
    ];

    afterEach(function () {
      App.RepositoryVersion.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App.RepositoryVersion, 'find').returns([
          Em.Object.create({
            status: 'CURRENT',
            stackVersionType: item.stackVersionType
          })
        ]);
        controller.set('currentVersion', {
          repository_version: item.repoVersion
        });
        expect(App.get('isStormMetricsSupported')).to.equal(item.isStormMetricsSupported);
      });
    });

  });

  describe('#updateFinalize', function () {

    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      controller.set('isFinalizeItem', true);
    });

    afterEach(function () {
      $.ajax.restore();
    });

    it('should do ajax-request', function () {
      sinon.stub(App, 'get').withArgs('upgradeState').returns('HOLDING');
      controller.updateFinalize();
      App.get.restore();
      expect($.ajax.calledOnce).to.be.true;
    });

    it('shouldn\'t do ajax-request', function () {
      sinon.stub(App, 'get').withArgs('upgradeState').returns('HOLDING_TIMEDOUT');
      controller.updateFinalize();
      App.get.restore();
      expect(controller.get('isFinalizeItem')).to.be.false;
      expect($.ajax.calledOnce).to.be.false;
    });

  });

  describe('#updateFinalizeSuccessCallback', function () {

    it('data exists and Finalize should be true', function() {
      var data = {
        items: [
          {
            upgrade_groups: [
              {
                upgrade_items: [
                  {
                    UpgradeItem: {
                      context: controller.get('finalizeContext'),
                      status: "HOLDING"
                    }
                  }
                ]
              }
            ]
          }
        ]
      };
      controller.set('isFinalizeItem', false);
      controller.updateFinalizeSuccessCallback(data);
      expect(controller.get('isFinalizeItem')).to.be.true;
    });

    it('data exists and Finalize should be false', function() {
      var data = {
        upgrade_groups: [
          {
            upgrade_items: [
              {
                UpgradeItem: {
                  context: '!@#$%^&',
                  status: "HOLDING"
                }
              }
            ]
          }
        ]
      };
      controller.set('isFinalizeItem', true);
      controller.updateFinalizeSuccessCallback(data);
      expect(controller.get('isFinalizeItem')).to.be.false;
    });

    it('data doesn\'t exist', function() {
      var data = null;
      controller.set('isFinalizeItem', true);
      controller.updateFinalizeSuccessCallback(data);
      expect(controller.get('isFinalizeItem')).to.be.false;
    });

  });

  describe('#updateFinalizeErrorCallback', function () {

    it('should set isFinalizeItem to false', function () {
      controller.set('isFinalizeItem', true);
      controller.updateFinalizeErrorCallback();
      expect(controller.get('isFinalizeItem')).to.be.false;
    });

  });

  describe("#suspendUpgrade()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'abortUpgradeWithSuspend').returns({
        done: function (callback) {
          callback();
        }
      });
      sinon.stub(controller, 'setDBProperty', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
    });
    afterEach(function () {
      controller.abortUpgradeWithSuspend.restore();
      controller.setDBProperty.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it("", function() {
      controller.suspendUpgrade();
      expect(controller.abortUpgradeWithSuspend.calledOnce).to.be.true;
      expect(App.get('upgradeState')).to.equal('ABORTED');
      expect(controller.setDBProperty.calledWith('upgradeState', 'ABORTED')).to.be.true;
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe("#resumeUpgrade()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'retryUpgrade').returns({
        done: function (callback) {
          callback();
        }
      });
      sinon.stub(controller, 'setDBProperty', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
    });
    afterEach(function () {
      controller.retryUpgrade.restore();
      controller.setDBProperty.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it("", function() {
      controller.resumeUpgrade();
      expect(controller.retryUpgrade.calledOnce).to.be.true;
      expect(App.get('upgradeState')).to.equal('PENDING');
      expect(controller.setDBProperty.calledWith('upgradeState', 'PENDING')).to.be.true;
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe("#runUpgradeMethodChecks()", function() {
    beforeEach(function () {
      sinon.stub(controller, 'runPreUpgradeCheckOnly');
    });
    afterEach(function () {
      controller.runPreUpgradeCheckOnly.restore();
      controller.get('upgradeMethods').setEach('allowed', true);
    });
    it("no allowed upgrade methods", function () {
      controller.get('upgradeMethods').setEach('allowed', false);
      controller.runUpgradeMethodChecks();
      expect(controller.runPreUpgradeCheckOnly.called).to.be.false;
    });
    it("Rolling method allowed", function () {
      controller.get('upgradeMethods').setEach('allowed', true);
      controller.runUpgradeMethodChecks(Em.Object.create({
        repositoryVersion: 'v1',
        displayName: 'V1'
      }));
      expect(controller.runPreUpgradeCheckOnly.calledWith({
        value: 'v1',
        label: 'V1',
        type: 'ROLLING'
      })).to.be.true;
    });
  });

  describe("#restoreLastUpgrade()", function () {
    beforeEach(function () {
      sinon.stub(App.RepositoryVersion, 'find').returns([Em.Object.create({
        repositoryVersion: '1',
        displayName: 'HDP-1'
      })]);
      sinon.stub(controller, 'setDBProperties');
      sinon.stub(controller, 'loadRepoVersionsToModel', function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      });
      sinon.stub(controller, 'setDBProperty');
      sinon.stub(controller, 'initDBProperties');
      sinon.stub(controller, 'loadUpgradeData');
    });
    afterEach(function () {
      App.RepositoryVersion.find.restore();
      controller.setDBProperties.restore();
      controller.loadRepoVersionsToModel.restore();
      controller.setDBProperty.restore();
      controller.initDBProperties.restore();
      controller.loadUpgradeData.restore();
    });
    it("", function () {
      var data = {
        Upgrade: {
          request_id: 1,
          direction: 'UPGRADE',
          request_status: 'PENDING',
          upgrade_type: 'ROLLING',
          downgrade_allowed: true,
          skip_failures: true,
          skip_service_check_failures: true,
          to_version: '1'
        }
      };
      controller.restoreLastUpgrade(data);
      expect(controller.setDBProperties.getCall(0).args[0]).to.eql({
        upgradeId: 1,
        isDowngrade: false,
        upgradeState: 'PENDING',
        upgradeType: "ROLLING",
        downgradeAllowed: true,
        upgradeTypeDisplayName: Em.I18n.t('admin.stackVersions.version.upgrade.upgradeOptions.RU.title'),
        failuresTolerance: Em.Object.create({
          skipComponentFailures: true,
          skipSCFailures: true
        })
      });
      expect(controller.loadRepoVersionsToModel.calledOnce).to.be.true;
      expect(controller.setDBProperty.calledWith('upgradeVersion', 'HDP-1')).to.be.true;
      expect(controller.initDBProperties.calledOnce).to.be.true;
      expect(controller.loadUpgradeData.calledWith(true)).to.be.true;
    });
  });

  describe("#getServiceCheckItemSuccessCallback()", function() {
    var testCases = [
      {
        title: 'no tasks',
        data: {
          tasks: []
        },
        expected: {
          slaveComponentStructuredInfo: null,
          serviceCheckFailuresServicenames: []
        }
      },
      {
        title: 'no structured_out property',
        data: {
          tasks: [
            {
              Tasks: {}
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: null,
          serviceCheckFailuresServicenames: []
        }
      },
      {
        title: 'no failures',
        data: {
          tasks: [
            {
              Tasks: {
                structured_out: {}
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: null,
          serviceCheckFailuresServicenames: []
        }
      },
      {
        title: 'service check failures',
        data: {
          tasks: [
            {
              Tasks: {
                structured_out: {
                  failures: {
                    service_check: ['HDSF', 'YARN']
                  }
                }
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: {
            hosts: [],
            host_detail: {}
          },
          serviceCheckFailuresServicenames: ['HDSF', 'YARN']
        }
      },
      {
        title: 'host-component failures',
        data: {
          tasks: [
            {
              Tasks: {
                structured_out: {
                  failures: {
                    service_check: ['HDSF'],
                    host_component: {
                      "host1": [
                        {
                          component: "DATANODE",
                          service: 'HDFS'
                        }
                      ]
                    }
                  }
                }
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: {
            hosts: ['host1'],
            host_detail: {
              "host1": [
                {
                  component: "DATANODE",
                  service: 'HDFS'
                }
              ]
            }
          },
          serviceCheckFailuresServicenames: ['HDSF']
        }
      }
    ];

    testCases.forEach(function(test) {
      it(test.title, function() {
        controller.set('slaveComponentStructuredInfo', null);
        controller.set('serviceCheckFailuresServicenames', []);
        controller.getServiceCheckItemSuccessCallback(test.data);
        expect(controller.get('serviceCheckFailuresServicenames')).eql(test.expected.serviceCheckFailuresServicenames);
        expect(controller.get('slaveComponentStructuredInfo')).eql(test.expected.slaveComponentStructuredInfo);
      });
    });
  });

  describe("#getSlaveComponentItemSuccessCallback()", function () {
    var testCases = [
      {
        title: 'no tasks',
        data: {
          tasks: []
        },
        expected: {
          slaveComponentStructuredInfo: null
        }
      },
      {
        title: 'structured_out property absent',
        data: {
          tasks: [
            {
              Tasks: {}
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: null
        }
      },
      {
        title: 'structured_out property present',
        data: {
          tasks: [
            {
              Tasks: {
                "structured_out" : {
                  "hosts" : [
                    "host1"
                  ],
                  "host_detail" : {
                    "host1" : [
                      {
                        "service" : "FLUME",
                        "component" : "FLUME_HANDLER"
                      }
                    ]
                  }
                }
              }
            }
          ]
        },
        expected: {
          slaveComponentStructuredInfo: {
            "hosts" : [
              "host1"
            ],
            "host_detail" : {
              "host1" : [
                {
                  "service" : "FLUME",
                  "component" : "FLUME_HANDLER"
                }
              ]
            }
          }
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('slaveComponentStructuredInfo', null);
        controller.getSlaveComponentItemSuccessCallback(test.data);
        expect(controller.get('slaveComponentStructuredInfo')).eql(test.expected.slaveComponentStructuredInfo);
      });
    });
  });

  describe('#getConfigsWarnings', function () {

    var cases = [
      {
        configs: [],
        title: 'no warning'
      },
      {
        configsMergeWarning: {},
        configs: [],
        title: 'empty data'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {}
        },
        configs: [],
        title: 'incomplete data'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            failed_detail: {}
          }
        },
        configs: [],
        title: 'invalid data'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            failed_detail: []
          }
        },
        configs: [],
        title: 'empty configs array'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            status: 'FAIL',
            failed_detail: [
              {
                type: 't0',
                property: 'p0',
                current: 'c0',
                new_stack_value: 'n0',
                result_value: 'r0'
              },
              {
                type: 't1',
                property: 'p1',
                current: 'c1',
                new_stack_value: 'n1'
              },
              {
                type: 't2',
                property: 'p2',
                current: 'c2',
                result_value: 'r2'
              }
            ]
          }
        },
        configs: [],
        title: 'not a warning'
      },
      {
        configsMergeWarning: {
          UpgradeChecks: {
            status: 'WARNING',
            failed_detail: [
              {
                type: 't0',
                property: 'p0',
                current: 'c0',
                new_stack_value: 'n0',
                result_value: 'r0'
              },
              {
                type: 't1',
                property: 'p1',
                current: 'c1',
                new_stack_value: 'n1'
              },
              {
                type: 't2',
                property: 'p2',
                current: 'c2',
                result_value: 'r2'
              }
            ]
          }
        },
        configs: [
          {
            type: 't0',
            name: 'p0',
            currentValue: 'c0',
            recommendedValue: 'n0',
            isDeprecated: false,
            resultingValue: 'r0',
            willBeRemoved: false
          },
          {
            type: 't1',
            name: 'p1',
            currentValue: 'c1',
            recommendedValue: 'n1',
            isDeprecated: false,
            resultingValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.willBeRemoved'),
            willBeRemoved: true
          },
          {
            type: 't2',
            name: 'p2',
            currentValue: 'c2',
            recommendedValue: Em.I18n.t('popup.clusterCheck.Upgrade.configsMerge.deprecated'),
            isDeprecated: true,
            resultingValue: 'r2',
            willBeRemoved: false
          }
        ],
        title: 'normal case'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(controller.getConfigsWarnings(item.configsMergeWarning)).to.eql(item.configs);
      });
    });

  });

  describe('#runPreUpgradeCheckOnly', function () {

    var appGetMock,
      upgradeMethods = controller.get('upgradeMethods'),
      cases = [
      {
        supportsPreUpgradeCheck: false,
        ru: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        eu: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        ajaxCallCount: 0,
        runningCheckRequestsLength: 0,
        title: 'pre-upgrade checks not supported'
      },
      {
        supportsPreUpgradeCheck: true,
        ru: {
          isCheckComplete: false,
          isCheckRequestInProgress: true,
          action: ''
        },
        eu: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        ajaxCallCount: 1,
        type: 'ROLLING',
        runningCheckRequestsLength: 1,
        title: 'rolling upgrade'
      },
      {
        supportsPreUpgradeCheck: true,
        ru: {
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        },
        eu: {
          isCheckComplete: false,
          isCheckRequestInProgress: true,
          action: ''
        },
        ajaxCallCount: 1,
        type: 'NON_ROLLING',
        runningCheckRequestsLength: 1,
        title: 'express upgrade'
      }
    ];

    beforeEach(function () {
      appGetMock = sinon.stub(App, 'get');
      controller.get('runningCheckRequests').clear();
      upgradeMethods.forEach(function (method) {
        method.setProperties({
          isCheckComplete: true,
          isCheckRequestInProgress: false,
          action: 'a'
        });
      });
      sinon.stub(App.ajax, 'send').returns({});
    });

    afterEach(function () {
      appGetMock.restore();
      App.ajax.send.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        var runningCheckRequests = controller.get('runningCheckRequests');
        appGetMock.returns(item.supportsPreUpgradeCheck);
        controller.runPreUpgradeCheckOnly({
          type: item.type
        });
        expect(upgradeMethods.findProperty('type', 'ROLLING').getProperties('isCheckComplete', 'isCheckRequestInProgress', 'action')).to.eql(item.ru);
        expect(upgradeMethods.findProperty('type', 'NON_ROLLING').getProperties('isCheckComplete', 'isCheckRequestInProgress', 'action')).to.eql(item.eu);
        expect(App.ajax.send.callCount).to.equal(item.ajaxCallCount);
        expect(runningCheckRequests).to.have.length(item.runningCheckRequestsLength);
        if (item.runningCheckRequestsLength) {
          expect(runningCheckRequests[0].type).to.equal(item.type);
        }
      });
    });

  });

});

});

;require.register("test/controllers/main/admin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('models/service');
require('models/host_component');
require('controllers/main/admin');

describe('MainAdminController', function () {

  var controller = App.MainAdminController.create();

  describe('#isAccessAvailable()', function () {

    beforeEach(function () {
      Em.propertyDidChange(controller, 'isAccessAvailable');
    });

    it('Services do not match dependencies', function () {
      App.Service.find().clear();
      App.store.load(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('APP_TIMELINE_SERVER is absent', function () {
      App.Service.find().clear();
      App.HostComponent.find().clear();
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('Only one YARN service installed', function () {
      App.store.load(App.Service, {
        id: 'YARN',
        service_name: 'YARN'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services installed', function () {
      App.store.load(App.Service, {
        id: 'TEZ',
        service_name: 'TEZ'
      });
      expect(controller.get("isAccessAvailable")).to.be.false;
    });
    it('TEZ and YARN services, APP_TIMELINE_SERVER component installed', function () {
      App.store.load(App.HostComponent, {
        id: 'APP_TIMELINE_SERVER_host1',
        component_name: 'APP_TIMELINE_SERVER'
      });
      expect(controller.get("isAccessAvailable")).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/alert_definitions_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/alert_definitions_controller');
require('models/alerts/alert_definition');

var controller;
describe('App.MainAlertDefinitionsController', function() {

  beforeEach(function() {

    controller = App.MainAlertDefinitionsController.create();

  });

  describe('#toggleDefinitionState', function() {

    beforeEach(function() {
      sinon.stub(App.ajax, 'send', Em.K);
      controller.reopen({
        content: [
          App.AlertDefinition.createRecord({id: 1, enabled: true})
        ]
      });
    });

    afterEach(function() {
      App.ajax.send.restore();
    });

    it('should do ajax-request', function() {
      var alertDefinition = controller.get('content')[0];
      controller.toggleDefinitionState(alertDefinition);
      expect(App.ajax.send.calledOnce).to.be.true;
    });

  });

  describe('#isCriticalAlerts', function () {

    beforeEach(function () {
      controller.set('content', Em.A([
        Em.Object.create({summary: {CRITICAL: {count: 0}}}),
        Em.Object.create({summary: {CRITICAL: {}}})
      ]));
    });

    it('if summary is undefined, 0 should be used', function () {
      expect(controller.get('isCriticalAlerts')).to.be.false;
    });

    it('should be true, if some CRITICAL count is greater than 0', function () {
      controller.get('content').pushObject(Em.Object.create({summary: {CRITICAL: {count: 1}}}));
      expect(controller.get('isCriticalAlerts')).to.be.true;
    });

  });

});

});

;require.register("test/controllers/main/alerts/add_alert_definition/step1_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/alerts/add_alert_definition/step1_controller');

var controller;

describe('App.AddAlertDefinitionStep1Controller', function () {

  beforeEach(function () {
    controller = App.AddAlertDefinitionStep1Controller.create({content: {}});
  });

  describe('#selectType', function() {

    beforeEach(function () {
      controller.get('alertDefinitionsTypes').setEach('isActive', false);
    });

    it('should set isActive for selected type', function () {
      var e = {context: {value: 'PORT'}};
      controller.selectType(e);
      expect(controller.get('alertDefinitionsTypes').findProperty('value', 'PORT').get('isActive')).to.be.true;
    });

  });

  describe('#loadStep', function () {

    beforeEach(function () {
      controller.set('content.selectedType', 'PORT');

    });

    it('should set predefined type', function () {
      controller.loadStep();
      expect(controller.get('alertDefinitionsTypes').findProperty('value', 'PORT').get('isActive')).to.be.true;
    });

  });

  describe('#isSubmitDisabled', function () {

    beforeEach(function () {
      controller.get('alertDefinitionsTypes').setEach('isActive', false);
    });

    it('should be based on isActive', function () {

      expect(controller.get('isSubmitDisabled')).to.be.true;
      controller.get('alertDefinitionsTypes').objectAt(0).set('isActive', true);
      expect(controller.get('isSubmitDisabled')).to.be.false;

    });

  });

});
});

;require.register("test/controllers/main/alerts/alert_definitions_actions_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var controller;

describe('App.MainAlertDefinitionActionsController', function () {

  beforeEach(function () {
    controller = App.MainAlertDefinitionActionsController.create({});
  });

  describe('#actionHandler', function () {

    beforeEach(function () {
      sinon.stub(controller, 'createNewAlertDefinition', Em.K);
      sinon.stub(controller, 'manageAlertGroups', Em.K);
      sinon.stub(controller, 'manageNotifications', Em.K);
    });

    afterEach(function () {
      controller.createNewAlertDefinition.restore();
      controller.manageAlertGroups.restore();
      controller.manageNotifications.restore();
    });

    it('should call proper methods', function () {

      controller.actionHandler({context: {action: 'createNewAlertDefinition'}});
      controller.actionHandler({context: {action: 'manageAlertGroups'}});
      controller.actionHandler({context: {action: 'manageNotifications'}});
      expect(controller.createNewAlertDefinition.calledOnce).to.be.ok;
      expect(controller.manageAlertGroups.calledOnce).to.be.ok;
      expect(controller.manageNotifications.calledOnce).to.be.ok;

    });

  });

  describe('#manageAlertGroups', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show modal popup', function () {
      controller.manageAlertGroups();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

  });

  describe('#createNewAlertDefinition', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    afterEach(function () {
      App.router.transitionTo.restore();
    });

    it('should navigate to wizard', function () {

      controller.createNewAlertDefinition();
      expect(App.router.transitionTo.calledWith('alertAdd')).to.be.true;

    });

  });

});
});

;require.register("test/controllers/main/alerts/alert_instances_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var controller;

describe('App.MainAlertInstancesController', function () {

  beforeEach(function () {
    controller = App.MainAlertInstancesController.create({});
  });

  describe('#fetchAlertInstances', function () {

    describe('loading instances from correct endpoint', function () {

      beforeEach(function () {
        sinon.stub(App.ajax, 'send', Em.K);
      });

      afterEach(function () {
        App.ajax.send.restore();
      });

      it('should load by Host name', function () {

        controller.loadAlertInstancesByHost('host');
        console.log(App.ajax.send.args[0]);
        expect(App.ajax.send.args[0][0].name).to.equal('alerts.instances.by_host');
        expect(App.ajax.send.args[0][0].data.hostName).to.equal('host');

      });

      it('should load by AlertDefinition id', function () {

        controller.loadAlertInstancesByAlertDefinition('1');
        console.log(App.ajax.send.args[0]);
        expect(App.ajax.send.args[0][0].name).to.equal('alerts.instances.by_definition');
        expect(App.ajax.send.args[0][0].data.definitionId).to.equal('1');

      });

      it('should load all', function () {

        controller.loadAlertInstances();
        console.log(App.ajax.send.args[0]);
        expect(App.ajax.send.args[0][0].name).to.equal('alerts.instances');

      });

    });

  });


  describe('#showPopup', function () {

    describe('#bodyClass', function () {

      var bodyView;

      beforeEach(function () {
        controller.reopen({unhealthyAlertInstances: [
          App.AlertInstance.createRecord({state: 'CRITICAL'}),
          App.AlertInstance.createRecord({state: 'WARNING'}),
          App.AlertInstance.createRecord({state: 'WARNING'}),
          App.AlertInstance.createRecord({state: 'CRITICAL'})
        ]});
        bodyView = controller.showPopup().get('bodyClass').create();
      });

      it('#content', function () {
        expect(bodyView.get('content.length')).to.equal(4);
      });

      it('#isLoaded', function () {
        expect(bodyView.get('isLoaded')).to.be.true;
      });

      it('#isAlertEmptyList', function () {
        expect(bodyView.get('isAlertEmptyList')).to.be.false;
      });

    });

  });

});
});

;require.register("test/controllers/main/alerts/definitions_configs_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var controller;

describe('App.MainAlertDefinitionConfigsController', function () {

  beforeEach(function () {
    controller = App.MainAlertDefinitionConfigsController.create({
      allServices: ['service1', 'service2', 'service3'],
      allComponents: ['component1', 'component2', 'component3'],
      aggregateAlertNames: ['alertDefinitionName', 'alertDefinitionName2', 'alertDefinitionName3']
    });
  });

  describe('#renderConfigs()', function () {

    beforeEach(function () {
      controller.set('content', Em.Object.create({}));
      sinon.stub(controller, 'renderPortConfigs', function () {
        return [];
      });
      sinon.stub(controller, 'renderMetricConfigs', function () {
        return [];
      });
      sinon.stub(controller, 'renderWebConfigs', function () {
        return [];
      });
      sinon.stub(controller, 'renderScriptConfigs', function () {
        return [];
      });
      sinon.stub(controller, 'renderAggregateConfigs', function () {
        return [];
      });
    });

    afterEach(function () {
      controller.renderPortConfigs.restore();
      controller.renderMetricConfigs.restore();
      controller.renderWebConfigs.restore();
      controller.renderScriptConfigs.restore();
      controller.renderAggregateConfigs.restore();
    });

    it('should call renderPortConfigs method', function () {
      controller.set('alertDefinitionType', 'PORT');
      controller.renderConfigs();
      expect(controller.renderPortConfigs.calledOnce).to.be.true;
    });

    it('should call renderMetricConfigs method', function () {
      controller.set('alertDefinitionType', 'METRIC');
      controller.renderConfigs();
      expect(controller.renderMetricConfigs.calledOnce).to.be.true;
    });

    it('should call renderWebConfigs method', function () {
      controller.set('alertDefinitionType', 'WEB');
      controller.renderConfigs();
      expect(controller.renderWebConfigs.calledOnce).to.be.true;
    });

    it('should call renderScriptConfigs method', function () {
      controller.set('alertDefinitionType', 'SCRIPT');
      controller.renderConfigs();
      expect(controller.renderScriptConfigs.calledOnce).to.be.true;
    });

    it('should call renderAggregateConfigs method', function () {
      controller.set('alertDefinitionType', 'AGGREGATE');
      controller.renderConfigs();
      expect(controller.renderAggregateConfigs.calledOnce).to.be.true;
    });

  });

  describe('#renderPortConfigs()', function () {

    it('should render array of configs with correct values', function () {

      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        uri: 'alertDefinitionUri',
        defaultPort: '777'
      }));

      controller.set('isWizard', true);
      var result = controller.renderPortConfigs();

      expect(result.length).to.equal(11);

      controller.set('isWizard', false);
      result = controller.renderPortConfigs();

      expect(result.length).to.equal(5);
    });

  });

  describe('#renderMetricConfigs()', function () {

    it('should render array of configs with correct values', function () {

      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        uri: {
          "http": "{{mapred-site/mapreduce.jobhistory.webapp.address}}",
          "https": "{{mapred-site/mapreduce.jobhistory.webapp.https.address}}",
          "https_property": "{{mapred-site/mapreduce.jobhistory.http.policy}}",
          "https_property_value": "HTTPS_ONLY",
          "default_port": 0.0
        },
        jmx: {
          propertyList: ['property1', 'property2'],
          value: 'jmxValue'
        },
        ganglia: {
          propertyList: null,
          value: null
        }
      }));

      controller.set('isWizard', true);
      var result = controller.renderMetricConfigs();

      expect(result.length).to.equal(11);

      controller.set('isWizard', false);
      result = controller.renderMetricConfigs();

      expect(result.length).to.equal(5);
    });

  });

  describe('#renderWebConfigs()', function () {

    it('should render array of configs with correct values', function () {

      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        uri: {
          "http": "{{mapred-site/mapreduce.jobhistory.webapp.address}}",
          "https": "{{mapred-site/mapreduce.jobhistory.webapp.https.address}}",
          "https_property": "{{mapred-site/mapreduce.jobhistory.http.policy}}",
          "https_property_value": "HTTPS_ONLY",
          "default_port": 0.0
        }
      }));

      controller.set('isWizard', true);
      var result = controller.renderWebConfigs();

      expect(result.length).to.equal(12);

      controller.set('isWizard', false);
      result = controller.renderWebConfigs();

      expect(result.length).to.equal(6);
    });

  });

  describe('#renderScriptConfigs()', function () {

    it('should render array of configs with correct values', function () {

      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        service: {displayName: 'alertDefinitionService'},
        componentName: 'component1',
        scope: 'HOST',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ],
        location: 'path to script'
      }));

      controller.set('isWizard', true);
      var result = controller.renderScriptConfigs();

      expect(result.length).to.equal(8);

      controller.set('isWizard', false);
      result = controller.renderScriptConfigs();

      expect(result.length).to.equal(2);
    });

  });

  describe('#renderAggregateConfigs()', function () {

    it('should render array of configs with correct values', function () {

      controller.set('content', Em.Object.create({
        name: 'alertDefinitionName',
        description: 'alertDefinitionDescription',
        interval: 60,
        reporting: [
          Em.Object.create({
            type: 'warning',
            value: 10
          }),
          Em.Object.create({
            type: 'critical',
            value: 20
          }),
          Em.Object.create({
            type: 'ok',
            value: 30
          })
        ]
      }));

      var result = controller.renderAggregateConfigs();

      expect(result.length).to.equal(5);
    });

  });

  describe('#editConfigs()', function () {

    it('should set previousValue, isDisabled for each config and change canEdit flag', function () {

      controller.set('configs', [
        Em.Object.create({value: 'value1', previousValue: '', isDisabled: true}),
        Em.Object.create({value: 'value2', previousValue: '', isDisabled: true}),
        Em.Object.create({value: 'value3', previousValue: '', isDisabled: true})
      ]);

      controller.set('canEdit', false);

      controller.editConfigs();

      expect(controller.get('configs').mapProperty('previousValue')).to.eql(['value1', 'value2', 'value3']);
      expect(controller.get('configs').someProperty('isDisabled', true)).to.be.false;
      expect(controller.get('canEdit')).to.be.true;
    });

  });

  describe('#cancelEditConfigs()', function () {

    it('should set previousValue, isDisabled for each config and change canEdit flag', function () {

      controller.set('configs', [
        Em.Object.create({value: '', previousValue: 'value1', isDisabled: false}),
        Em.Object.create({value: '', previousValue: 'value2', isDisabled: false}),
        Em.Object.create({value: '', previousValue: 'value3', isDisabled: false})
      ]);

      controller.set('canEdit', true);

      controller.cancelEditConfigs();

      expect(controller.get('configs').mapProperty('value')).to.eql(['value1', 'value2', 'value3']);
      expect(controller.get('configs').someProperty('isDisabled', false)).to.be.false;
      expect(controller.get('canEdit')).to.be.false;
    });

  });

  describe('#saveConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should set previousValue, isDisabled for each config and change canEdit flag', function () {

      controller.set('configs', [
        Em.Object.create({isDisabled: true}),
        Em.Object.create({isDisabled: true}),
        Em.Object.create({isDisabled: true})
      ]);

      controller.set('canEdit', true);

      controller.saveConfigs();

      expect(controller.get('configs').someProperty('isDisabled', false)).to.be.false;
      expect(controller.get('canEdit')).to.be.false;
      expect(App.ajax.send.calledOnce).to.be.true;
    });

  });

  describe('#getPropertiesToUpdate()', function () {

    beforeEach(function () {
      controller.set('content', {
        rawSourceData: {
          path1: 'value',
          path2: {
            path3: 'value'
          }
        }
      });
    });

    var testCases = [
      {
        m: 'should ignore configs with wasChanged false',
        configs: [
          Em.Object.create({
            wasChanged: false,
            apiProperty: 'name1',
            apiFormattedValue: 'test1'
          }),
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'name2',
            apiFormattedValue: 'test2'
          }),
          Em.Object.create({
            wasChanged: false,
            apiProperty: 'name3',
            apiFormattedValue: 'test3'
          })
        ],
        result: {
          'AlertDefinition/name2': 'test2'
        }
      },
      {
        m: 'should correctly map deep source properties',
        configs: [
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'name1',
            apiFormattedValue: 'test1'
          }),
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'source.path1',
            apiFormattedValue: 'value1'
          }),
          Em.Object.create({
            wasChanged: true,
            apiProperty: 'source.path2.path3',
            apiFormattedValue: 'value2'
          })
        ],
        result: {
          'AlertDefinition/name1': 'test1',
          'AlertDefinition/source': {
            path1: 'value1',
            path2: {
              path3: 'value2'
            }
          }
        }
      },
      {
        m: 'should correctly multiple apiProperties',
        configs: [
          Em.Object.create({
            wasChanged: true,
            apiProperty: ['name1', 'name2'],
            apiFormattedValue: ['value1', 'value2']
          })
        ],
        result: {
          'AlertDefinition/name1': 'value1',
          'AlertDefinition/name2': 'value2'
        }
      }
    ];

    testCases.forEach(function (testCase) {

      it(testCase.m, function () {

        controller.set('configs', testCase.configs);
        var result = controller.getPropertiesToUpdate(true);

        expect(result).to.eql(testCase.result);
      });
    });

    describe('Some fields should be removed', function () {

      beforeEach(function () {
        controller.set('content', Em.Object.create({
          rawSourceData: {
            uri: {
              id: 123
            }
          }
        }));
        controller.set('configs', [
          Em.Object.create({
            apiProperty: 'source.uri.connection_timeout',
            apiFormattedValue: 123,
            wasChanged: true
          })
        ]);
        this.result = controller.getPropertiesToUpdate();
      });

      it('`AlertDefinition/source.uri.id`', function () {
        expect(this.result).to.not.have.deep.property('AlertDefinition/source.uri.id');
      });

    });

  });

  describe('#changeType()', function () {

    it('should disable and enable appropriate configs', function () {

      controller.set('allServices', ['service1', 'service2']);
      controller.set('allScopes', ['scope1', 'scope2']);

      controller.set('configs', [
        Em.Object.create({name: 'service', isDisabled: false}),
        Em.Object.create({name: 'component', isDisabled: false}),
        Em.Object.create({name: 'scope', isDisabled: false})
      ]);

      controller.changeType('Host Alert Definition');

      expect(controller.get('configs').everyProperty('isDisabled', true)).to.be.true;
      expect(controller.get('configs').findProperty('name', 'service').get('options')).to.eql(['Ambari']);
      expect(controller.get('configs').findProperty('name', 'service').get('value')).to.equal('Ambari');
      expect(controller.get('configs').findProperty('name', 'component').get('value')).to.equal('Ambari Agent');
      expect(controller.get('configs').findProperty('name', 'scope').get('options')).to.eql(['Host']);
      expect(controller.get('configs').findProperty('name', 'scope').get('value')).to.equal('Host');

      controller.changeType('alert_type_service');

      expect(controller.get('configs').everyProperty('isDisabled', false)).to.be.true;
      expect(controller.get('configs').findProperty('name', 'service').get('options')).to.eql(['service1', 'service2']);
      expect(controller.get('configs').findProperty('name', 'service').get('value')).to.equal('service1');
      expect(controller.get('configs').findProperty('name', 'component').get('value')).to.equal('No component');
      expect(controller.get('configs').findProperty('name', 'scope').get('options')).to.eql(['scope1', 'scope2']);
      expect(controller.get('configs').findProperty('name', 'scope').get('value')).to.equal('scope1');

    });

  });

  describe('#renderCommonWizardConfigs()', function () {

    it('should return correct number of configs', function () {

      var result = controller.renderCommonWizardConfigs();

      expect(result.length).to.equal(6);

    });

  });

  describe('#getConfigsValues()', function () {

    it('should create key-value map from configs', function () {

      controller.set('configs', [
        Em.Object.create({name: 'name1', value: 'value1'}),
        Em.Object.create({name: 'name2', value: 'value2'}),
        Em.Object.create({name: 'name3', value: 'value3'})
      ]);

      var result = controller.getConfigsValues();

      expect(result).to.eql([
        {name: 'name1', value: 'value1'},
        {name: 'name2', value: 'value2'},
        {name: 'name3', value: 'value3'}
      ]);

    });

  });

});

});

;require.register("test/controllers/main/alerts/definitions_details_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var controller;

describe('App.MainAlertDefinitionDetailsController', function () {

  beforeEach(function () {
    controller = App.MainAlertDefinitionDetailsController.create({
      content: Em.Object.create({
        label: 'label'
      })
    });
  });

  describe('#labelValidation()', function () {

    it('should set editing.label.isError to true', function () {
      controller.set('editing.label.value', ' ');
      expect(controller.get('editing.label.isError')).to.be.true;
    });

  });

  describe('#edit()', function () {

    it('should change value of value, originalValue and isEditing properties', function () {
      controller.set('editing.label.value', 'test');
      controller.set('editing.label.originalValue', 'test');
      controller.set('editing.label.isEditing', false);

      controller.edit({context: controller.get('editing.label')});

      expect(controller.get('editing.label.value')).to.equal('label');
      expect(controller.get('editing.label.originalValue')).to.equal('label');
      expect(controller.get('editing.label.isEditing')).to.be.true;
    });

  });

  describe('#saveEdit()', function () {

    it('should change values of content.label and isEditing properties', function () {
      controller.set('editing.label.value', 'test');
      controller.set('editing.label.isEditing', true);

      controller.saveEdit({context: controller.get('editing.label')});

      expect(controller.get('content.label')).to.equal('test');
      expect(controller.get('editing.label.isEditing')).to.be.false;
    });

  });

  describe('#toggleDefinitionState()', function () {
    beforeEach(function() {
      sinon.stub(App.ajax, 'send', Em.K);
      controller.reopen({
        content: [
          App.AlertDefinition.createRecord({id: 1, enabled: true})
        ]
      });
    });

    afterEach(function() {
      App.ajax.send.restore();
    });

    it('should call App.ajax.send function', function () {
      var alertDefinition = controller.get('content')[0];
      controller.toggleDefinitionState(alertDefinition);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe("#deleteAlertDefinition()", function () {
    beforeEach(function () {
      sinon.stub(App.get('router'), 'transitionTo', Em.K);
    });
    afterEach(function () {
      App.get('router').transitionTo.restore();
    });
    it("deleteAlertDefinitionSuccess", function () {
      controller.deleteAlertDefinitionSuccess();
      expect(App.get('router').transitionTo.calledWith('main.alerts.index')).to.be.true;
    });
  });

  describe("#loadAlertInstancesHistory()", function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it("should load alert instances history", function () {

      controller.set('lastDayAlertsCount', 'test');

      controller.loadAlertInstancesHistory();

      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.get('lastDayAlertsCount')).to.equal(null);
    });
  });

  describe("#loadAlertInstancesHistorySuccess()", function () {

    it("should calculate alerts count in different hosts", function () {

      controller.set('lastDayAlertsCount', null);

      controller.loadAlertInstancesHistorySuccess({
        items: [
          {
            AlertHistory: {
              host_name: 'host1'
            }
          },
          {
            AlertHistory: {
              host_name: 'host2'
            }
          },
          {
            AlertHistory: {
              host_name: 'host1'
            }
          },
          {
            AlertHistory: {
              host_name: 'host3'
            }
          }
        ]
      });

      expect(controller.get('lastDayAlertsCount')).to.eql({
        host1: 2,
        host2: 1,
        host3: 1
      });
    });
  });

});

});

;require.register("test/controllers/main/alerts/manage_alert_groups_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var manageAlertGroupsController;
describe('App.ManageAlertGroupsController', function () {

  beforeEach(function () {
    manageAlertGroupsController = App.ManageAlertGroupsController.create({});
  });

  describe('#addAlertGroup', function () {

    beforeEach(function () {
      manageAlertGroupsController.addAlertGroup();
    });

    describe("#validate", function () {
      it("should display no warning if user inputs valid characters into group name", function () {

        manageAlertGroupsController.addGroupPopup.set('alertGroupName', 'test');

        expect(manageAlertGroupsController.addGroupPopup.warningMessage).to.be.empty;
      });

      it("should display warning if user inputs invalid characters into group name", function () {
        manageAlertGroupsController.addGroupPopup.set('alertGroupName', '/{"!@#$%');

        expect(manageAlertGroupsController.addGroupPopup.warningMessage).to.equal('Invalid Alert Group Name. Only alphanumerics, hyphens, spaces and underscores are allowed.');
      });

    });
  });

  describe('#duplicateAlertGroup', function () {
    beforeEach(function () {
      var group = Ember.Object.create({
        name: 'test'
      });

      manageAlertGroupsController.set('selectedAlertGroup', group);
      manageAlertGroupsController.duplicateAlertGroup();
    });

    describe("#validate", function () {
      it("should display no warning if user duplicate an existed group", function () {
        manageAlertGroupsController.addGroupPopup.set('alertGroupName', 'test Copy');

        expect(manageAlertGroupsController.addGroupPopup.warningMessage).to.be.empty;
      });
    });
  });

  describe('#renameAlertGroup', function () {
    beforeEach(function () {
      var group = Ember.Object.create({
        name: 'test'
      });

      manageAlertGroupsController.set('selectedAlertGroup', group);
      manageAlertGroupsController.renameAlertGroup();
    });

    describe("#validate", function () {
      it("should display no warning if user inputs valid characters into group name", function () {
        manageAlertGroupsController.renameGroupPopup.set('alertGroupName', 'hello');

        expect(manageAlertGroupsController.renameGroupPopup.warningMessage).to.be.empty;
      });

      it("should display warning if user inputs invalid characters into group name", function () {
        manageAlertGroupsController.renameGroupPopup.set('alertGroupName', '/{"!@#$%');

        expect(manageAlertGroupsController.renameGroupPopup.warningMessage).to.equal('Invalid Alert Group Name. Only alphanumerics, hyphens, spaces and underscores are allowed.');
      });
    });
  });

  describe('#deleteDefinitions', function () {
    var definitions = [
      Em.Object.create({
        name: 'def1',
        serviceName: 'HDFS',
        label: "Alert Definition 1",
        id: 1
      }),
      Em.Object.create({
        name: 'def2',
        serviceName: 'HDFS',
        label: "Alert Definition 2",
        id: 2
      }),
      Em.Object.create({
        name: 'def3',
        serviceName: 'HDFS',
        label: "Alert Definition 3",
        id: 3
      })
    ];

    beforeEach(function () {
      manageAlertGroupsController = App.ManageAlertGroupsController.create({});
    });

    var createAlertGroupMock = function (groupDefs) {
      return Em.Object.create({
        definitions: groupDefs,
        name: 'group'
      });
    };

    var tests = [
      {
        selectedDefinitions: definitions.slice(0, 1),
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: definitions.slice(1)
      },
      {
        selectedDefinitions: definitions.slice(0, 2),
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: definitions.slice(2)
      },
      {
        selectedDefinitions: definitions,
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: []
      }
    ];

    tests.forEach(function (test) {
      it('delete definitions length {0} definitions'.format(test.selectedDefinitions.slice(0).length), function () {
        manageAlertGroupsController.reopen({
          selectedDefinitions: test.selectedDefinitions,
          selectedAlertGroup: test.selectedAlertGroup
        });
        manageAlertGroupsController.deleteDefinitions();
        expect(manageAlertGroupsController.get('selectedAlertGroup.definitions').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#addDefinitionsCallback', function () {

    var definitions = [
      Em.Object.create({
        name: 'def1',
        serviceName: 'HDFS',
        label: "Alert Definition 1",
        id: 1
      }),
      Em.Object.create({
        name: 'def2',
        serviceName: 'HDFS',
        label: "Alert Definition 2",
        id: 2
      }),
      Em.Object.create({
        name: 'def3',
        serviceName: 'HDFS',
        label: "Alert Definition 3",
        id: 3
      })
    ];

    var definitionsToAdd = [
      Em.Object.create({
        name: 'def4',
        serviceName: 'HDFS',
        label: "Alert Definition 4",
        id: 4
      }),
      Em.Object.create({
        name: 'def5',
        serviceName: 'HDFS',
        label: "Alert Definition 5",
        id: 5
      }),
      Em.Object.create({
        name: 'def6',
        serviceName: 'HDFS',
        label: "Alert Definition 6",
        id: 6
      })
    ];

    beforeEach(function () {
      manageAlertGroupsController = App.ManageAlertGroupsController.create({});
    });

    var createAlertGroupMock = function (groupDefs) {
      return Em.Object.create({
        definitions: groupDefs,
        name: 'group'
      });
    };

    var result = function (originalDefs, addedDefs) {
      return originalDefs.concat(addedDefs);
    };

    var tests = [
      {
        selectedDefinitions: definitionsToAdd.slice(0, 1),
        selectedAlertGroup: createAlertGroupMock(definitions.slice(0, 1)),
        e: result(definitions.slice(0, 1), definitionsToAdd.slice(0, 1))
      },
      {
        selectedDefinitions: definitionsToAdd.slice(0, 2),
        selectedAlertGroup: createAlertGroupMock(definitions.slice(0, 2)),
        e: result(definitions.slice(0, 2), definitionsToAdd.slice(0, 2))
      },
      {
        selectedDefinitions: definitionsToAdd,
        selectedAlertGroup: createAlertGroupMock(definitions),
        e: result(definitions, definitionsToAdd)
      }
    ];

    tests.forEach(function (test) {
      it('add Definitions length {0} definitions'.format(test.selectedDefinitions.slice(0).length), function () {
        manageAlertGroupsController.set('selectedAlertGroup', test.selectedAlertGroup);
        manageAlertGroupsController.addDefinitionsCallback(test.selectedDefinitions);
        expect(manageAlertGroupsController.get('selectedAlertGroup.definitions').toArray()).to.eql(test.e);
      });
    });

  });

});


});

;require.register("test/controllers/main/alerts/manage_alert_notifications_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var controller;
var helpers = require('test/helpers');

describe('App.ManageAlertNotificationsController', function () {

  beforeEach(function () {
    controller = App.ManageAlertNotificationsController.create({});
    sinon.stub($, 'ajax', Em.K);
  });

  afterEach(function () {
    $.ajax.restore();
  });

  describe('#alertNotifications', function () {

    beforeEach(function () {
      sinon.stub(App.AlertNotification, 'find', function () {
        return [1, 2, 3];
      });
    });

    afterEach(function () {
      App.AlertNotification.find.restore();
    });

    it("should return all alert notifications if controller isLoaded", function () {

      controller.set('isLoaded', true);
      expect(controller.get('alertNotifications')).to.eql([1, 2, 3]);
    });

    it("should return [] if controller isLoaded=false", function () {

      controller.set('isLoaded', false);
      expect(controller.get('alertNotifications')).to.eql([]);
    });

  });

  describe('#loadAlertNotifications()', function () {

    it("should send ajax request and set isLoaded to false", function () {

      controller.set('isLoaded', true);
      controller.loadAlertNotifications();
      expect(controller.get('isLoaded')).to.be.false;
    });

  });

  describe('#getAlertNotificationsSuccessCallback()', function () {

    beforeEach(function () {
      sinon.spy(App.alertNotificationMapper, 'map');
    });

    afterEach(function () {
      App.alertNotificationMapper.map.restore();
    });

    it("should call mapper and set isLoaded to true", function () {

      controller.set('isLoaded', false);
      controller.getAlertNotificationsSuccessCallback('test');
      expect(controller.get('isLoaded')).to.be.true;
      expect(App.alertNotificationMapper.map.calledWith('test')).to.be.true;
    });

  });

  describe('#getAlertNotificationsErrorCallback()', function () {

    it("should set isLoaded to true", function () {

      controller.set('isLoaded', false);
      controller.getAlertNotificationsSuccessCallback('test');
      expect(controller.get('isLoaded')).to.be.true;
    });

  });

  describe('#addAlertNotification()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'showCreateEditPopup');
    });

    afterEach(function () {
      controller.showCreateEditPopup.restore();
    });

    it("should set value for inputFields and call showCreateEditPopup", function () {

      controller.set('inputFields', Em.Object.create({
        a: {
          value: '',
          defaultValue: 'a'
        },
        b: {
          value: '',
          defaultValue: 'b'
        },
        c: {
          value: '',
          defaultValue: 'c'
        },
        severityFilter: {
          value: [],
          defaultValue: ['OK', 'WARNING', 'CRITICAL', 'UNKNOWN']
        },
        global: {
          value: false
        },
        allGroups: Em.Object.create({
          value: 'custom'
        })
      }));
      controller.addAlertNotification();

      Em.keys(controller.get('inputFields')).forEach(function (key) {
        expect(controller.get('inputFields.' + key + '.value')).to.eql(controller.get('inputFields.' + key + '.defaultValue'));
      });
      expect(controller.showCreateEditPopup.calledOnce).to.be.true;
    });

  });

  describe('#editAlertNotification()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'showCreateEditPopup', Em.K);
      sinon.stub(controller, 'fillEditCreateInputs', Em.K);
    });

    afterEach(function () {
      controller.showCreateEditPopup.restore();
      controller.fillEditCreateInputs.restore();
    });

    it("should call fillEditCreateInputs and showCreateEditPopup", function () {

      controller.editAlertNotification();

      expect(controller.fillEditCreateInputs.calledOnce).to.be.true;
      expect(controller.showCreateEditPopup.calledWith(true)).to.be.true;
    });

  });

  describe('#fillEditCreateInputs()', function () {

    it("should map properties from selectedAlertNotification to inputFields (ambari.dispatch.recipients ignored) - EMAIL", function () {

      controller.set('selectedAlertNotification', Em.Object.create({
        name: 'test_name',
        global: true,
        description: 'test_description',
        groups: ['test1', 'test2'],
        type: 'EMAIL',
        alertStates: ['OK', 'UNKNOWN'],
        properties: {
          'ambari.dispatch.recipients': [
            'test1@test.test',
            'test2@test.test'
          ],
          'customName': 'customValue',
          "mail.smtp.from" : "from",
          "ambari.dispatch.credential.username" : "user",
          "mail.smtp.host" : "s1",
          "mail.smtp.port" : "25",
          "mail.smtp.auth" : "true",
          "ambari.dispatch.credential.password" : "pass",
          "mail.smtp.starttls.enable" : "true"
        }
      }));

      controller.set('inputFields', Em.Object.create({
        name: {
          value: ''
        },
        groups: {
          value: []
        },
        global: {
          value: false
        },
        allGroups: {
          value: false
        },
        method: {
          value: ''
        },
        email: {
          value: ''
        },
        severityFilter: {
          value: []
        },
        description: {
          value: ''
        },
        SMTPServer: {
          value: ''
        },
        SMTPPort: {
          value: ''
        },
        SMTPUseAuthentication: {
          value: ''
        },
        SMTPUsername: {
          value: ''
        },
        SMTPPassword: {
          value: ''
        },
        retypeSMTPPassword: {
          value: ''
        },
        SMTPSTARTTLS: {
          value: ''
        },
        emailFrom: {
          value: ''
        },
        version: {
          value: ''
        },
        OIDs: {
          value: ''
        },
        community: {
          value: ''
        },
        host: {
          value: ''
        },
        port: {
          value: ''
        },
        customProperties: [
          {name: 'customName', value: 'customValue1', defaultValue: 'customValue1'},
          {name: 'customName2', value: 'customValue1', defaultValue: 'customValue1'}
        ]
      }));

      controller.fillEditCreateInputs();

      expect(JSON.stringify(controller.get('inputFields'))).to.equal(JSON.stringify({
        name: {
          value: 'test_name'
        },
        groups: {
          value: ['test1', 'test2']
        },
        global: {
          value: true,
          disabled: true
        },
        allGroups: {
          value: 'all'
        },
        method: {
          value: 'EMAIL'
        },
        email: {
          value: 'test1@test.test, test2@test.test'
        },
        severityFilter: {
          value: ['OK', 'UNKNOWN']
        },
        description: {
          value: 'test_description'
        },
        SMTPServer: {
          value: 's1'
        },
        SMTPPort: {
          value: '25'
        },
        SMTPUseAuthentication: {
          value: true
        },
        SMTPUsername: {
          value: 'user'
        },
        SMTPPassword: {
          value: 'pass'
        },
        retypeSMTPPassword: {
          value: 'pass'
        },
        SMTPSTARTTLS: {
          value: true
        },
        emailFrom: {
          value: 'from'
        },
        version: {},
        OIDs: {},
        community: {},
        host: {
          value: 'test1@test.test, test2@test.test'
        },
        port: {},
        customProperties: [
          {name: 'customName', value: 'customValue', defaultValue: 'customValue'}
        ]
      }));

    });

    it("should map properties from selectedAlertNotification to inputFields (ambari.dispatch.recipients ignored) - SNMP", function () {

      controller.set('selectedAlertNotification', Em.Object.create({
        name: 'test_SNMP_name',
        global: true,
        description: 'test_description',
        groups: ['test1', 'test2'],
        type: 'SNMP',
        alertStates: ['OK', 'UNKNOWN'],
        properties: {
          'ambari.dispatch.recipients': [
            'c6401.ambari.apache.org',
            'c6402.ambari.apache.org'
          ],
          'customName': 'customValue',
          'ambari.dispatch.snmp.version': 'SNMPv1',
          'ambari.dispatch.snmp.oids.trap': '1',
          'ambari.dispatch.snmp.community': 'snmp',
          'ambari.dispatch.snmp.port': 161

        }
      }));

      controller.set('inputFields', Em.Object.create({
        name: {
          value: ''
        },
        groups: {
          value: []
        },
        global: {
          value: false
        },
        allGroups: {
          value: false
        },
        method: {
          value: ''
        },
        email: {
          value: ''
        },
        severityFilter: {
          value: []
        },
        description: {
          value: ''
        },
        SMTPServer: {
          value: ''
        },
        SMTPPort: {
          value: ''
        },
        SMTPUseAuthentication: {
          value: ''
        },
        SMTPUsername: {
          value: ''
        },
        SMTPPassword: {
          value: ''
        },
        retypeSMTPPassword: {
          value: ''
        },
        SMTPSTARTTLS: {
          value: ''
        },
        emailFrom: {
          value: ''
        },
        version: {
          value: ''
        },
        OIDs: {
          value: ''
        },
        community: {
          value: ''
        },
        host: {
          value: ''
        },
        port: {
          value: ''
        },
        customProperties: [
          {name: 'customName', value: 'customValue1', defaultValue: 'customValue1'},
          {name: 'customName2', value: 'customValue1', defaultValue: 'customValue1'}
        ]
      }));

      controller.fillEditCreateInputs();

      expect(JSON.stringify(controller.get('inputFields'))).to.equal(JSON.stringify({
        name: {
          value: 'test_SNMP_name'
        },
        groups: {
          value: ['test1', 'test2']
        },
        global: {
          value: true,
          disabled: true
        },
        allGroups: {
          value: 'all'
        },
        method: {
          value: 'SNMP'
        },
        email: {
          value: 'c6401.ambari.apache.org, c6402.ambari.apache.org'
        },
        severityFilter: {
          value: ['OK', 'UNKNOWN']
        },
        description: {
          value: 'test_description'
        },
        SMTPServer: {},
        SMTPPort: {},
        SMTPUseAuthentication: {
          value: true
        },
        SMTPUsername: {},
        SMTPPassword: {},
        retypeSMTPPassword: {},
        SMTPSTARTTLS: {
          value: true
        },
        emailFrom: {},
        version: {
          value:'SNMPv1'
        },
        OIDs: {
          value: '1'
        },
        community: {
          value: 'snmp'
        },
        host: {
          value: 'c6401.ambari.apache.org, c6402.ambari.apache.org'
        },
        port: {
          value: 161
        },
        customProperties: [
          {name: 'customName', value: 'customValue', defaultValue: 'customValue'}
        ]
      }));

    })
  });

  describe("#showCreateEditPopup()", function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it("should open popup and set popup object to createEditPopup", function () {

      controller.showCreateEditPopup();
      expect(App.ModalPopup.show.calledOnce).to.be.true;

    });

    describe('#bodyClass', function () {

      var view;

      beforeEach(function () {

        view = controller.showCreateEditPopup().get('bodyClass').create({
          controller: Em.Object.create({
            inputFields: {
              name: {},
              global: {},
              allGroups: {},
              SMTPPassword: {},
              retypeSMTPPassword: {},
              method: {}
            }
          }),
          groupSelect: Em.Object.create({
            selection: [],
            content: [{}, {}]
          }),
          parentView: Em.Object.create({
            hasErrors: false
          })
        });

      });

      describe('#selectAllGroups', function () {

        it('should check inputFields.allGroups.value', function () {

          view.set('controller.inputFields.allGroups.value', 'all');
          view.selectAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([]);

          view.set('controller.inputFields.allGroups.value', 'custom');
          view.selectAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([{}, {}]);

        });

      });

      describe('#clearAllGroups', function () {

        it('should check inputFields.allGroups.value', function () {

          view.set('controller.inputFields.allGroups.value', 'custom');
          view.selectAllGroups();

          view.set('controller.inputFields.allGroups.value', 'all');
          view.clearAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([{}, {}]);

          view.set('controller.inputFields.allGroups.value', 'custom');
          view.clearAllGroups();
          expect(view.get('groupSelect.selection')).to.eql([]);

        });

      });

      describe('#nameValidation', function () {

        it('should check inputFields.name.value', function () {
          view.set('controller.inputFields.name.value', '');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal(Em.I18n.t('alerts.actions.manage_alert_notifications_popup.error.name.empty'));
          expect(view.get('parentView.hasErrors')).to.be.true;
        });

        it('should check inputFields.name.value', function () {
          view.set('controller.inputFields.name.errorMsg', 'error');
          view.set('controller.inputFields.name.value', 'test');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal('');
        });

        it('should check inputFields.name.value', function () {
          view.set('isEdit', true);
          view.set('controller.inputFields.name.value', '');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal(Em.I18n.t('alerts.actions.manage_alert_notifications_popup.error.name.empty'));
          expect(view.get('parentView.hasErrors')).to.be.true;
        });

        it('should check inputFields.name.value', function () {
          view.set('isEdit', true);
          view.set('controller.inputFields.name.errorMsg', 'error');
          view.set('controller.inputFields.name.value', 'test');
          expect(view.get('controller.inputFields.name.errorMsg')).to.equal('');
        });

      });

      describe('#retypePasswordValidation', function () {

        it('should check inputFields.retypeSMTPPassword.value', function () {

          view.set('controller.inputFields.retypeSMTPPassword.errorMsg', null);
          view.set('controller.inputFields.SMTPPassword.value', 'pass');
          view.set('controller.inputFields.retypeSMTPPassword.value', 'pas');

          expect(view.get('controller.inputFields.retypeSMTPPassword.errorMsg')).to.equal(Em.I18n.t('alerts.notifications.error.retypePassword'));
          expect(view.get('parentView.hasErrors')).to.be.true;

        });

        it('should check inputFields.retypeSMTPPassword.value', function () {

          view.set('parentView.hasErrors', true);
          view.set('controller.inputFields.retypeSMTPPassword.errorMsg', 'error');
          view.set('controller.inputFields.SMTPPassword.value', 'pass');
          view.set('controller.inputFields.retypeSMTPPassword.value', 'pass');

          expect(view.get('controller.inputFields.retypeSMTPPassword.errorMsg')).to.equal(null);
          expect(view.get('parentView.hasErrors')).to.be.false;

        });

      });

      describe('#methodObserver', function () {

        var cases = [
            {
              method: 'EMAIL',
              errors: ['portError', 'hostError'],
              validators: ['emailToValidation', 'emailFromValidation', 'smtpPortValidation', 'retypePasswordValidation']
            },
            {
              method: 'SNMP',
              errors: ['emailToError', 'emailFromError', 'smtpPortError', 'passwordError'],
              validators: ['portValidation', 'hostsValidation']
            }
          ],
          validators = [];

        before(function () {
          cases.forEach(function (item) {
            validators.pushObjects(item.validators);
          });
        });

        beforeEach(function () {
          validators.forEach(function (item) {
            sinon.stub(view, item, Em.K);
          });
        });

        afterEach(function () {
          validators.forEach(function (item) {
            view.get(item).restore();
          });
        });

        cases.forEach(function (item) {
          it(item.method, function () {
            item.errors.forEach(function (errorName) {
              view.set(errorName, true);
            });
            view.set('controller.inputFields.method.value', item.method);
            item.errors.forEach(function (errorName) {
              expect(view.get(errorName)).to.be.false;
            });
            validators.forEach(function (validatorName) {
              expect(view.get(validatorName).calledOnce).to.equal(item.validators.contains(validatorName));
            });
          });
        });

      });

    });

  });

  describe("#formatNotificationAPIObject()", function () {

    var inputFields = Em.Object.create({
      name: {
        value: 'test_name'
      },
      groups: {
        value: [{id: 1}, {id: 2}, {id: 3}]
      },
      allGroups: {
        value: 'custom'
      },
      global: {
        value: false
      },
      method: {
        value: 'EMAIL'
      },
      email: {
        value: 'test1@test.test, test2@test.test,test3@test.test , test4@test.test'
      },
      severityFilter: {
        value: ['OK', 'CRITICAL']
      },
      SMTPServer: {
        value: 's1'
      },
      SMTPPort: {
        value: '25'
      },
      SMTPUseAuthentication: {
        value: "true"
      },
      SMTPUsername: {
        value: 'user'
      },
      SMTPPassword: {
        value: 'pass'
      },
      SMTPSTARTTLS: {
        value: "true"
      },
      emailFrom: {
        value: 'from'
      },
      description: {
        value: 'test_description'
      },
      customProperties: [
        {name: 'n1', value: 'v1'},
        {name: 'n2', value: 'v2'}
      ]
    });

    it("should create object with properties from inputFields values", function () {

      controller.set('inputFields', inputFields);

      var result = controller.formatNotificationAPIObject();

      expect(JSON.stringify(result)).to.eql(JSON.stringify({
        AlertTarget: {
          name: 'test_name',
          description: 'test_description',
          global: false,
          notification_type: 'EMAIL',
          alert_states: ['OK', 'CRITICAL'],
          properties: {
            'ambari.dispatch.recipients': [
              'test1@test.test',
              'test2@test.test',
              'test3@test.test',
              'test4@test.test'
            ],
            "mail.smtp.host" : "s1",
            "mail.smtp.port" : "25",
            "mail.smtp.from" : "from",
            "mail.smtp.auth" : "true",
            "ambari.dispatch.credential.username" : "user",
            "ambari.dispatch.credential.password" : "pass",
            "mail.smtp.starttls.enable" : "true",
            'n1': 'v1',
            'n2': 'v2'
          },
          groups: [1,2,3]
        }
      }));
    });

    it('should ignore groups if global is true', function () {

      controller.set('inputFields', inputFields);
      controller.set('inputFields.allGroups.value', 'all');

      var result = controller.formatNotificationAPIObject();
      expect(Em.keys(result.AlertTarget)).to.not.contain('groups');

    });

  });

  describe('#createAlertNotification()', function () {

    it("should send ajax request", function () {

      controller.createAlertNotification();
      expect($.ajax.calledOnce).to.be.true;
      expect($.ajax.args[0][0].url.contains('overwrite_existing=true')).to.be.false;
    });

  });

  describe('#createAlertNotificationSuccessCallback()', function () {

    beforeEach(function () {
      controller.set('createEditPopup', {
        hide: Em.K
      });
      sinon.stub(controller, 'loadAlertNotifications', Em.K);
      sinon.spy(controller.createEditPopup, 'hide');
    });

    afterEach(function () {
      controller.loadAlertNotifications.restore();
      controller.createEditPopup.hide.restore();
    });

    it("should call loadAlertNotifications and createEditPopup.hide", function () {

      controller.createAlertNotificationSuccessCallback();

      expect(controller.loadAlertNotifications.calledOnce).to.be.true;
      expect(controller.createEditPopup.hide.calledOnce).to.be.true;
    });

  });

  describe('#updateAlertNotification()', function () {

    it("should send ajax request", function () {

      controller.updateAlertNotification();
      expect($.ajax.calledOnce).to.be.true;
    });

  });

  describe('#updateAlertNotificationSuccessCallback()', function () {

    beforeEach(function () {
      controller.set('createEditPopup', {
        hide: Em.K
      });
      sinon.stub(controller, 'loadAlertNotifications', Em.K);
      sinon.spy(controller.createEditPopup, 'hide');
    });

    afterEach(function () {
      controller.loadAlertNotifications.restore();
      controller.createEditPopup.hide.restore();
    });

    it("should call loadAlertNotifications and createEditPopup.hide", function () {

      controller.updateAlertNotificationSuccessCallback();

      expect(controller.loadAlertNotifications.calledOnce).to.be.true;
      expect(controller.createEditPopup.hide.calledOnce).to.be.true;
    });

  });

  describe('#deleteAlertNotification()', function () {

    beforeEach(function () {
      sinon.spy(App, 'showConfirmationPopup');
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it("should show popup and send request on confirmation", function () {

      var popup = controller.deleteAlertNotification();

      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect($.ajax.calledOnce).to.be.true;
    });

  });

  describe('#deleteAlertNotificationSuccessCallback()', function () {

    it("should call loadAlertNotifications, selectedAlertNotification.deleteRecord and set null to selectedAlertNotification", function () {

      var mockSelectedAlertNotification = {
        deleteRecord: Em.K
      };
      controller.set('selectedAlertNotification', mockSelectedAlertNotification);
      sinon.stub(controller, 'loadAlertNotifications', Em.K);
      sinon.spy(mockSelectedAlertNotification, 'deleteRecord');

      controller.deleteAlertNotificationSuccessCallback();

      expect(controller.loadAlertNotifications.calledOnce).to.be.true;
      expect(mockSelectedAlertNotification.deleteRecord.calledOnce).to.be.true;
      expect(controller.get('selectedAlertNotification')).to.equal(null);

      controller.loadAlertNotifications.restore();
      mockSelectedAlertNotification.deleteRecord.restore();
    });

  });

  describe('#duplicateAlertNotification()', function () {

    beforeEach(function () {
      sinon.stub(controller, 'fillEditCreateInputs', Em.K);
      sinon.stub(controller, 'showCreateEditPopup', Em.K);
    });

    afterEach(function () {
      controller.fillEditCreateInputs.restore();
      controller.showCreateEditPopup.restore();
    });

    it("should call fillEditCreateInputs and showCreateEditPopup", function () {

      controller.duplicateAlertNotification();

      expect(controller.fillEditCreateInputs.calledWith(true)).to.be.true;
      expect(controller.showCreateEditPopup.calledOnce).to.be.true;
    });

  });

  describe('#addCustomProperty', function () {

    beforeEach(function () {
      controller.set('inputFields.customProperties', []);
    });

    it('should add custom Property to customProperties', function () {

      controller.set('newCustomProperty', {name: 'n1', value: 'v1'});
      controller.addCustomProperty();
      helpers.nestedExpect([{name: 'n1', value: 'v1', defaultValue: 'v1'}], controller.get('inputFields.customProperties'));

    });

  });

  describe('#removeCustomPropertyHandler', function () {

    var c = {name: 'n2', value: 'v2', defaultValue: 'v2'};

    beforeEach(function () {
      controller.set('inputFields.customProperties', [
        {name: 'n1', value: 'v1', defaultValue: 'v1'},
        c,
        {name: 'n3', value: 'v3', defaultValue: 'v3'}
      ]);
    });

    it('should remove selected custom property', function () {

      controller.removeCustomPropertyHandler({context: c});
      helpers.nestedExpect(
        [
          {name: 'n1', value: 'v1', defaultValue: 'v1'},
          {name: 'n3', value: 'v3', defaultValue: 'v3'}
        ],
        controller.get('inputFields.customProperties')
      );

    });

  });

  describe('#addCustomPropertyHandler', function () {

    it('should clean up newCustomProperty on primary click', function () {

      controller.set('newCustomProperty', {name: 'n1', value: 'v1'});
      controller.addCustomPropertyHandler().onPrimary();
      expect(controller.get('newCustomProperty')).to.eql({name: '', value: ''});

    });

    describe('#bodyClass', function () {

      var view;

      beforeEach(function () {
        view = controller.addCustomPropertyHandler().get('bodyClass').create({
          parentView: Em.View.create(),
          controller: Em.Object.create({
            inputFields: Em.Object.create({
              customProperties: [
                {name: 'n1', value: 'v1', defaultValue: 'v1'}
              ]
            }),
            newCustomProperty: {name: '', value: ''}
          })
        });
      });

      describe('#errorHandler', function () {

        it('should fire invalid name', function () {

          view.set('controller.newCustomProperty.name', '!!');
          view.errorsHandler();
          expect(view.get('isError')).to.be.true;
          expect(view.get('parentView.disablePrimary')).to.be.true;
          expect(view.get('errorMessage.length') > 0).to.be.true;

        });

        it('should fire existing property name', function () {

          view.set('controller.newCustomProperty.name', 'n1');
          view.errorsHandler();
          expect(view.get('isError')).to.be.true;
          expect(view.get('parentView.disablePrimary')).to.be.true;
          expect(view.get('errorMessage.length') > 0).to.be.true;

        });

      });

    });

  });

});

});

;require.register("test/controllers/main/charts/heatmap_metrics/heatmap_metric_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('controllers/main/charts/heatmap_metrics/heatmap_metric');
var date = require('utils/date/date');

describe('MainChartHeatmapMetric', function () {
  var mainChartHeatmapMetric = App.MainChartHeatmapMetric.create({});

  beforeEach(function () {
    mainChartHeatmapMetric = App.MainChartHeatmapMetric.create({});
  });

  describe('#formatLegendNumber', function () {
    var tests = [
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to 0',i:0,e:0},
      {m:'1 to 1',i:1,e:1},
      {m:'1.23 to 1.2',i:1.23,e:1.2}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(mainChartHeatmapMetric.formatLegendNumber(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN' + ' ', function () {
      expect(isNaN(mainChartHeatmapMetric.formatLegendNumber(NaN))).to.equal(true);
    });
  });


  describe('#slotDefinitions', function () {
    beforeEach(function () {
      sinon.stub(mainChartHeatmapMetric, 'generateSlot', Em.K);
    });
    afterEach(function () {
      mainChartHeatmapMetric.generateSlot.restore();
    });
    it('one slot', function () {
      mainChartHeatmapMetric.set('numberOfSlots', 1);
      mainChartHeatmapMetric.set('maximumValue', 100);
      mainChartHeatmapMetric.set('minimumValue', 0);

      mainChartHeatmapMetric.propertyDidChange('slotDefinitions');

      expect(mainChartHeatmapMetric.get('slotDefinitions').length).to.equal(3);
      expect(mainChartHeatmapMetric.generateSlot.getCall(0).args).to.eql([0, 100, '', {r: 0, g: 204, b: 0}]);
      expect(mainChartHeatmapMetric.generateSlot.callCount).to.be.equal(1);
    });
    it('two slots', function () {
      mainChartHeatmapMetric.set('numberOfSlots', 2);
      mainChartHeatmapMetric.set('maximumValue', 100);
      mainChartHeatmapMetric.set('minimumValue', 0);

      mainChartHeatmapMetric.propertyDidChange('slotDefinitions');

      expect(mainChartHeatmapMetric.get('slotDefinitions').length).to.equal(4);
      expect(mainChartHeatmapMetric.generateSlot.getCall(0).args).to.eql([0, 50, '', {r: 0, g: 204, b: 0}]);
      expect(mainChartHeatmapMetric.generateSlot.getCall(1).args).to.eql([50, 100, '', {r: 159, g: 238, b: 0}]);
      expect(mainChartHeatmapMetric.generateSlot.callCount).to.be.equal(2);
    });
  });

  describe('#generateSlot()', function () {
    beforeEach(function () {
      sinon.stub(mainChartHeatmapMetric, 'formatLegendNumber').returns('val');
      sinon.stub(date, 'timingFormat').returns('time');
    });
    afterEach(function () {
      mainChartHeatmapMetric.formatLegendNumber.restore();
      date.timingFormat.restore();
    });
    it('label suffix is empty', function () {
      expect(mainChartHeatmapMetric.generateSlot(0, 1, '', {r: 0, g: 0, b: 0})).to.eql(Em.Object.create({
        "from": "val",
        "to": "val",
        "label": "val - val",
        "cssStyle": "background-color:rgb(0,0,0)"
      }));

      expect(mainChartHeatmapMetric.formatLegendNumber.getCall(0).args).to.eql([0]);
      expect(mainChartHeatmapMetric.formatLegendNumber.getCall(1).args).to.eql([1]);
    });
    it('label suffix is "ms"', function () {
      expect(mainChartHeatmapMetric.generateSlot(0, 1, 'ms', {r: 0, g: 0, b: 0})).to.eql(Em.Object.create({
        "from": "val",
        "to": "val",
        "label": "time - time",
        "cssStyle": "background-color:rgb(0,0,0)"
      }));

      expect(mainChartHeatmapMetric.formatLegendNumber.getCall(0).args).to.eql([0]);
      expect(mainChartHeatmapMetric.formatLegendNumber.getCall(1).args).to.eql([1]);
      expect(date.timingFormat.getCall(0).args).to.eql(['val', 'zeroValid']);
      expect(date.timingFormat.getCall(1).args).to.eql(['val', 'zeroValid']);
    });
  });

  describe('#getHatchStyle()', function () {
    var testCases = [
      {
        title: 'unknown browser',
        data: {},
        result: 'background-color:rgb(135, 206, 250)'
      },
      {
        title: 'webkit browser',
        data: {
          webkit: true
        },
        result: 'background-image:-webkit-repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)'
      },
      {
        title: 'mozilla browser',
        data: {
          mozilla: true
        },
        result: 'background-image:repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)'
      },
      {
        title: 'IE version 9',
        data: {
          msie: true,
          version: '9.0'
        },
        result: 'background-color:rgb(135, 206, 250)'
      },
      {
        title: 'IE version 10',
        data: {
          msie: true,
          version: '10.0'
        },
        result: 'background-image:repeating-linear-gradient(-45deg, #FF1E10, #FF1E10 3px, #ff6c00 3px, #ff6c00 6px)'
      }
    ]

    testCases.forEach(function(test){
      it(test.title, function () {
        jQuery.browser = test.data;
        expect(mainChartHeatmapMetric.getHatchStyle()).to.equal(test.result);
      });
    });
  });

  describe('#hostToSlotMap', function () {
    it('hostToValueMap is null', function () {
      mainChartHeatmapMetric.set('hostToValueMap', null);
      mainChartHeatmapMetric.set('hostNames', []);
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.be.empty;
    });
    it('hostNames is null', function () {
      mainChartHeatmapMetric.set('hostToValueMap', {});
      mainChartHeatmapMetric.set('hostNames', null);
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.be.empty;
    });
    it('slot greater than -1', function () {
      mainChartHeatmapMetric.set('hostToValueMap', {});
      mainChartHeatmapMetric.set('hostNames', ['host1']);
      sinon.stub(mainChartHeatmapMetric, 'calculateSlot').returns(0);
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.eql({'host1': 0});
      expect(mainChartHeatmapMetric.calculateSlot.calledWith({}, 'host1')).to.be.true;
      mainChartHeatmapMetric.calculateSlot.restore();
    });
    it('slot equal to -1', function () {
      mainChartHeatmapMetric.set('hostToValueMap', {});
      mainChartHeatmapMetric.set('hostNames', ['host1']);
      sinon.stub(mainChartHeatmapMetric, 'calculateSlot').returns('-1');
      mainChartHeatmapMetric.propertyDidChange('hostToSlotMap');
      expect(mainChartHeatmapMetric.get('hostToSlotMap')).to.be.empty;
      expect(mainChartHeatmapMetric.calculateSlot.calledWith({}, 'host1')).to.be.true;
      mainChartHeatmapMetric.calculateSlot.restore();
    });
  });

  describe('#calculateSlot()', function () {
    var testCases = [
      {
        title: 'hostToValueMap is empty',
        data: {
          hostToValueMap: {},
          hostName: 'host1',
          slotDefinitions: []
        },
        result: -1
      },
      {
        title: 'host value is NaN',
        data: {
          hostToValueMap: {'host1': NaN},
          hostName: 'host1',
          slotDefinitions: []
        },
        result: -2
      },
      {
        title: 'host value correct but slotDefinitions does not contain host value',
        data: {
          hostToValueMap: {'host1': 1},
          hostName: 'host1',
          slotDefinitions: [{}, {}]
        },
        result: -1
      },
      {
        title: 'host value -1',
        data: {
          hostToValueMap: {'host1': -1},
          hostName: 'host1',
          slotDefinitions: [
            {
              from: 0,
              to: 10
            },
            {},
            {}
          ]
        },
        result: 0
      },
      {
        title: 'host value 11',
        data: {
          hostToValueMap: {'host1': 11},
          hostName: 'host1',
          slotDefinitions: [
            {
              from: 0,
              to: 10
            },
            {},
            {}
          ]
        },
        result: 0
      },
      {
        title: 'host value 5',
        data: {
          hostToValueMap: {'host1': 5},
          hostName: 'host1',
          slotDefinitions: [
            {},
            {
              from: 0,
              to: 10
            },
            {},
            {}
          ]
        },
        result: 1
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        sinon.stub(mainChartHeatmapMetric, 'get').withArgs('slotDefinitions').returns(test.data.slotDefinitions);
        expect(mainChartHeatmapMetric.calculateSlot(test.data.hostToValueMap, test.data.hostName)).to.equal(test.result);
        mainChartHeatmapMetric.get.restore();
      });
    });
  });

});

});

;require.register("test/controllers/main/charts/heatmap_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('models/rack');
require('controllers/main/charts/heatmap');

describe('MainChartsHeatmapController', function () {

  describe('#validation()', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      selectedMetric: Ember.Object.create({maximumValue: 100})
    });
    it('should set maximumValue if inputMaximum consists only of digits', function () {
      controller.set("inputMaximum", 5);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits', function () {
      controller.set("inputMaximum", 'qwerty');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should not set maximumValue if inputMaximum consists not only of digits', function () {
      controller.set("inputMaximum", '100%');
      expect(controller.get('selectedMetric.maximumValue')).to.equal(5);
    });
    it('should set maximumValue if inputMaximum consists only of digits', function () {
      controller.set("inputMaximum", 1000);
      expect(controller.get('selectedMetric.maximumValue')).to.equal(1000);
    })
  });

  describe('#showHeatMapMetric()', function () {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      });
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    var controller = App.MainChartsHeatmapController.create({
      activeWidgetLayout: Em.Object.create({
        displayName: 'widget',
        id: '1',
        scope: 'CLUSTER',
        layoutName: 'defualt_layout',
        sectionName: 'default_section'
      })
    });

    it('should call App.ajax', function () {
      controller.showHeatMapMetric({context:{id: 2}});
      expect(App.ajax.send.called).to.be.true;
    });
  });

  describe('#rackClass', function () {
    var controller = App.MainChartsHeatmapController.create({
      allMetrics: [],
      racks: [1]
    });
    it('should return "span12" for 1 cluster rack', function () {
      expect(controller.get('rackClass')).to.equal('span12');
    });
    it('should return "span6" for 2 cluster racks', function () {
      controller.set('racks', [1, 2]);
      expect(controller.get('rackClass')).to.equal('span6');
    });
    it('should return "span4" for 3 cluster racks', function () {
      controller.set('racks', [1, 2, 3]);
      expect(controller.get('rackClass')).to.equal('span4');
    });
  });
});


});

;require.register("test/controllers/main/dashboard/config_history_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

require('controllers/main/dashboard/config_history_controller');

describe('MainConfigHistoryController', function () {

  var controller = App.MainConfigHistoryController.create();

  describe('#realUrl', function () {
    it('cluster name is empty', function () {
      App.set('clusterName', '');
      expect(controller.get('realUrl')).to.equal('/api/v1/clusters//configurations/service_config_versions?<parameters>fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
    it('cluster name is "mycluster"', function () {
      App.set('clusterName', 'mycluster');
      expect(controller.get('realUrl')).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?<parameters>fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
  });
  describe('#load()', function () {
    it('', function () {
      sinon.stub(controller, 'updateTotalCounter', Em.K);
      sinon.stub(controller, 'loadConfigVersionsToModel').returns({done: Em.K});

      controller.load();
      expect(controller.updateTotalCounter.calledOnce).to.be.true;

      controller.updateTotalCounter.restore();
      controller.loadConfigVersionsToModel.restore();
    });
  });
  describe('#loadConfigVersionsToModel()', function () {
    it('', function () {
      sinon.stub(App.HttpClient, 'get', Em.K);
      sinon.stub(controller, 'getUrl', Em.K);
      sinon.stub(controller, 'getQueryParameters', function(){
        return [1];
      });

      controller.loadConfigVersionsToModel();
      expect(App.HttpClient.get.calledOnce).to.be.true;
      expect(controller.getQueryParameters.calledOnce).to.be.true;
      expect(controller.getUrl.calledWith([1])).to.be.true;


      controller.getUrl.restore();
      controller.getQueryParameters.restore();
      App.HttpClient.get.restore();
    });
  });

  describe('#updateTotalCounter()', function () {
    it('', function () {
      sinon.stub(App.ajax, 'send', Em.K);

      controller.updateTotalCounter();
      expect(App.ajax.send.calledOnce).to.be.true;

      App.ajax.send.restore();
    });
  });

  describe('#updateTotalCounterSuccess()', function () {
    it('', function () {
      controller.updateTotalCounterSuccess({itemTotal: 1});
      expect(controller.get('totalCount')).to.equal(1);
    });
  });
  describe('#getUrl()', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return {
          computeParameters: function () {
            return 'params'
          }
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
      App.get.restore();
    });
    it('testMode is true', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      expect(controller.getUrl()).to.equal('/data/configurations/service_versions.json');
    });
    it('query params is empty', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      expect(controller.getUrl()).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
    it('query params is correct', function () {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      expect(controller.getUrl({})).to.equal('/api/v1/clusters/mycluster/configurations/service_config_versions?params&fields=service_config_version,user,group_id,group_name,is_current,createtime,service_name,hosts,service_config_version_note,is_cluster_compatible,stack_id&minimal_response=true');
    });
  });

  describe('#doPolling()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'load', function(){
        return {done: Em.K};
      });
      this.clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      this.clock.restore();
      controller.load.restore();
    });
    it('isPolling false', function () {
      controller.set('isPolling', false);
      controller.doPolling();
      this.clock.tick(App.componentsUpdateInterval);
      expect(controller.load.called).to.be.false;
    });
    it('isPolling true', function () {
      controller.set('isPolling', true);
      controller.doPolling();
      this.clock.tick(App.componentsUpdateInterval);
      expect(controller.load.calledOnce).to.be.true;
    });
  });
});


});

;require.register("test/controllers/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
});

;require.register("test/controllers/main/host/addHost/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.AddHostStep4Controller', function() {
  var controller;
  
  describe('#errorLoadingConfigGroup()', function() {
    before(function() {
      controller = App.AddHostStep4Controller.create({});
      controller.errorLoadingConfigGroup();
    });
    it('should set config groups on failed request', function() {
      expect(App.router.get('addHostController.content.configGroups')).to.eql([]);
    });
    it('should set `isConfigGroupLoaded` to true', function() {
      expect(controller.get('isConfigGroupLoaded')).to.true;
    });
  });
});

});

;require.register("test/controllers/main/host/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/wizard');
require('controllers/main/host/add_controller');
require('models/host_component');
require('models/service');
require('mappers/server_data_mapper');

describe('App.AddHostController', function () {

  var controller = App.AddHostController.create({
    testDBHosts: null,
    getDBProperty: function () {
      return this.get('testDBHosts');
    },
    setDBProperty: function () {
    },
    loadClients: function () {
    }
  });

  describe('#removeHosts()', function () {
    var testCases = [
      {
        title: 'No hosts, db is empty',
        content: {
          hosts: [],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Host is passed, db is empty',
        content: {
          hosts: [
            {name: 'host1'}
          ],
          dbHosts: {}
        },
        result: {}
      },
      {
        title: 'Passed host different from hosts in db',
        content: {
          hosts: [
            {name: 'host1'}
          ],
          dbHosts: {
            'host2': {}
          }
        },
        result: {
          'host2': {}
        }
      },
      {
        title: 'Passed host match host in db',
        content: {
          hosts: [
            {name: 'host1'}
          ],
          dbHosts: {
            'host1': {}
          }
        },
        result: {}
      }
    ];
    beforeEach(function () {
      sinon.spy(controller, "setDBProperty");
    });
    afterEach(function () {
      controller.setDBProperty.restore();
    });
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('testDBHosts', test.content.dbHosts);
        controller.removeHosts(test.content.hosts);
        expect(controller.setDBProperty.calledWith('hosts', test.result)).to.be.true;
      });
    });
  });

  describe('#sortServiceConfigGroups()', function () {
    var testCases = [
      {
        title: 'No selected services',
        selectedServices: [
          {configGroups: []}
        ],
        result: [
          {configGroups: []}
        ]
      },
      {
        title: 'Only one group is present',
        selectedServices: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ],
        result: [
          {configGroups: [
            {configGroups: {group_name: 'b'}}
          ]}
        ]
      },
      {
        title: 'Reverse order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'b2'}},
            {ConfigGroup: {group_name: 'a1'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      },
      {
        title: 'Correct order of groups',
        selectedServices: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ],
        result: [
          {configGroups: [
            {ConfigGroup: {group_name: 'a1'}},
            {ConfigGroup: {group_name: 'b2'}}
          ]}
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.sortServiceConfigGroups(test.selectedServices);
        expect(test.selectedServices).to.eql(test.result);
      });
    });
  });

  describe('#loadServiceConfigGroupsBySlaves()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        slaveComponentHosts: null,
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        slaveComponentHosts: [],
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Component does not have hosts',
        slaveComponentHosts: [
          {hosts: []}
        ],
        result: {
          output: true,
          selectedServices: []
        }
      },
      {
        title: 'Only client component is present',
        slaveComponentHosts: [
          {
            hosts: [
              {hostName: 'host1'}
            ],
            componentName: 'CLIENT'
          }
        ],
        result: {
          output: true,
          selectedServices: []
        }
      }
    ];

    controller.set('content.configGroups', [
      {
        ConfigGroup: {
          tag: 'HDFS',
          group_name: 'HDFS test'
        }
      }
    ]);
    testCases.forEach(function (test) {
      it(test.title, function () {
        var selectedServices = [];
        controller.set('content.slaveComponentHosts', test.slaveComponentHosts);
        expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.equal(test.result.output);
        expect(selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#loadServiceConfigGroupsByClients()', function () {
    var testCases = [
      {
        title: 'slaveComponentHosts is null',
        content: {
          slaveComponentHosts: null,
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'slaveComponentHosts is empty',
        content: {
          slaveComponentHosts: [],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client does not have hosts',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: []
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      },
      {
        title: 'Client has hosts, but clients is empty',
        content: {
          slaveComponentHosts: [
            {
              componentName: 'CLIENT',
              hosts: [
                {hostName: 'host1'}
              ]
            }
          ],
          clients: [],
          selectedServices: []
        },
        result: {
          output: false,
          selectedServices: []
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('content.slaveComponentHosts', test.content.slaveComponentHosts);
        controller.set('content.clients', test.content.clients);
        expect(controller.loadServiceConfigGroupsByClients(test.content.selectedServices)).to.equal(test.result.output);
        expect(test.content.selectedServices).to.eql(test.result.selectedServices);
      });
    });
  });

  describe('#installServices()', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, "send");
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('No hosts', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {});
      expect(controller.installServices()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('Cluster name is empty', function () {
      controller.set('content.cluster', {name: ''});
      controller.set('testDBHosts', {'host1': {}});
      expect(controller.installServices()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('Cluster name is correct and hosts are present', function () {
      controller.set('content.cluster', {name: 'cl'});
      controller.set('testDBHosts', {'host1': {isInstalled: false}});
      expect(controller.installServices()).to.be.true;
      expect(App.ajax.send.called).to.be.true;
    });
  });

  describe('#getClientsToInstall', function () {
    var services = [
      Em.Object.create({
        serviceName: 'service1'
      }),
      Em.Object.create({
        serviceName: 'service2'
      })
    ];
    var components = [
      Em.Object.create({
        componentName: 'comp1',
        displayName: 'comp1',
        serviceName: 'service1',
        isClient: true
      }),
      Em.Object.create({
        componentName: 'comp2',
        displayName: 'comp2',
        serviceName: 'service1',
        isClient: true
      }),
      Em.Object.create({
        componentName: 'comp3',
        displayName: 'comp3',
        serviceName: 'service2',
        isClient: false
      }),
      Em.Object.create({
        componentName: 'comp4',
        displayName: 'comp4',
        serviceName: 'service3',
        isClient: true
      })
    ];
    var clients = [
      {
        component_name: 'comp1',
        display_name: 'comp1',
        isInstalled: false
      },
      {
        component_name: 'comp2',
        display_name: 'comp2',
        isInstalled: false
      }
    ];
    it("generatel list of clients to install", function () {
      expect(controller.getClientsToInstall(services, components)).to.eql(clients);
    })
  });

  describe("#setCurrentStep()", function () {
    before(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(App.db, 'setWizardCurrentStep', Em.K);
    });
    after(function () {
      App.clusterStatus.setClusterStatus.restore();
      App.db.setWizardCurrentStep.restore();
    });
    it("call App.clusterStatus.setClusterStatus()", function () {
      controller.setCurrentStep();
      expect(App.clusterStatus.setClusterStatus.getCall(0).args[0].wizardControllerName).to.be.equal('addHostController');
    });
  });

  describe("#getCluster()", function () {
    before(function () {
      sinon.stub(App.router, 'getClusterName').returns('c1');
    });
    after(function () {
      App.router.getClusterName.restore();
    });
    it("", function () {
      controller.set('clusterStatusTemplate', {'prop': 'clusterStatusTemplate'});
      expect(controller.getCluster()).to.be.eql({
        prop: 'clusterStatusTemplate',
        name: 'c1'
      });
    });
  });

  describe("#loadServices", function () {
    var services = {
      db: null,
      stack: [],
      model: []
    };
    beforeEach(function () {
      sinon.stub(controller, 'getDBProperty', function () {
        return services.db;
      });
      sinon.stub(App.StackService, 'find', function () {
        return services.stack;
      });
      sinon.stub(App.Service, 'find', function () {
        return services.model;
      });
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    afterEach(function () {
      controller.getDBProperty.restore();
      App.StackService.find.restore();
      App.Service.find.restore();
      controller.setDBProperty.restore();
    });
    it("No services in db, no installed services", function () {
      services.stack = [Em.Object.create({
        serviceName: 'S1'
      })];
      controller.loadServices();
      expect(controller.setDBProperty.getCall(0).args).to.eql(['services',
        {
          selectedServices: [],
          installedServices: []
        }
      ]);
      expect(controller.get('content.services')).to.eql([
        Em.Object.create({
          serviceName: 'S1',
          isInstalled: false,
          isSelected: false
        })
      ])
    });
    it("No services in db, installed service present", function () {
      services.stack = [
        Em.Object.create({
          serviceName: 'S1'
        }),
        Em.Object.create({
          serviceName: 'S2'
        })
      ];
      services.model = [
        Em.Object.create({
          serviceName: 'S1'
        })
      ];
      controller.loadServices();
      expect(controller.setDBProperty.getCall(0).args).to.eql(['services',
        {
          selectedServices: ['S1'],
          installedServices: ['S1']
        }
      ]);
      expect(controller.get('content.services')).to.eql([
        Em.Object.create({
          serviceName: 'S1',
          isInstalled: true,
          isSelected: true
        }),
        Em.Object.create({
          serviceName: 'S2',
          isInstalled: false,
          isSelected: false
        })
      ]);
    });
    it("DB is empty", function () {
      services.stack = [Em.Object.create({
        serviceName: 'S1'
      })];
      services.db = {
        selectedServices: [],
        installedServices: []
      };
      controller.loadServices();
      expect(controller.setDBProperty.called).to.be.false;
      expect(controller.get('content.services')).to.eql([
        Em.Object.create({
          serviceName: 'S1',
          isSelected: false,
          isInstalled: false
        })
      ]);
    });
    it("DB has selected and installed services", function () {
      services.stack = [
        Em.Object.create({
          serviceName: 'S1'
        }),
        Em.Object.create({
          serviceName: 'S2'
        })
      ];
      services.db = {
        selectedServices: ['S1'],
        installedServices: ['S2']
      };
      controller.loadServices();
      expect(controller.setDBProperty.called).to.be.false;
      expect(controller.get('content.services')).to.eql([
        Em.Object.create({
          serviceName: 'S1',
          isInstalled: false,
          isSelected: true
        }),
        Em.Object.create({
          serviceName: 'S2',
          isInstalled: true,
          isSelected: false
        })
      ]);
    });
  });

  describe("#loadSlaveComponentHosts()", function () {

    var mock = {
      hosts: null,
      slaveComponentHosts: null
    };

    beforeEach(function () {
      sinon.stub(controller, 'getDBProperties', function (propsList) {
        var ret = {};
        propsList.forEach(function(k) {
          ret[k] = mock[k];
        });
        return ret;
      });
    });

    afterEach(function () {
      controller.getDBProperties.restore();
    });

    it("No slaveComponentHosts in db, null", function () {
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.empty;
    });

    it("No slaveComponentHosts in db", function () {
      mock.slaveComponentHosts = [];
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.empty;
    });

    it("One slaveComponent without hosts", function () {
      mock.slaveComponentHosts = [
        {hosts: []}
      ];
      mock.hosts = {};
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.eql([
        {hosts: []}
      ]);
    });

    it("One slaveComponent with host", function () {
      mock.slaveComponentHosts = [
        {hosts: [
          {host_id: 1}
        ]}
      ];
      mock.hosts = {'host1': {id: 1}};
      controller.loadSlaveComponentHosts();
      expect(controller.get('content.slaveComponentHosts')).to.be.eql([
        {hosts: [
          {
            host_id: 1,
            hostName: 'host1'
          }
        ]}
      ]);
    });

  });

  describe("#saveClients()", function () {
    before(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns('StackServiceComponent');
      sinon.stub(controller, 'getClientsToInstall').returns(['client']);
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    after(function () {
      controller.setDBProperty.restore();
      App.StackServiceComponent.find.restore();
      controller.getClientsToInstall.restore();
    });
    it("", function () {
      controller.set('content.services', [Em.Object.create({'isSelected': true, 'isInstallable': true})]);
      controller.saveClients();
      expect(controller.getClientsToInstall.calledWith(
        [Em.Object.create({'isSelected': true, 'isInstallable': true})],
        'StackServiceComponent'
      )).to.be.true;
      expect(controller.setDBProperty.calledWith('clientInfo', ['client'])).to.be.true;
      expect(controller.get('content.clients')).to.be.eql(['client']);
    });
  });

  describe("#getClientsToInstall()", function () {
    var testCases = [
      {
        title: 'No services',
        data: {
          services: [],
          components: []
        },
        result: []
      },
      {
        title: 'No components',
        data: {
          services: [
            {}
          ],
          components: []
        },
        result: []
      },
      {
        title: 'Component is not client',
        data: {
          services: [Em.Object.create({serviceName: 'S1'})],
          components: [Em.Object.create({serviceName: 'S1'})]
        },
        result: []
      },
      {
        title: 'Component is not client',
        data: {
          services: [Em.Object.create({serviceName: 'S1'})],
          components: [Em.Object.create({serviceName: 'S1', isClient: false})]
        },
        result: []
      },
      {
        title: 'Component is client',
        data: {
          services: [Em.Object.create({serviceName: 'S1'})],
          components: [Em.Object.create({
            serviceName: 'S1',
            isClient: true,
            componentName: 'C1',
            displayName: 'C1'
          })]
        },
        result: [
          {
            component_name: 'C1',
            display_name: 'C1',
            isInstalled: false
          }
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.getClientsToInstall(test.data.services, test.data.components)).to.eql(test.result);
      });
    });
  });

  describe("#applyConfigGroup()", function () {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it("No config groups", function () {
      controller.set('content.configGroups', []);
      controller.applyConfigGroup();
      expect(App.ajax.send.called).to.be.false;
    });
    it("selectedConfigGroup absent", function () {
      controller.set('content.configGroups', [
        {
          configGroups: [],
          selectedConfigGroup: ''
        }
      ]);
      controller.applyConfigGroup();
      expect(App.ajax.send.called).to.be.false;
    });
    it("selectedConfigGroup present", function () {
      controller.set('content.configGroups', [
        {
          configGroups: [
            {
              ConfigGroup: {
                id: 1,
                group_name: 'G1',
                hosts: []
              }
            }
          ],
          selectedConfigGroup: 'G1',
          hosts: ['host1']
        }
      ]);
      controller.applyConfigGroup();

      expect(App.ajax.send.getCall(0).args[0].name).to.equal('config_groups.update_config_group');
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        "id": 1,
        "configGroup": {
          "ConfigGroup": {
            "id": 1,
            "group_name": "G1",
            "hosts": [
              {
                "host_name": "host1"
              }
            ]
          }
        }
      });
    });
  });

  describe("#getServiceConfigGroups()", function () {
    before(function () {
      sinon.stub(controller, 'getDBProperty').withArgs('serviceConfigGroups').returns(['serviceConfigGroup']);
    });
    after(function () {
      controller.getDBProperty.restore();
    });
    it("", function () {
      controller.getServiceConfigGroups();
      expect(controller.get('content.configGroups')).to.eql(['serviceConfigGroup']);
    });
  });

  describe("#saveServiceConfigGroups()", function () {
    before(function () {
      sinon.stub(controller, 'setDBProperty', Em.K);
    });
    after(function () {
      controller.setDBProperty.restore();
    });
    it("call setDBProperty()", function () {
      controller.set('content.configGroups', [
        {}
      ]);
      controller.saveServiceConfigGroups();
      expect(controller.setDBProperty.calledWith('serviceConfigGroups', [
        {}
      ])).to.be.true;
    });
  });

  describe("#loadServiceConfigGroups()", function () {
    before(function () {
      sinon.stub(controller, 'loadServiceConfigGroupsBySlaves', Em.K);
      sinon.stub(controller, 'loadServiceConfigGroupsByClients', Em.K);
      sinon.stub(controller, 'sortServiceConfigGroups', Em.K);
    });
    after(function () {
      controller.loadServiceConfigGroupsBySlaves.restore();
      controller.loadServiceConfigGroupsByClients.restore();
      controller.sortServiceConfigGroups.restore();
    });
    it("", function () {
      controller.loadServiceConfigGroups();
      expect(controller.loadServiceConfigGroupsByClients.calledWith([])).to.be.true;
      expect(controller.loadServiceConfigGroupsBySlaves.calledWith([])).to.be.true;
      expect(controller.sortServiceConfigGroups.calledWith([])).to.be.true;
      expect(controller.get('content.configGroups')).to.eql([]);
    });
  });

  describe("#sortServiceConfigGroups", function () {
    var testCases = [
      {
        title: 'sorted',
        selectedServices: [
          {
            configGroups: [
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              },
              {
                ConfigGroup: {
                  group_name: 'b'
                }
              }
            ]
          }
        ],
        result: ['a', 'b']
      },
      {
        title: 'not sorted',
        selectedServices: [
          {
            configGroups: [
              {
                ConfigGroup: {
                  group_name: 'b'
                }
              },
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              }
            ]
          }
        ],
        result: ['a', 'b']
      },
      {
        title: 'sort equal',
        selectedServices: [
          {
            configGroups: [
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              },
              {
                ConfigGroup: {
                  group_name: 'a'
                }
              }
            ]
          }
        ],
        result: ['a', 'a']
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.sortServiceConfigGroups(test.selectedServices);
        expect(test.selectedServices[0].configGroups.mapProperty('ConfigGroup.group_name')).to.eql(test.result);
      });
    });
  });

  describe("#loadServiceConfigGroupsBySlaves()", function () {
    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.Object.create({
        stackService: Em.Object.create({
          serviceName: 'S1',
          displayName: 's1'
        })
      }));
      controller.set('content.configGroups', [
        {
          ConfigGroup: {
            tag: 'S1',
            group_name: 'G1'
          }
        }
      ]);
    });
    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });
    it("slaveComponentHosts is empty", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', []);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("slaveComponentHosts has ho hosts", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {hosts: []}
      ]);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.true;
      expect(selectedServices).to.be.empty;
    });
    it("slaveComponentHosts is CLIENT", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          hosts: [
            {hostName: 'host1'}
          ],
          componentName: 'CLIENT'
        }
      ]);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.true;
      expect(selectedServices).to.be.empty;
    });
    it("slaveComponentHosts is slave", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          hosts: [
            {hostName: 'host1'}
          ],
          componentName: 'C1'
        },
        {
          hosts: [
            {hostName: 'host2'}
          ],
          componentName: 'C2'
        }
      ]);
      expect(controller.loadServiceConfigGroupsBySlaves(selectedServices)).to.be.true;
      expect(selectedServices.toArray()).to.eql([
        {
          "serviceId": "S1",
          "displayName": "s1",
          "hosts": [
            "host1",
            "host2"
          ],
          "configGroupsNames": [
            "Default",
            "G1"
          ],
          "configGroups": [
            {
              "ConfigGroup": {
                "tag": "S1",
                "group_name": "G1"
              }
            }
          ],
          "selectedConfigGroup": "Default"
        }
      ]);
    });
  });

  describe("#loadServiceConfigGroupsByClients()", function () {
    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.Object.create({
        stackService: Em.Object.create({
          serviceName: 'S1',
          displayName: 's1'
        })
      }));
      sinon.stub(controller, 'loadClients', Em.K);
      controller.set('content.configGroups', [
        {
          ConfigGroup: {
            tag: 'S1',
            group_name: 'G1'
          }
        }
      ]);
    });
    afterEach(function () {
      controller.loadClients.restore();
      App.StackServiceComponent.find.restore();
    });
    it("Clients is null", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', null);
      controller.set('content.clients', null);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("No CLIENT component", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', []);
      controller.set('content.clients', []);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("Clients is empty", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: []
        }
      ]);
      controller.set('content.clients', []);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("Client component does not have hosts", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: []
        }
      ]);
      controller.set('content.clients', [
        {}
      ]);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.false;
      expect(selectedServices).to.be.empty;
    });
    it("Client present, selectedServices is empty", function () {
      var selectedServices = [];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: [
            {hostName: 'host1'}
          ]
        }
      ]);
      controller.set('content.clients', [
        {
          component_name: 'C1'
        }
      ]);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.true;
      expect(selectedServices).to.be.eql([
        {
          "serviceId": "S1",
          "displayName": "s1",
          "hosts": [
            "host1"
          ],
          "configGroupsNames": [
            "Default",
            "G1"
          ],
          "configGroups": [
            {
              "ConfigGroup": {
                "tag": "S1",
                "group_name": "G1"
              }
            }
          ],
          "selectedConfigGroup": "Default"
        }
      ]);
    });
    it("Client present, selectedServices has service", function () {
      var selectedServices = [
        {
          serviceId: 'S1',
          hosts: ['host1', 'host2']
        }
      ];
      controller.set('content.slaveComponentHosts', [
        {
          componentName: 'CLIENT',
          hosts: [
            {hostName: 'host1'}
          ]
        }
      ]);
      controller.set('content.clients', [
        {
          component_name: 'C1'
        }
      ]);

      expect(controller.loadServiceConfigGroupsByClients(selectedServices)).to.be.true;
      expect(selectedServices[0].hosts).to.be.eql(["host1", "host2"]);
    });
  });

  describe("#loadServiceConfigProperties()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.db, 'get');
      this.mock.withArgs('Installer', 'serviceConfigProperties').returns([1]);
    });
    afterEach(function () {
      this.mock.restore();
    });
    it("serviceConfigProperties is null", function () {
      this.mock.withArgs('AddService', 'serviceConfigProperties').returns(null);
      controller.loadServiceConfigProperties();
      expect(controller.get('content.serviceConfigProperties')).to.eql([1]);
    });
    it("serviceConfigProperties is empty", function () {
      this.mock.withArgs('AddService', 'serviceConfigProperties').returns([]);
      controller.loadServiceConfigProperties();
      expect(controller.get('content.serviceConfigProperties')).to.eql([1]);
    });
    it("serviceConfigProperties has data", function () {
      this.mock.withArgs('AddService', 'serviceConfigProperties').returns([1]);
      controller.loadServiceConfigProperties();
      expect(controller.get('content.serviceConfigProperties')).to.eql([1]);
    });
  });

  describe("#loadAllPriorSteps()", function () {
    var stepsSet = {
      '1': [
        {
          name: 'load',
          args: ['hosts']
        },
        {
          name: 'load',
          args: ['installOptions']
        },
        {
          name: 'load',
          args: ['cluster']
        }
      ],
      '2': [
        {
          name: 'loadServices',
          args: []
        }
      ],
      '3': [
        {
          name: 'loadClients',
          args: []
        },
        {
          name: 'loadServices',
          args: []
        },
        {
          name: 'loadMasterComponentHosts',
          args: []
        },
        {
          name: 'loadSlaveComponentHosts',
          args: []
        },
        {
          name: 'load',
          args: ['hosts']
        }
      ],
      '5': [
        {
          name: 'loadServiceConfigProperties',
          args: []
        },
        {
          name: 'getServiceConfigGroups',
          args: []
        }
      ]
    };
    var testCases = [
      {
        currentStep: '0',
        calledFunctions: []
      },
      {
        currentStep: '1',
        calledFunctions: stepsSet['1']
      },
      {
        currentStep: '2',
        calledFunctions: stepsSet['1'].concat(stepsSet['2'])
      },
      {
        currentStep: '3',
        calledFunctions: stepsSet['3'].concat(stepsSet['2'], stepsSet['1'])
      },
      {
        currentStep: '4',
        calledFunctions: stepsSet['3'].concat(stepsSet['2'], stepsSet['1'])
      },
      {
        currentStep: '5',
        calledFunctions: stepsSet['5'].concat(stepsSet['3'], stepsSet['2'], stepsSet[1])
      },
      {
        currentStep: '6',
        calledFunctions: stepsSet['5'].concat(stepsSet['3'], stepsSet['2'], stepsSet[1])
      },
      {
        currentStep: '7',
        calledFunctions: stepsSet['5'].concat(stepsSet['3'], stepsSet['2'], stepsSet[1])
      },
      {
        currentStep: '8',
        calledFunctions: []
      }
    ];
    var functionsToCall = [
      'loadServiceConfigProperties',
      'getServiceConfigGroups',
      'loadClients',
      'loadServices',
      'loadMasterComponentHosts',
      'loadSlaveComponentHosts',
      'load'
    ];
    beforeEach(function () {
      this.mock = sinon.stub(controller, 'get');
      sinon.stub(controller, 'loadServiceConfigProperties', Em.K);
      sinon.stub(controller, 'getServiceConfigGroups', Em.K);
      sinon.stub(controller, 'loadClients', Em.K);
      sinon.stub(controller, 'loadServices', Em.K);
      sinon.stub(controller, 'loadMasterComponentHosts', Em.K);
      sinon.stub(controller, 'loadSlaveComponentHosts', Em.K);
      sinon.stub(controller, 'load', Em.K);
      sinon.stub(controller, 'saveClusterStatus', Em.K);
    });
    afterEach(function () {
      this.mock.restore();
      controller.loadServiceConfigProperties.restore();
      controller.getServiceConfigGroups.restore();
      controller.loadClients.restore();
      controller.loadServices.restore();
      controller.loadMasterComponentHosts.restore();
      controller.loadSlaveComponentHosts.restore();
      controller.load.restore();
      controller.saveClusterStatus.restore();
    });
    testCases.forEach(function (test) {
      it("current step - " + test.currentStep, function () {
        this.mock.returns(test.currentStep);
        controller.loadAllPriorSteps();
        functionsToCall.forEach(function (fName) {
          var callStack = test.calledFunctions.filterProperty('name', fName);
          if (callStack.length > 0) {
            callStack.forEach(function (f, index) {
              expect(controller[f.name].getCall(index).args).to.eql(f.args);
            }, this);
          } else {
            expect(controller[fName].called).to.be.false;
          }
        }, this);
      });
    }, this);
  });

  describe("#clearAllSteps()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearInstallOptions', Em.K);
      sinon.stub(controller, 'getCluster').returns({});
    });
    afterEach(function () {
      controller.clearInstallOptions.restore();
      controller.getCluster.restore();
    });
    it("", function () {
      controller.clearAllSteps();
      expect(controller.getCluster.calledOnce).to.be.true;
      expect(controller.clearInstallOptions.calledOnce).to.be.true;
      expect(controller.get('content.cluster')).to.eql({});
    });
  });

  describe("#clearStorageData()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'resetDbNamespace', Em.K);
    });
    afterEach(function () {
      controller.resetDbNamespace.restore();
    });
    it("launch resetDbNamespace", function () {
      controller.clearStorageData();
      expect(controller.resetDbNamespace.calledOnce).to.be.true;
    });
  });

  describe("#finish()", function () {
    var mock = {
      updateAll: Em.K,
      getAllHostNames: Em.K
    };
    beforeEach(function () {
      sinon.stub(controller, 'clearAllSteps', Em.K);
      sinon.stub(controller, 'clearStorageData', Em.K);
      sinon.stub(App.updater, 'immediateRun', Em.K);
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'updateAll');
      sinon.spy(mock, 'getAllHostNames');
    });
    afterEach(function () {
      controller.clearAllSteps.restore();
      controller.clearStorageData.restore();
      App.updater.immediateRun.restore();
      App.router.get.restore();
      mock.updateAll.restore();
      mock.getAllHostNames.restore();
    });
    it("", function () {
      controller.finish();
      expect(controller.clearAllSteps.calledOnce).to.be.true;
      expect(controller.clearStorageData.calledOnce).to.be.true;
      expect(mock.updateAll.calledOnce).to.be.true;
      expect(App.updater.immediateRun.calledWith('updateHost')).to.be.true;
      expect(mock.getAllHostNames.calledOnce).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/host/configs_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/configs_service');


describe('App.MainHostServiceConfigsController', function () {

  var controller = App.MainHostServiceConfigsController.create({
    host: Em.Object.create()
  });


  describe('#filterServiceConfigs()', function () {
    var testCases = [
      {
        title: 'configCategories is empty',
        content: {
          configCategories: [],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Category hostComponentNames is null',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: null})
          ],
          hostComponents: []
        },
        result: [
          Em.Object.create({hostComponentNames: null})
        ]
      },
      {
        title: 'Components of host are empty',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: []
        },
        result: []
      },
      {
        title: 'Host components do not match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp2'
            }
          ]
        },
        result: []
      },
      {
        title: 'Host components match component of categories',
        content: {
          configCategories: [
            Em.Object.create({hostComponentNames: ['comp1']})
          ],
          hostComponents: [
            {
              componentName: 'comp1'
            }
          ]
        },
        result: [
          Em.Object.create({hostComponentNames: ['comp1']})
        ]
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('host.hostComponents', test.content.hostComponents);
        expect(controller.filterServiceConfigs(test.content.configCategories)).to.eql(test.result);
      });
    });
  });

	describe("#loadStep()", function () {
    beforeEach(function() {
      sinon.stub(controller, 'loadCurrentVersions', Em.K);
    });
    afterEach(function() {
      controller.loadCurrentVersions.restore();
    });
		it("should set host", function () {
			controller.set('content', {
				host: 'host1',
        dependentServiceNames: []
			});
			controller.loadStep();
			expect(controller.get('host')).to.be.equal('host1');
		});
	});

	describe("#renderServiceConfigs()", function () {
		it("should call filterServiceConfigs", function () {
			var serviceConfigs = {
				configCategories: 'val'
			};
			sinon.stub(controller, 'filterServiceConfigs', function () {
				this._super = Em.K;
			});
			controller.renderServiceConfigs(serviceConfigs);

			expect(controller.filterServiceConfigs.calledWith('val')).to.be.true;
			controller.filterServiceConfigs.restore();
		});
	});

	describe("#switchHostGroup()", function () {

    beforeEach(function() {
      sinon.stub(controller, 'launchSwitchConfigGroupOfHostDialog', Em.K);
      });

    afterEach(function () {
      controller.launchSwitchConfigGroupOfHostDialog.restore();
    });

		it("should call launchSwitchConfigGroupOfHostDialog", function () {
			controller.set('selectedConfigGroup', {});
			controller.set('configGroups', []);
			controller.set('host', {hostName: 'host1'});
			controller.switchHostGroup();

			expect(controller.launchSwitchConfigGroupOfHostDialog.calledWith({}, [], 'host1')).to.be.true;
		});
	});

});

});

;require.register("test/controllers/main/host/details_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('controllers/main/host/details');
require('models/service');
require('models/host_component');
require('models/host_stack_version');
var batchUtils = require('utils/batch_scheduled_requests');
var hostsManagement = require('utils/hosts');
var controller;

describe('App.MainHostDetailsController', function () {


  beforeEach(function () {
    sinon.stub(App.ajax, 'send').returns({
      then: Em.K,
      complete: Em.K
    });
    controller = App.MainHostDetailsController.create(App.InstallComponent, {
      content: Em.Object.create()
    });
  });
  afterEach(function () {
    App.ajax.send.restore();
  });

  describe('#routeHome()', function () {
    it('transiotion to dashboard', function () {
      sinon.stub(App.router, 'transitionTo', Em.K);
      controller.routeHome();
      expect(App.router.transitionTo.calledWith('main.dashboard.index')).to.be.true;
      App.router.transitionTo.restore();
    });
  });

  describe('#startComponent()', function () {
    it('call sendComponentCommand', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'comp'
        })
      };
      sinon.stub(App, 'showConfirmationPopup', function (callback) {
        callback();
      });
      sinon.stub(controller, 'sendComponentCommand');
      controller.startComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      expect(controller.sendComponentCommand.calledWith(Em.Object.create({
        displayName: 'comp'
      })), Em.I18n.t('requestInfo.startHostComponent') + " comp", App.HostComponentStatus.started).to.be.true;
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
    });
  });

  describe('#stopComponent()', function () {
    it('call sendComponentCommand', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'comp'
        })
      };
      sinon.stub(App, 'showConfirmationPopup', function (callback) {
        callback();
      });
      sinon.stub(controller, 'sendComponentCommand');
      controller.stopComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      expect(controller.sendComponentCommand.calledWith(Em.Object.create({
        displayName: 'comp'
      })), Em.I18n.t('requestInfo.stopHostComponent') + " comp", App.HostComponentStatus.started).to.be.true;
      App.showConfirmationPopup.restore();
      controller.sendComponentCommand.restore();
    });

    it('stop NN, should check last NN checkpoint before stop', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'NameNode',
          componentName: 'NAMENODE'
        })
      };
      sinon.stub(controller, 'checkNnLastCheckpointTime', function() {
        return true;
      });
      controller.stopComponent(event);
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      controller.checkNnLastCheckpointTime.restore();
    });
  });

  describe('#sendComponentCommand()', function () {
    it('single component', function () {
      controller.set('content.hostName', 'host1');
      var component = Em.Object.create({
        service: {serviceName: 'S1'},
        componentName: 'COMP1'
      });

      controller.sendComponentCommand(component, {}, 'state');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.host.host_component.update');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        "hostName": "host1",
        "context": {},
        "component": Em.Object.create({
          service: {serviceName: 'S1'},
          componentName: 'COMP1'
        }),
        "HostRoles": {
          "state": "state"
        },
        "componentName": "COMP1",
        "serviceName": "S1"
      });
    });
    it('multiple component', function () {
      controller.set('content.hostName', 'host1');
      var component = [
        Em.Object.create({
          service: {serviceName: 'S1'},
          componentName: 'COMP1'
        }),
        Em.Object.create({
          service: {serviceName: 'S1'},
          componentName: 'COMP2'
        })
      ];

      controller.sendComponentCommand(component, {}, 'state');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.host.host_components.update');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        "hostName": "host1",
        "context": {},
        "component": [
          Em.Object.create({
            service: {serviceName: 'S1'},
            componentName: 'COMP1'
          }),
          Em.Object.create({
            service: {serviceName: 'S1'},
            componentName: 'COMP2'
          })
        ],
        "HostRoles": {
          "state": "state"
        },
        "query": "HostRoles/component_name.in(COMP1,COMP2)"
      });
    });
  });

  describe('#sendComponentCommandSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
      controller.mimicWorkStatusChange.restore();
    });
    it('testMode, starting component', function () {
      var params = {
        component: Em.Object.create({}),
        HostRoles: {
          state: App.HostComponentStatus.started
        }
      };

      App.set('testMode', true);
      controller.sendComponentCommandSuccessCallback({}, {}, params);
      expect(controller.mimicWorkStatusChange.calledWith(Em.Object.create({
        workStatus: App.HostComponentStatus.starting
      }), App.HostComponentStatus.starting, App.HostComponentStatus.started)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode, stopping component', function () {
      var params = {
        component: Em.Object.create({}),
        HostRoles: {
          state: App.HostComponentStatus.stopped
        }
      };

      App.set('testMode', true);
      controller.sendComponentCommandSuccessCallback({}, {}, params);
      expect(controller.mimicWorkStatusChange.calledWith(Em.Object.create({
        workStatus: App.HostComponentStatus.stopping
      }), App.HostComponentStatus.stopping, App.HostComponentStatus.stopped)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode, stopping component', function () {
      var params = {
        component: Em.Object.create({}),
        HostRoles: {
          state: App.HostComponentStatus.stopped
        }
      };

      App.set('testMode', false);
      controller.sendComponentCommandSuccessCallback({}, {}, params);
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#ajaxErrorCallback()', function () {
    it('call mainServiceItemController.ajaxErrorCallback', function () {
      sinon.stub(controller, 'ajaxErrorCallback', Em.K);
      controller.ajaxErrorCallback('request', 'ajaxOptions', 'error', 'opt', 'params');
      expect(controller.ajaxErrorCallback.calledWith('request', 'ajaxOptions', 'error', 'opt', 'params')).to.be.true;
      controller.ajaxErrorCallback.restore();
    });
  });

  describe('#showBackgroundOperationsPopup()', function () {
    var mock = {
      done: function (callback) {
        callback(this.initValue);
      }
    };
    var bgController = {
      showPopup: Em.K
    };
    beforeEach(function () {
      var stub = sinon.stub(App.router, 'get');
      stub.withArgs('userSettingsController').returns({
        dataLoading: function () {
          return mock;
        }
      });
      stub.withArgs('backgroundOperationsController').returns(bgController);
      sinon.spy(bgController, 'showPopup');
      sinon.spy(mock, 'done');
    });
    afterEach(function () {
      bgController.showPopup.restore();
      mock.done.restore();
      App.router.get.restore();
    });
    it('initValue is true, callback is undefined', function () {
      mock.initValue = true;
      controller.showBackgroundOperationsPopup();
      expect(mock.done.calledOnce).to.be.true;
      expect(bgController.showPopup.calledOnce).to.be.true;
    });
    it('initValue is false, callback is defined', function () {
      mock.initValue = false;
      var callback = sinon.stub();
      controller.showBackgroundOperationsPopup(callback);
      expect(mock.done.calledOnce).to.be.true;
      expect(bgController.showPopup.calledOnce).to.be.false;
      expect(callback.calledOnce).to.be.true;
    });
  });


  describe('#serviceActiveComponents', function () {

    it('No host-components', function () {
      controller.set('content', {hostComponents: []});
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });

    it('No host-components in active state', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          service: {
            isInPassive: true
          }
        })]
      });
      expect(controller.get('serviceActiveComponents')).to.be.empty;
    });
    it('Host-components in active state', function () {
      controller.set('content', {
        hostComponents: [Em.Object.create({
          service: {
            isInPassive: false
          }
        })]
      });
      expect(controller.get('serviceActiveComponents')).to.eql([Em.Object.create({
        service: {
          isInPassive: false
        }
      })]);
    });
  });

  describe('#serviceNonClientActiveComponents', function () {

    it('No active host-components', function () {
      controller.reopen({
        serviceActiveComponents: []
      });
      controller.set('serviceActiveComponents', []);
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });

    it('Active host-component is client', function () {
      controller.reopen({
        serviceActiveComponents: [Em.Object.create({
          isClient: true
        })]
      });
      expect(controller.get('serviceNonClientActiveComponents')).to.be.empty;
    });
    it('Active host-component is not client', function () {
      controller.reopen({
        serviceActiveComponents: [Em.Object.create({
          isClient: false
        })]
      });
      expect(controller.get('serviceNonClientActiveComponents')).to.eql([Em.Object.create({
        isClient: false
      })]);
    });
  });

  describe.skip('#deleteComponent()', function () {

    var jQueryMock,
      cases = [
        {
          isDisabled: false,
          showCallCount: 1,
          title: 'confirm popup should be displayed'
        },
        {
          isDisabled: true,
          showCallCount: 0,
          title: 'confirm popup shouldn\'t be displayed'
        }
      ];

    beforeEach(function () {
      jQueryMock = sinon.stub(window, '$');
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(controller, '_doDeleteHostComponent', Em.K);
    });

    afterEach(function () {
      window.$.restore();
      App.ModalPopup.show.restore();
      controller._doDeleteHostComponent.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        jQueryMock.returns({
          closest: function () {
            return {
              hasClass: function () {
                return item.isDisabled;
              }
            }
          }
        });
        var event = {
            context: Em.Object.create({})
          },
          popup = controller.deleteComponent(event);
        expect(App.ModalPopup.show.callCount).to.equal(item.showCallCount);
        if (item.showCallCount) {
          popup.onPrimary();
          expect(controller._doDeleteHostComponent.calledWith(Em.Object.create({}))).to.be.true;
        }
      });
    });

  });

  describe('#mimicWorkStatusChange()', function () {

    var clock;
    beforeEach(function () {
      clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      clock.restore();
    });

    it('change status of object', function () {
      var entity = Em.Object.create({
        workStatus: ''
      });
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity.get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity.get('workStatus')).to.equal('STATE2');
    });
    it('change status of objects in array', function () {
      var entity = [Em.Object.create({
        workStatus: ''
      })];
      controller.mimicWorkStatusChange(entity, 'STATE1', 'STATE2');
      expect(entity[0].get('workStatus')).to.equal('STATE1');
      clock.tick(App.testModeDelayForActions);
      expect(entity[0].get('workStatus')).to.equal('STATE2');
    });
  });

  describe('#upgradeComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('confirm popup should be displayed', function () {
      var popup = controller.upgradeComponent({context: Em.Object.create()});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#restartComponent()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.restartComponent({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledOnce).to.be.true;
    });

    it('restart NN, should check last NN checkpoint before restart', function () {
      var event = {
        context: Em.Object.create({
          displayName: 'NameNode',
          componentName: 'NAMENODE'
        })
      };
      sinon.stub(controller, 'checkNnLastCheckpointTime', function() {
        return true;
      });
      controller.restartComponent(event);
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      controller.checkNnLastCheckpointTime.restore();
    });
  });

  describe('#securityEnabled', function () {
    it('', function () {
      sinon.stub(App.router, 'get').withArgs('mainAdminSecurityController.securityEnabled').returns(true);

      controller.propertyDidChange('securityEnabled');
      expect(controller.get('securityEnabled')).to.be.true;
      App.router.get.restore();
    });
  });


  describe('#addComponent()', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "addClientComponent", Em.K);
      sinon.stub(controller, "installHostComponentCall", Em.K);
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: "HDFS_CLIENT"
        })]
      });
      controller.reopen({
        securityEnabled: false
      });
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.addClientComponent.restore();
      controller.installHostComponentCall.restore();
    });

    it('add ZOOKEEPER_SERVER', function () {
      var event = {
        context: Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER'
        })
      };
      controller.addComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
    it('add WEBHCAT_SERVER', function () {
      var event = {
        context: Em.Object.create({
          componentName: 'WEBHCAT_SERVER'
        })
      };
      controller.addComponent(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
    it('add slave component', function () {
      var event = {
        context: Em.Object.create({
          componentName: 'HIVE_CLIENT'
        })
      };
      controller.set('securityEnabled', false);
      controller.addComponent(event);
      expect(controller.addClientComponent.calledWith(Em.Object.create({
        componentName: 'HIVE_CLIENT'
      }))).to.be.true;
    });
  });

  describe('#formatClientsMessage()', function () {
    var testCases = [
      {
        title: 'subComponentNames is null',
        client: Em.Object.create({
          subComponentNames: null,
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS'
      },
      {
        title: 'subComponentNames is empty',
        client: Em.Object.create({
          subComponentNames: [],
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS'
      },
      {
        title: 'displayName is null',
        client: Em.Object.create({
          subComponentNames: ['DATANODE'],
          displayName: null
        }),
        result: ' (DataNode)'
      },
      {
        title: 'displayName is CLIENTS',
        client: Em.Object.create({
          subComponentNames: ['DATANODE'],
          displayName: 'CLIENTS'
        }),
        result: 'CLIENTS (DataNode)'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(controller.formatClientsMessage(test.client)).to.equal(test.result);
      });
    });
  });

  describe('#addClientComponent()', function () {

    var component = Em.Object.create({
      componentName: ' Comp1'
    });

    beforeEach(function () {
      sinon.stub(controller, 'showAddComponentPopup', Em.K);
    });

    afterEach(function () {
      controller.showAddComponentPopup.restore();
    });

    it('any CLIENT component', function () {
      var popup = controller.addClientComponent(component);
      expect(controller.showAddComponentPopup.calledOnce).to.be.true;
    });

  });

  describe('#showAddComponentPopup()', function () {

    var message = 'Comp1',
      component = Em.Object.create({
        componentName: ' Comp1'
      });

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should display add component confirmation', function () {
      var popup = controller.showAddComponentPopup(message, false, Em.K);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(popup.get('addComponentMsg')).to.eql(Em.I18n.t('hosts.host.addComponent.msg').format(message));
    });
  });

  describe('#installNewComponentSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data is null', function () {
      var data = {Requests: null};
      expect(controller.installNewComponentSuccessCallback(null, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests is null', function () {
      var data = {Requests: null};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is null', function () {
      var data = {Requests: {id: null}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {})).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data.Requests.id is correct', function () {
      var data = {Requests: {id: 1}};
      expect(controller.installNewComponentSuccessCallback(data, {}, {component: []})).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshComponentConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "sendRefreshComponentConfigsCommand", Em.K);
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.sendRefreshComponentConfigsCommand.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.refreshComponentConfigs({context: Em.Object.create({'displayName': 'Comp1'})});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendRefreshComponentConfigsCommand.calledOnce).to.be.true;
    });
  });

  describe('#sendRefreshComponentConfigsCommand()', function () {
    it('Query should be sent', function () {
      var component = Em.Object.create({
        service: {},
        componentName: 'COMP1',
        host: {}
      });
      controller.sendRefreshComponentConfigsCommand(component, {});
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#loadConfigs()', function () {
    it('Query should be sent', function () {
      controller.loadConfigs();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#constructConfigUrlParams()', function () {

    it('URL params should be empty', function () {
      var data = {};
      App.Service.find().clear();
      expect(controller.constructConfigUrlParams(data)).to.eql([]);
    });
    it('isHaEnabled = true', function () {
      App.store.load(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      var data = {Clusters: {desired_configs: {'core-site': {tag: 1}}}};
      App.HostComponent.find().clear();
      App.propertyDidChange('isHaEnabled');
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=core-site&tag=1)']);
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE_host1',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.set('currentStackVersion', 'HDP-2.0.1');
    });
    it('HBASE is installed', function () {
      App.store.load(App.Service, {
        id: 'HBASE',
        service_name: 'HBASE'
      });
      App.propertyDidChange('isHaEnabled');
      var data = {Clusters: {desired_configs: {'hbase-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=hbase-site&tag=1)']);
      App.Service.find().clear();
    });
    it('HIVE is installed', function () {
      App.store.load(App.Service, {
        id: 'HIVE',
        service_name: 'HIVE'
      });
      var data = {Clusters: {desired_configs: {'webhcat-site': {tag: 1}, 'hive-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=webhcat-site&tag=1)', '(type=hive-site&tag=1)']);
      App.Service.find().clear();
    });
    it('STORM is installed', function () {
      App.store.load(App.Service, {
        id: 'STORM',
        service_name: 'STORM'
      });
      var data = {Clusters: {desired_configs: {'storm-site': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=storm-site&tag=1)']);
      App.Service.find().clear();
    });
    it('YARN for 2.2 stack is installed', function () {
      App.set('currentStackVersion', 'HDP-2.2.0');
      App.store.load(App.Service, {
        id: 'YARN',
        service_name: 'YARN'
      });
      var data = {Clusters: {desired_configs: {'yarn-site': {tag: 1}, 'zoo.cfg': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=yarn-site&tag=1)', '(type=zoo.cfg&tag=1)']);
      App.set('currentStackVersion', 'HDP-2.0.1');
      App.Service.find().clear();
    });
    it('isRMHaEnabled true', function () {
      sinon.stub(App, 'get').withArgs('isRMHaEnabled').returns(true);
      var data = {Clusters: {desired_configs: {'yarn-site': {tag: 1}, 'zoo.cfg': {tag: 1}}}};
      expect(controller.constructConfigUrlParams(data)).to.eql(['(type=yarn-site&tag=1)', '(type=zoo.cfg&tag=1)']);
      App.get.restore();
    });
  });

  describe('#loadConfigsSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "constructConfigUrlParams", function () {
        return this.get('mockUrlParams');
      });
    });
    afterEach(function () {
      controller.constructConfigUrlParams.restore();
    });

    it('url params is empty', function () {
      controller.set('mockUrlParams', []);
      expect(controller.loadConfigsSuccessCallback()).to.be.false;
      expect(App.ajax.send.called).to.be.false;
    });
    it('url params are correct', function () {
      controller.set('mockUrlParams', ['param1']);
      expect(controller.loadConfigsSuccessCallback()).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#saveZkConfigs()', function () {

    var yarnCases = [
        {
          isYARNInstalled: true,
          isHadoop22Stack: true,
          isRMHaEnabled: true,
          shouldYarnSiteBeModified: true,
          title: 'HDP 2.2, YARN installed, RM HA enabled'
        },
        {
          isYARNInstalled: true,
          isHadoop22Stack: false,
          isRMHaEnabled: true,
          shouldYarnSiteBeModified: true,
          title: 'HDP < 2.2, YARN installed, RM HA enabled'
        },
        {
          isYARNInstalled: true,
          isHadoop22Stack: true,
          isRMHaEnabled: false,
          shouldYarnSiteBeModified: true,
          title: 'HDP 2.2, YARN installed, RM HA disabled'
        },
        {
          isYARNInstalled: false,
          isHadoop22Stack: true,
          isRMHaEnabled: false,
          shouldYarnSiteBeModified: false,
          title: 'HDP 2.2, YARN not installed'
        },
        {
          isYARNInstalled: true,
          isHadoop22Stack: false,
          isRMHaEnabled: false,
          shouldYarnSiteBeModified: false,
          title: 'HDP < 2.2, YARN installed, RM HA disabled'
        },
        {
          isYARNInstalled: false,
          isHadoop22Stack: false,
          isRMHaEnabled: false,
          shouldYarnSiteBeModified: false,
          title: 'HDP < 2.2, YARN not installed'
        }
      ],
      yarnData = {
        items: [
          {
            type: 'yarn-site',
            properties: {
              p: 'v'
            }
          }
        ]
      };

    beforeEach(function () {
      sinon.stub(controller, "getZkServerHosts", Em.K);
      sinon.stub(controller, "concatZkNames", Em.K);
      sinon.stub(controller, "setZKConfigs", Em.K);
      sinon.stub(controller, 'saveConfigsBatch', Em.K);
    });
    afterEach(function () {
      controller.getZkServerHosts.restore();
      controller.concatZkNames.restore();
      controller.setZKConfigs.restore();
      controller.saveConfigsBatch.restore();
    });

    it('call saveConfigsBatch()', function () {
      var data = {items: []};
      controller.saveZkConfigs(data);
      expect(controller.saveConfigsBatch.calledOnce).to.be.true;
    });

    yarnCases.forEach(function (item) {
      it(item.title, function () {
        var servicesMock = item.isYARNInstalled ? [
          {
            serviceName: 'YARN'
          }
        ] : [];
        sinon.stub(App, 'get').withArgs('isHadoop22Stack').returns(item.isHadoop22Stack).
          withArgs('isRMHaEnabled').returns(item.isRMHaEnabled);
        sinon.stub(App.Service, 'find').returns(servicesMock);
        controller.saveZkConfigs(yarnData);
        expect(controller.saveConfigsBatch.firstCall.args[0].someProperty('properties.yarn-site')).to.equal(item.shouldYarnSiteBeModified);
        expect(controller.saveConfigsBatch.firstCall.args[0].someProperty('properties_attributes.yarn-site')).to.equal(item.shouldYarnSiteBeModified);
        App.get.restore();
        App.Service.find.restore();
      });
    });

  });

  describe("#saveConfigsBatch()", function () {
    it("no groups", function () {
      controller.saveConfigsBatch([]);
      expect(App.ajax.send.called).to.be.false;
    });
    it("configs is empty", function () {
      controller.saveConfigsBatch([{}]);
      expect(App.ajax.send.called).to.be.false;
    });
    it("configs is correct", function () {
      controller.saveConfigsBatch([{'properties': {'site': {}}, 'properties_attributes': {'site': {}}}]);
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#setZKConfigs()', function () {
    it('configs is null', function () {
      expect(controller.setZKConfigs(null)).to.be.false;
    });
    it('zks is null', function () {
      expect(controller.setZKConfigs({}, '', null)).to.be.false;
    });
    it('isHaEnabled = true', function () {
      var configs = {'core-site': {}};
      App.HostComponent.find().clear();
      App.store.load(App.Service, {
        id: 'HDFS',
        service_name: 'HDFS'
      });
      App.propertyDidChange('isHaEnabled');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({
        "core-site": {
          "ha.zookeeper.quorum": "host1:2181"
        }
      });
      App.store.load(App.HostComponent, {
        id: 'SECONDARY_NAMENODE_host1',
        component_name: 'SECONDARY_NAMENODE'
      });
      App.propertyDidChange('isHaEnabled');
    });
    it('hbase-site is present', function () {
      var configs = {'hbase-site': {}};
      expect(controller.setZKConfigs(configs, '', ['host1', 'host2'])).to.be.true;
      expect(configs).to.eql({
        "hbase-site": {
          "hbase.zookeeper.quorum": "host1,host2"
        }
      });
    });
    it('webhcat-site is present', function () {
      var configs = {'webhcat-site': {}};
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({
        "webhcat-site": {
          "templeton.zookeeper.hosts": "host1:2181"
        }
      });
    });
    it('hive-site is present and stack < 2.2', function () {
      var version = App.get('currentStackVersion');
      var configs = {'hive-site': {}};
      App.set('currentStackVersion', 'HDP-2.1.0');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({
        "hive-site": {
          'hive.cluster.delegation.token.store.zookeeper.connectString': "host1:2181"
        }
      });
      App.set('currentStackVersion', version);
    });
    it('hive-site is present and stack > 2.2', function () {
      var version = App.get('currentStackVersion');
      var configs = {'hive-site': {}};
      App.set('currentStackVersion', 'HDP-2.2.0');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({
        "hive-site": {
          'hive.cluster.delegation.token.store.zookeeper.connectString': "host1:2181",
          'hive.zookeeper.quorum': "host1:2181"
        }
      });
      App.set('currentStackVersion', version);
    });
    it('yarn-site is present and stack > 2.2', function () {
      var version = App.get('currentStackVersion');
      var configs = {'yarn-site': {}};
      App.set('currentStackVersion', 'HDP-2.2.0');
      expect(controller.setZKConfigs(configs, 'host1:2181', [])).to.be.true;
      expect(configs).to.eql({
        "yarn-site": {
          'hadoop.registry.zk.quorum': "host1:2181",
          'yarn.resourcemanager.zk-address': "host1:2181"
        }
      });
      App.set('currentStackVersion', version);
    });
    it('storm-site is present', function () {
      var configs = {'storm-site': {}};
      expect(controller.setZKConfigs(configs, '', ["host1", 'host2'])).to.be.true;
      expect(configs).to.eql({
        "storm-site": {
          "storm.zookeeper.servers": "['host1','host2']"
        }
      });
    });
    it('isRMHaEnabled true', function () {
      var configs = {'yarn-site': {}};
      sinon.stub(App, 'get').withArgs('isRMHaEnabled').returns(true);
      expect(controller.setZKConfigs(configs, 'host1:2181', ['host1', 'host2'])).to.be.true;
      expect(configs).to.eql({
        "yarn-site": {
          "yarn.resourcemanager.zk-address": "host1:2181"
        }
      });
      App.get.restore();
    });
  });

  describe('#concatZkNames()', function () {
    it('No ZooKeeper hosts', function () {
      expect(controller.concatZkNames([])).to.equal('');
    });
    it('One ZooKeeper host', function () {
      expect(controller.concatZkNames(['host1'], '2181')).to.equal('host1:2181');
    });
    it('Two ZooKeeper hosts', function () {
      expect(controller.concatZkNames(['host1', 'host2'], '2181')).to.equal('host1:2181,host2:2181');
    });
  });

  describe('#getZkServerHosts()', function () {

    beforeEach(function () {
      controller.set('content', {});
    });

    afterEach(function () {
      App.HostComponent.find.restore();
    });

    it('No ZooKeeper hosts, fromDeleteHost = false', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return []
      });
      controller.set('fromDeleteHost', false);
      expect(controller.getZkServerHosts()).to.be.empty;
    });

    it('No ZooKeeper hosts, fromDeleteHost = true', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return []
      });
      controller.set('fromDeleteHost', true);
      expect(controller.getZkServerHosts()).to.be.empty;
      expect(controller.get('fromDeleteHost')).to.be.false;
    });

    it('One ZooKeeper host, fromDeleteHost = false', function () {
      controller.set('fromDeleteHost', false);
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'ZOOKEEPER_SERVER_host1',
            componentName: 'ZOOKEEPER_SERVER',
            hostName: 'host1'
          }
        ]
      });
      expect(controller.getZkServerHosts()).to.eql(['host1']);
    });

    it('One ZooKeeper host match current host name, fromDeleteHost = true', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'ZOOKEEPER_SERVER_host1',
            componentName: 'ZOOKEEPER_SERVER',
            hostName: 'host1'
          }
        ]
      });
      controller.set('fromDeleteHost', true);
      controller.set('content.hostName', 'host1');
      expect(controller.getZkServerHosts()).to.be.empty;
      expect(controller.get('fromDeleteHost')).to.be.false;
    });

    it('One ZooKeeper host does not match current host name, fromDeleteHost = true', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'ZOOKEEPER_SERVER_host1',
            componentName: 'ZOOKEEPER_SERVER',
            hostName: 'host1'
          }
        ]
      });
      controller.set('fromDeleteHost', true);
      controller.set('content.hostName', 'host2');
      expect(controller.getZkServerHosts()[0]).to.equal("host1");
      expect(controller.get('fromDeleteHost')).to.be.false;
    });
  });

  describe('#installComponent()', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, "show");
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('popup should be displayed', function () {
      var event = {context: Em.Object.create()};
      var popup = controller.installComponent(event);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.called).to.be.true;
    });
  });

  describe('#decommission()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "runDecommission", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.runDecommission.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.decommission(Em.Object.create({service: {}}));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.runDecommission.calledOnce).to.be.true;
    });
  });

  describe('#recommission()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "runRecommission", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.runRecommission.restore();
    });

    it('popup should be displayed', function () {
      var popup = controller.recommission(Em.Object.create({service: {}}));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.runRecommission.calledOnce).to.be.true;
    });
  });

  describe('#runDecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doDecommission", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });

    afterEach(function () {
      controller.doDecommission.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runDecommission('host1', 'HDFS');
      expect(controller.doDecommission.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
    });
    it('YARN service', function () {
      controller.runDecommission('host1', 'YARN');
      expect(controller.doDecommission.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
    });
    it('HBASE service', function () {
      sinon.stub(controller, 'warnBeforeDecommission', Em.K);
      controller.runDecommission('host1', 'HBASE');
      expect(controller.warnBeforeDecommission.calledWith('host1')).to.be.true;
      controller.warnBeforeDecommission.restore();
    });
  });

  describe('#runRecommission()', function () {

    beforeEach(function () {
      sinon.stub(controller, "doRecommissionAndStart", Em.K);
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });

    afterEach(function () {
      controller.doRecommissionAndStart.restore();
      controller.showBackgroundOperationsPopup.restore();
    });

    it('HDFS service', function () {
      controller.runRecommission('host1', 'HDFS');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HDFS', "NAMENODE", "DATANODE")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('YARN service', function () {
      controller.runRecommission('host1', 'YARN');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'YARN', "RESOURCEMANAGER", "NODEMANAGER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('HBASE service', function () {
      controller.runRecommission('host1', 'HBASE');
      expect(controller.doRecommissionAndStart.calledWith('host1', 'HBASE', "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doDecommission()', function () {
    it('Query should be sent', function () {
      controller.doDecommission('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doDecommissionRegionServer()', function () {
    it('Query should be sent', function () {
      controller.doDecommissionRegionServer('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#warnBeforeDecommission()', function () {
    beforeEach(function () {
      sinon.stub(controller, "showHbaseActiveWarning", Em.K);
      sinon.stub(controller, "checkRegionServerState", Em.K);
    });
    afterEach(function () {
      controller.checkRegionServerState.restore();
      controller.showHbaseActiveWarning.restore();
    });

    it('Component in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'ON'
      })]);
      controller.warnBeforeDecommission('host1');
      expect(controller.checkRegionServerState.calledOnce).to.be.true;
    });
    it('Component is not in passive state', function () {
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'HBASE_REGIONSERVER',
        passiveState: 'OFF'
      })]);
      controller.warnBeforeDecommission('host1');
      expect(controller.showHbaseActiveWarning.calledOnce).to.be.true;
    });
  });

  describe('#checkRegionServerState()', function () {
    it('', function () {
      expect(controller.checkRegionServerState('host1')).to.be.an('object');
      expect(App.ajax.send.getCall(0).args[0].data.hostNames).to.equal('host1');
    });
  });

  describe('#checkRegionServerStateSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, "doDecommissionRegionServer", Em.K);
      sinon.stub(controller, "showRegionServerWarning", Em.K);
    });
    afterEach(function () {
      controller.doDecommissionRegionServer.restore();
      controller.showRegionServerWarning.restore();
    });

    it('Decommission all regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1,host2'});
      expect(controller.showRegionServerWarning.calledOnce).to.be.true;
    });
    it('Decommission one of two regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1'});
      expect(controller.doDecommissionRegionServer.calledWith('host1', "HBASE", "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
    });
    it('Decommission one of three regionservers', function () {
      var data = {
        items: [
          {
            HostRoles: {
              host_name: 'host1'
            }
          },
          {
            HostRoles: {
              host_name: 'host2'
            }
          },
          {
            HostRoles: {
              host_name: 'host3'
            }
          }
        ]
      };
      controller.checkRegionServerStateSuccessCallback(data, {}, {hostNames: 'host1'});
      expect(controller.doDecommissionRegionServer.calledWith('host1', "HBASE", "HBASE_MASTER", "HBASE_REGIONSERVER")).to.be.true;
    });
  });

  describe('#showRegionServerWarning()', function () {
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it('', function () {
      controller.showRegionServerWarning();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#doRecommissionAndStart()', function () {
    it('Query should be sent', function () {
      controller.doRecommissionAndStart('', '', '', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#decommissionSuccessCallback()', function () {

    beforeEach(function () {
      sinon.stub(controller, "showBackgroundOperationsPopup", Em.K);
    });
    afterEach(function () {
      controller.showBackgroundOperationsPopup.restore();
    });

    it('data is null', function () {
      expect(controller.decommissionSuccessCallback(null)).to.be.false;
      expect(controller.showBackgroundOperationsPopup.called).to.be.false;
    });
    it('data has Requests', function () {
      var data = {Requests: []};
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('data has resources', function () {
      var data = {
        resources: [
          {RequestSchedule: {}}
        ]
      };
      expect(controller.decommissionSuccessCallback(data)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#doAction()', function () {

    beforeEach(function () {
      sinon.stub(controller, "validateAndDeleteHost", Em.K);
      sinon.stub(controller, "doStartAllComponents", Em.K);
      sinon.stub(controller, "doStopAllComponents", Em.K);
      sinon.stub(controller, "doRestartAllComponents", Em.K);
      sinon.stub(controller, "onOffPassiveModeForHost", Em.K);
    });

    afterEach(function () {
      controller.validateAndDeleteHost.restore();
      controller.doStartAllComponents.restore();
      controller.doStopAllComponents.restore();
      controller.doRestartAllComponents.restore();
      controller.onOffPassiveModeForHost.restore();
    });

    it('"deleteHost" action', function () {
      var option = {context: {action: "deleteHost"}};
      controller.doAction(option);
      expect(controller.validateAndDeleteHost.calledOnce).to.be.true;
    });

    it('"startAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doStartAllComponents.calledOnce).to.be.true;
    });

    it('"startAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "startAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doStartAllComponents.called).to.be.false;
    });

    it('"stopAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doStopAllComponents.calledOnce).to.be.true;
    });

    it('"stopAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "stopAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doStopAllComponents.called).to.be.false;
    });

    it('"restartAllComponents" action, isNotHeartBeating = false', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content', {isNotHeartBeating: false});
      controller.doAction(option);
      expect(controller.doRestartAllComponents.calledOnce).to.be.true;
    });

    it('"restartAllComponents" action, isNotHeartBeating = true', function () {
      var option = {context: {action: "restartAllComponents"}};
      controller.set('content', {isNotHeartBeating: true});
      controller.doAction(option);
      expect(controller.doRestartAllComponents.called).to.be.false;
    });

    it('"onOffPassiveModeForHost" action', function () {
      var option = {context: {action: "onOffPassiveModeForHost"}};
      controller.doAction(option);
      expect(controller.onOffPassiveModeForHost.calledWith({action: "onOffPassiveModeForHost"})).to.be.true;
    });
  });

  describe('#onOffPassiveModeForHost()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "hostPassiveModeRequest", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.hostPassiveModeRequest.restore();
    });

    it('popup should be displayed, active = true', function () {
      var popup = controller.onOffPassiveModeForHost({active: true});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('ON')).to.be.true;
    });
    it('popup should be displayed, active = false', function () {
      var popup = controller.onOffPassiveModeForHost({active: false});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.hostPassiveModeRequest.calledWith('OFF')).to.be.true;
    });
  });

  describe('#hostPassiveModeRequest()', function () {
    it('Query should be sent', function () {
      controller.hostPassiveModeRequest('', '');
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#doStartAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      controller.reopen({serviceActiveComponents: []});
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('serviceNonClientActiveComponents is empty', function () {
      controller.reopen({
        serviceNonClientActiveComponents: []
      });
      controller.doStartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('serviceNonClientActiveComponents is correct', function () {
      controller.reopen({
        serviceNonClientActiveComponents: [
          {}
        ]
      });
      sinon.stub(controller, 'sendComponentCommand', Em.K);
      var popup = controller.doStartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendComponentCommand.calledWith(
          [
            {}
          ],
          Em.I18n.t('hosts.host.maintainance.startAllComponents.context'),
          App.HostComponentStatus.started)
      ).to.be.true;
      controller.sendComponentCommand.restore();
    });
  });

  describe('#doStopAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      controller.reopen({serviceActiveComponents: []});
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('serviceNonClientActiveComponents is empty', function () {
      controller.reopen({
        serviceNonClientActiveComponents: []
      });
      controller.doStopAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });

    it('serviceNonClientActiveComponents is correct', function () {
      controller.reopen({
        serviceNonClientActiveComponents: [
          {}
        ]
      });
      sinon.stub(controller, 'sendComponentCommand', Em.K);
      var popup = controller.doStopAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.sendComponentCommand.calledWith(
          [
            {}
          ],
          Em.I18n.t('hosts.host.maintainance.stopAllComponents.context'),
          App.HostComponentStatus.stopped)
      ).to.be.true;
      controller.sendComponentCommand.restore();
    });
  });

  describe('#doRestartAllComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('serviceActiveComponents is empty', function () {
      controller.reopen({
        serviceActiveComponents: []
      });
      controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.called).to.be.false;
    });

    it('serviceActiveComponents is correct', function () {
      controller.reopen({
        serviceActiveComponents: [
          {}
        ]
      });
      sinon.stub(batchUtils, 'restartHostComponents', Em.K);

      var popup = controller.doRestartAllComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith(
          [
            {}
          ])
      ).to.be.true;
      batchUtils.restartHostComponents.restore();

    });
  });

  describe('#getHostComponentsInfo()', function () {

    var result = {
      zkServerInstalled: false,
      lastComponents: [],
      masterComponents: [],
      runningComponents: [],
      nonDeletableComponents: [],
      unknownComponents: []
    };

    it('content.hostComponents is null', function () {
      controller.set('content', {hostComponents: null});
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });
    it('content.hostComponents is empty', function () {
      controller.set('content', {hostComponents: []});
      expect(controller.getHostComponentsInfo()).to.eql(result);
    });
    it('content.hostComponents has ZOOKEEPER_SERVER', function () {
      App.HostComponent.find().clear();
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          workStatus: 'INIT',
          isDeletable: true
        })]
      });
      expect(controller.getHostComponentsInfo().zkServerInstalled).to.be.true;
    });
    it('content.hostComponents has last component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          displayName: 'TaskTracker',
          workStatus: 'INIT',
          isDeletable: true
        })]
      });
      expect(controller.getHostComponentsInfo().lastComponents).to.eql(['TaskTracker']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has master non-deletable component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'INIT',
          isDeletable: false,
          isMaster: true,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().masterComponents).to.eql(['ZK1']);
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has running component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'STARTED',
          isDeletable: true,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().runningComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has non-deletable component', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'INIT',
          isDeletable: false,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().nonDeletableComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
    it('content.hostComponents has component with UNKNOWN state', function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return [
          {
            id: 'TASKTRACKER_host1',
            componentName: 'TASKTRACKER'
          }
        ];
      });
      controller.set('content', {
        hostComponents: [Em.Object.create({
          componentName: 'TASKTRACKER',
          workStatus: 'UNKNOWN',
          isDeletable: false,
          displayName: 'ZK1'
        })]
      });
      expect(controller.getHostComponentsInfo().unknownComponents).to.eql(['ZK1']);
      App.HostComponent.find.restore();
    });
  });

  describe('#validateAndDeleteHost()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, "getHostComponentsInfo", function () {
        return this.get('mockHostComponentsInfo');
      });
      sinon.stub(controller, "raiseDeleteComponentsError", Em.K);
      sinon.stub(controller, "confirmDeleteHost", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.getHostComponentsInfo.restore();
      controller.raiseDeleteComponentsError.restore();
      controller.confirmDeleteHost.restore();
    });

    it('masterComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [
          {}
        ]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([
        {}
      ], 'masterList')).to.be.true;
    });
    it('nonDeletableComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [
          {}
        ]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([
        {}
      ], 'nonDeletableList')).to.be.true;
    });
    it('runningComponents exist', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [{}]
      });
      controller.validateAndDeleteHost();
      expect(controller.raiseDeleteComponentsError.calledWith([{}], 'runningList')).to.be.true;
    });
    it('zkServerInstalled = true', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: true
      });
      var popup = controller.validateAndDeleteHost();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.confirmDeleteHost.calledWith([], [])).to.be.true;
    });
    it('zkServerInstalled = false', function () {
      controller.set('mockHostComponentsInfo', {
        masterComponents: [],
        nonDeletableComponents: [],
        runningComponents: [],
        unknownComponents: [],
        lastComponents: [],
        zkServerInstalled: false
      });
      controller.validateAndDeleteHost();
      expect(controller.confirmDeleteHost.calledWith([], [])).to.be.true;
    });
  });

  describe('#raiseDeleteComponentsError()', function () {

    beforeEach(function () {
      sinon.stub(App.ModalPopup, "show", Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('Popup should be displayed', function () {
      controller.raiseDeleteComponentsError([], '');
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#confirmDeleteHost()', function () {
    it('Popup should be displayed', function () {
      sinon.spy(App.ModalPopup, "show");
      sinon.stub(controller, 'doDeleteHost');

      var popup = controller.confirmDeleteHost([], []);
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.doDeleteHost.calledOnce).to.be.true;
      App.ModalPopup.show.restore();
      controller.doDeleteHost.restore();
    });
  });


  describe('#setRackId', function () {
    beforeEach(function () {
      sinon.stub(hostsManagement, 'setRackInfo', Em.K);

    });
    afterEach(function () {
      hostsManagement.setRackInfo.restore();
    });
    it('should call setRackInfo with appropriate arguments', function () {
      var mockedHost = Em.Object.create({
        rack: 'rackId'
      });
      controller.setRackId({
        context: mockedHost
      });
      expect(hostsManagement.setRackInfo.calledWith({message: Em.I18n.t('hosts.host.details.setRackId')}, [mockedHost], 'rackId')).to.be.true;
    });
  });

  describe('#restartAllStaleConfigComponents()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
      sinon.stub(controller, 'checkNnLastCheckpointTime', function(callback){
        callback();
      });
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
      controller.checkNnLastCheckpointTime.restore();
    });

    it('popup should be displayed', function () {
      controller.set('content', {
        componentsWithStaleConfigs: [
          {}
        ]
      });
      var popup = controller.restartAllStaleConfigComponents();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith([
        {}
      ])).to.be.true;
    });

    it('popup ro check NameNode checkpoint should be displayed first', function () {
      controller.set('content.componentsWithStaleConfigs', [Em.Object.create({
        componentName: 'NAMENODE',
        workStatus: 'STARTED'
      })]);
      controller.set('content.hostComponents', [Em.Object.create({
        componentName: 'NAMENODE',
        workStatus: 'STARTED'
      })]);
      controller.restartAllStaleConfigComponents();
      expect(controller.checkNnLastCheckpointTime.calledOnce).to.be.true;
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe.skip('#moveComponent()', function () {

    var jQueryMock,
      mock = {
        saveComponentToReassign: Em.K,
        getSecurityStatus: Em.K,
        setCurrentStep: Em.K
      },
      cases = [
        {
          isDisabled: false,
          showConfirmationPopupCallCount: 1,
          title: 'popup should be displayed'
        },
        {
          isDisabled: true,
          showConfirmationPopupCallCount: 0,
          title: 'popup shouldn\'t be displayed'
        }
      ];

    beforeEach(function () {
      jQueryMock = sinon.stub(window, '$');
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(App.router, 'get').withArgs('reassignMasterController').returns(mock);
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.spy(mock, "saveComponentToReassign");
      sinon.spy(mock, "getSecurityStatus");
      sinon.spy(mock, "setCurrentStep");
    });

    afterEach(function () {
      window.$.restore();
      App.showConfirmationPopup.restore();
      App.router.get.restore();
      App.router.transitionTo.restore();
      mock.saveComponentToReassign.restore();
      mock.getSecurityStatus.restore();
      mock.setCurrentStep.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        jQueryMock.returns({
          closest: function () {
            return {
              hasClass: function () {
                return item.isDisabled;
              }
            }
          }
        });
        var popup = controller.moveComponent({context: {}});
        expect(App.showConfirmationPopup.callCount).to.equal(item.showConfirmationPopupCallCount);
        if (item.showConfirmationPopupCallCount) {
          popup.onPrimary();
          expect(App.router.get.calledWith('reassignMasterController')).to.be.true;
          expect(mock.saveComponentToReassign.calledWith({})).to.be.true;
          expect(mock.getSecurityStatus.calledOnce).to.be.true;
          expect(mock.setCurrentStep.calledWith('1')).to.be.true;
          expect(App.router.transitionTo.calledWith('reassign')).to.be.true;
        }
      });
    });

  });

  describe('#refreshConfigs()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(batchUtils, "restartHostComponents", Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      batchUtils.restartHostComponents.restore();
    });

    it('No components', function () {
      var event = {context: []};
      controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.called).to.be.false;
    });
    it('Some components present', function () {
      var event = {context: [Em.Object.create()]};
      var popup = controller.refreshConfigs(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(batchUtils.restartHostComponents.calledWith([Em.Object.create()])).to.be.true;
    });
  });

  describe('#getTotalComponent()', function () {

    beforeEach(function () {
      sinon.stub(App.SlaveComponent, 'find', function () {
        return Em.Object.create({
          componentName: "SLAVE",
          totalCount: 1
        });
      });
      sinon.stub(App.ClientComponent, 'find', function () {
        return Em.Object.create({
          componentName: "CLIENT",
          totalCount: 1
        });
      });
      sinon.stub(App.HostComponent, 'find', function () {
        return [Em.Object.create({
          componentName: "MASTER",
          totalCount: 1
        })]
      });
    });
    afterEach(function () {
      App.SlaveComponent.find.restore();
      App.ClientComponent.find.restore();
      App.HostComponent.find.restore();
    });

    it('component is slave', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "SLAVE",
        isSlave: true
      }))).to.equal(1);
    });
    it('component is client', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "CLIENT",
        isClient: true
      }))).to.equal(1);
    });
    it('component is master', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "MASTER"
      }))).to.equal(1);
    });
    it('unknown component', function () {
      expect(controller.getTotalComponent(Em.Object.create({
        componentName: "UNKNOWN"
      }))).to.equal(0);
    });
  });
  describe('#downloadClientConfigsCall', function () {

    beforeEach(function () {
      sinon.stub(controller, 'downloadClientConfigsCall', Em.K);
    });
    afterEach(function () {
      controller.downloadClientConfigsCall.restore();
    });

    it('should launch controller.downloadClientConfigsCall method', function () {
      controller.downloadClientConfigs({
        context: Em.Object.create({
          componentName: 'name',
          hostName: 'host1',
          displayName: 'dName'
        })
      });
      expect(controller.downloadClientConfigsCall.calledWith({
        componentName: 'name',
        hostName: 'host1',
        displayName: 'dName'
      })).to.be.true;
    });
  });

  describe('#executeCustomCommands', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('confirm popup should be displayed', function () {
      var popup = controller.executeCustomCommand({context: Em.Object.create()});
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#_doDeleteHostComponent()', function () {
    it('single component', function () {
      controller.set('content.hostName', 'host1');
      var component = Em.Object.create({componentName: 'COMP'});
      controller._doDeleteHostComponent(component);
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host_component');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        componentName: 'COMP',
        hostName: 'host1'
      });
    });
    it('all components', function () {
      controller.set('content.hostName', 'host1');
      controller._doDeleteHostComponent(null);
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        componentName: '',
        hostName: 'host1'
      });
    });
  });

  describe('#_doDeleteHostComponentSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'removeHostComponentModel', Em.K);
      sinon.stub(controller, 'isServiceMetricsLoaded', function (callback) {
        callback();
      });
    });

    afterEach(function () {
      controller.removeHostComponentModel.restore();
      controller.isServiceMetricsLoaded.restore();
    });

    it('ZOOKEEPER_SERVER component', function () {
      var data = {
        componentName: 'ZOOKEEPER_SERVER'
      };
      sinon.stub(controller, 'loadConfigs', Em.K);
      controller._doDeleteHostComponentSuccessCallback({}, {}, data);
      expect(controller.get('_deletedHostComponentResult')).to.be.null;
      expect(controller.get('fromDeleteZkServer')).to.be.true;
      expect(controller.loadConfigs.calledOnce).to.be.true;
      controller.loadConfigs.restore();
    });
    it('Not ZOOKEEPER_SERVER component', function () {
      var data = {
        componentName: 'COMP'
      };
      controller.set('fromDeleteZkServer', false);
      controller._doDeleteHostComponentSuccessCallback({}, {}, data);
      expect(controller.get('_deletedHostComponentResult')).to.be.null;
      expect(controller.get('fromDeleteZkServer')).to.be.false;
    });
    it('should call `removeHostComponentModel` with correct params', function () {
      var data = {
        componentName: 'COMPONENT',
        hostName: 'h1'
      };
      controller._doDeleteHostComponentSuccessCallback({}, {}, data);
      expect(controller.removeHostComponentModel.calledWith('COMPONENT', 'h1')).to.be.true;
    });
  });

  describe('#upgradeComponentSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
    });
    afterEach(function () {
      controller.mimicWorkStatusChange.restore();
      controller.showBackgroundOperationsPopup.restore();
    });
    it('testMode is true', function () {
      App.set('testMode', true);

      controller.upgradeComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.calledWith("COMP", App.HostComponentStatus.starting, App.HostComponentStatus.started)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode is false', function () {
      App.set('testMode', false);

      controller.upgradeComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#refreshComponentConfigsSuccessCallback()', function () {
    it('call showBackgroundOperationsPopup', function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      controller.refreshComponentConfigsSuccessCallback();
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
      controller.showBackgroundOperationsPopup.restore();
    });
  });

  describe('#checkZkConfigs()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'removeObserver');
      sinon.stub(controller, 'loadConfigs');
      sinon.stub(controller, 'isServiceMetricsLoaded', function (callback) {
        callback();
      });
    });
    afterEach(function () {
      controller.loadConfigs.restore();
      controller.removeObserver.restore();
      controller.isServiceMetricsLoaded.restore();
      App.router.get.restore();
    });
    it('No operations of ZOOKEEPER_SERVER', function () {
      sinon.stub(App.router, 'get').withArgs('backgroundOperationsController.services').returns([]);
      controller.checkZkConfigs();
      expect(controller.removeObserver.called).to.be.false;
      expect(controller.loadConfigs.called).to.be.false;
    });
    it('Operation of ZOOKEEPER_SERVER running', function () {
      sinon.stub(App.router, 'get').withArgs('backgroundOperationsController.services').returns([Em.Object.create({
        id: 1,
        isRunning: true
      })]);
      controller.set('zkRequestId', 1);
      controller.checkZkConfigs();
      expect(controller.removeObserver.called).to.be.false;
      expect(controller.loadConfigs.called).to.be.false;
    });
    it('Operation of ZOOKEEPER_SERVER finished', function () {
      sinon.stub(App.router, 'get').withArgs('backgroundOperationsController.services').returns([Em.Object.create({
        id: 1
      })]);
      var clock = sinon.useFakeTimers();
      controller.set('zkRequestId', 1);
      controller.checkZkConfigs();
      expect(controller.removeObserver.calledWith('App.router.backgroundOperationsController.serviceTimestamp', controller, controller.checkZkConfigs)).to.be.true;
      clock.tick(App.get('componentsUpdateInterval'));
      expect(controller.loadConfigs.calledOnce).to.be.true;
      clock.restore();
    });
  });

  describe('#_doDeleteHostComponentErrorCallback()', function () {
    it('call showBackgroundOperationsPopup', function () {
      controller._doDeleteHostComponentErrorCallback({}, 'textStatus', {}, {url: 'url'});
      expect(controller.get('_deletedHostComponentResult')).to.be.eql({xhr: {}, url: 'url', method: 'DELETE'});
    });
  });

  describe('#installComponentSuccessCallback()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'showBackgroundOperationsPopup', Em.K);
      sinon.stub(controller, 'mimicWorkStatusChange', Em.K);
    });
    afterEach(function () {
      controller.mimicWorkStatusChange.restore();
      controller.showBackgroundOperationsPopup.restore();
    });
    it('testMode is true', function () {
      App.set('testMode', true);

      controller.installComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.calledWith("COMP", App.HostComponentStatus.installing, App.HostComponentStatus.stopped)).to.be.true;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
    it('testMode is false', function () {
      App.set('testMode', false);

      controller.installComponentSuccessCallback({}, {}, {component: "COMP"});
      expect(controller.mimicWorkStatusChange.called).to.be.false;
      expect(controller.showBackgroundOperationsPopup.calledOnce).to.be.true;
    });
  });

  describe('#showHbaseActiveWarning()', function () {
    it('popup should be displayed', function () {
      sinon.spy(App.ModalPopup, "show");
      var popup = controller.showHbaseActiveWarning(Em.Object.create({service: {}}));
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      App.ModalPopup.show.restore();
    });
  });

  describe('#updateHost()', function () {
    it('popup should be displayed', function () {
      sinon.stub(batchUtils, "infoPassiveState", Em.K);
      controller.updateHost({}, {}, {passive_state: 'state'});
      expect(controller.get('content.passiveState')).to.equal('state');
      expect(batchUtils.infoPassiveState.calledWith('state')).to.be.true;
      batchUtils.infoPassiveState.restore();
    });
  });

  describe('#updateComponentPassiveState()', function () {
    it('popup should be displayed', function () {
      controller.set('content.hostName', 'host1');
      var component = Em.Object.create({
        componentName: 'COMP1'
      });
      controller.updateComponentPassiveState(component, 'state', 'message');
      expect(App.ajax.send.getCall(0).args[0].data).to.be.eql({
        "hostName": "host1",
        "componentName": "COMP1",
        "component": component,
        "passive_state": "state",
        "context": "message"
      });
    });
  });

  describe('#updateHostComponent()', function () {
    it('popup should be displayed', function () {
      sinon.stub(batchUtils, "infoPassiveState", Em.K);
      var params = {
        component: Em.Object.create(),
        passive_state: 'state'
      };
      controller.updateHostComponent({}, {}, params);
      expect(params.component.get('passiveState')).to.equal('state');
      expect(batchUtils.infoPassiveState.calledWith('state')).to.be.true;
      batchUtils.infoPassiveState.restore();
    });
  });

  describe('#toggleMaintenanceMode()', function () {
    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, 'updateComponentPassiveState');
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.updateComponentPassiveState.restore();
    });
    it('passive state is ON', function () {
      var event = {
        context: Em.Object.create({
          passiveState: 'ON'
        })
      };
      var popup = controller.toggleMaintenanceMode(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.updateComponentPassiveState.calledWith(Em.Object.create({
        passiveState: 'ON'
      }), 'OFF')).to.be.true;
    });
    it('passive state is OFF', function () {
      var event = {
        context: Em.Object.create({
          passiveState: 'OFF'
        })
      };
      var popup = controller.toggleMaintenanceMode(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.updateComponentPassiveState.calledWith(Em.Object.create({
        passiveState: 'OFF'
      }), 'ON')).to.be.true;
    });
  });

  describe('#installClients()', function () {

    var cases = [
        {
          context: [
            Em.Object.create({
              componentName: 'c0',
              workStatus: 'INSTALLED'
            }),
            Em.Object.create({
              componentName: 'c1',
              workStatus: 'INIT'
            }),
            Em.Object.create({
              componentName: 'c2',
              workStatus: 'INSTALL_FAILED'
            })
          ],
          dependencies: {
            c0: [],
            c1: [],
            c2: []
          },
          getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
          getKDCSessionStateCalled: true,
          sendComponentCommandCalled: true,
          showAlertPopupCalled: false,
          title: 'No clients to add, some clients to install'
        },
        {
          context: [
            Em.Object.create({
              componentName: 'c3',
              displayName: 'c3'
            })
          ],
          dependencies: {
            c3: []
          },
          getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
          getKDCSessionStateCalled: true,
          sendComponentCommandCalled: false,
          showAlertPopupCalled: false,
          title: 'No clients to install, some clients to add'
        },
        {
          context: [
            Em.Object.create({
              componentName: 'c4',
              displayName: 'c4'
            })
          ],
          dependencies: {
            c4: ['c5']
          },
          getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
          getKDCSessionStateCalled: false,
          sendComponentCommandCalled: false,
          showAlertPopupCalled: true,
          title: 'Clients to add have unresolved dependencies'
        },
        {
          context: [
            Em.Object.create({
              componentName: 'c5',
              displayName: 'c5'
            }),
            Em.Object.create({
              componentName: 'c6',
              displayName: 'c6'
            })
          ],
          dependencies: {
            c5: ['c6'],
            c6: ['c5']
          },
          getSecurityTypeCalled: null, //should have same value as getKDCSessionStateCalled, always
          getKDCSessionStateCalled: true,
          sendComponentCommandCalled: false,
          showAlertPopupCalled: false,
          title: 'Clients to add have mutual dependencies'
        }
      ];

    beforeEach(function () {
      sinon.stub(controller, 'sendComponentCommand', Em.K);
      sinon.stub(controller, 'showAddComponentPopup', Em.K);
      sinon.stub(App.get('router.mainAdminKerberosController'), 'getKDCSessionState', function (arg) {
        return arg();
      });
      sinon.stub(App.get('router.mainAdminKerberosController'), 'getSecurityType', function (arg) {
        return arg();
      });
      sinon.stub(App, 'showAlertPopup', Em.K);
      sinon.stub(App.StackServiceComponent, 'find', function (componentName) {
        return Em.Object.create({
          displayName: componentName
        });
      });
      controller.set('content.hostComponents', []);
    });
    afterEach(function () {
      controller.sendComponentCommand.restore();
      controller.showAddComponentPopup.restore();
      App.get('router.mainAdminKerberosController').getKDCSessionState.restore();
      App.get('router.mainAdminKerberosController').getSecurityType.restore();
      App.showAlertPopup.restore();
      App.StackServiceComponent.find.restore();
      controller.checkComponentDependencies.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(controller, 'checkComponentDependencies', function (componentName, params) {
          return item.dependencies[componentName];
        });
        controller.installClients({
          context: item.context
        });
        expect(App.get('router.mainAdminKerberosController').getSecurityType.calledOnce).to.equal(item.getKDCSessionStateCalled);
        expect(App.get('router.mainAdminKerberosController').getKDCSessionState.calledOnce).to.equal(item.getKDCSessionStateCalled);
        expect(controller.sendComponentCommand.calledOnce).to.equal(item.sendComponentCommandCalled);
        expect(App.showAlertPopup.calledOnce).to.equal(item.showAlertPopupCalled);
      });
    });
  });

  describe("#executeCustomCommandErrorCallback()", function () {
    beforeEach(function () {
      sinon.stub($, 'parseJSON');
      sinon.spy(App, 'showAlertPopup');
    });
    afterEach(function () {
      App.showAlertPopup.restore();
      $.parseJSON.restore();
    });
    it("data empty", function () {
      controller.executeCustomCommandErrorCallback(null);

      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.called).to.be.false;
    });
    it("responseText empty", function () {
      var data = {
        responseText: null
      };
      controller.executeCustomCommandErrorCallback(data);

      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.called).to.be.false;
    });
    it("data empty", function () {
      var data = {
        responseText: "test"
      };
      controller.executeCustomCommandErrorCallback(data);
      expect(App.showAlertPopup.calledWith(Em.I18n.t('services.service.actions.run.executeCustomCommand.error'), Em.I18n.t('services.service.actions.run.executeCustomCommand.error'))).to.be.true;
      expect($.parseJSON.calledWith('test')).to.be.true;
    });
  });

  describe("#doDeleteHost()", function () {
    beforeEach(function () {
      controller.set('fromDeleteHost', false);
      controller.set('content.hostName', 'host1');
      sinon.stub(controller, '_doDeleteHostComponent', function (comp, callback) {
        callback();
      });
    });
    afterEach(function () {
      controller._doDeleteHostComponent.restore();
    });
    it("Host has no components", function () {
      controller.set('content.hostComponents', Em.A([]));
      controller.doDeleteHost(Em.K);
      expect(controller.get('fromDeleteHost')).to.be.true;
      expect(App.ajax.send.getCall(0).args[0].data.hostName).to.be.equal('host1');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host');
    });
    it("Host has components", function () {
      controller.set('content.hostComponents', Em.A([Em.Object.create({
        componentName: 'COMP1'
      })]));
      controller.doDeleteHost(Em.K);
      expect(controller._doDeleteHostComponent.calledWith(Em.Object.create({
        componentName: 'COMP1'
      }))).to.be.true;
      expect(controller.get('fromDeleteHost')).to.be.true;
      expect(App.ajax.send.getCall(0).args[0].data.hostName).to.be.equal('host1');
      expect(App.ajax.send.getCall(0).args[0].name).to.be.equal('common.delete.host');
    });
  });

  describe("#deleteHostSuccessCallback", function () {
    it("call updateHost", function () {
      var mock = {
        updateHost: function (callback) {
          callback();
        },
        getAllHostNames: Em.K
      };
      sinon.stub(App.router, 'get').withArgs('updateController').returns(mock).withArgs('clusterController').returns(mock);
      sinon.spy(mock, 'updateHost');
      sinon.spy(mock, 'getAllHostNames');
      sinon.stub(controller, 'loadConfigs', Em.K);
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.stub(controller, 'isServiceMetricsLoaded', function (callback) {
        callback();
      });

      controller.deleteHostSuccessCallback();
      expect(App.router.get.calledWith('updateController')).to.be.true;
      expect(mock.updateHost.calledOnce).to.be.true;
      expect(controller.loadConfigs.called).to.be.false;
      expect(App.router.transitionTo.calledWith('hosts.index')).to.be.true;
      expect(App.router.get.calledWith('clusterController')).to.be.true;
      expect(mock.getAllHostNames.calledOnce).to.be.true;

      App.router.get.restore();
      mock.updateHost.restore();
      mock.getAllHostNames.restore();
      controller.loadConfigs.restore();
      controller.isServiceMetricsLoaded.restore();
      App.router.transitionTo.restore();
    });
  });

  describe("#deleteHostErrorCallback", function () {
    it("call defaultErrorHandler", function () {
      sinon.stub(controller, 'loadConfigs', Em.K);
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
      sinon.stub(controller, 'isServiceMetricsLoaded', function (callback) {
        callback();
      });
      controller.deleteHostErrorCallback({
        status: 'status',
        statusText: "statusText"
      }, 'textStatus', 'errorThrown', {url: 'url'});
      expect(controller.loadConfigs.calledOnce).to.be.true;
      expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
      App.ajax.defaultErrorHandler.restore();
      controller.loadConfigs.restore();
      controller.isServiceMetricsLoaded.restore();
    });
  });

  describe('#installVersionConfirmation()', function () {

    beforeEach(function () {
      sinon.spy(App, "showConfirmationPopup");
      sinon.stub(controller, 'installVersion', Em.K);
    });
    afterEach(function () {
      App.showConfirmationPopup.restore();
      controller.installVersion.restore();
    });

    it('confirm popup should be displayed', function () {
      var event = {context: Em.Object.create({displayName: 'displayName'})};
      var popup = controller.installVersionConfirmation(event);
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(controller.installVersion.calledWith(event)).to.be.true;
    });
  });


  describe("#installVersion()", function () {
    it("call App.ajax.send", function () {
      controller.set('content.hostName', 'host1');
      controller.installVersion({context: {}});
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'host.stack_versions.install',
        sender: controller,
        data: {
          hostName: 'host1',
          version: {}
        },
        success: 'installVersionSuccessCallback'
      });
    });
  });

  describe("#installVersionSuccessCallback()", function () {
    before(function () {
      this.mock = sinon.stub(App.HostStackVersion, 'find');
      sinon.stub(App.db, 'set', Em.K);
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
    });
    after(function () {
      this.mock.restore();
      App.db.set.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it("", function () {
      var version = Em.Object.create({
        id: 1,
        status: 'INIT'
      });
      this.mock.returns(version);
      controller.installVersionSuccessCallback({Requests: {id: 1}}, {}, {version: version});
      expect(version.get('status')).to.equal('INSTALLING');
      expect(App.db.set.calledWith('repoVersionInstall', 'id', [1])).to.be.true;
      expect(App.clusterStatus.setClusterStatus.calledOnce).to.be.true;
    });
  });

  describe('#getHiveHosts()', function () {

    var cases = [
      {
        'input': {
          'hiveMetastoreHost': '',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h1', 'h2', 'h4'],
        'title': 'adding HiveServer2'
      },
      {
        'input': {
          'hiveMetastoreHost': 'h0',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h0', 'h1', 'h2', 'h4'],
        'title': 'adding Hive Metastore'
      },
      {
        'input': {
          'webhcatServerHost': 'h0',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h0', 'h1', 'h2', 'h4'],
        'title': 'adding WebHCat Server'
      },
      {
        'input': {
          'hiveMetastoreHost': '',
          'content.hostName': 'h1',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': true,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h2', 'h4'],
        'title': 'deleting Hive component'
      },
      {
        'input': {
          'hiveMetastoreHost': '',
          'content.hostName': 'h4',
          'fromDeleteHost': false,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': true
        },
        'hiveHosts': ['h1', 'h2'],
        'title': 'deleting WebHCat Server'
      },
      {
        'input': {
          'hiveMetastoreHost': '',
          'content.hostName': 'h2',
          'fromDeleteHost': true,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h1', 'h4'],
        'title': 'deleting host with Hive component'
      },
      {
        'input': {
          'webhcatServerHost': '',
          'content.hostName': 'h2',
          'fromDeleteHost': true,
          'deleteHiveMetaStore': false,
          'deleteWebHCatServer': false
        },
        'hiveHosts': ['h1', 'h4'],
        'title': 'deleting host with WebHCat Server'
      }
    ];

    before(function () {
      sinon.stub(App.HostComponent, 'find').returns([
        {
          componentName: 'HIVE_METASTORE',
          hostName: 'h2'
        },
        {
          componentName: 'HIVE_METASTORE',
          hostName: 'h1'
        },
        {
          componentName: 'HIVE_SERVER',
          hostName: 'h3'
        },
        {
          componentName: 'WEBHCAT_SERVER',
          hostName: 'h4'
        }
      ]);
    });

    after(function () {
      App.HostComponent.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        Em.keys(item.input).forEach(function (key) {
          controller.set(key, item.input[key]);
        });
        expect(controller.getHiveHosts().toArray()).to.eql(item.hiveHosts);
        expect(controller.get('hiveMetastoreHost')).to.be.empty;
        expect(controller.get('webhcatServerHost')).to.be.empty;
        expect(controller.get('fromDeleteHost')).to.be.false;
        expect(controller.get('deleteHiveMetaStore')).to.be.false;
      });
    });

  });

  describe('#onLoadRangerConfigs()', function () {

    var cases = [
      {
        'kmsHosts': ['host1'],
        'kmsPort': 'port',
        'title': 'single host',
        'hostToInstall': undefined,
        'result': [
          {
            properties: {
              'core-site': {'hadoop.security.key.provider.path': 'kms://http@host1:port/kms'},
              'hdfs-site': {'dfs.encryption.key.provider.uri': 'kms://http@host1:port/kms'}
            },
            properties_attributes: {
              'core-site': undefined,
              'hdfs-site': undefined
            }
          }
        ]
      },
      {
        'kmsHosts': ['host1', 'host2'],
        'kmsPort': 'port',
        'title': 'two hosts',
        'hostToInstall': 'host2',
        'result': [
          {
            properties: {
              'core-site': {'hadoop.security.key.provider.path': 'kms://http@host1;host2:port/kms'},
              'hdfs-site': {'dfs.encryption.key.provider.uri': 'kms://http@host1;host2:port/kms'}
            },
            properties_attributes: {
              'core-site': undefined,
              'hdfs-site': undefined
            }
          }
        ]
      }
    ];

    beforeEach(function () {
      sinon.spy(controller, 'saveConfigsBatch')
    });

    afterEach(function () {
      controller.saveConfigsBatch.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('rangerKMSServerHost', item.hostToInstall);
        sinon.stub(controller, 'getRangerKMSServerHosts').returns(item.kmsHosts);
        var data = {
          items: [
            {
              type: 'kms-env',
              properties: {'kms_port': item.kmsPort}
            },
            {
              type: 'core-site',
              properties: {}
            },
            {
              type: 'hdfs-site',
              properties: {}
            }
          ]
        };
        controller.onLoadRangerConfigs(data);
        expect(controller.saveConfigsBatch.calledWith(item.result, 'RANGER_KMS_SERVER', item.hostToInstall)).to.be.true;
      });
    });

  });

  describe("#removeHostComponentModel()", function () {
    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find').returns([
        Em.Object.create({
          id: 'C1_host1',
          componentName: 'C1',
          hostName: 'host1',
          service: Em.Object.create({
            serviceName: 'S1'
          })
        })
      ]);
      sinon.stub(App.serviceMapper, 'deleteRecord', Em.K);
    });
    afterEach(function () {
      App.HostComponent.find.restore();
      App.serviceMapper.deleteRecord.restore();
    });
    it("", function () {
      App.cache['services'] = [
        {
          ServiceInfo: {
            service_name: 'S1'
          },
          host_components: ['C1_host1']
        }
      ];
      controller.removeHostComponentModel('C1', 'host1');
      expect(App.cache['services'][0].host_components).to.be.empty;
      expect(App.HostComponent.find.calledOnce).to.be.true;
      expect(App.serviceMapper.deleteRecord.calledOnce).to.be.true;
    });
  });

  describe("#updateStormConfigs()", function () {
    beforeEach(function () {
      this.serviceMock = sinon.stub(App.Service, 'find');
      sinon.stub(controller, 'loadConfigs');
      this.mock = sinon.stub(App, 'get')
    });
    afterEach(function () {
      this.serviceMock.restore();
      this.mock.restore();
      controller.loadConfigs.restore();
    });
    it("storm not installed, hadoop stack is 2.2", function () {
      this.serviceMock.returns(Em.Object.create({
        isLoaded: false
      }));
      this.mock.returns(false);
      controller.updateStormConfigs();
      expect(controller.loadConfigs.called).to.be.false;
    });
    it("storm installed, hadoop stack is 2.2", function () {
      this.serviceMock.returns(Em.Object.create({
        isLoaded: true
      }));
      this.mock.returns(false);
      controller.updateStormConfigs();
      expect(controller.loadConfigs.called).to.be.false;
    });
    it("storm installed, hadoop stack is 2.3", function () {
      this.serviceMock.returns(Em.Object.create({
        isLoaded: true
      }));
      this.mock.returns(true);
      controller.updateStormConfigs();
      expect(controller.loadConfigs.calledWith('loadStormConfigs')).to.be.true;
    });
  });

  describe("#parseNnCheckPointTime", function () {
    var tests = [
      {
        m: "NameNode on this host has JMX data, the last checkpoint time is less than 12 hours ago",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "active",
                "LastCheckpointTime" : 1435775648000
              }
            }
          }
        },
        result: false
      },
      {
        m: "NameNode on this host has JMX data, the last checkpoint time is > 12 hours ago",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "active",
                "LastCheckpointTime" : 1435617248000
              }
            }
          }
        },
        result: "c6401.ambari.apache.org"
      },
      {
        m: "NameNode(standby) on this host has JMX data",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "standby",
                "LastCheckpointTime" : 1435617248000
              }
            }
          }
        },
        result: false
      },
      {
        m: "NameNode on this host has no JMX data",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
            "dfs" : {
              "FSNamesystem" : {
                "HAState" : "active"
              }
            }
          }
        },
        result: null
      },
      {
        m: "NameNode on this host has no JMX data",
        data:
        {
          "href" : "",
          "HostRoles" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "host_name" : "c6401.ambari.apache.org"
          },
          "metrics" : {
          }
        },
        result: null
      }
    ];

    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(1435790048000);
    });

    afterEach(function () {
      App.dateTime.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        var mainHostDetailsController = App.MainHostDetailsController.create({isNNCheckpointTooOld: null});
        mainHostDetailsController.parseNnCheckPointTime(test.data);
        expect(mainHostDetailsController.get('isNNCheckpointTooOld')).to.equal(test.result);
      });
    });
  });
});

});

;require.register("test/controllers/main/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var validator = require('utils/validator');
require('utils/batch_scheduled_requests');
require('controllers/main/host');
require('mappers/server_data_mapper');

describe('MainHostController', function () {

  var hostController, db;

  // @todo add unit tests after bulk ops reimplementing
  describe('#bulkOperation', function() {

    beforeEach(function() {
      hostController = App.MainHostController.create({});
      sinon.stub(hostController, 'bulkOperationForHostsRestart', Em.K);
      sinon.stub(hostController, 'bulkOperationForHosts', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponentsRestart', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostsReinstall', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponentsDecommission', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostComponents', Em.K);
      sinon.stub(hostController, 'bulkOperationForHostsPassiveState', Em.K);
    });

    afterEach(function() {
      hostController.bulkOperationForHosts.restore();
      hostController.bulkOperationForHostsRestart.restore();
      hostController.bulkOperationForHostsReinstall.restore();
      hostController.bulkOperationForHostComponentsRestart.restore();
      hostController.bulkOperationForHostComponentsDecommission.restore();
      hostController.bulkOperationForHostComponents.restore();
      hostController.bulkOperationForHostsPassiveState.restore();

    });

    it('RESTART for hosts', function() {
      var operationData = {
        action: 'RESTART'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsRestart.calledOnce).to.equal(true);
    });

    it('START for hosts', function() {
      var operationData = {
        action: 'STARTED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('STOP for hosts', function() {
      var operationData = {
        action: 'INSTALLED'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHosts.calledOnce).to.equal(true);
    });

    it('REINSTALL for hosts', function() {
      var operationData = {
        action: 'REINSTALL'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsReinstall.calledOnce).to.equal(true);
    });

    it('PASSIVE_STATE for hosts', function() {
      var operationData = {
        action: 'PASSIVE_STATE'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostsPassiveState.calledOnce).to.equal(true);
    });

    it('RESTART for hostComponents', function() {
      var operationData = {
        action: 'RESTART',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsRestart.calledOnce).to.equal(true);
    });

    it('START for hostComponents', function() {
      var operationData = {
        action: 'STARTED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('STOP for hostComponents', function() {
      var operationData = {
        action: 'INSTALLED',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponents.calledOnce).to.equal(true);
    });

    it('DECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

    it('RECOMMISSION for hostComponents', function() {
      var operationData = {
        action: 'DECOMMISSION_OFF',
        componentNameFormatted: 'DataNodes'
      };
      hostController.bulkOperation(operationData, []);
      expect(hostController.bulkOperationForHostComponentsDecommission.calledOnce).to.equal(true);
    });

  });

  describe('#getRegExp()', function() {
    before(function() {
      hostController = App.MainHostController.create({});
    });

    var message = '`{0}` should convert to `{1}`',
      tests = [
        { value: '.*', expected: '.*' },
        { value: '.', expected: '.*' },
        { value: '.*.*', expected: '.*' },
        { value: '*', expected: '^$' },
        { value: '........', expected: '.*' },
        { value: '........*', expected: '.*' },
        { value: 'a1', expected: '.*a1.*' },
        { value: 'a1.', expected: '.*a1.*' },
        { value: 'a1...', expected: '.*a1.*' },
        { value: 'a1.*', expected: '.*a1.*' },
        { value: 'a1.*.a2.a3', expected: '.*a1.*.a2.a3.*' },
        { value: 'a1.*.a2...a3', expected: '.*a1.*.a2...a3.*' }
      ];

    tests.forEach(function(test){
      it(message.format(test.value, test.expected), function() {
        expect(hostController.getRegExp(test.value)).to.be.equal(test.expected);
      });
    });
  });

  describe('#warnBeforeDecommissionSuccess()', function () {
    var mock = {
      showHbaseActiveWarning: Em.K,
      checkRegionServerState: Em.K
    };
    beforeEach(function () {
      hostController = App.MainHostController.create({});
      sinon.stub(App.router, 'get', function () {
        return mock;
      });
      sinon.spy(mock, 'showHbaseActiveWarning');
      sinon.spy(mock, 'checkRegionServerState');
    });
    afterEach(function () {
      App.router.get.restore();
      mock.showHbaseActiveWarning.restore();
      mock.checkRegionServerState.restore();
    });

    it('items length more than 0', function () {
      hostController.warnBeforeDecommissionSuccess({items: [1]}, {}, {});
      expect(mock.showHbaseActiveWarning.calledOnce).to.be.true;
    });
    it('items length equal 0', function () {
      hostController.warnBeforeDecommissionSuccess({items: []}, {}, {hostNames: 'host1'});
      expect(mock.checkRegionServerState.calledWith('host1')).to.be.true;
    });
  });

  describe('#getQueryParameters', function() {
    beforeEach(function() {
      hostController = App.MainHostController.create({});
      sinon.spy(hostController, 'getRegExp');
      sinon.stub(App.db, 'getFilterConditions', function() {
        return [{
          iColumn: 1,
          skipFilter: false,
          type: "string",
          value: "someval"
        }];
      });
    });

    afterEach(function() {
      App.db.getFilterConditions.restore();
      hostController.getRegExp.restore();
    });

    it('should call #getRegExp with value `someval` on host name filter', function() {
      hostController.getQueryParameters();
      expect(hostController.getRegExp.calledWith('someval')).to.ok;
    });

    it('result should include host name filter converted value', function() {
      expect(hostController.getQueryParameters().findProperty('key', 'Hosts/host_name').value).to.equal('.*someval.*');
    });
  });

  describe('#getSortProps', function () {

    beforeEach(function () {
      db = {mainHostController: [
        {name: 'hostName', status: 'sorting'}
      ]};
      hostController = App.MainHostController.create({});
      sinon.stub(App.db, 'getSortingStatuses', function (k) {
        return db[k];
      });
      sinon.stub(App.db, 'setSortingStatuses', function (k, v) {
        db[k] = Em.typeOf(v) === 'array' ? v : [v];
      });
    });

    afterEach(function () {
      App.db.getSortingStatuses.restore();
      App.db.setSortingStatuses.restore();
    });

    it('should set default sorting condition', function () {
      hostController.getSortProps();
      expect(db.mainHostController).to.eql([{name: 'hostName', status: 'sorting_asc'}]);
    });

  });

});

});

;require.register("test/controllers/main/service/add_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/wizard');
require('controllers/main/service/add_controller');
var addServiceController = null;

describe('App.AddServiceController', function() {

  beforeEach(function () {
    addServiceController = App.AddServiceController.create({});
  });

  describe('#installAdditionalClients', function() {

    var t = {
      additionalClients: {
        componentName: "TEZ_CLIENT",
        hostNames: ["hostName1", "hostName2"]
      },
      additionalClientsWithoutHosts: {
        componentName: "TEZ_CLIENT",
        hostNames: []
      },
      RequestInfo: {
        "context": Em.I18n.t('requestInfo.installHostComponent') + ' ' + App.format.role("TEZ_CLIENT", false),
        "query": "HostRoles/component_name=TEZ_CLIENT&HostRoles/host_name.in(hostName1,hostName2)"
      },
      Body: {
        HostRoles: {
          state: 'INSTALLED'
        }
      }
    };

    beforeEach(function () {
      sinon.spy($, 'ajax');
      sinon.stub(App, 'get', function(k) {
        if ('clusterName' === k) return 'tdk';
        return Em.get(App, k);
      });
      addServiceController.set('installClietsQueue', App.ajaxQueue.create())
    });

    afterEach(function () {
      $.ajax.restore();
      App.get.restore();
    });

    it('send request to install client', function () {
      addServiceController.set("content.additionalClients", [t.additionalClients]);
      addServiceController.installAdditionalClients();
      expect($.ajax.calledOnce).to.equal(true);

      expect(JSON.parse($.ajax.args[0][0].data).Body).to.deep.eql(t.Body);
      expect(JSON.parse($.ajax.args[0][0].data).RequestInfo).to.eql(t.RequestInfo);
    });

    it('should not send request to install client', function () {
      addServiceController.set("content.additionalClients", [t.additionalClientsWithoutHosts]);
      expect($.ajax.called).to.be.false;
    });

  });

  describe('#generateDataForInstallServices', function() {
    var tests = [{
      selected: ["YARN","HBASE"],
      res: {
        "context": Em.I18n.t('requestInfo.installServices'),
        "ServiceInfo": {"state": "INSTALLED"},
        "urlParams": "ServiceInfo/service_name.in(YARN,HBASE)"
      }
    },
    {
      selected: ['OOZIE'],
      res: {
        "context": Em.I18n.t('requestInfo.installServices'),
        "ServiceInfo": {"state": "INSTALLED"},
        "urlParams": "ServiceInfo/service_name.in(OOZIE,HDFS,YARN,MAPREDUCE2)"
      }
    }];
    tests.forEach(function(t){
      it('should generate data with ' + t.selected.join(","), function () {
        expect(addServiceController.generateDataForInstallServices(t.selected)).to.be.eql(t.res);
      });
    });
  });

  describe('#saveServices', function() {
    beforeEach(function() {
      sinon.stub(addServiceController, 'setDBProperty', Em.K);
    });

    afterEach(function() {
      addServiceController.setDBProperty.restore();
    });

    var tests = [
      {
        appService: [
          Em.Object.create({ serviceName: 'HDFS' }),
          Em.Object.create({ serviceName: 'KERBEROS' })
        ],
        stepCtrlContent: Em.Object.create({
          content: Em.A([
            Em.Object.create({ serviceName: 'HDFS', isInstalled: true, isSelected: true }),
            Em.Object.create({ serviceName: 'YARN', isInstalled: false, isSelected: true })
          ])
        }),
        e: {
          selected: ['YARN'],
          installed: ['HDFS', 'KERBEROS']
        }
      },
      {
        appService: [
          Em.Object.create({ serviceName: 'HDFS' }),
          Em.Object.create({ serviceName: 'STORM' })
        ],
        stepCtrlContent: Em.Object.create({
          content: Em.A([
            Em.Object.create({ serviceName: 'HDFS', isInstalled: true, isSelected: true }),
            Em.Object.create({ serviceName: 'YARN', isInstalled: false, isSelected: true }),
            Em.Object.create({ serviceName: 'MAPREDUCE2', isInstalled: false, isSelected: true })
          ])
        }),
        e: {
          selected: ['YARN', 'MAPREDUCE2'],
          installed: ['HDFS', 'STORM']
        }
      }
    ];

    var message = '{0} installed, {1} selected. Installed list should be {2} and selected - {3}';
    tests.forEach(function(test) {
      var installed = test.appService.mapProperty('serviceName');
      var selected = test.stepCtrlContent.get('content').filterProperty('isSelected', true)
        .filterProperty('isInstalled', false).mapProperty('serviceName');
      it(message.format(installed, selected, test.e.installed, test.e.selected), function() {
        sinon.stub(App.Service, 'find').returns(test.appService);
        addServiceController.saveServices(test.stepCtrlContent);
        App.Service.find.restore();
        var savedServices = addServiceController.setDBProperty.withArgs('services').args[0][1];
        expect(savedServices.selectedServices).to.have.members(test.e.selected);
        expect(savedServices.installedServices).to.have.members(test.e.installed);
      });
    });
  });

  describe('#loadHosts', function () {

    var cases = [
      {
        hosts: {},
        isAjaxRequestSent: false,
        title: 'hosts are already loaded'
      },
      {
        areHostsLoaded: false,
        isAjaxRequestSent: true,
        title: 'hosts aren\'t yet loaded'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', function () {
        return {
          promise: Em.K
        };
      });
    });

    afterEach(function () {
      addServiceController.getDBProperty.restore();
      App.ajax.send.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(addServiceController, 'getDBProperty').withArgs('hosts').returns(item.hosts);
        addServiceController.loadHosts();
        expect(App.ajax.send.calledOnce).to.equal(item.isAjaxRequestSent);
      });
    });

  });

  describe('#loadHostsSuccessCallback', function () {

    it('should load hosts to local db and model', function () {
      var diskInfo = [
          {
            available: '600000',
            used: '400000',
            percent: '40%',
            size: '10000000',
            type: 'ext4',
            mountpoint: '/'
          },
          {
            available: '500000',
            used: '300000',
            percent: '50%',
            size: '6000000',
            type: 'ext4',
            mountpoint: '/'
          }
        ],
        hostComponents = [
          [
            {
              HostRoles: {
                component_name: 'c0',
                state: 'STARTED'
              }
            },
            {
              HostRoles: {
                component_name: 'c1',
                state: 'INSTALLED'
              }
            }
          ],
          [
            {
              HostRoles: {
                component_name: 'c2',
                state: 'STARTED'
              }
            },
            {
              HostRoles: {
                component_name: 'c3',
                state: 'INSTALLED'
              }
            }
          ]
        ],
        response = {
          items: [
            {
              Hosts: {
                cpu_count: 1,
                disk_info: [
                  diskInfo[0]
                ],
                host_name: 'h0',
                ip: '10.1.1.0',
                os_arch: 'x86_64',
                os_type: 'centos6',
                total_mem: 4194304
              },
              host_components: hostComponents[0]
            },
            {
              Hosts: {
                cpu_count: 2,
                disk_info: [
                  diskInfo[1]
                ],
                host_name: 'h1',
                ip: '10.1.1.1',
                os_arch: 'x86',
                os_type: 'centos5',
                total_mem: 3145728
              },
              host_components: hostComponents[1]
            }
          ]
        },
        expected = {
          h0: {
            name: 'h0',
            cpu: 1,
            memory: 4194304,
            disk_info: [diskInfo[0]],
            osType: 'centos6',
            osArch: 'x86_64',
            ip: '10.1.1.0',
            bootStatus: 'REGISTERED',
            isInstalled: true,
            hostComponents: hostComponents[0],
            id: 0
          },
          h1: {
            name: 'h1',
            cpu: 2,
            memory: 3145728,
            disk_info: [diskInfo[1]],
            osType: 'centos5',
            osArch: 'x86',
            ip: '10.1.1.1',
            bootStatus: 'REGISTERED',
            isInstalled: true,
            hostComponents: hostComponents[1],
            id: 1
          }
        };
      addServiceController.loadHostsSuccessCallback(response);
      var hostsInDb = addServiceController.getDBProperty('hosts');
      var hostsInModel = addServiceController.get('content.hosts');
      expect(hostsInDb).to.eql(expected);
      expect(hostsInModel).to.eql(expected);
    });

  });

  describe('#loadHostsErrorCallback', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
    });

    afterEach(function () {
      App.ajax.defaultErrorHandler.restore();
    });

    it('should execute default error handler', function () {
      addServiceController.loadHostsErrorCallback({status: '500'}, 'textStatus', 'errorThrown', {url: 'url', method: 'GET'});
      expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
      expect(App.ajax.defaultErrorHandler.calledWith({status: '500'}, 'url', 'GET', '500')).to.be.true;
    });

  });

  describe('#loadServices', function() {
    beforeEach(function() {
      this.controller = App.AddServiceController.create({});
      this.db = {};
      sinon.stub(this.controller, 'getDBProperty');
      sinon.stub(this.controller, 'setDBProperty', function(key, value) {
        this.db = value;
      }.bind(this));
    });

    afterEach(function() {
      this.controller.getDBProperty.restore();
      this.controller.setDBProperty.restore();
    });

    var tests = [
      {
        appStackService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS', coSelectedServices: []}),
          Em.Object.create({ id: 'YARN', serviceName: 'YARN', coSelectedServices: ['MAPREDUCE2']}),
          Em.Object.create({ id: 'MAPREDUCE2', serviceName: 'MAPREDUCE2', coSelectedServices: []}),
          Em.Object.create({ id: 'FALCON', serviceName: 'FALCON', coSelectedServices: []}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM', coSelectedServices: []})
        ],
        appService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS'}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM'})
        ],
        servicesFromDB: false,
        serviceToInstall: 'MAPREDUCE2',
        e: {
          selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'STORM'],
          installedServices: ['HDFS', 'STORM']
        },
        m: 'MapReduce selected on Admin -> Stack Versions Page, Yarn service should be selected because it coselected'
      },
      {
        appStackService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS', coSelectedServices: []}),
          Em.Object.create({ id: 'YARN', serviceName: 'YARN', coSelectedServices: ['MAPREDUCE2']}),
          Em.Object.create({ id: 'HBASE', serviceName: 'HBASE', coSelectedServices: []}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM', coSelectedServices: []})
        ],
        appService: [
          Em.Object.create({ id: 'HDFS', serviceName: 'HDFS'}),
          Em.Object.create({ id: 'STORM', serviceName: 'STORM'})
        ],
        servicesFromDB: {
          selectedServices: ['HBASE'],
          installedServices: ['HDFS', 'STORM']
        },
        serviceToInstall: null,
        e: {
          selectedServices: ['HDFS', 'HBASE', 'STORM'],
          installedServices: ['HDFS', 'STORM']
        },
        m: 'HDFS and STORM are installed. Select HBASE'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.stub(App.StackService, 'find').returns(test.appStackService);
        sinon.stub(App.Service, 'find').returns(test.appService);
        this.controller.getDBProperty.withArgs('services').returns(test.servicesFromDB);
        this.controller.set('serviceToInstall', test.serviceToInstall);
        this.controller.loadServices();
        App.StackService.find.restore();
        App.Service.find.restore();
        if (!test.servicesFromDB) {
          // verify saving to local db on first enter to the wizard
          expect(this.db.selectedServices).to.be.eql(test.e.selectedServices);
          expect(this.db.installedServices).to.be.eql(test.e.installedServices);
        } else {
          // verify values for App.StackService
          expect(test.appStackService.filterProperty('isSelected', true).mapProperty('serviceName')).to.be.eql(test.e.selectedServices);
          expect(test.appStackService.filterProperty('isInstalled', true).mapProperty('serviceName')).to.be.eql(test.e.installedServices);
        }
        expect(this.controller.get('serviceToInstall')).to.be.null;
      });
    }, this);
  });

  describe('#checkSecurityStatus', function () {

    var cases = [
      {
        securityEnabled: true,
        skipConfigureIdentitiesStep: false,
        isStep5Disabled: false,
        title: 'security enabled'
      },
      {
        securityEnabled: false,
        skipConfigureIdentitiesStep: true,
        isStep5Disabled: true,
        title: 'security disabled'
      }
    ];

    beforeEach(function () {
      addServiceController.setProperties({
        skipConfigureIdentitiesStep: false,
        isStepDisabled: [
          Em.Object.create({
            step: 5,
            value: false
          })
        ]
      });
    });

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(item.securityEnabled);
        addServiceController.checkSecurityStatus();
        expect(addServiceController.get('skipConfigureIdentitiesStep')).to.equal(item.skipConfigureIdentitiesStep);
        expect(addServiceController.get('isStepDisabled').findProperty('step', 5).get('value')).to.equal(item.isStep5Disabled);
      });
    });

  });

  describe('#loadServiceConfigGroups', function () {

    var dbMock,
      dbMock2,
      cases = [
        {
          serviceConfigGroups: null,
          areInstalledConfigGroupsLoaded: false,
          title: 'config groups not yet loaded'
        },
        {
          serviceConfigGroups: [],
          areInstalledConfigGroupsLoaded: true,
          title: 'config groups already loaded'
        }
      ];

    beforeEach(function () {
      dbMock = sinon.stub(addServiceController, 'getDBProperties');
      dbMock2 = sinon.stub(addServiceController, 'getDBProperty');
    });

    afterEach(function () {
      dbMock.restore();
      dbMock2.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        dbMock.withArgs(['serviceConfigGroups', 'hosts']).returns({
          hosts: {},
          serviceConfigGroups: item.serviceConfigGroups
        });
        dbMock2.withArgs('hosts').returns({}).
          withArgs('serviceConfigGroups').returns(item.serviceConfigGroups);
        addServiceController.loadServiceConfigGroups();
        expect(addServiceController.get('areInstalledConfigGroupsLoaded')).to.equal(item.areInstalledConfigGroupsLoaded);
      });
    });

  });

  describe('#clearStorageData', function () {
    it('areInstalledConfigGroupsLoaded should be false', function () {
      addServiceController.set('areInstalledConfigGroupsLoaded', true);
      addServiceController.clearStorageData();
      expect(addServiceController.get('areInstalledConfigGroupsLoaded')).to.be.false;
    });
  });

});

});

;require.register("test/controllers/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service/info/configs');
var batchUtils = require('utils/batch_scheduled_requests');
var mainServiceInfoConfigsController = null;
describe("App.MainServiceInfoConfigsController", function () {

  beforeEach(function () {
    sinon.stub(App.themesMapper, 'generateAdvancedTabs').returns(Em.K);
    mainServiceInfoConfigsController = App.MainServiceInfoConfigsController.create({
      dependentServiceNames: [],
      loadDependentConfigs: function () {
        return {done: Em.K}
      },
      loadConfigTheme: function () {
        return $.Deferred().resolve().promise();
      }
    });
  });

  afterEach(function() {
    App.themesMapper.generateAdvancedTabs.restore();
  });

  describe("#showSavePopup", function () {
    var tests = [
      {
        path: false,
        callback: null,
        action: "onSave",
        m: "save configs without path/callback",
        results: [
          {
            method: "restartServicePopup",
            called: true
          }
        ]
      },
      {
        path: true,
        callback: true,
        action: "onSave",
        m: "save configs with path/callback",
        results: [
          {
            method: "restartServicePopup",
            called: true
          }
        ]
      },
      {
        path: false,
        callback: false,
        action: "onDiscard",
        m: "discard changes without path/callback",
        results: [
          {
            method: "restartServicePopup",
            called: false
          }
        ]
      },
      {
        path: false,
        callback: true,
        action: "onDiscard",
        m: "discard changes with callback",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            method: "callback",
            called: true
          },
          {
            field: "hash",
            value: "hash"
          }
        ]
      },
      {
        path: true,
        callback: null,
        action: "onDiscard",
        m: "discard changes with path",
        results: [
          {
            method: "restartServicePopup",
            called: false
          },
          {
            field: "forceTransition",
            value: true
          }
        ]
      }
    ];

    beforeEach(function () {
      mainServiceInfoConfigsController.reopen({
        passwordConfigsAreChanged: false
      });
      sinon.stub(mainServiceInfoConfigsController, "get", function(key) {
        return key == 'isSubmitDisabled' ?  false : Em.get(mainServiceInfoConfigsController, key);
      });
      sinon.stub(mainServiceInfoConfigsController, "restartServicePopup", Em.K);
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
      sinon.stub(App.router, "route", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.get.restore();
      mainServiceInfoConfigsController.restartServicePopup.restore();
      mainServiceInfoConfigsController.getHash.restore();
      App.router.route.restore();
    });

    tests.forEach(function (t) {
      t.results.forEach(function (r) {
        it(t.m + " " + r.method + " " + r.field, function () {
          if (t.callback) {
            t.callback = sinon.stub();
          }
          mainServiceInfoConfigsController.showSavePopup(t.path, t.callback)[t.action]();
          if (r.method) {
            if (r.method === 'callback') {
              expect(t.callback.calledOnce).to.equal(r.called);
            } else {
              expect(mainServiceInfoConfigsController[r.method].calledOnce).to.equal(r.called);
            }
          } else if (r.field) {
            expect(mainServiceInfoConfigsController.get(r.field)).to.equal(r.value);
          }
        }, this);
      });
    }, this);
  });

  describe("#hasUnsavedChanges", function () {
    var cases = [
      {
        hash: null,
        hasUnsavedChanges: false,
        title: 'configs not rendered'
      },
      {
        hash: 'hash1',
        hasUnsavedChanges: true,
        title: 'with unsaved'
      },
      {
        hash: 'hash',
        hasUnsavedChanges: false,
        title: 'without unsaved'
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "getHash", function () {
        return "hash"
      });
    });
    afterEach(function () {
      mainServiceInfoConfigsController.getHash.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        mainServiceInfoConfigsController.set('hash', item.hash);
        expect(mainServiceInfoConfigsController.hasUnsavedChanges()).to.equal(item.hasUnsavedChanges);
      });
    });
  });

  describe("#showComponentsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker'],
              'publicHostName2': ['JobTracker', 'TaskTracker']
            }
          }
        },
        components: "2 TaskTrackers, 1 JobTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.components'))
      },
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker']
            }
          }
        },
        components: "1 TaskTracker",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.component'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with components", function () {
        mainServiceInfoConfigsController.showComponentsShouldBeRestarted(t.input);
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.components, t.text)).to.equal(true);
      });
    });
  });

  describe("#showHostsShouldBeRestarted", function () {

    var tests = [
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker'],
              'publicHostName2': ['JobTracker', 'TaskTracker']
            }
          }
        },
        hosts: "publicHostName1, publicHostName2",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.hosts'))
      },
      {
        input: {
          context: {
            restartRequiredHostsAndComponents: {
              'publicHostName1': ['TaskTracker']
            }
          }
        },
        hosts: "publicHostName1",
        text: Em.I18n.t('service.service.config.restartService.shouldBeRestarted').format(Em.I18n.t('common.host'))
      }
    ];

    beforeEach(function () {
      sinon.stub(mainServiceInfoConfigsController, "showItemsShouldBeRestarted", Em.K);
    });
    afterEach(function () {
      mainServiceInfoConfigsController.showItemsShouldBeRestarted.restore();
    });

    tests.forEach(function (t) {
      it("trigger showItemsShouldBeRestarted popup with hosts", function () {
        mainServiceInfoConfigsController.showHostsShouldBeRestarted(t.input);
        expect(mainServiceInfoConfigsController.showItemsShouldBeRestarted.calledWith(t.hosts, t.text)).to.equal(true);
      });
    });
  });

  describe("#rollingRestartStaleConfigSlaveComponents", function () {
    var tests = [
      {
        componentName: {
          context: "ComponentName"
        },
        displayName: "displayName",
        passiveState: "ON"
      },
      {
        componentName: {
          context: "ComponentName1"
        },
        displayName: "displayName1",
        passiveState: "OFF"
      }
    ];

    beforeEach(function () {
      mainServiceInfoConfigsController.set("content", {displayName: "", passiveState: ""});
      sinon.stub(batchUtils, "launchHostComponentRollingRestart", Em.K);
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
    });
    tests.forEach(function (t) {
      it("trigger rollingRestartStaleConfigSlaveComponents", function () {
        mainServiceInfoConfigsController.set("content.displayName", t.displayName);
        mainServiceInfoConfigsController.set("content.passiveState", t.passiveState);
        mainServiceInfoConfigsController.rollingRestartStaleConfigSlaveComponents(t.componentName);
        expect(batchUtils.launchHostComponentRollingRestart.calledWith(t.componentName.context, t.displayName, t.passiveState == "ON", true)).to.equal(true);
      });
    });
  });

  describe("#restartAllStaleConfigComponents", function () {
    beforeEach(function () {
      sinon.stub(batchUtils, "restartAllServiceHostComponents", Em.K);
    });
    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
    });
    it("trigger restartAllServiceHostComponents", function () {
      mainServiceInfoConfigsController.restartAllStaleConfigComponents().onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });
    it("trigger check last check point warning before triggering restartAllServiceHostComponents", function () {
      var mainConfigsControllerHdfsStarted = App.MainServiceInfoConfigsController.create({
        content: {
          serviceName: "HDFS",
          hostComponents: [{
            componentName: 'NAMENODE',
            workStatus: 'STARTED'
          }],
          restartRequiredHostsAndComponents: {
            "host1": ['NameNode'],
            "host2": ['DataNode', 'ZooKeeper']
          }
        }
      });
      var mainServiceItemController = App.MainServiceItemController.create({});
      sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
        return true;
      });
      sinon.stub(App.router, 'get', function(k) {
        if ('mainServiceItemController' === k) {
          return mainServiceItemController;
        }
        return Em.get(App.router, k);
      });

      mainConfigsControllerHdfsStarted.restartAllStaleConfigComponents();
      expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      mainServiceItemController.checkNnLastCheckpointTime.restore();
      App.router.get.restore();
    });
  });

  describe("#doCancel", function () {
    beforeEach(function () {
      sinon.stub(Em.run, 'once', Em.K);
    });
    afterEach(function () {
      Em.run.once.restore();
    });

    it("should clear dependent configs", function() {
      mainServiceInfoConfigsController.set('groupsToSave', { HDFS: 'my cool group'});
      mainServiceInfoConfigsController.set('_dependentConfigValues', Em.A([{name: 'prop_1'}]));
      mainServiceInfoConfigsController.doCancel();
      expect(App.isEmptyObject(mainServiceInfoConfigsController.get('_dependentConfigValues'))).to.be.true;
    });
  });

  describe("#putChangedConfigurations", function () {
      var sc = [
      Em.Object.create({
        configs: [
          Em.Object.create({
            name: '_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: '_newsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: '_maxnewsize',
            value: '1024m'
          })
        ]
      })
    ],
    scExc = [
      Em.Object.create({
        configs: [
          Em.Object.create({
            name: 'hadoop_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'yarn_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'nodemanager_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'resourcemanager_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'apptimelineserver_heapsize',
            value: '1024m'
          }),
          Em.Object.create({
            name: 'jobhistory_heapsize',
            value: '1024m'
          })
        ]
      })
    ];
    beforeEach(function () {
      sinon.stub(App.router, 'getClusterName', function() {
        return 'clName';
      });
      sinon.stub(App.ajax, "send", Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
      App.router.getClusterName.restore();
    });
    it("ajax request to put cluster cfg", function () {
      mainServiceInfoConfigsController.set('stepConfigs', sc);
      expect(mainServiceInfoConfigsController.putChangedConfigurations([]));
      expect(App.ajax.send.calledOnce).to.be.true;
    });
    it('values should be parsed', function () {
      mainServiceInfoConfigsController.set('stepConfigs', sc);
      mainServiceInfoConfigsController.putChangedConfigurations([]);
      expect(mainServiceInfoConfigsController.get('stepConfigs')[0].get('configs').mapProperty('value').uniq()).to.eql(['1024m']);
    });
    it('values should not be parsed', function () {
      mainServiceInfoConfigsController.set('stepConfigs', scExc);
      mainServiceInfoConfigsController.putChangedConfigurations([]);
      expect(mainServiceInfoConfigsController.get('stepConfigs')[0].get('configs').mapProperty('value').uniq()).to.eql(['1024m']);
    });
  });

  describe("#isDirChanged", function() {

    describe("when service name is HDFS", function() {
      beforeEach(function() {
        mainServiceInfoConfigsController.set('content', Ember.Object.create ({ serviceName: 'HDFS' }));
      });

      describe("for hadoop 2", function() {

        var tests = [
          {
            it: "should set dirChanged to false if none of the properties exist",
            expect: false,
            config: Ember.Object.create ({})
          },
          {
            it: "should set dirChanged to true if dfs.namenode.name.dir is not default",
            expect: true,
            config: Ember.Object.create ({
              name: 'dfs.namenode.name.dir',
              isNotDefaultValue: true
            })
          },
          {
            it: "should set dirChanged to false if dfs.namenode.name.dir is default",
            expect: false,
            config: Ember.Object.create ({
              name: 'dfs.namenode.name.dir',
              isNotDefaultValue: false
            })
          },
          {
            it: "should set dirChanged to true if dfs.namenode.checkpoint.dir is not default",
            expect: true,
            config: Ember.Object.create ({
              name: 'dfs.namenode.checkpoint.dir',
              isNotDefaultValue: true
            })
          },
          {
            it: "should set dirChanged to false if dfs.namenode.checkpoint.dir is default",
            expect: false,
            config: Ember.Object.create ({
              name: 'dfs.namenode.checkpoint.dir',
              isNotDefaultValue: false
            })
          },
          {
            it: "should set dirChanged to true if dfs.datanode.data.dir is not default",
            expect: true,
            config: Ember.Object.create ({
              name: 'dfs.datanode.data.dir',
              isNotDefaultValue: true
            })
          },
          {
            it: "should set dirChanged to false if dfs.datanode.data.dir is default",
            expect: false,
            config: Ember.Object.create ({
              name: 'dfs.datanode.data.dir',
              isNotDefaultValue: false
            })
          }
        ];

        beforeEach(function() {
          sinon.stub(App, 'get').returns(true);
        });

        afterEach(function() {
          App.get.restore();
        });

        tests.forEach(function(test) {
          it(test.it, function() {
            mainServiceInfoConfigsController.set('stepConfigs', [Ember.Object.create ({ configs: [test.config], serviceName: 'HDFS' })]);
            expect(mainServiceInfoConfigsController.isDirChanged()).to.equal(test.expect);
          })
        });
      });
    });

  });

  describe("#formatConfigValues", function () {
    var t = {
      configs: [
        Em.Object.create({ name: "p1", value: " v1 v1 ", displayType: "" }),
        Em.Object.create({ name: "p2", value: true, displayType: "" }),
        Em.Object.create({ name: "p3", value: " d1 ", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: " d1 d2 d3 ", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: " v ", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1 ", displayType: "string" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1 ", displayType: "string" })
      ],
      result: [
        Em.Object.create({ name: "p1", value: " v1 v1", displayType: "" }),
        Em.Object.create({ name: "p2", value: "true", displayType: "" }),
        Em.Object.create({ name: "p3", value: "d1", displayType: "directory" }),
        Em.Object.create({ name: "p4", value: "d1,d2,d3", displayType: "directories" }),
        Em.Object.create({ name: "p5", value: " v1 ", displayType: "password" }),
        Em.Object.create({ name: "p6", value: "v", displayType: "host" }),
        Em.Object.create({ name: "javax.jdo.option.ConnectionURL", value: " v1", displayType: "string" }),
        Em.Object.create({ name: "oozie.service.JPAService.jdbc.url", value: " v1", displayType: "string" })
      ]
    };

    it("format config values", function () {
      mainServiceInfoConfigsController.formatConfigValues(t.configs);
      expect(t.configs).to.deep.equal(t.result);
    });

  });

  describe("#putConfigGroupChanges", function() {

    var t = {
      data: {
        ConfigGroup: {
          id: "id"
        }
      },
      request: [{
        ConfigGroup: {
          id: "id"
        }
      }]
    };

    beforeEach(function() {
      sinon.spy($,"ajax");
    });
    afterEach(function() {
      $.ajax.restore();
    });

    it("updates configs groups", function() {
      mainServiceInfoConfigsController.putConfigGroupChanges(t.data);
      expect(JSON.parse($.ajax.args[0][0].data)).to.deep.equal(t.request);
    });
  });

  describe("#checkOverrideProperty", function () {
    var tests = [{
      overrideToAdd: {
        name: "name1",
        filename: "filename1"
      },
      componentConfig: {
        configs: [
          {
            name: "name1",
            filename: "filename2"
          },
          {
            name: "name1",
            filename: "filename1"
          }
        ]
      },
      add: true,
      m: "add property"
    },
      {
        overrideToAdd: {
          name: "name1"
        },
        componentConfig: {
          configs: [
            {
              name: "name2"
            }
          ]
        },
        add: false,
        m: "don't add property, different names"
      },
      {
        overrideToAdd: {
          name: "name1",
          filename: "filename1"
        },
        componentConfig: {
          configs: [
            {
              name: "name1",
              filename: "filename2"
            }
          ]
        },
        add: false,
        m: "don't add property, different filenames"
      },
      {
        overrideToAdd: null,
        componentConfig: {},
        add: false,
        m: "don't add property, overrideToAdd is null"
      }];

    beforeEach(function() {
      sinon.stub(App.config,"createOverride", Em.K)
    });
    afterEach(function() {
      App.config.createOverride.restore();
    });
    tests.forEach(function(t) {
      it(t.m, function() {
        mainServiceInfoConfigsController.set("overrideToAdd", t.overrideToAdd);
        mainServiceInfoConfigsController.checkOverrideProperty(t.componentConfig);
        if(t.add) {
          expect(App.config.createOverride.calledWith(t.overrideToAdd)).to.equal(true);
          expect(mainServiceInfoConfigsController.get("overrideToAdd")).to.equal(null);
        } else {
          expect(App.config.createOverride.calledOnce).to.equal(false);
        }
      });
    });
  });

  describe("#trackRequest()", function () {
    after(function(){
      mainServiceInfoConfigsController.get('requestsInProgress').clear();
    });
    it("should set requestsInProgress", function () {
      mainServiceInfoConfigsController.get('requestsInProgress').clear();
      mainServiceInfoConfigsController.trackRequest({'request': {}});
      expect(mainServiceInfoConfigsController.get('requestsInProgress')[0]).to.eql({'request': {}});
    });
  });

  describe("#setCompareDefaultGroupConfig", function() {
    beforeEach(function() {
      sinon.stub(mainServiceInfoConfigsController, "getComparisonConfig").returns("compConfig");
      sinon.stub(mainServiceInfoConfigsController, "getMockComparisonConfig").returns("mockConfig");
      sinon.stub(mainServiceInfoConfigsController, "hasCompareDiffs").returns(true);
    });
    afterEach(function() {
      mainServiceInfoConfigsController.getComparisonConfig.restore();
      mainServiceInfoConfigsController.getMockComparisonConfig.restore();
      mainServiceInfoConfigsController.hasCompareDiffs.restore();
    });
    it("empty service config passed, expect that setCompareDefaultGroupConfig will not run anything", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({}).compareConfigs.length).to.equal(0);
    });
    it("empty service config and comparison passed, expect that setCompareDefaultGroupConfig will not run anything", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({},{}).compareConfigs).to.eql(["compConfig"]);
    });
    it("expect that serviceConfig.compareConfigs will be getMockComparisonConfig", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isUserProperty: true}, null)).to.eql({compareConfigs: ["mockConfig"], isUserProperty: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isUserProperty: true}, {})).to.eql({compareConfigs: ["compConfig"], isUserProperty: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isReconfigurable: true}, {})).to.eql({compareConfigs: ["compConfig"], isReconfigurable: true, isComparison: true, hasCompareDiffs: true});
    });
    it("expect that serviceConfig.compareConfigs will be getComparisonConfig", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({isReconfigurable: true, isMock: true}, {})).to.eql({compareConfigs: ["compConfig"], isReconfigurable: true, isMock: true, isComparison: true, hasCompareDiffs: true});
    });
    it("property was created during upgrade and have no comparison, compare with 'Undefined' value should be created", function() {
      expect(mainServiceInfoConfigsController.setCompareDefaultGroupConfig({name: 'prop1', isUserProperty: false}, null)).to.eql({
        name: 'prop1', isUserProperty: false, compareConfigs: ["mockConfig"],
        isComparison: true, hasCompareDiffs: true
      });
    });
  });

  describe('#showSaveConfigsPopup', function () {

    var bodyView;

    describe('#bodyClass', function () {
      beforeEach(function() {
        sinon.stub(App.StackService, 'find').returns([{dependentServiceNames: []}]);
        sinon.stub(App.ajax, 'send', Em.K);
        // default implementation
        bodyView = mainServiceInfoConfigsController.showSaveConfigsPopup().get('bodyClass').create({
          parentView: Em.View.create()
        });
      });

      afterEach(function() {
        App.ajax.send.restore();
        App.StackService.find.restore();
      });

      describe('#componentsFilterSuccessCallback', function () {
        it('check components with unknown state', function () {
          bodyView = mainServiceInfoConfigsController.showSaveConfigsPopup('', true, '', {}, '', 'unknown', '').get('bodyClass').create({
            parentView: Em.View.create()
          });
          bodyView.componentsFilterSuccessCallback({
            items: [
              {
                ServiceComponentInfo: {
                  total_count: 4,
                  started_count: 2,
                  installed_count: 1,
                  component_name: 'c1'
                },
                host_components: [
                  {HostRoles: {host_name: 'h1'}}
                ]
              }
            ]
          });
          var unknownHosts = bodyView.get('unknownHosts');
          expect(unknownHosts.length).to.equal(1);
          expect(unknownHosts[0]).to.eql({name: 'h1', components: 'C1'});
        });
      });
    });
  });

  describe('#errorsCount', function () {

    it('should ignore configs with widgets (enhanced configs)', function () {

      mainServiceInfoConfigsController.reopen({selectedService: {
        configs: [
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: false}),
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: true}),
          Em.Object.create({isVisible: true, isValid: true}),
          Em.Object.create({isVisible: true, isValid: false})
        ]
      }});

      expect(mainServiceInfoConfigsController.get('errorsCount')).to.equal(1);

    });

    it('should ignore configs with widgets (enhanced configs) and hidden configs', function () {

      mainServiceInfoConfigsController.reopen({selectedService: {
        configs: [
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: false}),
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: true}),
          Em.Object.create({isVisible: false, isValid: false}),
          Em.Object.create({isVisible: true, isValid: true}),
          Em.Object.create({isVisible: true, isValid: false})
        ]
      }});

      expect(mainServiceInfoConfigsController.get('errorsCount')).to.equal(1);

    });

  });

  describe('#_onLoadComplete', function () {

    beforeEach(function () {
      sinon.stub(Em.run, 'next', Em.K);
      mainServiceInfoConfigsController.setProperties({
        dataIsLoaded: false,
        versionLoaded: false,
        isInit: true
      });
    });

    afterEach(function () {
      Em.run.next.restore();
    });

    it('should update flags', function () {

      mainServiceInfoConfigsController._onLoadComplete();
      expect(mainServiceInfoConfigsController.get('dataIsLoaded')).to.be.true;
      expect(mainServiceInfoConfigsController.get('versionLoaded')).to.be.true;
      expect(mainServiceInfoConfigsController.get('isInit')).to.be.false;

    });

  });

  describe('#hasCompareDiffs', function () {

    it('should return false for `password`-configs', function () {

      var hasCompareDiffs = mainServiceInfoConfigsController.hasCompareDiffs({displayType: 'password'}, {});
      expect(hasCompareDiffs).to.be.false;

    });

  });

});

});

;require.register("test/controllers/main/service/info/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service/info/summary');

describe('App.MainServiceInfoSummaryController', function () {

  var controller;

  beforeEach(function () {
    controller = App.MainServiceInfoSummaryController.create();
  });

  describe('#setRangerPlugins', function () {

    var cases = [
      {
        isLoaded: true,
        isRangerPluginsArraySet: false,
        expectedIsRangerPluginsArraySet: true,
        title: 'cluster loaded, ranger plugins array not set'
      },
      {
        isLoaded: false,
        isRangerPluginsArraySet: false,
        expectedIsRangerPluginsArraySet: false,
        title: 'cluster not loaded, ranger plugins array not set'
      },
      {
        isLoaded: false,
        isRangerPluginsArraySet: true,
        expectedIsRangerPluginsArraySet: true,
        title: 'cluster not loaded, ranger plugins array set'
      },
      {
        isLoaded: true,
        isRangerPluginsArraySet: true,
        expectedIsRangerPluginsArraySet: true,
        title: 'cluster loaded, ranger plugins array set'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS'
        }),
        Em.Object.create({
          serviceName: 'YARN'
        }),
        Em.Object.create({
          serviceName: 'HIVE'
        })
      ]);
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS',
          displayName: 'HDFS',
          configTypes: {
            'ranger-hdfs-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'HIVE',
          displayName: 'Hive',
          configTypes: {
            'hive-env': {}
          }
        }),
        Em.Object.create({
          serviceName: 'HBASE',
          displayName: 'HBase',
          configTypes: {
            'ranger-hbase-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'KNOX',
          displayName: 'Knox',
          configTypes: {
            'ranger-knox-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'STORM',
          displayName: 'Storm',
          configTypes: {
            'ranger-storm-plugin-properties': {}
          }
        }),
        Em.Object.create({
          serviceName: 'YARN',
          displayName: 'YARN',
          configTypes: {}
        })
      ]);
    });

    afterEach(function () {
      App.Service.find.restore();
      App.StackService.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isRangerPluginsArraySet', item.isRangerPluginsArraySet);
        App.set('router.clusterController.isLoaded', item.isLoaded);
        expect(controller.get('isRangerPluginsArraySet')).to.equal(item.expectedIsRangerPluginsArraySet);
        expect(controller.get('rangerPlugins').filterProperty('isDisplayed').mapProperty('serviceName').sort()).to.eql(['HDFS', 'HIVE']);
      });
    });

  });

  describe('#getRangerPluginsStatus', function () {

    var data = {
        'Clusters': {
          'desired_configs': {
            'ranger-hdfs-plugin-properties': {
              'tag': 'version1'
            },
            'hive-env': {
              'tag': 'version2'
            },
            'ranger-hbase-plugin-properties': {
              'tag': 'version3'
            }
          }
        }
      },
      cases = [
        {
          isPreviousRangerConfigsCallFailed: false,
          ajaxRequestSent: true,
          title: 'initial case'
        },
        {
          isPreviousRangerConfigsCallFailed: true,
          hdfsTag: 'version1',
          hiveTag: 'version2',
          hbaseTag: 'version3',
          ajaxRequestSent: true,
          title: 'previous call failed'
        },
        {
          isPreviousRangerConfigsCallFailed: false,
          hdfsTag: 'version2',
          hiveTag: 'version2',
          hbaseTag: 'version3',
          ajaxRequestSent: true,
          title: 'configs changed'
        },
        {
          isPreviousRangerConfigsCallFailed: false,
          hdfsTag: 'version1',
          hiveTag: 'version2',
          hbaseTag: 'version3',
          ajaxRequestSent: false,
          title: 'configs unchanged'
        }
      ];

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({
          serviceName: 'HDFS'
        }),
        Em.Object.create({
          serviceName: 'HIVE'
        }),
        Em.Object.create({
          serviceName: 'HBASE'
        }),
        Em.Object.create({
          serviceName: 'YARN'
        })
      ]);
    });

    afterEach(function () {
      App.ajax.send.restore();
      App.Service.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isPreviousRangerConfigsCallFailed', item.isPreviousRangerConfigsCallFailed);
        controller.get('rangerPlugins').findProperty('serviceName', 'HDFS').tag = item.hdfsTag;
        controller.get('rangerPlugins').findProperty('serviceName', 'HBASE').tag = item.hbaseTag;
        controller.getRangerPluginsStatus(data);
        expect(App.ajax.send.calledOnce).to.equal(item.ajaxRequestSent);
        if (item.ajaxRequestSent) {
          expect(App.ajax.send.getCall(0).args[0].data.urlParams.contains('ranger-yarn-plugin-properties')).to.be.false;
        }
      });
    });

  });

  describe('#getRangerPluginsStatusSuccess', function () {
    it('relevant plugin statuses are set', function () {
      controller.getRangerPluginsStatusSuccess({
        'items': [
          {
            'type': 'ranger-hdfs-plugin-properties',
            'properties': {
              'ranger-hdfs-plugin-enabled': 'Yes'
            }
          },
          {
            'type': 'hive-env',
            'properties': {
              'hive_security_authorization': 'Ranger'
            }
          },
          {
            'type': 'ranger-hbase-plugin-properties',
            'properties': {
              'ranger-hbase-plugin-enabled': ''
            }
          }
        ]
      });
      expect(controller.get('isPreviousRangerConfigsCallFailed')).to.be.false;
      expect(controller.get('rangerPlugins').findProperty('serviceName', 'HDFS').status).to.equal(Em.I18n.t('alerts.table.state.enabled'));
      expect(controller.get('rangerPlugins').findProperty('serviceName', 'HIVE').status).to.equal(Em.I18n.t('alerts.table.state.enabled'));
      expect(controller.get('rangerPlugins').findProperty('serviceName', 'HBASE').status).to.equal(Em.I18n.t('common.unknown'));
    });
  });

  describe('#getRangerPluginsStatusError', function () {

    it('should set isPreviousRangerConfigsCallFailed to true', function () {
      controller.getRangerPluginsStatusError();
      expect(controller.get('isPreviousRangerConfigsCallFailed')).to.be.true;
    });

  });

  describe("#getActiveWidgetLayout() for Enhanced Dashboard", function () {
    before(function () {
      sinon.stub(App.ajax, 'send');
    });
    after(function () {
      App.ajax.send.restore();
    });
    it("make GET call", function () {
      var controller = App.MainServiceInfoSummaryController.create({
        isServiceWithEnhancedWidgets: true,
        content: Em.Object.create({serviceName: 'HDFS'})
      });
      controller.getActiveWidgetLayout();
      expect(App.ajax.send.getCall(0).args[0].name).to.equal('widgets.layouts.active.get');
    });
  });

  describe("#getActiveWidgetLayoutSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub( App.widgetLayoutMapper, 'map');
      sinon.stub( App.widgetMapper, 'map');
    });
    afterEach(function () {
      App.widgetLayoutMapper.map.restore();
      App.widgetMapper.map.restore();
    });
    it("isWidgetLayoutsLoaded should be set to true", function () {
      var controller = App.MainServiceInfoSummaryController.create({
        isServiceWithEnhancedWidgets: true,
        content: Em.Object.create({serviceName: 'HDFS'})
      });
      controller.getActiveWidgetLayoutSuccessCallback({items:[{
        WidgetLayoutInfo: {}
      }]});
      expect(controller.get('isWidgetsLoaded')).to.be.true;
    });

  });

  describe("#hideWidgetSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub(App.widgetLayoutMapper, 'map');
      sinon.stub(controller, 'propertyDidChange');
    });
    afterEach(function () {
      App.widgetLayoutMapper.map.restore();
      controller.propertyDidChange.restore();
    });
    it("", function () {
      var params = {
        data: {
          WidgetLayoutInfo: {
            widgets: [
              {
                id: 1
              }
            ]
          }
        }
      };
      controller.hideWidgetSuccessCallback({}, {}, params);
      expect(App.widgetLayoutMapper.map.calledWith({
        items: [{
          WidgetLayoutInfo: {
            widgets: [
              {
                WidgetInfo: {
                  id: 1
                }
              }
            ]
          }
        }]
      })).to.be.true;
      expect(controller.propertyDidChange.calledWith('widgets')).to.be.true;
    });
  });

});
});

;require.register("test/controllers/main/service/item_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');
require('ember');
require('models/host_component');
require('views/common/modal_popup');
require('mixins/common/userPref');
require('controllers/application');
require('controllers/global/background_operations_controller');
require('controllers/global/cluster_controller');
require('controllers/main/service/reassign_controller');
require('controllers/main/service/item');
var batchUtils = require('utils/batch_scheduled_requests');

describe('App.MainServiceItemController', function () {

  describe('#setStartStopState', function () {
    var tests = [
      {
        serviceController: {
          serviceName: "YARN"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active because all services are running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HBASE"
            }
          ]
        },
        isPending: true,
        m: 'operaion is active button because current service is running'
      },
      {
        serviceController: {
          serviceName: "HDFS"
        },
        backgroundOperationsController: {
          services: [

          ]
        },
        isPending: true,
        m: 'pending is true - backgroundOperationsController.services is empty'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: false,
              dependentService: "ALL_SERVICES"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - operation is not running'
      },
      {
        serviceController: {
          serviceName: "HBASE"
        },
        backgroundOperationsController: {
          services: [
            {
              isRunning: true,
              dependentService: "HDFS"
            }
          ]
        },
        isPending: false,
        m: 'pending is false - current service is not running'
      }
    ];

    tests.forEach(function (test) {
      it(test.m, function () {
        sinon.stub(App.router, 'get', function(k) {
          if ('backgroundOperationsController.services' === k) return test.backgroundOperationsController.services;
          return Em.get(App.router, k);
        });
        var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.serviceController.serviceName}});
        mainServiceItemController.setStartStopState();
        App.router.get.restore();
        expect(mainServiceItemController.get('isPending')).to.equal(test.isPending);
      });
    })
  });

  describe('#reassignMaster()', function () {
    var tests = [
      {
        host_components: [
          {componentName: "RESOURCEMANGER"}
        ],
        componentName: "RESOURCEMANGER",
        result: true,
        m: 'run reassignMaster'
      },
      {
        host_components: [
          {componentName: "RESOURCEMANGER"}
        ],
        componentName: "DATANODE",
        result: false,
        m: 'don\t run reassignMaster'
      }
    ];

    tests.forEach(function (test) {
      var reassignMasterController = App.ReassignMasterController.create({currentStep: ''});

      beforeEach(function () {
        sinon.stub(reassignMasterController, 'saveComponentToReassign', Em.K);
        sinon.stub(reassignMasterController, 'setCurrentStep', Em.K);
      });

      afterEach(function () {
        reassignMasterController.saveComponentToReassign.restore();
        reassignMasterController.setCurrentStep.restore();
      });

      it(test.m, function () {
        sinon.stub(App.router, 'transitionTo', Em.K);
        var mainServiceItemController = App.MainServiceItemController.create({});
        sinon.stub(App.HostComponent, 'find', function() {
          return test.host_components
        });
        sinon.stub(App.router, 'get', function(k) {
          if ('reassignMasterController' === k) return reassignMasterController;
          return Em.get(App.router, k);
        });
        mainServiceItemController.reassignMaster(test.componentName);
        expect(reassignMasterController.saveComponentToReassign.calledOnce).to.equal(test.result);
        expect(reassignMasterController.setCurrentStep.calledOnce).to.equal(test.result);
        App.HostComponent.find.restore();
        App.router.transitionTo.restore();
        App.router.get.restore();
      });
    }, this);
  });

  describe("#doAction", function () {

    var el = document.createElement("BUTTON");
    el.disabled = false;
    var tests = [
      {
        event: {
          target: el,
          context: {
            action: 'runSmokeTest'
          }
        },
        m: "run runSmokeTest"
      },
      {
        event: {
          target: el,
          context: {
            action: 'refreshConfigs'
          }
        },
        m: "run refreshConfigs"
      },
      {
        event: {
          target: el,
          context: {
            action: 'restartAllHostComponents'
          }
        },
        m: "run restartAllHostComponents"
      },
      {
        event: {
          target: el,
          context: {
            action: 'rollingRestart'
          }
        },
        m: "run rollingRestart"
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = App.MainServiceItemController.create({});
      mainServiceItemController.set(test.event.context.action, Em.K);
      beforeEach(function () {
        sinon.spy(mainServiceItemController, test.event.context.action);
      });
      afterEach(function () {
        mainServiceItemController[test.event.context.action].restore();
      });
      it(test.m, function () {
        mainServiceItemController.doAction(test.event);
        expect(mainServiceItemController[test.event.context.action].calledOnce).to.equal(!test.event.target.disabled);
      });
    });
  });

  describe("#startStopPopupPrimary", function () {


    var tests = [
      {
        data: {
          "serviceName": "HDFS",
          "state": "STARTED",
          "query": Em.Object.create({ServiceInfo: "FAIL"})
        },
        request: {
          "RequestInfo": {
            "context": "_PARSE_.START.HDFS"
          },
          "Body": {
            "ServiceInfo": {
              "state": "STARTED"
            }
          }
        },
        m: "Start HDFS"
      },
      {
        data: {
          "serviceName": "YARN",
          "state": "STOPPED",
          "query": Em.Object.create({ServiceInfo: "FAIL"})
        },
        request: {
          "RequestInfo": {
            "context": "_PARSE_.STOP.YARN"
          },
          "Body": {
            "ServiceInfo": {
              "state": "STOPPED"
            }
          }
        },
        m: "Stop YARN"
      }
    ];

    beforeEach(function () {
      sinon.spy($, 'ajax');
    });

    afterEach(function () {
      $.ajax.restore();
    });


    tests.forEach(function (test) {
      it('', function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName}});
        mainServiceItemController.startStopPopupPrimary(test.data.state, test.data.query);
        expect($.ajax.calledOnce).to.equal(true);

        expect(JSON.parse($.ajax.args[0][0].data).Body.ServiceInfo.state).to.equal(test.request.Body.ServiceInfo.state);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.context).to.equal(test.request.RequestInfo.context);

        expect(mainServiceItemController.get('isStopDisabled')).to.equal(true);
        expect(mainServiceItemController.get('isStartDisabled')).to.equal(true);
      });
    });


  });

  describe("#startService , #stopService", function () {
    var mainServiceItemController = App.MainServiceItemController.create({startStopPopup: Em.K});
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopup");
    });
    afterEach(function () {
      mainServiceItemController.startStopPopup.restore();
    });
    it("start service", function () {
      mainServiceItemController.startService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.started)).to.equal(true);
    });
    it("stop service", function () {
      mainServiceItemController.stopService({});
      expect(mainServiceItemController.startStopPopup.calledWith({},App.HostComponentStatus.stopped)).to.equal(true);
    });
  });


  describe("#turnOnOffPassive", function () {
    var mainServiceItemController = App.MainServiceItemController.create({turnOnOffPassiveRequest: Em.K});
    beforeEach(function () {
      sinon.spy(batchUtils, "turnOnOffPassiveRequest");
      mainServiceItemController.set('content', {serviceName: ''});
    });
    afterEach(function () {
      batchUtils.turnOnOffPassiveRequest.restore();
    });
    it("turns on/off passive mode for service", function () {
      mainServiceItemController.turnOnOffPassive({}).onPrimary();
      expect(batchUtils.turnOnOffPassiveRequest.calledOnce).to.equal(true);
    });
  });

  describe("#runSmokeTest", function () {
    var tests = [
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STARTED"
        },
        startSmoke: true,
        serviceName: "MAPREDUCE2",
        m: "don't run smoke test primary for MAPREDUCE2"
      },
      {
        content: {
          id: "YARN",
          service_name: "YARN",
          work_status: "STOPPED"
        },
        startSmoke: false,
        serviceName: "MAPREDUCE2",
        m: "run smoke test primary for MAPREDUCE2"
      },
      {
        m: "run smoke test primary for all services (not MAPREDUCE2)",
        startSmoke: true,
        default: true
      }
    ];

    tests.forEach(function (test) {
      var mainServiceItemController = test.default ? App.MainServiceItemController.create({runSmokeTestPrimary: Em.K}) :
        App.MainServiceItemController.create({content: {serviceName: test.serviceName}, runSmokeTestPrimary: Em.K});
      beforeEach(function () {
        sinon.spy(mainServiceItemController, "runSmokeTestPrimary");
      });
      afterEach(function () {
        mainServiceItemController.runSmokeTestPrimary.restore();
      });
      it(test.m, function () {
        if (!test.default) {
          App.store.load(App.Service, test.content);
        }
        mainServiceItemController.runSmokeTest({}).onPrimary();
        expect(mainServiceItemController.runSmokeTestPrimary.calledOnce).to.equal(test.startSmoke);
      });
    });
  });

  describe("#startStopPopup", function () {
    var el = document.createElement("BUTTON");
    el.disabled = false;
    var event = {
      target: el
    };
    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        serviceName: "HDFS",
        hostComponents: [ {
          componentName: 'NAMENODE',
          workStatus: 'INSTALLED'
        }]
      }
    });
    var mainServiceItemControllerHdfsStarted = App.MainServiceItemController.create({
      content: {
        serviceName: "HDFS",
        hostComponents: [ {
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }]
      }
    });
    beforeEach(function () {
      sinon.spy(mainServiceItemController, "startStopPopupPrimary");
      sinon.spy(mainServiceItemControllerHdfsStarted, "startStopPopupPrimary");
      sinon.spy(Em.I18n, "t");
      sinon.stub(mainServiceItemControllerHdfsStarted, 'checkNnLastCheckpointTime', function(callback) {
        return callback;
      });
    });
    afterEach(function () {
      mainServiceItemController.startStopPopupPrimary.restore();
      mainServiceItemControllerHdfsStarted.startStopPopupPrimary.restore();
      mainServiceItemControllerHdfsStarted.checkNnLastCheckpointTime.restore();
      Em.I18n.t.restore();
    });
    it("start start/stop service popup", function () {
      mainServiceItemController.startStopPopup(event, "").onPrimary();
      expect(mainServiceItemController.startStopPopupPrimary.calledOnce).to.equal(true);
    });

    it ("should popup warning to check last checkpoint time if work status is STARTED", function() {
      mainServiceItemControllerHdfsStarted.startStopPopup(event, "INSTALLED");
      expect(mainServiceItemControllerHdfsStarted.checkNnLastCheckpointTime.calledOnce).to.equal(true);
    });

    describe("modal messages", function() {
      
      beforeEach(function () {
        sinon.stub(App.StackService, 'find').returns([
          Em.Object.create({
            serviceName: 'HDFS',
            displayName: 'HDFS',
            isInstalled: true,
            isSelected: true,
            requiredServices:["ZOOKEEPER"] 
          }),
          Em.Object.create({
            serviceName: 'HIVE',
            displayName: 'Hive',
            isInstalled: true,
            isSelected: true
          }),
          Em.Object.create({
            serviceName: 'HBASE',
            displayName: 'HBase',
            isInstalled: true,
            isSelected: true,
            requiredServices:["HDFS", "ZOOKEEPER"]
          }),
          Em.Object.create({
            serviceName: 'YARN',
            displayName: 'YARN',
            isInstalled: true,
            isSelected: true,
            requiredServices:["HDFS"]
          }),
          Em.Object.create({
            serviceName: 'SPARK',
            displayName: 'Spark',
            isInstalled: true,
            isSelected: true,
            requiredServices:["HIVE"]
          })
        ]);
      });
      
      it ("should confirm stop if serviceHealth is INSTALLED", function() {
        mainServiceItemController.startStopPopup(event, "INSTALLED");
        expect(Em.I18n.t.calledWith('services.service.stop.confirmMsg')).to.be.ok;
        expect(Em.I18n.t.calledWith('services.service.stop.confirmButton')).to.be.ok;
      });

      it ("should confirm start if serviceHealth is not INSTALLED", function() {
        mainServiceItemController.startStopPopup(event, "");
        expect(Em.I18n.t.calledWith('services.service.start.confirmMsg')).to.be.ok;
        expect(Em.I18n.t.calledWith('services.service.start.confirmButton')).to.be.ok;
      });
      
      it ("should not display a dependent list if it is to start a service", function() {
        var mainServiceItemController = App.MainServiceItemController.create(
            {content: {serviceName: "HDFS", passiveState:'OFF'}});
        mainServiceItemController.startStopPopup(event, "");
        expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.dependent.services')).to.not.be.ok;
      });
      
      it ("should display dependent list if other services depend on the one to be stopped", function() {
        var mainServiceItemController = App.MainServiceItemController.create(
          {content: {
            serviceName: "HDFS",
            passiveState:'OFF',
            hostComponents: [{
              componentName: 'NAMENODE',
              workStatus: 'INSTALLED'
            }]
          }}
        );
        mainServiceItemController.startStopPopup(event, "INSTALLED");
        expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.turnOnMM')).to.be.ok;
        expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.dependent.services')).to.be.ok;
        
        var dependencies = Em.I18n.t('services.service.stop.warningMsg.dependent.services').format("HDFS", "HBase,YARN")
        var msg = Em.I18n.t('services.service.stop.warningMsg.turnOnMM').format("HDFS");
        var fullMsg = mainServiceItemController.addAdditionalWarningMessage("INSTALLED", msg, "HDFS");
        expect(fullMsg).to.be.equal(msg + " " + dependencies);
      });

      it ("should display the dependent service if another service depends on the one to be stopped", function() {
        var mainServiceItemController = App.MainServiceItemController.create(
            {content: {serviceName: "HIVE", passiveState:'OFF'}});
        mainServiceItemController.startStopPopup(event, "INSTALLED");
        expect(Em.I18n.t.calledWith('services.service.stop.warningMsg.dependent.services')).to.be.ok;
        
        var dependencies = Em.I18n.t('services.service.stop.warningMsg.dependent.services').format("HIVE", "Spark")
        var msg = Em.I18n.t('services.service.stop.warningMsg.turnOnMM').format("HIVE");
        var fullMsg = mainServiceItemController.addAdditionalWarningMessage("INSTALLED", msg, "HIVE");
        expect(fullMsg).to.be.equal(msg + " " + dependencies);
      });
      
      afterEach(function () {
        App.StackService.find.restore();
      });
    });
  });

  describe("#restartAllHostComponents", function () {
    var temp = batchUtils.restartAllServiceHostComponents;
    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        serviceName: "HDFS",
        hostComponents: [{
          componentName: 'NAMENODE',
          workStatus: 'STARTED'
        }]
      }
    });
    beforeEach(function () {
      batchUtils.restartAllServiceHostComponents = Em.K;
      sinon.spy(batchUtils, "restartAllServiceHostComponents");
      sinon.stub(App.Service, 'find', function() {
        return Em.Object.create({serviceTypes: []});
      });
      sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
        return true;
      });
    });
    afterEach(function () {
      batchUtils.restartAllServiceHostComponents.restore();
      batchUtils.restartAllServiceHostComponents = temp;
      App.Service.find.restore();
      mainServiceItemController.checkNnLastCheckpointTime.restore();
    });

    it("start restartAllHostComponents for service", function () {
      var controller = App.MainServiceItemController.create({
        content: {
          serviceName: "HDFS",
          hostComponents: [{
            componentName: 'NAMENODE',
            workStatus: 'INSTALLED'
          }]
        }
      });
      controller.restartAllHostComponents({}).onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
    });

    it("check last checkpoint time for NameNode before start restartAllHostComponents for service", function () {
      mainServiceItemController.restartAllHostComponents({});
      expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
    });
  });

  describe("#rollingRestart", function () {
    var temp = batchUtils.launchHostComponentRollingRestart;
    beforeEach(function () {
      batchUtils.launchHostComponentRollingRestart = Em.K;
      sinon.spy(batchUtils, "launchHostComponentRollingRestart");
    });
    afterEach(function () {
      batchUtils.launchHostComponentRollingRestart.restore();
      batchUtils.launchHostComponentRollingRestart = temp;
    });

    var mainServiceItemController = App.MainServiceItemController.create();

    it("start restartAllHostComponents for service", function () {
      mainServiceItemController.rollingRestart();
      expect(batchUtils.launchHostComponentRollingRestart.calledOnce).to.equal(true);
    });
  });

  describe("#parseNnCheckPointTime", function () {
    var tests = [
      {
        m: "NameNode has JMX data, the last checkpoint time is less than 12 hours ago",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "NameNode has JMX data, the last checkpoint time is > 12 hours ago",
        data:
          {"href" : "",
            "ServiceComponentInfo" : {
              "cluster_name" : "c123",
              "component_name" : "NAMENODE",
              "service_name" : "HDFS"
            },
            "host_components" : [
              {
                "href" : "",
                "HostRoles" : {
                  "cluster_name" : "c123",
                  "component_name" : "NAMENODE",
                  "host_name" : "c6401.ambari.apache.org"
                },
                "metrics" : {
                  "dfs" : {
                    "FSNamesystem" : {
                      "HAState" : "active",
                      "LastCheckpointTime" : 1435617248000
                    }
                  }
                }
              }
            ]
          },
        result: "c6401.ambari.apache.org"
      },
      {
        m: "NameNode has no JMX data available",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active"
                  }
                }
              }
            }
          ]
        },
        result: null
      },
      {
        m: "HA enabled, both active and standby NN has JMX data normally.",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "HA enabled, both NamoNodes are standby NN",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "HA enabled, active NN has no JMX data, use the standby's data",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active"
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby",
                    "LastCheckpointTime" : 1435775648000
                  }
                }
              }
            }
          ]
        },
        result: false
      },
      {
        m: "HA enabled, both NamoNodes no JMX data",
        data:
        {"href" : "",
          "ServiceComponentInfo" : {
            "cluster_name" : "c123",
            "component_name" : "NAMENODE",
            "service_name" : "HDFS"
          },
          "host_components" : [
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6401.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "active"
                  }
                }
              }
            },
            {
              "href" : "",
              "HostRoles" : {
                "cluster_name" : "c123",
                "component_name" : "NAMENODE",
                "host_name" : "c6402.ambari.apache.org"
              },
              "metrics" : {
                "dfs" : {
                  "FSNamesystem" : {
                    "HAState" : "standby"
                  }
                }
              }
            }
          ]
        },
        result: null
      }
    ];

    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(1435790048000);
    });

    afterEach(function () {
      App.dateTime.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({isNNCheckpointTooOld: null});
        mainServiceItemController.parseNnCheckPointTime(test.data);
        expect(mainServiceItemController.get('isNNCheckpointTooOld')).to.equal(test.result);
      });
    });
  });

  describe("#isStartDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not red"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is red and pending is false"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: {healthStatus: test.content.healthStatus}, isPending: test.isPending});
        expect(mainServiceItemController.get('isStartDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#isStopDisabled", function () {
    var tests = [
      {
        content: {
          healthStatus: 'red'
        },
        isPending: true,
        disabled: true,
        m: "disabled because of pending"
      },
      {
        content: {
          healthStatus: 'green'
        },
        isPending: false,
        disabled: false,
        m: "enabled because healthStatus is green and pending is false"
      },
      {
        content: {
          healthStatus: 'red'
        },
        isPending: false,
        disabled: true,
        m: "disabled because healthStatus is not green"
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        var mainServiceItemController = App.MainServiceItemController.create({content: test.content, isPending: test.isPending});
        expect(mainServiceItemController.get('isStopDisabled')).to.equal(test.disabled);
      });
    });
  });

  describe("#runRebalancer", function () {
    it("run rebalancer", function () {
      sinon.stub(App.router, 'get', function(k) {
        if ('applicationController' === k) {
          return Em.Object.create({
            dataLoading: function() {
              return {done: Em.K}
            }
          });
        }
        return Em.get(App.router, k);
      });
      var mainServiceItemController = App.MainServiceItemController.create({content: {runRebalancer: false}});
      mainServiceItemController.runRebalancer().onPrimary();
      expect(mainServiceItemController.get("content.runRebalancer")).to.equal(true);
      App.router.get.restore();
    });
  });

  describe("#runCompaction", function () {
    it("run compaction", function () {
      sinon.stub(App.router, 'get', function(k) {
        if ('applicationController' === k) {
          return Em.Object.create({
            dataLoading: function() {
              return {done: Em.K}
            }
          });
        }
        return Em.get(App.router, k);
      });
      var mainServiceItemController = App.MainServiceItemController.create({content: {runCompaction: false}});
      mainServiceItemController.runCompaction().onPrimary();
      expect(mainServiceItemController.get("content.runCompaction")).to.equal(true);
      App.router.get.restore();
    });
  });

  describe("#runSmokeTestPrimary", function () {
    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('clusterName').returns('myCluster');
      sinon.spy($, 'ajax');
    });

    afterEach(function () {
      App.get.restore();
      $.ajax.restore();
    });

    var tests = [
      {
        data: {
          'serviceName': "HDFS",
          'displayName': "HDFS",
          'query': "test"
        },
        "RequestInfo": {
          "context": "HDFS Service Check",
          "command" : "HDFS_SERVICE_CHECK"
        },
        "Requests/resource_filters": [{"service_name" : "HDFS"}]
      },
      {
        data: {
          'serviceName': "KERBEROS",
          'displayName': "Kerberos",
          'query': "test"
        },
        "RequestInfo": {
          "context": "Kerberos Service Check",
          "command" : "KERBEROS_SERVICE_CHECK",
          "operation_level": {
            "level": "CLUSTER",
            "cluster_name": "myCluster"
          }
        },
        "Requests/resource_filters": [{"service_name" : "KERBEROS"}]
      }
    ];

    tests.forEach(function (test) {

      var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: test.data.serviceName,
        displayName: test.data.displayName}});
      beforeEach(function () {
        mainServiceItemController.set("runSmokeTestErrorCallBack", Em.K);
        mainServiceItemController.set("runSmokeTestSuccessCallBack", Em.K);
      });

      it('send request to run smoke test for ' + test.data.serviceName, function () {
        mainServiceItemController.runSmokeTestPrimary(test.data.query);
        expect($.ajax.calledOnce).to.equal(true);

        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.context).to.equal(test.RequestInfo.context);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.command).to.equal(test.RequestInfo.command);
        expect(JSON.parse($.ajax.args[0][0].data)["Requests/resource_filters"][0].serviceName).to.equal(test["Requests/resource_filters"][0].serviceName);
        expect(JSON.parse($.ajax.args[0][0].data).RequestInfo.operation_level).to.be.deep.equal(test.RequestInfo.operation_level);
      });
    });
  });


  describe('#downloadClientConfigs()', function () {

    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        clientComponents: [
          Em.Object.create({
            totalCount: 1,
            componentName: 'C1',
            displayName: 'd1'
          })
        ],
        serviceName: 'S1'
      }
    });

    beforeEach(function () {
      sinon.stub(mainServiceItemController, 'downloadClientConfigsCall', Em.K);
    });
    afterEach(function () {
      mainServiceItemController.downloadClientConfigsCall.restore();
    });

    it('should launch $.fileDownload method', function () {
      mainServiceItemController.downloadClientConfigs();
      expect(mainServiceItemController.downloadClientConfigsCall.calledWith({
        serviceName: 'S1',
        componentName: 'C1',
        displayName: 'd1'
      })).to.be.true;
    });
    it('should launch $.fileDownload method, event passed', function () {
      var event = {
        label: 'label1',
        name: 'name1'
      };
      mainServiceItemController.downloadClientConfigs(event);
      expect(mainServiceItemController.downloadClientConfigsCall.calledWith({
        serviceName: 'S1',
        componentName: 'name1',
        displayName: 'label1'
      })).to.be.true;
    });
  });

  describe('#startLdapKnox() and #stopLdapKnox() should call startStopLdapKnox once: ', function () {


    var mainServiceItemController = App.MainServiceItemController.create({content: {serviceName: 'KNOX',
      displayName: 'Knox'}});

    beforeEach(function () {
      sinon.stub(mainServiceItemController, 'startStopLdapKnox', function(){
        return true;
      });
    });
    afterEach(function () {
      mainServiceItemController.startStopLdapKnox.restore();
    });

    var tests = [
      {
        methodName: 'startLdapKnox',
        callback: mainServiceItemController.startLdapKnox
      },
      {
        methodName: 'stopLdapKnox',
        callback: mainServiceItemController.stopLdapKnox
      }
    ];

    tests.forEach(function(test){
      it(test.methodName + ' should call startStopLdapKnox method', function () {
        test.callback.call(mainServiceItemController);
        expect(mainServiceItemController.startStopLdapKnox.calledOnce).to.be.true;
      });
    },this);

  });

  describe("#executeCustomCommand", function () {
    var data = {
      data: {
        'serviceName': "SAMPLESRV",
        'displayName': "SAMPLESRV",
        'query': "test"
      },
      "RequestInfo": {
        "context": "Execute Custom Commands",
        "command" : "SAMPLESRVCUSTOMCOMMANDS"
      },
      "Requests/resource_filters": [{"service_name" : "SAMPLESRV"}]
    };

    var context = {
      label: 'Execute Custom Commands',
      service: data.data.serviceName,
      component: data.data.serviceName,
      command: data.RequestInfo.command
    };

    var mainServiceItemController = App.MainServiceItemController.create({
      content: {
        serviceName: data.data.serviceName,
        displayName: data.data.displayName
      }
    });

    before(function () {
      mainServiceItemController.set("executeCustomCommandErrorCallback", Em.K);
      mainServiceItemController.set("executeCustomCommandSuccessCallback", Em.K);
      sinon.spy(App, 'showConfirmationPopup');
    });

    after(function () {
      App.showConfirmationPopup.restore();
    });

    it('shows a confirmation popup', function () {
      mainServiceItemController.executeCustomCommand(context);
      expect(App.showConfirmationPopup.calledOnce).to.equal(true);
    });
  });
});

});

;require.register("test/controllers/main/service/manage_config_groups_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var c;

describe('App.ManageConfigGroupsController', function() {
  var controller = App.ManageConfigGroupsController.create({});

  beforeEach(function() {
    c = App.ManageConfigGroupsController.create({});
  });

	var manageConfigGroupsController = App.ManageConfigGroupsController.create({});

	describe('#addConfigGroup', function() {
		beforeEach(function() {
			manageConfigGroupsController.addConfigGroup();
		});

		describe("#validate", function() {
			it("should display no warning if user inputs valid characters into group name", function() {

				manageConfigGroupsController.addGroupPopup.set('configGroupName', 'hello');

				expect(manageConfigGroupsController.addGroupPopup.warningMessage).to.be.empty;
			});

			it("should display warning if user inputs invalid characters into group name", function() {
				manageConfigGroupsController.addGroupPopup.set('configGroupName', '/{"!@#$%');

				expect(manageConfigGroupsController.addGroupPopup.warningMessage).to.equal('Invalid Group Name. Only alphanumerics, hyphens, spaces and underscores are allowed.');
			});
		});
	});

	describe('#renameConfigGroup', function() {
		beforeEach(function() {
			var configGroup = Ember.Object.create ({
				name: 'name',
				description: 'description'
			});

			manageConfigGroupsController.set('selectedConfigGroup', configGroup);
			manageConfigGroupsController.renameConfigGroup();
		});

		describe("#validate", function() {
			it("should display no warning if user inputs valid characters into group name", function() {
				manageConfigGroupsController.renameGroupPopup.set('configGroupName', 'hello');

				expect(manageConfigGroupsController.renameGroupPopup.warningMessage).to.be.empty;
			});

			it("should display warning if user inputs invalid characters into group name", function() {
				manageConfigGroupsController.renameGroupPopup.set('configGroupName', '/{"!@#$%');

				expect(manageConfigGroupsController.renameGroupPopup.warningMessage).to.equal('Invalid Group Name. Only alphanumerics, hyphens, spaces and underscores are allowed.');
			});
		});
	});

  describe('#addHostsCallback', function() {

    beforeEach(function() {

      c.reopen({
        selectedConfigGroup: Em.Object.create({
          hosts: ['h1'],
          parentConfigGroup: Em.Object.create({
            hosts: ['h2', 'h3']
          })
        })
      });
    });

    it('should set hosts to selectedConfigGroup and remove them form default group', function () {

      c.addHostsCallback(['h2', 'h3']);

      expect(c.get('selectedConfigGroup.hosts')).to.include.members(['h1','h2','h3']);
      expect(c.get('selectedConfigGroup.parentConfigGroup.hosts').toArray()).to.be.empty;
    });

  });

  describe('#isHostsModified', function () {

    Em.A([
        {
          o: {
            toClearHosts: [],
            toDelete: [],
            toSetHosts: [],
            toCreate: []
          },
          e: false
        },
        {
          o: {
            toClearHosts: [{}],
            toDelete: [],
            toSetHosts: [],
            toCreate: []
          },
          e: true
        },
        {
          o: {
            toClearHosts: [],
            toDelete: [{}],
            toSetHosts: [],
            toCreate: []
          },
          e: true
        },
        {
          o: {
            toClearHosts: [],
            toDelete: [],
            toSetHosts: [{}],
            toCreate: []
          },
          e: true
        },
        {
          o: {
            toClearHosts: [],
            toDelete: [],
            toSetHosts: [],
            toCreate: [{}]
          },
          e: true
        }
    ]).forEach(function (test, index) {
        it('test #' + index, function () {
          c.reopen({
            isLoaded: true,
            hostsModifiedConfigGroups: test.o
          });
          expect(c.get('isHostsModified')).to.equal(test.e);
        });
      });

  });

  describe('#deleteConfigGroup', function () {

    beforeEach(function() {

      var defaultGroup = Em.Object.create({
        hosts: ['h2', 'h3'],
        isDefault: true
      });

      var selectedGroup = Em.Object.create({
        hosts: ['h1'],
        parentConfigGroup: defaultGroup
      });

      c.reopen({
        configGroups: [defaultGroup, selectedGroup],
        selectedConfigGroup: selectedGroup
      });
    });

    it('after deleting some config group, Default should be selected', function () {

      c.deleteConfigGroup();

      expect(c.get('selectedConfigGroup.hosts')).to.include.members(['h1','h2','h3']);
      expect(c.get('selectedConfigGroup.isDefault')).to.be.true;
    });

  });

});

});

;require.register("test/controllers/main/service/reassign/step1_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/service/reassign/step1_controller');
require('models/host_component');

describe('App.ReassignMasterWizardStep1Controller', function () {


  var controller = App.ReassignMasterWizardStep1Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create({}),
      services: []
    })
  });
  controller.set('_super', Em.K);

  describe('#loadConfigTags', function() {
    beforeEach(function() {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function() {
      App.ajax.send.restore();
    });

    it('tests loadConfigTags', function() {
      controller.loadConfigsTags();

      expect(App.ajax.send.calledOnce).to.be.true;
    });

    it('tests saveDatabaseType with type', function() {
      sinon.stub(App.router, 'get', function() {
        return { saveDatabaseType: Em.K};
      });

      controller.saveDatabaseType(true);
      expect(App.router.get.calledOnce).to.be.true;

      App.router.get.restore();
    });

    it('tests saveDatabaseType without type', function() {
      sinon.stub(App.router, 'get', function() {
        return { saveDatabaseType: Em.K};
      });

      controller.saveDatabaseType(false);
      expect(App.router.get.called).to.be.false;

      App.router.get.restore();
    });

    it('tests saveServiceProperties with propertie', function() {
      sinon.stub(App.router, 'get', function() {
        return { saveServiceProperties: Em.K};
      });

      controller.saveServiceProperties(true);
      expect(App.router.get.calledOnce).to.be.true;

      App.router.get.restore();
    });

    it('tests saveServiceProperties without properties', function() {
      sinon.stub(App.router, 'get', function() {
        return { saveServiceProperties: Em.K};
      });

      controller.saveServiceProperties(false);
      expect(App.router.get.called).to.be.false;

      App.router.get.restore();
    });

    it('tests getDatabaseHost', function() {
      controller.set('content.serviceProperties', {
        'javax.jdo.option.ConnectionURL': "jdbc:mysql://c6401/hive?createDatabaseIfNotExist=true"
      });

      controller.set('content.reassign.service_id', 'HIVE');
      controller.set('databaseType', 'mysql');

      expect(controller.getDatabaseHost()).to.equal('c6401')
    });

  });

  describe('#onLoadConfigs', function() {

    var controller;
    var reassignCtrl;

    beforeEach(function() {
      controller = App.ReassignMasterWizardStep1Controller.create({
        content: Em.Object.create({
          reassign: Em.Object.create({
            'component_name': 'OOZIE_SERVER',
            'service_id': 'OOZIE'
          }),
          services: []
        })
      });
      controller.set('_super', Em.K);

      sinon.stub(controller, 'getDatabaseHost', Em.K);
      sinon.stub(controller, 'saveDatabaseType', Em.K);
      sinon.stub(controller, 'saveServiceProperties', Em.K);
    
      reassignCtrl = App.router.reassignMasterController;
      reassignCtrl.set('content.hasManualSteps', true);
    });

    afterEach(function() {
      controller.getDatabaseHost.restore();
      controller.saveDatabaseType.restore();
      controller.saveServiceProperties.restore();
    });
  
    it('should not set hasManualSteps to false for oozie with derby db', function() {
      var data = {
        items: [
          {
            properties: {
              'oozie.service.JPAService.jdbc.driver': 'jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true'
            }
          }
        ]
      };
    
      expect(reassignCtrl.get('content.hasManualSteps')).to.be.true;

      controller.onLoadConfigs(data);

      expect(reassignCtrl.get('content.hasManualSteps')).to.be.true;
    });
  
    it('should set hasManualSteps to false for oozie without derby db', function() {
      var data = {
        items: [
          {
            properties: {
              'oozie.service.JPAService.jdbc.driver': 'mysql'
            }
          }
        ]
      };

    
      expect(reassignCtrl.get('content.hasManualSteps')).to.be.true;

      controller.onLoadConfigs(data);

      expect(reassignCtrl.get('content.hasManualSteps')).to.be.false;
    });
  });
});

});

;require.register("test/controllers/main/service/reassign/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/main/service/reassign/step2_controller');
require('models/host_component');

describe('App.ReassignMasterWizardStep2Controller', function () {


  var controller = App.ReassignMasterWizardStep2Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create({}),
      services: []
    }),
    renderComponents: Em.K,
    multipleComponents: []
  });

  describe('#customClientSideValidation', function () {
    var hostComponents = [];
    var isSubmitDisabled = false;

    beforeEach(function () {
      sinon.stub(App.HostComponent, 'find', function () {
        return hostComponents;
      });
    });
    afterEach(function () {
      App.HostComponent.find.restore();
    });
    it('No host-components, reassigned equal 0', function () {
      expect(controller.customClientSideValidation()).to.be.false;
    });
    it('Reassign component match existed components, reassigned equal 0', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [Em.Object.create({
        componentName: 'COMP1',
        hostName: 'host1'
      })];
      controller.set('servicesMasters', [{
        component_name: 'COMP1',
        selectedHost: 'host1'
      }]);

      expect(controller.customClientSideValidation()).to.be.false;
    });
    it('Reassign component do not match existed components, reassigned equal 1', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [Em.Object.create({
        componentName: 'COMP1',
        hostName: 'host1'
      })];
      controller.set('servicesMasters', []);

      expect(controller.customClientSideValidation()).to.be.true;
    });
    it('Reassign component do not match existed components, reassigned equal 2', function () {
      controller.set('content.reassign.component_name', 'COMP1');
      hostComponents = [
        Em.Object.create({
          componentName: 'COMP1',
          hostName: 'host1'
        }),
        Em.Object.create({
          componentName: 'COMP1',
          hostName: 'host2'
        })
      ];
      controller.set('servicesMasters', []);

      expect(controller.customClientSideValidation()).to.be.false;
    });

    it('submitDisabled is already true', function () {
      isSubmitDisabled = true;

      expect(controller.customClientSideValidation()).to.be.false;
    });
  });
});

});

;require.register("test/controllers/main/service/reassign/step4_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/reassign/step4_controller');

describe('App.ReassignMasterWizardStep4Controller', function () {

  var controller = App.ReassignMasterWizardStep4Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create(),
      reassignHosts: Em.Object.create()
    })
  });

  beforeEach(function () {
    sinon.stub(App.ajax, 'send', Em.K);
  });
  afterEach(function () {
    App.ajax.send.restore();
  });

  describe('#setAdditionalConfigs()', function () {

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('isHaEnabled').returns(true);
    });

    afterEach(function () {
      App.get.restore();
    });

    it('Component is absent', function () {
      controller.set('additionalConfigsMap', []);
      var configs = {};

      expect(controller.setAdditionalConfigs(configs, 'COMP1', '')).to.be.false;
      expect(configs).to.eql({});
    });

    it('configs for Hadoop 2 is present', function () {
      controller.set('additionalConfigsMap', [
        {
          componentName: 'COMP1',
          configs: {
            'test-site': {
              'property1': '<replace-value>:1111'
            }
          },
          configs_Hadoop2: {
            'test-site': {
              'property2': '<replace-value>:2222'
            }
          }
        }
      ]);
      var configs = {
        'test-site': {}
      };

      expect(controller.setAdditionalConfigs(configs, 'COMP1', 'host1')).to.be.true;
      expect(configs).to.eql({
        'test-site': {
          'property2': 'host1:2222'
        }
      });
    });

    it('ignore some configs for NameNode after HA', function () {
      controller.set('additionalConfigsMap', [
        {
          componentName: 'NAMENODE',
          configs: {
            'test-site': {
              'fs.defaultFS': '<replace-value>:1111',
              'dfs.namenode.rpc-address': '<replace-value>:1111'
            }
          }
        }
      ]);
      var configs = {'test-site': {}};

      expect(controller.setAdditionalConfigs(configs, 'NAMENODE', 'host1')).to.be.true;
      expect(configs).to.eql({'test-site': {}});
    });
  });

  describe('#getHostComponentsNames()', function () {
    it('No host-components', function () {
      controller.set('hostComponents', []);
      expect(controller.getHostComponentsNames()).to.be.empty;
    });
    it('one host-components', function () {
      controller.set('hostComponents', ['COMP1']);
      expect(controller.getHostComponentsNames()).to.equal('Comp1');
    });
    it('ZKFC host-components', function () {
      controller.set('hostComponents', ['COMP1', 'ZKFC']);
      expect(controller.getHostComponentsNames()).to.equal('Comp1+ZKFC');
    });
  });

  describe('#testDBConnection', function() {
    beforeEach(function() {
      controller.set('requiredProperties', Em.A([]));
      controller.set('content.serviceProperties', Em.Object.create({'javax.jdo.option.ConnectionDriverName': 'mysql'}));
      controller.set('content.reassign.component_name', 'HIVE_SERVER');
      sinon.stub(controller, 'getConnectionProperty', Em.K);
      sinon.stub(App.router, 'get', Em.K);
    });

    afterEach(function() {
      controller.getConnectionProperty.restore();
      App.router.get.restore();
    });

    it('tests database connection', function() {
      sinon.stub(controller, 'prepareDBCheckAction', Em.K);

      controller.testDBConnection();
      expect(controller.prepareDBCheckAction.calledOnce).to.be.true;

      controller.prepareDBCheckAction.restore();
    });

    it('tests prepareDBCheckAction', function() {
      controller.prepareDBCheckAction();

      expect(App.ajax.send.calledOnce).to.be.true;
    });

  });

  describe('#removeUnneededTasks()', function () {
    var isHaEnabled = false;
    var commands;
    var commandsForDB;

    beforeEach(function () {
      sinon.stub(App, 'get', function () {
        return isHaEnabled;
      });

      commands = [
        { id: 1, command: 'stopRequiredServices' },
        { id: 2, command: 'cleanMySqlServer' },
        { id: 3, command: 'createHostComponents' },
        { id: 4, command: 'putHostComponentsInMaintenanceMode' },
        { id: 5, command: 'reconfigure' },
        { id: 6, command: 'installHostComponents' },
        { id: 7, command: 'startZooKeeperServers' },
        { id: 8, command: 'startNameNode' },
        { id: 9, command: 'deleteHostComponents' },
        { id: 10, command: 'configureMySqlServer' },
        { id: 11, command: 'startMySqlServer' },
        { id: 12, command: 'startNewMySqlServer' },
        { id: 13, command: 'startRequiredServices' }
      ];

      commandsForDB = [
        { id: 1, command: 'createHostComponents' },
        { id: 2, command: 'installHostComponents' },
        { id: 3, command: 'configureMySqlServer' },
        { id: 4, command: 'restartMySqlServer' },
        { id: 5, command: 'testDBConnection' },
        { id: 6, command: 'stopRequiredServices' },
        { id: 7, command: 'cleanMySqlServer' },
        { id: 8, command: 'putHostComponentsInMaintenanceMode' },
        { id: 9, command: 'reconfigure' },
        { id: 10, command: 'deleteHostComponents' },
        { id: 11, command: 'configureMySqlServer' },
        { id: 12, command: 'startRequiredServices' }
      ];
    });

    afterEach(function () {
      App.get.restore();
    });

    it('hasManualSteps is false', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', false);

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1,3,4,5,6,9,12,13]);
    });

    it('reassign component is not NameNode and HA disabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'COMP1');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 5, 6]);
    });

    it('reassign component is not NameNode and HA enabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'COMP1');
      isHaEnabled = true;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 5, 6]);
    });

    it('reassign component is NameNode and HA disabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'NAMENODE');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 5, 6]);
    });

    it('reassign component is NameNode and HA enabled', function () {
      controller.set('tasks', commands);
      controller.set('content.hasManualSteps', true);
      controller.set('content.reassign.component_name', 'NAMENODE');
      isHaEnabled = true;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 3, 4, 5, 6, 7, 8]);
    });

    it('reassign component is HiveServer and db type is mysql', function () {
      controller.set('tasks', commandsForDB);
      controller.set('content.hasManualSteps', false);
      controller.set('content.databaseType', 'mysql');
      controller.set('content.reassign.component_name', 'HIVE_SERVER');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]);
    });

    it('reassign component is HiveServer and db type is not mysql', function () {
      controller.set('tasks', commandsForDB);
      controller.set('content.hasManualSteps', false);
      controller.set('content.databaseType', 'derby');
      controller.set('content.reassign.component_name', 'HIVE_SERVER');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1, 2, 6, 8, 9, 10, 12]);
    });

    it('reassign component is Oozie Server and db type is derby', function () {
      controller.set('tasks', commandsForDB);
      controller.set('content.hasManualSteps', true);
      controller.set('content.databaseType', 'derby');
      controller.set('content.reassign.component_name', 'OOZIE_SERVER');
      isHaEnabled = false;

      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1,2,6,8,9]);
    });

    it('reassign component is Oozie Server and db type is mysql', function () {
      controller.set('content.hasManualSteps', false);
      controller.set('content.databaseType', 'mysql');
      controller.set('content.reassign.component_name', 'OOZIE_SERVER');
      isHaEnabled = false;

      controller.set('tasks', commandsForDB);
      controller.removeUnneededTasks();
      expect(controller.get('tasks').mapProperty('id')).to.eql([1,2,3,4,5,6,7,8,9,10,11,12]);
    });
  });

  describe('#initializeTasks()', function () {
    beforeEach(function () {
      controller.set('tasks', []);
      sinon.stub(controller, 'getHostComponentsNames', Em.K);
      sinon.stub(controller, 'removeUnneededTasks', Em.K);
    });
    afterEach(function () {
      controller.removeUnneededTasks.restore();
      controller.getHostComponentsNames.restore();
    });
    it('No commands', function () {
      controller.set('commands', []);
      controller.set('commandsForDB', []);
      controller.initializeTasks();

      expect(controller.get('tasks')).to.be.empty;
    });
    it('One command', function () {
      controller.set('commands', ['COMMAND1']);
      controller.set('commandsForDB', ['COMMAND1']);
      controller.initializeTasks();

      expect(controller.get('tasks')[0].get('id')).to.equal(0);
      expect(controller.get('tasks')[0].get('command')).to.equal('COMMAND1');
    });
  });

  describe('#hideRollbackButton()', function () {

    it('No showRollback command', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: false
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
    it('showRollback command is present', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: true
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
  });

  describe('#onComponentsTasksSuccess()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onTaskCompleted', Em.K);
    });
    afterEach(function () {
      controller.onTaskCompleted.restore();
    });

    it('One host-component', function () {
      controller.set('multiTaskCounter', 1);
      controller.set('hostComponents', [
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
    it('two host-components', function () {
      controller.set('multiTaskCounter', 2);
      controller.set('hostComponents', [
        {},
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.onTaskCompleted.called).to.be.false;
    });
  });

  describe('#stopServices()', function () {
    it('', function () {
      controller.stopServices();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#createHostComponents()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'createComponent', Em.K);
    });
    afterEach(function () {
      controller.createComponent.restore();
    });

    it('One host-component', function () {
      controller.set('hostComponents', ['COMP1']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.set('content.reassign.service_id', 'SERVICE1');

      controller.createHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.createComponent.calledWith('COMP1', 'host1', 'SERVICE1')).to.be.true;
    });
  });

  describe('#onCreateComponent()', function () {
    it('', function () {
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      controller.onCreateComponent();
      expect(controller.onComponentsTasksSuccess.calledOnce).to.be.true;
      controller.onComponentsTasksSuccess.restore();
    });
  });

  describe('#putHostComponentsInMaintenanceMode()', function () {
    beforeEach(function(){
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      controller.set('content.reassignHosts.source', 'source');
    });
    afterEach(function(){
      controller.onComponentsTasksSuccess.restore();
    });
    it('No host-components', function () {
      controller.set('hostComponents', []);
      controller.putHostComponentsInMaintenanceMode();
      expect(App.ajax.send.called).to.be.false;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it('One host-components', function () {
      controller.set('hostComponents', [{}]);
      controller.putHostComponentsInMaintenanceMode();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.get('multiTaskCounter')).to.equal(1);
    });
  });

  describe('#installHostComponents()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'updateComponent', Em.K);
    });
    afterEach(function () {
      controller.updateComponent.restore();
    });

    it('No host-components', function () {
      controller.set('hostComponents', []);

      controller.installHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.updateComponent.called).to.be.false;
    });
    it('One host-component', function () {
      controller.set('hostComponents', ['COMP1']);
      controller.set('content.reassignHosts.target', 'host1');
      controller.set('content.reassign.service_id', 'SERVICE1');

      controller.installHostComponents();

      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.updateComponent.calledWith('COMP1', 'host1', 'SERVICE1', 'Install', 1)).to.be.true;
    });
  });

  describe('#reconfigure()', function () {
    it('', function () {
      sinon.stub(controller, 'loadConfigsTags', Em.K);
      controller.reconfigure();
      expect(controller.loadConfigsTags.calledOnce).to.be.true;
      controller.loadConfigsTags.restore();
    });
  });

  describe('#loadConfigsTags()', function () {
    it('', function () {
      controller.loadConfigsTags();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#getConfigUrlParams()', function () {
    var testCases  = [
      {
        componentName: 'NAMENODE',
        result: [
          "(type=hdfs-site&tag=1)",
          "(type=core-site&tag=2)"
        ]
      },
      {
        componentName: 'SECONDARY_NAMENODE',
        result: [
          "(type=hdfs-site&tag=1)",
          "(type=core-site&tag=2)"
        ]
      },
      {
        componentName: 'JOBTRACKER',
        result: [
          "(type=mapred-site&tag=4)"
        ]
      },
      {
        componentName: 'RESOURCEMANAGER',
        result: [
          "(type=yarn-site&tag=5)"
        ]
      },
      {
        componentName: 'APP_TIMELINE_SERVER',
        result: [
          "(type=yarn-site&tag=5)",
          "(type=yarn-env&tag=8)",
        ]
      },
      {
        componentName: 'OOZIE_SERVER',
        result: [
          "(type=oozie-site&tag=6)",
          "(type=core-site&tag=2)",
          "(type=oozie-env&tag=2)"
        ]
      },
      {
        componentName: 'WEBHCAT_SERVER',
        result: [
          "(type=webhcat-site&tag=7)"
        ]
      }
    ];

    var data = {
      Clusters: {
        desired_configs: {
          'hdfs-site': {tag: 1},
          'core-site': {tag: 2},
          'hbase-site': {tag: 3},
          'mapred-site': {tag: 4},
          'yarn-site': {tag: 5},
          'oozie-site': {tag: 6},
          'oozie-env': {tag: 2},
          'webhcat-site': {tag: 7},
          'yarn-env': {tag: 8},
          'accumulo-site': {tag: 9}
        }
      }
    };

    var services = [];

    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return services;
      });
    });
    afterEach(function () {
      App.Service.find.restore();
    });

    testCases.forEach(function (test) {
      it('get config of ' + test.componentName, function () {
        expect(controller.getConfigUrlParams(test.componentName, data)).to.eql(test.result);
      });
    });
    it('get config of NAMENODE when HBASE installed', function () {
      services = [
        {
          serviceName: 'HBASE'
        }
      ];
      expect(controller.getConfigUrlParams('NAMENODE', data)).to.eql([
        "(type=hdfs-site&tag=1)",
        "(type=core-site&tag=2)",
        "(type=hbase-site&tag=3)"
      ]);
    });

    it('get config of NAMENODE when ACCUMULO installed', function () {
      services = [
        {
          serviceName: 'ACCUMULO'
        }
      ];
      expect(controller.getConfigUrlParams('NAMENODE', data)).to.eql([
        "(type=hdfs-site&tag=1)",
        "(type=core-site&tag=2)",
        "(type=accumulo-site&tag=9)"
      ]);
    });

  });

  describe('#onLoadConfigsTags()', function () {
    it('', function () {
      sinon.stub(controller, 'getConfigUrlParams', function () {
        return [];
      });
      controller.set('content.reassign.component_name', 'COMP1');

      controller.onLoadConfigsTags({});
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.getConfigUrlParams.calledWith('COMP1', {})).to.be.true;

      controller.getConfigUrlParams.restore();
    });
  });

  describe('#onLoadConfigs()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'setAdditionalConfigs', Em.K);
      sinon.stub(controller, 'setSecureConfigs', Em.K);
      sinon.stub(controller, 'setSpecificNamenodeConfigs', Em.K);
      sinon.stub(controller, 'setSpecificResourceMangerConfigs', Em.K);
      sinon.stub(controller, 'getWebAddressPort', Em.K);
      sinon.stub(controller, 'getComponentDir', Em.K);
      sinon.stub(controller, 'saveClusterStatus', Em.K);
      sinon.stub(controller, 'saveConfigsToServer', Em.K);
      sinon.stub(controller, 'saveServiceProperties', Em.K);
      controller.set('content.reassignHosts.target', 'host1');
    });
    afterEach(function () {
      controller.setAdditionalConfigs.restore();
      controller.setSecureConfigs.restore();
      controller.setSpecificNamenodeConfigs.restore();
      controller.setSpecificResourceMangerConfigs.restore();
      controller.getWebAddressPort.restore();
      controller.getComponentDir.restore();
      controller.saveClusterStatus.restore();
      controller.saveConfigsToServer.restore();
      controller.saveServiceProperties.restore();
    });

    it('component is not NAMENODE', function () {
      controller.set('content.reassign.component_name', 'COMP1');

      controller.onLoadConfigs({items: []});
      expect(controller.setAdditionalConfigs.calledWith({}, 'COMP1', 'host1')).to.be.true;
      expect(controller.setSecureConfigs.calledWith([], {}, 'COMP1')).to.be.true;
      expect(controller.setSpecificNamenodeConfigs.called).to.be.false;
      expect(controller.getComponentDir.calledWith({}, 'COMP1')).to.be.true;
      expect(controller.saveClusterStatus.calledWith([])).to.be.true;
      expect(controller.saveConfigsToServer.calledWith({})).to.be.true;
      expect(controller.saveServiceProperties.calledWith({})).to.be.true;
    });
    it('component is NAMENODE, has configs', function () {
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.onLoadConfigs({items: [
        {
          type: 'hdfs-site',
          properties: {}
        }
      ]});
      expect(controller.setAdditionalConfigs.calledWith({'hdfs-site': {}}, 'NAMENODE', 'host1')).to.be.true;
      expect(controller.setSecureConfigs.calledWith([], {'hdfs-site': {}}, 'NAMENODE')).to.be.true;
      expect(controller.setSpecificNamenodeConfigs.calledWith({'hdfs-site': {}}, 'host1')).to.be.true;
      expect(controller.getComponentDir.calledWith({'hdfs-site': {}}, 'NAMENODE')).to.be.true;
      expect(controller.saveClusterStatus.calledWith([])).to.be.true;
      expect(controller.saveConfigsToServer.calledWith({'hdfs-site': {}})).to.be.true;
      expect(controller.saveServiceProperties.calledWith({'hdfs-site': {}})).to.be.true;
    });
    it('component is RESOURCEMANAGER, has configs', function () {
      controller.set('content.reassign.component_name', 'RESOURCEMANAGER');

      controller.onLoadConfigs({items: [
        {
          type: 'hdfs-site',
          properties: {}
        }
      ]});
      expect(controller.setAdditionalConfigs.calledWith({'hdfs-site': {}}, 'RESOURCEMANAGER', 'host1')).to.be.true;
      expect(controller.setSecureConfigs.calledWith([], {'hdfs-site': {}}, 'RESOURCEMANAGER')).to.be.true;
      expect(controller.setSpecificResourceMangerConfigs.calledWith({'hdfs-site': {}}, 'host1')).to.be.true;
      expect(controller.getComponentDir.calledWith({'hdfs-site': {}}, 'RESOURCEMANAGER')).to.be.true;
      expect(controller.saveClusterStatus.calledWith([])).to.be.true;
      expect(controller.saveConfigsToServer.calledWith({'hdfs-site': {}})).to.be.true;
      expect(controller.saveServiceProperties.calledWith({'hdfs-site': {}})).to.be.true;
    });
  });

  describe('#loadStep()', function () {
    var isHaEnabled = true;

    beforeEach(function () {
      controller.set('content.reassign.service_id', 'service1');
      sinon.stub(controller, 'onTaskStatusChange', Em.K);
      sinon.stub(controller, 'initializeTasks', Em.K);
      sinon.stub(App, 'get', function () {
        return isHaEnabled;
      });
    });
    afterEach(function () {
      controller.onTaskStatusChange.restore();
      controller.initializeTasks.restore();
      App.get.restore();
    });

    it('reassign component is NameNode and HA enabled', function () {
      isHaEnabled = true;
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE', 'ZKFC']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
    it('reassign component is NameNode and HA disabled', function () {
      isHaEnabled = false;
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
    it('reassign component is JOBTRACKER and HA enabled', function () {
      isHaEnabled = true;
      controller.set('content.reassign.component_name', 'JOBTRACKER');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['JOBTRACKER']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
    it('reassign component is RESOURCEMANAGER and HA enabled', function () {
      isHaEnabled = true;
      controller.set('content.reassign.component_name', 'RESOURCEMANAGER');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['RESOURCEMANAGER']);
      expect(controller.get('serviceName')).to.eql(['service1']);
    });
  });


  describe('#saveConfigsToServer()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'getServiceConfigData', Em.K);
    });
    afterEach(function () {
      controller.getServiceConfigData.restore();
    });
    it('', function () {
      controller.saveConfigsToServer([1]);
      expect(controller.getServiceConfigData.calledWith([1])).to.be.true;
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#setSpecificNamenodeConfigs()', function () {
    var isHaEnabled = false;
    var service = Em.Object.create();
    beforeEach(function () {
      sinon.stub(App, 'get', function () {
        return isHaEnabled;
      });
      sinon.stub(App.Service, 'find', function () {
        return service;
      });
      controller.set('content.reassignHosts.source', 'host1');
    });
    afterEach(function () {
      App.get.restore();
      App.Service.find.restore();
    });
    it('HA isn\'t enabled and no HBASE or ACCUMULO service', function () {
      isHaEnabled = false;
      var configs = {};
      controller.setSpecificNamenodeConfigs(configs, 'host1');
      expect(configs).to.eql({});
    });
    it('HA isn\'t enabled and HBASE and ACCUMULO service', function () {
      isHaEnabled = false;
      service = Em.Object.create({
        isLoaded: true
      });
      var configs = {
        'hbase-site': {
          'hbase.rootdir': 'hdfs://localhost:8020/apps/hbase/data'
        },
        'accumulo-site': {
          'instance.volumes': 'hdfs://localhost:8020/apps/accumulo/data'
        }
      };
      controller.setSpecificNamenodeConfigs(configs, 'host1');
      expect(configs['hbase-site']['hbase.rootdir']).to.equal('hdfs://host1:8020/apps/hbase/data');
      expect(configs['accumulo-site']['instance.volumes']).to.equal('hdfs://host1:8020/apps/accumulo/data');
    });
    it('HA enabled and namenode 1', function () {
      isHaEnabled = true;
      var configs = {
        'hdfs-site': {
          'dfs.nameservices': 's',
          'dfs.namenode.http-address.s.nn1': 'host1:50070',
          'dfs.namenode.https-address.s.nn1': '',
          'dfs.namenode.rpc-address.s.nn1': ''
        }
      };
      controller.setSpecificNamenodeConfigs(configs, 'host2');
      expect(configs['hdfs-site']).to.eql({
        "dfs.nameservices": "s",
        "dfs.namenode.http-address.s.nn1": "host2:50070",
        "dfs.namenode.https-address.s.nn1": "host2:50470",
        "dfs.namenode.rpc-address.s.nn1": "host2:8020"
      });
    });
    it('HA enabled and namenode 2', function () {
      isHaEnabled = true;
      var configs = {
        'hdfs-site': {
          'dfs.nameservices': 's',
          'dfs.namenode.http-address.s.nn2': 'host2:50070',
          'dfs.namenode.https-address.s.nn2': '',
          'dfs.namenode.rpc-address.s.nn2': ''
        }
      };
      controller.setSpecificNamenodeConfigs(configs, 'host1');
      expect(configs['hdfs-site']).to.eql({
        "dfs.nameservices": "s",
        "dfs.namenode.http-address.s.nn2": "host1:50070",
        "dfs.namenode.https-address.s.nn2": "host1:50470",
        "dfs.namenode.rpc-address.s.nn2": "host1:8020"
      });
    });
  });

  describe('#setSpecificResourceMangerConfigs()', function () {
    var isRMHaEnabled = false;
    var service = Em.Object.create();
    beforeEach(function () {
      sinon.stub(App, 'get', function () {
        return isRMHaEnabled;
      });
      controller.set('content.reassignHosts.source', 'host1');
    });
    afterEach(function () {
      App.get.restore();
    });

    it('HA isn\'t enabled', function () {
      isRMHaEnabled = false;
      var configs = {};
      controller.setSpecificResourceMangerConfigs(configs, 'host1');
      expect(configs).to.eql({});
    });
    it('HA enabled and resource manager 1', function () {
      isRMHaEnabled = true;
      var configs = {
        'yarn-site': {
          'yarn.resourcemanager.hostname.rm1': 'host1',
          'yarn.resourcemanager.webapp.address.rm1': 'host1:8088',
          'yarn.resourcemanager.webapp.https.address.rm1': 'host1:8443'
        }
      };
      controller.setSpecificResourceMangerConfigs(configs, 'host2');
      expect(configs['yarn-site']).to.eql({
        'yarn.resourcemanager.hostname.rm1': 'host2',
        'yarn.resourcemanager.webapp.address.rm1': 'host2:8088',
        'yarn.resourcemanager.webapp.https.address.rm1': 'host2:8443'
      });
    });
    it('HA enabled and resource manager 2', function () {
      isRMHaEnabled = true;
      var configs = {
        'yarn-site': {
          'yarn.resourcemanager.hostname.rm2': 'host2',
          'yarn.resourcemanager.webapp.address.rm2': 'host2:8088',
          'yarn.resourcemanager.webapp.https.address.rm2': 'host2:8443'
        }
      };
      controller.setSpecificResourceMangerConfigs(configs, 'host1');
      expect(configs['yarn-site']).to.eql({
        'yarn.resourcemanager.hostname.rm2': 'host1',
        'yarn.resourcemanager.webapp.address.rm2': 'host1:8088',
        'yarn.resourcemanager.webapp.https.address.rm2': 'host1:8443'
      });
    });
  });

  describe('#getWebAddressPort', function(){
    var configs = {
        'yarn-site': {
          'yarn.resourcemanager.hostname.rm2': 'host2',
          'yarn.resourcemanager.webapp.address.rm2': 'host2:8088',
          'yarn.resourcemanager.webapp.https.address.rm2': 'host2:8443'
        }
    };
    
    var httpPort = controller.getWebAddressPort(configs, 'yarn.resourcemanager.webapp.address.rm2');
    expect(httpPort).to.eql('8088');
    
    var httpsPort = controller.getWebAddressPort(configs, 'yarn.resourcemanager.webapp.https.address.rm2');
    expect(httpsPort).to.eql('8443');

    configs = {
        'yarn-site': {
          'yarn.resourcemanager.hostname.rm2': 'host2',
          'yarn.resourcemanager.webapp.address.rm2': 'host2:',
          'yarn.resourcemanager.webapp.https.address.rm2': 'host2:  '
        }
    };
    
    //check for falsy conditions
    httpPort = controller.getWebAddressPort(configs, 'yarn.resourcemanager.webapp.address.rm2');
    var flag = "falsy"
    if (httpPort)
      flag = "truthy"
    expect(flag).to.eql('falsy')

    httpsPort = controller.getWebAddressPort(configs, 'yarn.resourcemanager.webapp.https.address.rm2');
    flag = "falsy"
    if (httpsPort)
      flag = "truthy"
    expect(flag).to.eql("falsy")

    configs = {
        'yarn-site': {
          'yarn.resourcemanager.hostname.rm2': 'host2'
        }
    };

   httpPort = controller.getWebAddressPort(configs, 'yarn.resourcemanager.webapp.address.rm2');
   var flag = "falsy"
   if (httpPort != null) //check for null, still part of the falsy condition checks.
      flag = "truthy"
    expect(flag).to.eql('falsy')
  });
  
  describe('#setSecureConfigs()', function () {
    it('undefined component and security disabled', function () {
      var secureConfigs = [];
      sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(false);
      controller.set('secureConfigsMap', []);
      expect(controller.setSecureConfigs(secureConfigs, {}, 'COMP1')).to.be.false;
      expect(secureConfigs).to.eql([]);
      App.get.restore();
    });
    it('component exist and security disabled', function () {
      var secureConfigs = [];
      sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(false);
      controller.set('secureConfigsMap', [{
        componentName: 'COMP1'
      }]);
      expect(controller.setSecureConfigs(secureConfigs, {}, 'COMP1')).to.be.false;
      expect(secureConfigs).to.eql([]);
      App.get.restore();
    });
    it('undefined component and security enabled', function () {
      var secureConfigs = [];
      sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(true);
      controller.set('secureConfigsMap', []);
      expect(controller.setSecureConfigs(secureConfigs, {}, 'COMP1')).to.be.false;
      expect(secureConfigs).to.eql([]);
      App.get.restore();
    });
    it('component exist and security enabled', function () {
      var secureConfigs = [];
      sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(true);
      var configs = {'s1': {
        'k1': 'kValue',
        'p1': 'pValue'
      }};
      controller.set('secureConfigsMap', [{
        componentName: 'COMP1',
        configs: [{
          site: 's1',
          keytab: 'k1',
          principal: 'p1'
        }]
      }]);
      expect(controller.setSecureConfigs(secureConfigs, configs, 'COMP1')).to.be.true;
      expect(secureConfigs).to.eql([
        {
          "keytab": "kValue",
          "principal": "pValue"
        }
      ]);
      App.get.restore();
    });
  });

  describe('#getComponentDir()', function () {
    var configs = {
      'hdfs-site': {
        'dfs.name.dir': 'case1',
        'dfs.namenode.name.dir': 'case2',
        'dfs.namenode.checkpoint.dir': 'case3'
      },
      'core-site': {
        'fs.checkpoint.dir': 'case4'
      }
    };

    it('unknown component name', function () {
      expect(controller.getComponentDir(configs, 'COMP1')).to.be.empty;
    });
    it('NAMENODE component', function () {
      expect(controller.getComponentDir(configs, 'NAMENODE')).to.equal('case2');
    });
    it('SECONDARY_NAMENODE component', function () {
      expect(controller.getComponentDir(configs, 'SECONDARY_NAMENODE')).to.equal('case3');
    });
  });

  describe('#saveClusterStatus()', function () {
    var mock = {
      saveComponentDir: Em.K,
      saveSecureConfigs: Em.K
    };
    beforeEach(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', Em.K);
      sinon.stub(App.router, 'get', function() {
        return mock;
      });
      sinon.spy(mock, 'saveComponentDir');
      sinon.spy(mock, 'saveSecureConfigs');
    });
    afterEach(function () {
      App.clusterStatus.setClusterStatus.restore();
      App.router.get.restore();
      mock.saveSecureConfigs.restore();
      mock.saveComponentDir.restore();
    });

    it('componentDir undefined and secureConfigs is empty', function () {
      expect(controller.saveClusterStatus([], null)).to.be.false;
    });
    it('componentDir defined and secureConfigs is empty', function () {
      expect(controller.saveClusterStatus([], 'dir1')).to.be.true;
      expect(mock.saveComponentDir.calledWith('dir1')).to.be.true;
      expect(mock.saveSecureConfigs.calledWith([])).to.be.true;
    });
    it('componentDir undefined and secureConfigs has data', function () {
      expect(controller.saveClusterStatus([1], null)).to.be.true;
      expect(mock.saveComponentDir.calledWith(null)).to.be.true;
      expect(mock.saveSecureConfigs.calledWith([1])).to.be.true;
    });
    it('componentDir defined and secureConfigs has data', function () {
      expect(controller.saveClusterStatus([1], 'dir1')).to.be.true;
      expect(mock.saveComponentDir.calledWith('dir1')).to.be.true;
      expect(mock.saveSecureConfigs.calledWith([1])).to.be.true;
    });
  });

  describe('#onSaveConfigs()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onTaskCompleted', Em.K);
    });
    afterEach(function () {
      controller.onTaskCompleted.restore();
    });

    it('', function () {
      controller.onSaveConfigs();
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
  });

  describe('#startZooKeeperServers()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'updateComponent', Em.K);
    });
    afterEach(function () {
      controller.updateComponent.restore();
    });

    it('', function () {
      controller.set('content.masterComponentHosts', [{
        component: 'ZOOKEEPER_SERVER',
        hostName: 'host1'
      }]);
      controller.startZooKeeperServers();
      expect(controller.updateComponent.calledWith('ZOOKEEPER_SERVER', ['host1'], 'ZOOKEEPER', 'Start')).to.be.true;
    });
  });

  describe('#startNameNode()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'updateComponent', Em.K);
    });
    afterEach(function () {
      controller.updateComponent.restore();
    });

    it('reassign host does not match current', function () {
      controller.set('content.masterComponentHosts', [{
        component: 'NAMENODE',
        hostName: 'host1'
      }]);
      controller.set('content.reassignHosts.source', 'host2');
      controller.startNameNode();
      expect(controller.updateComponent.calledWith('NAMENODE', ['host1'], 'HDFS', 'Start')).to.be.true;
    });
    it('reassign host matches current', function () {
      controller.set('content.masterComponentHosts', [{
        component: 'NAMENODE',
        hostName: 'host1'
      }]);
      controller.set('content.reassignHosts.source', 'host1');
      controller.startNameNode();
      expect(controller.updateComponent.calledWith('NAMENODE', [], 'HDFS', 'Start')).to.be.true;
    });
  });

  describe('#startServices()', function () {
    before(function () {
      sinon.stub(App.router, 'get').returns({"skip.service.checks": "false"});
    });
    after(function () {
      App.router.get.restore();
    });
    it('', function () {
      controller.startServices();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#deleteHostComponents()', function () {

    it('No host components', function () {
      controller.set('hostComponents', []);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      expect(App.ajax.send.called).to.be.false;
    });
    it('delete two components', function () {
      controller.set('hostComponents', [1, 2]);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        "hostName": "host1",
        "componentName": 1
      });
      expect(App.ajax.send.getCall(1).args[0].data).to.eql({
        "hostName": "host1",
        "componentName": 2
      });
    });
  });

  describe('#onDeleteHostComponentsError()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      sinon.stub(controller, 'onTaskError', Em.K);
    });
    afterEach(function () {
      controller.onComponentsTasksSuccess.restore();
      controller.onTaskError.restore();
    });

    it('task success', function () {
      var error = {
        responseText: 'org.apache.ambari.server.controller.spi.NoSuchResourceException'
      }
      controller.onDeleteHostComponentsError(error);
      expect(controller.onComponentsTasksSuccess.calledOnce).to.be.true;
    });
    it('unknown error', function () {
      var error = {
        responseText: ''
      }
      controller.onDeleteHostComponentsError(error);
      expect(controller.onTaskError.calledOnce).to.be.true;
    });
  });

  describe('#done()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'removeObserver', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      controller.removeObserver.restore();
      App.router.send.restore();
    });

    it('submit disabled', function () {
      controller.set('isSubmitDisabled', true);
      controller.done();
      expect(App.router.send.called).to.be.false;
    });
    it('submit enabled and does not have manual steps', function () {
      controller.set('isSubmitDisabled', false);
      controller.set('content.hasManualSteps', false);
      controller.done();
      expect(controller.removeObserver.calledWith('tasks.@each.status', controller, 'onTaskStatusChange')).to.be.true;
      expect(App.router.send.calledWith('complete')).to.be.true;
    });
    it('submit enabled and has manual steps', function () {
      controller.set('isSubmitDisabled', false);
      controller.set('content.hasManualSteps', true);
      controller.done();
      expect(controller.removeObserver.calledWith('tasks.@each.status', controller, 'onTaskStatusChange')).to.be.true;
      expect(App.router.send.calledWith('next')).to.be.true;
    });
  });

  describe('#getServiceConfigData()', function () {
    var services = [];
    var stackServices = [];
    beforeEach(function () {
      sinon.stub(App.Service, 'find', function () {
        return services;
      });
      sinon.stub(App.StackService, 'find', function () {
        return stackServices;
      });
    });
    afterEach(function () {
      App.Service.find.restore();
      App.StackService.find.restore();
    });

    it('No services', function () {
      services = [];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData([])).to.eql([]);
    });
    it('No services in stackServices', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData([])).to.eql([]);
    });
    it('Services in stackServicesm but configTypesRendered is empty', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [Em.Object.create({
        serviceName: 'S1',
        configTypesRendered: {}
      })];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData([])[0]).to.equal("{\"Clusters\":{\"desired_config\":[]}}");
    });
    it('Services in stackServicesm and configTypesRendered has data, but configs is empty', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [
        Em.Object.create({
          serviceName: 'S1',
          configTypesRendered: {'type1': {}}
        })
      ];
      controller.set('content.reassign.component_name', 'COMP1');
      expect(controller.getServiceConfigData([])[0]).to.equal("{\"Clusters\":{\"desired_config\":[]}}");
    });
    it('Services in stackServicesm and configTypesRendered has data, and configs present', function () {
      services = [Em.Object.create({serviceName: 'S1'})];
      stackServices = [
        Em.Object.create({
          serviceName: 'S1',
          configTypesRendered: {'type1': {}}
        })
      ];
      var configs = {
        'type1': {
          'prop1': 'value1'
        }
      };
      controller.set('content.reassign.component_name', 'COMP1');
      expect(JSON.parse(controller.getServiceConfigData(configs)[0]).Clusters.desired_config.length).to.equal(1);
    });
  });

  describe('#testsMySqlServer()', function () {
    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find', function() {
        return Em.A([
          Em.Object.create({
            'componentName': 'MYSQL_SERVER',
            'hostName': 'c6401.ambari.apache.org'
          })
        ]);
      });
    });

    afterEach(function() {
      App.HostComponent.find.restore();
    });

    it('Cleans MySql Server', function () {
      controller.cleanMySqlServer();
      expect(App.ajax.send.calledOnce).to.be.true;
    });

    it('Configures MySql Server', function () {
      controller.configureMySqlServer();
      expect(App.ajax.send.calledOnce).to.be.true;
    });

  });

  describe("#prepareDBCheckAction()", function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        'jdk_location': 'jdk_location',
        'jdk.name': 'jdk.name',
        'java.home': 'java.home'
      });
      sinon.stub(controller, 'getConnectionProperty').returns('prop1');
    });
    afterEach(function () {
      App.router.get.restore();
      controller.getConnectionProperty.restore();
    });
    it("", function() {
      controller.set('content.reassignHosts', Em.Object.create({target: 'host1'}));
      controller.reopen({
        dbType: 'type1',
        requiredProperties: [],
        preparedDBProperties: {}
      });
      controller.prepareDBCheckAction();
      expect(App.ajax.send.getCall(0).args[0].name).to.equal('cluster.custom_action.create');
      expect(App.ajax.send.getCall(0).args[0].success).to.equal('onCreateActionSuccess');
      expect(App.ajax.send.getCall(0).args[0].error).to.equal('onTaskError');
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        requestInfo: {
          "context": "Check host",
          "action": "check_host",
          "parameters": {
            "db_name": "type1",
            "jdk_location": "jdk_location",
            "jdk_name": "jdk.name",
            "java_home": "java.home",
            "threshold": 60,
            "ambari_server_host": "",
            "check_execute_list": "db_connection_check"
          }
        },
        filteredHosts: ['host1']
      });
    });
  });
});

});

;require.register("test/controllers/main/service/reassign/step6_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/reassign/step6_controller');

describe('App.ReassignMasterWizardStep6Controller', function () {

  var controller = App.ReassignMasterWizardStep6Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create(),
      reassignHosts: Em.Object.create()
    })
  });

  beforeEach(function () {
    sinon.stub(App.ajax, 'send', Em.K);
  });
  afterEach(function () {
    App.ajax.send.restore();
  });


  describe('#initializeTasks()', function () {
    it('No commands', function () {
      controller.set('commands', []);
      controller.set('hostComponents', []);
      controller.initializeTasks();

      expect(controller.get('tasks')).to.be.empty;
    });
    it('One command', function () {
      controller.set('commands', ['COMMAND1']);
      controller.initializeTasks();

      expect(controller.get('tasks')[0].get('id')).to.equal(0);
      expect(controller.get('tasks')[0].get('command')).to.equal('COMMAND1');
    });
  });

  describe('#hideRollbackButton()', function () {

    it('No showRollback command', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: false
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
    it('showRollback command is present', function () {
      controller.set('tasks', [Em.Object.create({
        showRollback: true
      })]);
      controller.hideRollbackButton();
      expect(controller.get('tasks')[0].get('showRollback')).to.be.false;
    });
  });

  describe('#onComponentsTasksSuccess()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onTaskCompleted', Em.K);
    });
    afterEach(function () {
      controller.onTaskCompleted.restore();
    });

    it('One host-component', function () {
      controller.set('multiTaskCounter', 1);
      controller.set('hostComponents', [
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(0);
      expect(controller.onTaskCompleted.calledOnce).to.be.true;
    });
    it('two host-components', function () {
      controller.set('multiTaskCounter', 2);
      controller.set('hostComponents', [
        {},
        {}
      ]);
      controller.onComponentsTasksSuccess();
      expect(controller.get('multiTaskCounter')).to.equal(1);
      expect(controller.onTaskCompleted.called).to.be.false;
    });
  });


  describe('#loadStep()', function () {
    var isHaEnabled = true;

    beforeEach(function () {
      controller.set('content.reassign.service_id', 'service1');
      sinon.stub(controller, 'onTaskStatusChange', Em.K);
      sinon.stub(controller, 'initializeTasks', Em.K);
      sinon.stub(App, 'get', function () {
        return isHaEnabled;
      });
    });
    afterEach(function () {
      controller.onTaskStatusChange.restore();
      controller.initializeTasks.restore();
      App.get.restore();
    });

    it('reassign component is NameNode and HA enabled', function () {
      isHaEnabled = true;
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE', 'ZKFC']);
    });
    it('reassign component is NameNode and HA disabled', function () {
      isHaEnabled = false;
      controller.set('content.reassign.component_name', 'NAMENODE');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['NAMENODE']);
    });
    it('reassign component is RESOURCEMANAGER', function () {
      controller.set('content.reassign.component_name', 'RESOURCEMANAGER');

      controller.loadStep();
      expect(controller.get('hostComponents')).to.eql(['RESOURCEMANAGER']);
    });
  });

  describe('#startServices()', function () {
    before(function () {
      sinon.stub(App.router, 'get').returns({"skip.service.checks": "false"});
    });
    after(function () {
      App.router.get.restore();
    });
    it('', function () {
      controller.startServices();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#deleteHostComponents()', function () {

    it('No host components', function () {
      controller.set('hostComponents', []);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      expect(App.ajax.send.called).to.be.false;
    });
    it('delete two components', function () {
      controller.set('hostComponents', [1, 2]);
      controller.set('content.reassignHosts.source', 'host1');
      controller.deleteHostComponents();
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        "hostName": "host1",
        "componentName": 1
      });
      expect(App.ajax.send.getCall(1).args[0].data).to.eql({
        "hostName": "host1",
        "componentName": 2
      });
    });
  });

  describe('#onDeleteHostComponentsError()', function () {
    beforeEach(function () {
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      sinon.stub(controller, 'onTaskError', Em.K);
    });
    afterEach(function () {
      controller.onComponentsTasksSuccess.restore();
      controller.onTaskError.restore();
    });

    it('task success', function () {
      var error = {
        responseText: 'org.apache.ambari.server.controller.spi.NoSuchResourceException'
      }
      controller.onDeleteHostComponentsError(error);
      expect(controller.onComponentsTasksSuccess.calledOnce).to.be.true;
    });
    it('unknown error', function () {
      var error = {
        responseText: ''
      }
      controller.onDeleteHostComponentsError(error);
      expect(controller.onTaskError.calledOnce).to.be.true;
    });
  });

  describe('#stopMysqlService()', function () {
    it('stopMysqlService', function () {
      controller.stopMysqlService();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('#putHostComponentsInMaintenanceMode()', function () {
    beforeEach(function(){
      sinon.stub(controller, 'onComponentsTasksSuccess', Em.K);
      controller.set('content.reassignHosts.source', 'source');
    });
    afterEach(function(){
      controller.onComponentsTasksSuccess.restore();
    });
    it('No host-components', function () {
      controller.set('hostComponents', []);
      controller.putHostComponentsInMaintenanceMode();
      expect(App.ajax.send.called).to.be.false;
      expect(controller.get('multiTaskCounter')).to.equal(0);
    });
    it('One host-components', function () {
      controller.set('hostComponents', [{}]);
      controller.putHostComponentsInMaintenanceMode();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(controller.get('multiTaskCounter')).to.equal(1);
    });
  });
});
});

;require.register("test/controllers/main/service/reassign/step7_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/reassign/step7_controller');

describe('App.ReassignMasterWizardStep7Controller', function () {

  var controller = App.ReassignMasterWizardStep7Controller.create({
    content: Em.Object.create({
      reassign: Em.Object.create(),
      reassignHosts: Em.Object.create()
    })
  });

  beforeEach(function () {
    sinon.stub(App.ajax, 'send', Em.K);
  });
  afterEach(function () {
    App.ajax.send.restore();
  });

  describe('#initializeTasks()', function () {

    it('should set isLoaded to true', function () {
      controller.set('isLoaded', false);

      controller.initializeTasks();
      expect(controller.get('isLoaded')).to.be.true;
    });

  });

});

});

;require.register("test/controllers/main/service/reassign_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');
require('controllers/main/service/reassign_controller');

describe('App.ReassignMasterController', function () {

  var reassignMasterController = App.ReassignMasterController.create({});

  describe('#totalSteps', function () {

    var cases = [
      {
        componentName: 'ZOOKEEPER_SERVER',
        result: 4
      },
      {
        componentName: 'RESOURCE_MANAGER',
        result: 4
      },
      {
        componentName: 'OOZIE_SERVER',
        result: 6
      },
      {
        componentName: 'APP_TIMELINE_SERVER',
        result: 6
      },
      {
        componentName: 'NAMENODE',
        result: 6
      }
    ];

    cases.forEach(function (c) {
      it('check ' + c.componentName, function () {
        reassignMasterController.set('content.reassign', {'component_name': c.componentName});
        expect(reassignMasterController.get('totalSteps')).to.equal(c.result);
        reassignMasterController.set('content.reassign', {service_id:null});
      });
    });
  });

  reassignMasterController.set('content.reassign', {service_id:null});

});

});

;require.register("test/controllers/main/service/widgets/create/step1_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/step1_controller');


describe('App.WidgetWizardStep1Controller', function () {
  var controller = App.WidgetWizardStep1Controller.create();

  describe("#isSubmitDisabled", function() {
    it("disabled", function() {
      controller.set('widgetType', '');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("enabled", function() {
      controller.set('widgetType', 'w1');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
  });

  describe("#chooseOption()", function () {
    before(function () {
      sinon.stub(controller, 'next');
    });
    after(function () {
      controller.next.restore();
    });
    it("", function () {
      controller.chooseOption({context: 'type1'});
      expect(controller.get('widgetType')).to.equal('type1');
      expect(controller.next.calledOnce).to.be.true;
    });
  });

  describe("#loadStep()", function () {
    before(function () {
      sinon.stub(controller, 'clearStep');
    });
    after(function () {
      controller.clearStep.restore();
    });
    it("", function () {
      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.be.true;
    });
  });

  describe("#clearStep()", function () {
    it("", function () {
      controller.clearStep();
      expect(controller.get('widgetType')).to.be.empty;
    });
  });

  describe("#next()", function () {
    before(function () {
      sinon.stub(App.router, 'send');
    });
    after(function () {
      App.router.send.restore();
    });
    it("", function () {
      controller.next();
      expect(App.router.send.calledWith('next')).to.be.true;
    });
  });



});

});

;require.register("test/controllers/main/service/widgets/create/step2_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/step2_controller');


describe('App.WidgetWizardStep2Controller', function () {
  var controller = App.WidgetWizardStep2Controller.create({
    content: Em.Object.create()
  });

  describe("#isEditWidget", function () {
    it("empty name", function () {
      controller.set('content.controllerName', '');
      controller.propertyDidChange('isEditWidget');
      expect(controller.get('isEditWidget')).to.be.false;
    });
    it("correct name", function () {
      controller.set('content.controllerName', 'widgetEditController');
      controller.propertyDidChange('isEditWidget');
      expect(controller.get('isEditWidget')).to.be.true;
    });
  });

  describe("#filteredMetrics", function () {
    var testCases = [
      {
        metric: {
          point_in_time: false
        },
        type: null,
        result: []
      },
      {
        metric: {
          point_in_time: true
        },
        type: null,
        result: [
          {
            point_in_time: true
          }
        ]
      },
      {
        metric: {
          temporal: false
        },
        type: 'GRAPH',
        result: []
      },
      {
        metric: {
          temporal: true
        },
        type: 'GRAPH',
        result: [
          {
            temporal: true
          }
        ]
      }
    ];

    testCases.forEach(function (test) {
      it("type=" + test.type + "; temporal=" + test.metric.temporal + "; point_in_time=" + test.metric.point_in_time, function () {
        controller.get('content').setProperties({
          widgetType: test.type,
          allMetrics: [test.metric]
        });
        controller.propertyDidChange('filteredMetrics');
        expect(controller.get('filteredMetrics')).to.eql(test.result);
      });
    });
  });

  describe("#isSubmitDisabled", function () {
    beforeEach(function () {
      this.expressionFunc = sinon.stub(controller, 'isExpressionComplete');
      this.graphFunc = sinon.stub(controller, 'isGraphDataComplete');
      this.templateFunc = sinon.stub(controller, 'isTemplateDataComplete');
      controller.set('expressions', ['']);
    });
    afterEach(function () {
      this.expressionFunc.restore();
      this.graphFunc.restore();
      this.templateFunc.restore();
      controller.get('expressions').clear();
    });
    it("invalid property", function () {
      controller.set('widgetPropertiesViews', [Em.Object.create({isValid: false})]);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("valid number widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'NUMBER');
      this.expressionFunc.returns(true);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it("invalid number widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'NUMBER');
      this.expressionFunc.returns(false);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("valid graph widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'GRAPH');
      this.graphFunc.returns(true);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it("invalid graph widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'GRAPH');
      this.graphFunc.returns(false);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("valid template widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'TEMPLATE');
      this.templateFunc.returns(true);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
    it("invalid template widget", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', 'TEMPLATE');
      this.templateFunc.returns(false);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("unknown widget type", function () {
      controller.set('widgetPropertiesViews', []);
      controller.set('content.widgetType', '');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
  });

  describe("#isExpressionComplete()", function () {
    var testCases = [
      {
        expression: null,
        result: false
      },
      {
        expression: Em.Object.create({isInvalid: true}),
        result: false
      },
      {
        expression: Em.Object.create({isInvalid: false, isEmpty: false}),
        result: true
      },
      {
        expression: Em.Object.create({isInvalid: false, isEmpty: true}),
        result: false
      }
    ];
    testCases.forEach(function (test) {
      it("expression = " + test.expression, function () {
        expect(controller.isExpressionComplete(test.expression)).to.equal(test.result);
      });
    });
  });

  describe("#isGraphDataComplete()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(controller, 'isExpressionComplete');
    });
    afterEach(function () {
      this.mock.restore();
    });
    it("dataSets is empty", function () {
      expect(controller.isGraphDataComplete([])).to.be.false;
    });
    it("label is empty", function () {
      expect(controller.isGraphDataComplete([Em.Object.create({label: ''})])).to.be.false;
    });
    it("expression is not complete", function () {
      this.mock.returns(false);
      expect(controller.isGraphDataComplete([Em.Object.create({label: 'abc'})])).to.be.false;
    });
    it("expression is complete", function () {
      this.mock.returns(true);
      expect(controller.isGraphDataComplete([Em.Object.create({label: 'abc'})])).to.be.true;
    });
  });

  describe("#isTemplateDataComplete()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(controller, 'isExpressionComplete');
    });
    afterEach(function () {
      this.mock.restore();
    });
    it("expressions is empty", function () {
      expect(controller.isTemplateDataComplete([])).to.be.false;
    });
    it("templateValue is empty", function () {
      expect(controller.isTemplateDataComplete([{}], '')).to.be.false;
    });
    it("expression is not complete", function () {
      this.mock.returns(false);
      expect(controller.isTemplateDataComplete([{}], 'abc')).to.be.false;
    });
    it("expression is complete", function () {
      this.mock.returns(true);
      expect(controller.isTemplateDataComplete([{}], 'abc')).to.be.true;
    });
  });

  describe("#addDataSet()", function () {
    it("", function () {
      controller.get('dataSets').clear();
      controller.addDataSet(null, true);
      expect(controller.get('dataSets').objectAt(0).get('id')).to.equal(1);
      expect(controller.get('dataSets').objectAt(0).get('isRemovable')).to.equal(false);
      controller.addDataSet(null);
      expect(controller.get('dataSets').objectAt(1).get('id')).to.equal(2);
      expect(controller.get('dataSets').objectAt(1).get('isRemovable')).to.equal(true);
      controller.get('dataSets').clear();
    });
  });

  describe("#removeDataSet()", function () {
    it("", function () {
      var dataSet = Em.Object.create();
      controller.get('dataSets').pushObject(dataSet);
      controller.removeDataSet({context: dataSet});
      expect(controller.get('dataSets')).to.be.empty;
    });
  });

  describe("#addExpression()", function () {
    it("", function () {
      controller.get('expressions').clear();
      controller.addExpression(null, true);
      expect(controller.get('expressions').objectAt(0).get('id')).to.equal(1);
      expect(controller.get('expressions').objectAt(0).get('isRemovable')).to.equal(false);
      controller.addExpression(null);
      expect(controller.get('expressions').objectAt(1).get('id')).to.equal(2);
      expect(controller.get('expressions').objectAt(1).get('isRemovable')).to.equal(true);
      controller.get('expressions').clear();
    });
  });

  describe("#removeExpression()", function () {
    it("", function () {
      var expression = Em.Object.create();
      controller.get('expressions').pushObject(expression);
      controller.removeExpression({context: expression});
      expect(controller.get('expressions')).to.be.empty;
    });
  });

  describe("#initWidgetData()", function () {
    it("new data", function () {
      controller.set('expressions', []);
      controller.set('dataSets', []);
      controller.get('content').setProperties({
        widgetProperties: {a: 1},
        widgetValues: [1],
        widgetMetrics: [2]
      });

      controller.initWidgetData();

      expect(controller.get('widgetProperties')).to.eql({a: 1});
      expect(controller.get('widgetValues')).to.eql([]);
      expect(controller.get('widgetMetrics')).to.eql([]);
      expect(controller.get('expressions')).to.not.be.empty;
      expect(controller.get('dataSets')).to.not.be.empty;
    });
    it("previously edited", function () {
      controller.set('expressions', [{}]);
      controller.set('dataSets', [{}]);
      controller.get('content').setProperties({
        widgetProperties: {a: 1},
        widgetValues: [1],
        widgetMetrics: [2]
      });

      controller.initWidgetData();

      expect(controller.get('widgetProperties')).to.eql({a: 1});
      expect(controller.get('widgetValues')).to.eql([1]);
      expect(controller.get('widgetMetrics')).to.eql([2]);
      expect(controller.get('expressions')).to.not.be.empty;
      expect(controller.get('dataSets')).to.not.be.empty;
    });
  });

  describe("#updateExpressions()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'parseExpression').returns({values: [1], metrics: [1]});
      sinon.stub(controller, 'parseTemplateExpression').returns({values: [1], metrics: [1]});
      sinon.stub(controller, 'parseGraphDataset').returns({values: [1], metrics: [1]});
    });
    afterEach(function () {
      controller.parseExpression.restore();
      controller.parseTemplateExpression.restore();
      controller.parseGraphDataset.restore();
    });
    it("empty expressions", function () {
      controller.set('expressions', []);
      controller.updateExpressions();
      expect(controller.parseExpression.called).to.be.false;
      expect(controller.parseTemplateExpression.called).to.be.false;
      expect(controller.parseGraphDataset.called).to.be.false;
      expect(controller.get('widgetValues')).to.be.empty;
      expect(controller.get('widgetMetrics')).to.be.empty;
    });
    it("empty dataSets", function () {
      controller.set('dataSets', []);
      controller.updateExpressions();
      expect(controller.parseExpression.called).to.be.false;
      expect(controller.parseTemplateExpression.called).to.be.false;
      expect(controller.parseGraphDataset.called).to.be.false;
      expect(controller.get('widgetValues')).to.be.empty;
      expect(controller.get('widgetMetrics')).to.be.empty;
    });
    it("GAUGE widget", function () {
      controller.set('expressions', [{}]);
      controller.set('content.widgetType', 'GAUGE');
      controller.set('dataSets', [{}]);
      //controller.updateExpressions();
      expect(controller.parseExpression.calledOnce).to.be.true;
      expect(controller.parseTemplateExpression.called).to.be.false;
      expect(controller.parseGraphDataset.called).to.be.false;
      expect(controller.get('widgetValues')).to.not.be.empty;
      expect(controller.get('widgetMetrics')).to.not.be.empty;
    });
    it("NUMBER widget", function () {
      controller.set('expressions', [{}]);
      controller.set('content.widgetType', 'NUMBER');
      controller.set('dataSets', [{}]);
      //controller.updateExpressions();
      expect(controller.parseExpression.calledOnce).to.be.true;
      expect(controller.parseTemplateExpression.called).to.be.false;
      expect(controller.parseGraphDataset.called).to.be.false;
      expect(controller.get('widgetValues')).to.not.be.empty;
      expect(controller.get('widgetMetrics')).to.not.be.empty;
    });
    it("TEMPLATE widget", function () {
      controller.set('expressions', [{}]);
      controller.set('content.widgetType', 'TEMPLATE');
      controller.set('dataSets', [{}]);
      //controller.updateExpressions();
      expect(controller.parseExpression.called).to.be.false;
      expect(controller.parseTemplateExpression.calledOnce).to.be.true;
      expect(controller.parseGraphDataset.called).to.be.false;
      expect(controller.get('widgetValues')).to.not.be.empty;
      expect(controller.get('widgetMetrics')).to.not.be.empty;
    });
    it("GRAPH widget", function () {
      controller.set('expressions', [{}]);
      controller.set('content.widgetType', 'GRAPH');
      controller.set('dataSets', [{}]);
      //controller.updateExpressions();
      expect(controller.parseExpression.called).to.be.false;
      expect(controller.parseTemplateExpression.called).to.be.false;
      expect(controller.parseGraphDataset.calledOnce).to.be.true;
      expect(controller.get('widgetValues')).to.not.be.empty;
      expect(controller.get('widgetMetrics')).to.not.be.empty;
    });
  });

  describe("#parseGraphDataset()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'parseExpression').returns({value: 'value'});
    });
    afterEach(function () {
      controller.parseExpression.restore();
    });
    it("empty dataSets", function () {
      expect(controller.parseGraphDataset([])).to.be.eql({
        metrics: [],
        values: []
      });
    });
    it("correct dataSets", function () {
      var result = controller.parseGraphDataset([Em.Object.create({label: 'label'})]);
      expect(result.values).to.be.eql([
        {
          "name": "label",
          "value": "value"
        }
      ]);
      expect(result.metrics).to.be.empty;
    });
  });

  describe("#parseTemplateExpression()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'parseExpression').returns({value: 'value'});
    });
    afterEach(function () {
      controller.parseExpression.restore();
    });
    it("empty expressions", function () {
      expect(controller.parseTemplateExpression("{{Expression1}}", [])).to.be.eql({
        metrics: [],
        values: [
          {
            value: "{{Expression1}}"
          }
        ]
      });
    });
    it("correct expressions", function () {
      var result = controller.parseTemplateExpression("{{Expression1}}", [Em.Object.create({alias: '{{Expression1}}'})]);
      expect(result.values).to.be.eql([
        {
          value: "value"
        }
      ]);
      expect(result.metrics).to.be.empty;
    });
  });

  describe("#parseExpression()", function () {
    it("expression is empty", function () {
      expect(controller.parseExpression({data: []})).to.eql({
        metrics: [],
        value: ''
      });
    });
    it("expression is correct", function () {
      var data = [
        {
          name: 'm1',
          serviceName: 'S1',
          componentName: 'C1',
          metricPath: 'mp',
          hostComponentCriteria: 'hcc',
          isMetric: true
        },
        {
          name: '+'
        },
        {
          name: '10'
        }
      ];
      expect(controller.parseExpression({data: data})).to.eql({
        metrics: [
          {
            "name": "m1",
            "service_name": "S1",
            "component_name": "C1",
            "metric_path": "mp",
            "host_component_criteria": "hcc"
          }
        ],
        value: '${m1+10}'
      });
    });
  });

  describe("#updateProperties()", function () {
    it("widgetPropertiesViews is empty", function () {
      controller.set('widgetPropertiesViews', []);
      expect(controller.get('widgetProperties')).to.be.empty;
    });
    it("widgetPropertiesViews is correct", function () {
      controller.set('widgetPropertiesViews', [
        Em.Object.create({
          valueMap: {
            "key1": 'alias1'
          },
          key1: 1
        })
      ]);
      expect(controller.get('widgetProperties')).to.eql({
        "alias1": 1
      });
    });
  });

  describe("#renderProperties()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App.WidgetType, 'find');
      sinon.stub(App.WidgetPropertyTypes, 'findProperty').returns({valueMap: {}});
      sinon.stub(App.WidgetProperty, 'create').returns({});
    });
    afterEach(function () {
      this.mock.restore();
      App.WidgetPropertyTypes.findProperty.restore();
      App.WidgetProperty.create.restore();
    });
    it("no properties", function () {
      this.mock.returns(Em.Object.create({properties: []}));
      controller.renderProperties();
      expect(controller.get('widgetPropertiesViews')).to.be.empty;
    });
    it("correct properties", function () {
      this.mock.returns(Em.Object.create({properties: [{}]}));
      controller.renderProperties();
      expect(App.WidgetProperty.create.calledWith({valueMap: {}})).to.be.true;
      expect(controller.get('widgetPropertiesViews')).to.not.be.empty;
    });
  });

  describe("#parseValue()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'getExpressionData').returns({});
    });
    afterEach(function () {
      controller.getExpressionData.restore();
    });
    it("empty value", function () {
      expect(controller.parseValue("", [])).to.be.empty;
    });
    it("correct value", function () {
      expect(controller.parseValue("${m1}", [])).to.not.be.empty;
      expect(controller.getExpressionData.calledWith("m1", [])).to.be.true;
    });
  });

  describe("#getExpressionData()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'getExpressionVariable').returns({});
    });
    afterEach(function () {
      controller.getExpressionVariable.restore();
    });
    it("empty expression", function () {
      expect(controller.getExpressionData("", [])).to.be.empty;
    });
    it("correct expression", function () {
      expect(controller.getExpressionData("m1+10", [])).to.not.be.empty;
      expect(controller.getExpressionVariable.getCall(0).args).to.eql(["m1", 1, []]);
      expect(controller.getExpressionVariable.getCall(1).args).to.eql(["10", 3, []]);
    });
  });

  describe("#getExpressionVariable()", function () {
    it("get metric definition", function () {
      var metrics = [
        {
          name: 'm1',
          component_name: 'C1',
          service_name: 'S1',
          metric_path: 'mp',
          host_component_criteria: 'hcc'
        }
      ];
      expect(controller.getExpressionVariable("m1", 1, metrics)).to.be.eql(Em.Object.create({
        id: 1,
        name: 'm1',
        isMetric: true,
        componentName: 'C1',
        serviceName: 'S1',
        metricPath: 'mp',
        hostComponentCriteria: 'hcc'
      }));
    });
    it("get number definition", function () {
      expect(controller.getExpressionVariable("10", 2, [])).to.be.eql(Em.Object.create({
        id: 2,
        name: "10",
        isNumber: true
      }));
    });
  });

  describe("#next()", function () {
    beforeEach(function () {
      sinon.stub(App.router, 'send');
    });
    afterEach(function () {
      App.router.send.restore();
    });
    it("", function () {
      controller.next();
      expect(App.router.send.calledWith('next'));
    });
  });
});

});

;require.register("test/controllers/main/service/widgets/create/step3_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/step3_controller');


describe('App.WidgetWizardStep3Controller', function () {
  var controller = App.WidgetWizardStep3Controller.create({
    content: Em.Object.create()
  });

  describe("#isEditController", function () {
    it("empty name", function () {
      controller.set('content.controllerName', '');
      controller.propertyDidChange('isEditController');
      expect(controller.get('isEditController')).to.be.false;
    });
    it("widgetEditController name", function () {
      controller.set('content.controllerName', 'widgetEditController');
      controller.propertyDidChange('isEditController');
      expect(controller.get('isEditController')).to.be.true;
    });
  });

  describe("#widgetScope", function () {
    it("isSharedChecked - false", function () {
      controller.set('isSharedChecked', false);
      controller.propertyDidChange('widgetScope');
      expect(controller.get('widgetScope')).to.equal('User');
    });
    it("isSharedChecked - true", function () {
      controller.set('isSharedChecked', true);
      controller.propertyDidChange('widgetScope');
      expect(controller.get('widgetScope')).to.equal('Cluster');
    });
  });

  describe("#isSubmitDisabled", function () {
    it("widgetName - null", function () {
      controller.set('widgetName', null);
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("widgetName empty ", function () {
      controller.set('widgetName', '');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("widgetName contains only whitespace", function () {
      controller.set('widgetName', ' ');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.true;
    });
    it("widgetName correct", function () {
      controller.set('widgetName', 'w1');
      controller.propertyDidChange('isSubmitDisabled');
      expect(controller.get('isSubmitDisabled')).to.be.false;
    });
  });

  describe("#initPreviewData()", function () {
    beforeEach(function () {
      sinon.stub(controller, 'addObserver');
    });
    afterEach(function () {
      controller.addObserver.restore();
    });
    it("", function () {
      controller.set('content', Em.Object.create({
        widgetProperties: 'widgetProperties',
        widgetValues: 'widgetValues',
        widgetMetrics: 'widgetMetrics',
        widgetAuthor: 'widgetAuthor',
        widgetName: 'widgetName',
        widgetDescription: 'widgetDescription',
        widgetScope: 'CLUSTER',
        controllerName: 'widgetEditController'
      }));
      controller.initPreviewData();
      controller.get('isSharedCheckboxDisabled') ? expect(controller.addObserver.calledWith('isSharedChecked')).to.be.false:
        expect(controller.addObserver.calledWith('isSharedChecked')).to.be.true;
      expect(controller.get('widgetProperties')).to.equal('widgetProperties');
      expect(controller.get('widgetValues')).to.equal('widgetValues');
      expect(controller.get('widgetMetrics')).to.equal('widgetMetrics');
      expect(controller.get('widgetAuthor')).to.equal('widgetAuthor');
      expect(controller.get('widgetName')).to.equal('widgetName');
      expect(controller.get('widgetDescription')).to.equal('widgetDescription');
      expect(controller.get('isSharedChecked')).to.be.true;
      expect(controller.get('isSharedCheckboxDisabled')).to.be.true;
    });
  });

  describe("#showConfirmationOnSharing()", function () {
    beforeEach(function () {
      sinon.spy(App, 'showConfirmationFeedBackPopup');
    });
    afterEach(function () {
      App.showConfirmationFeedBackPopup.restore();
    });
    it("isSharedChecked - false", function () {
      controller.set('isSharedChecked', false);
      controller.showConfirmationOnSharing();
      expect(App.showConfirmationFeedBackPopup.called).to.be.false;
    });
    it("isSharedChecked - true", function () {
      controller.set('isSharedChecked', true);
      var popup = controller.showConfirmationOnSharing();
      expect(App.showConfirmationFeedBackPopup.calledOnce).to.be.true;
      popup.onSecondary();
      expect(controller.get('isSharedChecked')).to.be.false;
      popup.onPrimary();
      expect(controller.get('isSharedChecked')).to.be.true;
    });
  });

  describe("#collectWidgetData()", function () {
    it("", function () {
      controller.setProperties({
        widgetName: 'widgetName',
        content: Em.Object.create({widgetType: 'T1'}),
        widgetDescription: 'widgetDescription',
        widgetScope: 'Cluster',
        widgetAuthor: 'widgetAuthor',
        widgetMetrics: [{data: 'data', name: 'm1'}],
        widgetValues: [{computedValue: 'cv', value: 'v'}],
        widgetProperties: 'widgetProperties'
      });
      expect(controller.collectWidgetData()).to.eql({
        "WidgetInfo": {
          "widget_name": "widgetName",
          "widget_type": "T1",
          "description": "widgetDescription",
          "scope": "CLUSTER",
          "author": "widgetAuthor",
          "metrics": [
            {
              "name": "m1"
            }
          ],
          "values": [
            {
              "value": "v"
            }
          ],
          "properties": "widgetProperties"
        }
      });
    });
  });

  describe("#cancel()", function () {
    var mock = {
      cancel: Em.K
    };
    beforeEach(function () {
      sinon.spy(mock, 'cancel');
      sinon.stub(App.router, 'get').returns(mock);
    });
    afterEach(function () {
      App.router.get.restore();
      mock.cancel.restore();
    });
    it("", function () {
      controller.cancel();
      expect(mock.cancel.calledOnce).to.be.true;
    });
  });

  describe("#complete()", function () {
    var mock = {
      finishWizard: Em.K
    };
    beforeEach(function () {
      sinon.spy(mock, 'finishWizard');
      sinon.stub(controller, 'collectWidgetData');
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(App.router, 'send');
    });
    afterEach(function () {
      App.router.get.restore();
      App.router.send.restore();
      controller.collectWidgetData.restore();
      mock.finishWizard.restore();
    });
    it("", function () {
      controller.complete();
      expect(controller.collectWidgetData.calledOnce).to.be.true;
      expect(App.router.send.calledWith('complete')).to.be.true;
      expect(mock.finishWizard.calledOnce).to.be.true;
    });
  });
});

});

;require.register("test/controllers/main/service/widgets/create/wizard_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

App = require('app');

require('controllers/main/service/widgets/create/wizard_controller');


describe('App.WidgetWizardController', function () {
  var controller;

  /**
   * tests the function with following hierarchical queue scenario
   *                   root 
   *                    |
   *                  queue1
   *                 /     \
   *             queue2   queue3
   *                  
   */
  describe("#substitueQueueMetrics", function () {
    beforeEach(function () {
      controller = App.WidgetWizardController.create();
      sinon.stub(App.YARNService, 'find', function (k) {
        if ('YARN' === k) return Em.Object.create({
          'allQueueNames': ["root", "root/queue1", "root/queue1/queue2", "root/queue1/queue3"]
        });
      });
    });
    afterEach(function () {
      controller = '';
      App.YARNService.find.restore();
    });


    var testCases = [
      {
        msg: 'AMS Queue metric with regex as name and regex as path should be replaced with actual metric name and path of all existing queues',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            level: 'COMPONENT',
            name: 'yarn.QueueMetrics.Queue=(.+).AppsFailed',
            point_in_time: false,
            service_name: 'YARN',
            temporal: true,
            type: 'GANGLIA',
            widget_id: 'metrics/yarn/Queue/$1.replaceAll("([.])","/")/AppsFailed'
          }
        ],
        expectedResult: [
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/AppsFailed"
          },
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.queue1.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/queue1/AppsFailed"
          },
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.queue1.queue2.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/queue1/queue2/AppsFailed"
          },
          {
            "component_name": "RESOURCEMANAGER",
            "level": "COMPONENT",
            "name": "yarn.QueueMetrics.Queue=root.queue1.queue3.AppsFailed",
            "point_in_time": false,
            "service_name": "YARN",
            "temporal": true,
            "type": "GANGLIA",
            "widget_id": "metrics/yarn/Queue/root/queue1/queue3/AppsFailed"
          }
        ]
      },
      {
        msg: 'JMX Queue metric with regex as name and regex as path should be replaced with actual metric name and path of all existing queues',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics(.+).AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/$1.replaceAll(",q(\d+)=","/").substring(1)/AppsFailed'
          }
        ],
        expectedResult: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/AppsFailed'
          },
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root,q1=queue1.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/queue1/AppsFailed'
          },
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root,q1=queue1,q2=queue2.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/queue1/queue2/AppsFailed'
          },
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics,q0=root,q1=queue1,q2=queue3.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/root/queue1/queue3/AppsFailed'
          }
        ]
      },
      {
        msg: 'AMS Queue metric without regex in name and path should retain same name and path',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            level: 'COMPONENT',
            name: 'yarn.QueueMetrics.Queue.Clustermetrics.AppsFailed',
            point_in_time: false,
            service_name: 'YARN',
            temporal: true,
            type: 'GANGLIA',
            widget_id: 'metrics/yarn/Queue/Clustermetrics/AppsFailed'
          }
        ],
        expectedResult: [
          {
            component_name: 'RESOURCEMANAGER',
            level: 'COMPONENT',
            name: 'yarn.QueueMetrics.Queue.Clustermetrics.AppsFailed',
            point_in_time: false,
            service_name: 'YARN',
            temporal: true,
            type: 'GANGLIA',
            widget_id: 'metrics/yarn/Queue/Clustermetrics/AppsFailed'
          }
        ]
      },
      {
        msg: 'JMX Queue metric without regex in name and path should retain same name and path',
        inputMetrics: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics.clusterMetric.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/clusterMetric/AppsFailed'
          }
        ],
        expectedResult: [
          {
            component_name: 'RESOURCEMANAGER',
            host_component_criteria: 'host_components/HostRoles/ha_state=ACTIVE',
            level: 'HOSTCOMPONENT',
            name: 'Hadoop:service=ResourceManager,name=QueueMetrics.clusterMetric.AppsFailed',
            point_in_time: true,
            service_name: 'YARN',
            temporal: false,
            type: 'JMX',
            widget_id: 'metrics/yarn/Queue/clusterMetric/AppsFailed'
          }
        ]
      }
    ];
    testCases.forEach(function (_testCase) {
      it(_testCase.msg, function () {
        var result = controller.substitueQueueMetrics(_testCase.inputMetrics);
        expect(JSON.stringify(result)).to.equal(JSON.stringify(_testCase.expectedResult));
      });
    });
  });
});

});

;require.register("test/controllers/main/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/service');

var mainServiceController;

describe('App.MainServiceController', function () {

  var tests = Em.A([
    {
      isStartStopAllClicked: true,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: true,
      eStop: true,
      mStart: 'mainServiceController StartAll is Disabled 2',
      mStop: 'mainServiceController StopAll is Disabled 2'
    },
    {
      isStartStopAllClicked: false,
      content: Em.A([
        Em.Object.create({
          healthStatus: 'green',
          serviceName: 'HIVE',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'HDFS',
          isClientsOnly: false
        }),
        Em.Object.create({
          healthStatus: 'red',
          serviceName: 'TEZ',
          isClientsOnly: true
        })
      ]),
      eStart: false,
      eStop: false,
      mStart: 'mainServiceController StartAll is Enabled 3',
      mStop: 'mainServiceController StopAll is Enabled 3'
    }

  ]);

  beforeEach(function() {
    mainServiceController = App.MainServiceController.create();
  });

  describe('#isStartAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStart, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStartAllDisabled')).to.equals(test.eStart);
      });
    });
  });

  describe('#isStopAllDisabled', function () {
    tests.forEach(function (test) {
      it(test.mStop, function () {
        mainServiceController = App.MainServiceController.create({
          content: test.content,
          isStartStopAllClicked: test.isStartStopAllClicked
        });
        expect(mainServiceController.get('isStopAllDisabled')).to.equals(test.eStop);
      });
    });
  });

  describe('#isStartStopAllClicked', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return Em.Object.create({
          allOperationsCount: 1
        });
      });
    });

    afterEach(function () {
      App.router.get.restore();
    });

    it('should be based on BG ops count', function () {
      expect(mainServiceController.get('isStartStopAllClicked')).to.be.true;
    });

  });

  describe('#cluster', function() {

    var tests = Em.A([
      {
        isLoaded: true,
        cluster: [],
        m: 'cluster is loaded',
        e: {name: 'c1'}
      },
      {
        isLoaded: false,
        cluster: [],
        m: 'cluster is not loaded',
        e: null
      }
    ]).forEach(function(test) {
        it(test.m, function() {
          sinon.stub(App.router, 'get', function(k) {
            if ('clusterController.isClusterDataLoaded' === k) return test.isLoaded;
            return Em.get(App.router, k);
          });
          sinon.stub(App.Cluster, 'find', function() {
            return [test.e];
          });
          var c = mainServiceController.get('cluster');
          App.router.get.restore();
          App.Cluster.find.restore();
          expect(c).to.eql(test.e);
        });
      });

  });

  describe('#startAllService', function() {

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
    });

    it('target is disabled', function() {
      var event = {target: {className: 'disabled', nodeType: 1}};
      var r = mainServiceController.startAllService(event);
      expect(r).to.be.null;
    });

    it('parent is disabled', function() {
      var event = {target: {parentElement: {className: 'disabled', nodeType: 1}}};
      var r = mainServiceController.startAllService(event);
      expect(r).to.be.null;
    });

    it('nothing disabled', function() {
      var event = {target: {}}, query = 'query';
      mainServiceController.startAllService(event).onPrimary(query);
      expect(mainServiceController.allServicesCall.calledWith('STARTED', query));
    });

  });

  describe('#stopAllService', function() {

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
    });

    it('target is disabled', function() {
      var event = {target: {className: 'disabled', nodeType: 1}};
      var r = mainServiceController.stopAllService(event);
      expect(r).to.be.null;
    });

    it('parent is disabled', function() {
      var event = {target: {parentElement: {className: 'disabled', nodeType: 1}}};
      var r = mainServiceController.stopAllService(event);
      expect(r).to.be.null;
    });

    it('nothing disabled', function() {
      var event = {target: {}}, query = 'query';
      mainServiceController.stopAllService(event).onPrimary(query);
      expect(mainServiceController.allServicesCall.calledWith('STARTED', query));
    });

  });

  describe('#startStopAllService', function() {
    var event = { target: document.createElement("BUTTON") };

    beforeEach(function() {
      sinon.stub(mainServiceController, 'allServicesCall', Em.K);
      sinon.spy(Em.I18n, "t");
    });

    afterEach(function() {
      mainServiceController.allServicesCall.restore();
      Em.I18n.t.restore();
    });

    it ("should confirm stop if state is INSTALLED", function() {
      mainServiceController.startStopAllService(event, "INSTALLED");
      expect(Em.I18n.t.calledWith('services.service.stopAll.confirmMsg')).to.be.ok;
      expect(Em.I18n.t.calledWith('services.service.stop.confirmButton')).to.be.ok;
    });

    it ("should check last checkpoint for NN before confirming stop", function() {
      var mainServiceItemController = App.MainServiceItemController.create({});
      sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
        return true;
      });
      sinon.stub(App.router, 'get', function(k) {
        if ('mainServiceItemController' === k) {
          return mainServiceItemController;
        }
        return Em.get(App.router, k);
      });
      sinon.stub(App.Service, 'find', function() {
        return [{
          serviceName: "HDFS",
          workStatus: "STARTED"
        }];
      });
      mainServiceController.startStopAllService(event, "INSTALLED");
      expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      mainServiceItemController.checkNnLastCheckpointTime.restore();
      App.router.get.restore();
      App.Service.find.restore();
    });

    it ("should confirm start if state is not INSTALLED", function() {
      mainServiceController.startStopAllService(event, "STARTED");
      expect(Em.I18n.t.calledWith('services.service.startAll.confirmMsg')).to.be.ok;
      expect(Em.I18n.t.calledWith('services.service.start.confirmButton')).to.be.ok;
    });
  });

  describe('#allServicesCall', function() {

    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        if ('clusterName' === k) return 'tdk';
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      $.ajax.restore();
      App.get.restore();
    });

    it('should do ajax-request', function() {
      var state = 'STARTED',
        query = 'some query';
      mainServiceController.allServicesCall(state, query);
      var params = $.ajax.args[0][0];
      expect(params.type).to.equal('PUT');
      expect(params.url.contains('/clusters/tdk/services?')).to.be.true;
      var data = JSON.parse(params.data);
      expect(data.Body.ServiceInfo.state).to.equal(state);
      expect(data.RequestInfo.context).to.equal(App.BackgroundOperationsController.CommandContexts.START_ALL_SERVICES);
    });

  });

  describe('#allServicesCallErrorCallback', function() {

    it('should set status to FAIL', function() {
      var params = {query: Em.Object.create({status: ''})};
      mainServiceController.allServicesCallErrorCallback({}, {}, '', {}, params);
      expect(params.query.get('status')).to.equal('FAIL');
    });

  });

  describe('#gotoAddService', function() {

    beforeEach(function() {
      sinon.stub(App.router, 'transitionTo', Em.K);
    });

    afterEach(function() {
      App.router.transitionTo.restore();
    });

    it('should not go to wizard', function() {
      mainServiceController.reopen({isAllServicesInstalled: true});
      mainServiceController.gotoAddService();
      expect(App.router.transitionTo.called).to.be.false;
    });

    it('should go to wizard', function() {
      mainServiceController.reopen({isAllServicesInstalled: false});
      mainServiceController.gotoAddService();
      expect(App.router.transitionTo.calledWith('main.serviceAdd')).to.be.true;
    });

  });

});

});

;require.register("test/controllers/main/views_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('controllers/main/views_controller');

var mainViewsController;
describe('MainViewsController', function () {

  beforeEach(function () {
    mainViewsController = App.MainViewsController.create();
  });

  describe('#loadAmbariViews()', function () {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.router.get.restore();
      App.ajax.send.restore();
    });

    it('should load views if the user is logged in', function () {
      sinon.stub(App.router, 'get').withArgs('loggedIn').returns(true);
      mainViewsController.loadAmbariViews();
      expect(App.ajax.send.calledOnce).to.be.true;
    });

    it('should not load views if the user is not logged in', function () {
      sinon.stub(App.router, 'get').withArgs('loggedIn').returns(false);
      mainViewsController.loadAmbariViews();
      expect(App.ajax.send.notCalled).to.be.true;
    })
  });

});

});

;require.register("test/controllers/main_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');

describe('App.MainController', function () {
  var mainController = App.MainController.create();

  describe('#getServerVersionSuccessCallback', function () {

    var controller = App.MainController.create(),
      cases = [
        {
          osFamily: 'redhat5',
          expected: false
        },
        {
          osFamily: 'redhat6',
          expected: true
        },
        {
          osFamily: 'suse11',
          expected: false
        }
      ],
      title = 'App.isManagedMySQLForHiveEnabled should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osFamily), function () {
        controller.getServerVersionSuccessCallback({
          'RootServiceComponents': {
            'component_version': '',
            'properties': {
              'server.os_family': item.osFamily
            }
          }
        });
        expect(App.get('isManagedMySQLForHiveEnabled')).to.equal(item.expected);
      });
    });
  });

  describe('#isClusterDataLoaded', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(true);
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return true', function() {
      expect(mainController.get('isClusterDataLoaded')).to.be.true;
    });
  });

  describe('#clusterDataLoadedPercent', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(16);
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return 16', function() {
      expect(mainController.get('clusterDataLoadedPercent')).to.be.equal(16);
    });
  });

  describe('#initialize', function() {
    var initialize = false;
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        loadClusterData: function() {
          initialize = true;
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return true', function() {
      mainController.initialize();
      expect(initialize).to.be.true;
    });
  });

  describe('#dataLoading', function() {
    it ('Should resolve promise', function() {
      sinon.stub(App.router, 'get').returns(true);
      var deffer = mainController.dataLoading();
      App.router.get.restore();
      deffer.then(function(val){
        expect(val).to.be.undefined;
      });
    });
    it ('Should resolve promise', function() {
      sinon.stub(App.router, 'get').returns(false);
      
      setTimeout(function() {
        mainController.set('isClusterDataLoaded', true);
      },150);

      var deffer = mainController.dataLoading();
      App.router.get.restore();
      deffer.then(function(val){
        expect(val).to.be.undefined;
      });
    });
  });

  describe('#checkServerClientVersion', function() {
    var initialize = false;
    beforeEach(function () {
      sinon.stub(mainController, 'getServerVersion').returns({
        done: function(func) {
          if (func) {
            func();
          }
        }
      });
    });
    afterEach(function () {
      mainController.getServerVersion.restore();
    });
    it ('Should resolve promise', function() {
      var deffer = mainController.checkServerClientVersion();
      deffer.then(function(val){
        expect(val).to.be.undefined;
      });
    });
  });

  describe('#getServerVersion', function() {
    var res;
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', function(data) {
        res = JSON.parse(JSON.stringify(data));
      });
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it ('Should send data', function() {
      mainController.getServerVersion();
      expect(res).to.be.eql({
        "name": "ambari.service",
        "sender": {},
        "data": {
          "fields": "?fields=RootServiceComponents/component_version,RootServiceComponents/properties/server.os_family&minimal_response=true"
        },
        "success": "getServerVersionSuccessCallback",
        "error": "getServerVersionErrorCallback"
      });
    });
  });

  describe('#stopAllService', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        stopAllService: function(func) {
          if (func) {
            func();
          }
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should call event', function() {
      var done = false;
      var event = function() {
        done = true;
      };
      mainController.stopAllService(event);
      expect(done).to.be.true;
    });
  });

  describe('#startAllService', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        startAllService: function(func) {
          if (func) {
            func();
          }
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should call event', function() {
      var done = false;
      var event = function() {
        done = true;
      };
      mainController.startAllService(event);
      expect(done).to.be.true;
    });
  });

  describe('#isStopAllDisabled', function() {
    beforeEach(function () {
      sinon.stub(mainController, 'scRequest').returns(true);
    });
    afterEach(function () {
      mainController.scRequest.restore();
    });
    it ('Should return true', function() {
      expect(mainController.get('isStopAllDisabled')).to.be.true;
    });
  });

  describe('#gotoAddService', function() {
    var done = false;
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        gotoAddService: function() {
          done = true;
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should call router', function() {
      mainController.gotoAddService();
      expect(done).to.be.true;
    });
  });

  describe('#isStartAllDisabled', function() {
    beforeEach(function () {
      sinon.stub(mainController, 'scRequest').returns(true);
    });
    afterEach(function () {
      mainController.scRequest.restore();
    });
    it ('Should return true', function() {
      expect(mainController.get('isStartAllDisabled')).to.be.true;
    });
  });

  describe('#isAllServicesInstalled', function() {
    beforeEach(function () {
      sinon.stub(mainController, 'scRequest').returns(true);
    });
    afterEach(function () {
      mainController.scRequest.restore();
    });
    it ('Should return true', function() {
      expect(mainController.get('isAllServicesInstalled')).to.be.true;
    });
  });

  describe('#scRequest', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns({
        get: function(request) {
          if (request) {
            request();
          }
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should return true', function() {
      var done = false;
      var event = function() {
        done = true;
      };
      mainController.scRequest(event);
      expect(done).to.be.true;
    });
  });

  describe('#updateTitle', function() {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function(message){
        if (message == 'clusterController.clusterName') {
          return 'c1';
        } else if (message == 'clusterInstallCompleted') {
          return true;
        } else if (message == 'clusterController') {
          return {
            get: function() {
              return true;
            }
          };
        }
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it ('Should update title', function() {
      $('body').append('<title id="title-id">text</title>');
      mainController.updateTitle();
      expect($('title').text()).to.be.equal('Ambari - c1');
      $('body').remove('#title-id');
    });
  });

});

});

;require.register("test/controllers/wizard/slave_component_groups_controller", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('utils/helper');
require('controllers/wizard/slave_component_groups_controller');

var configPropertyHelper = require('utils/configs/config_property_helper');
var controller;
describe('App.SlaveComponentGroupsController', function () {

  beforeEach(function () {
    controller = App.SlaveComponentGroupsController.create({
      content: {},
      selectedSlaveComponent: null
    });
  });

  describe('#getHostsByGroup', function () {
    it('should return empty array', function () {
      controller.set('hosts', undefined);
      expect(controller.getHostsByGroup()).to.eql([]);
    });
    it('should return g1 hosts', function () {
      var hosts = Em.A([
        Em.Object.create({
          group: 'g1',
          name: 'h1'
        }),
        Em.Object.create({
          group: 'g2',
          name: 'h2'
        }),
        Em.Object.create({
          group: 'g1',
          name: 'h3'
        })
      ]);
      var group = {
        name: 'g1'
      };
      var selectedSlaveComponent = Em.Object.create({
        hosts: hosts
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      var expected = [
        {
          "group": "g1",
          "name": "h1"
        },
        {
          "group": "g1",
          "name": "h3"
        }
      ];
 
      expect(JSON.parse(JSON.stringify(controller.getHostsByGroup(group)))).to.eql(expected);
    });
  });

  describe('#changeSlaveGroupName', function () {
    it('should return true if group is exist', function () {
      var selectedSlaveComponent = Em.Object.create({
        groups: Em.A([
          Em.Object.create({
            name: 'g1'
          })
        ])
      });
      var group = {};
      controller.set('selectedSlaveComponent',selectedSlaveComponent);
      expect(controller.changeSlaveGroupName(group, 'g1')).to.be.true;
    });
    it('should return false if group is not exist', function () {
      var hosts = Em.A([
        Em.Object.create({
          group: 'g1',
          name: 'h1'
        }),
        Em.Object.create({
          group: 'g2',
          name: 'h2'
        }),
        Em.Object.create({
          group: 'g1',
          name: 'h3'
        })
      ]);
      var selectedSlaveComponent = Em.Object.create({
        hosts: hosts,
        groups: Em.A([
          Em.Object.create({
            name: 'g1'
          })
        ])
      });
      var group = {
        name: 'g2'
      };
      controller.set('selectedSlaveComponent',selectedSlaveComponent);
      expect(controller.changeSlaveGroupName(group, 'g2')).to.be.false;
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(App.SlaveConfigs, 'create').returns(Em.Object.create({
        groups: false,
        componentName: '',
        displayName: ''
      }));
      sinon.stub(App.config, 'get').returns(Em.A([
        Em.Object.create({
          category: 'HBASE',
          serviceName: 'HBASE',
          configs: Em.A([Em.Object.create({})])
        })
      ]));
      sinon.stub(App.ServiceConfigProperty, 'create').returns(Em.Object.create({
          name: 'dfs_data_dir',
          initialValue: Em.K
        })
      );
    });
    afterEach(function () {
      App.SlaveConfigs.create.restore();
      App.ServiceConfigProperty.create.restore();
      App.config.get.restore();
    });
    it('should add groups to stepConfgig', function () {
      var stepConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HBASE',
          configCategories: Em.A([
            Em.Object.create({
              isForSlaveComponent: true,
              primaryName: 'sl1',
              slaveConfigs: Em.A([])
            })
          ])
        })
      ]);
      var content = Em.A([
        Em.Object.create({
          componentName: 'sl1',
          displayName: 'd1'
        })
      ]);
      controller.set('content',content);
      controller.set('stepConfigs',stepConfigs);
      controller.loadStep();
      var expected = [
        {
          "serviceName": "HBASE",
          "configCategories": [
            {
              "isForSlaveComponent": true,
              "primaryName": "sl1",
              "slaveConfigs": {
                "groups": [
                  {
                   "name": "Default",
                   "index":
                   "default",
                   "type": "default",
                   "active": true,
                   "properties": []
                  }
                ],

                "componentName": "sl1",
                "displayName": "d1"
              }
            }
          ]
        }
      ];
      var result = JSON.parse(JSON.stringify(controller.get('stepConfigs')));
      expect(result).to.be.eql(expected);
    });
  });

  describe('#componentProperties', function () {
    beforeEach(function () {
      sinon.stub(App.config, 'get').returns(Em.A([
        Em.Object.create({
          category: 'RegionServer',
          serviceName: 'HBASE',
          configs: Em.A([
            Em.Object.create({
              category: 'RegionServer'
            }),
            Em.Object.create({
              next: true,
              category: 'RegionServer'
            })
          ])
        })
      ]));
      sinon.stub(App.ServiceConfigProperty, 'create', function(value) {
        if (value && value.next) {
          return Em.Object.create({
            name: 'dfs_data_dir',
            initialValue: Em.K,
            validate: Em.K
          });
        } else {
          return Em.Object.create({
            name: 'mapred_local_dir',
            initialValue: Em.K,
            validate: Em.K
          });
        }
      });
      sinon.stub(configPropertyHelper, 'initialValue', Em.K);
    });
    afterEach(function () {
      App.ServiceConfigProperty.create.restore();
      App.config.get.restore();
      configPropertyHelper.initialValue.restore();
    });
    it('should return created config', function () {
      var res = JSON.parse(JSON.stringify(controller.componentProperties('HBASE')));
      var expected = [
        {
          "name": "mapred_local_dir"
        },
        {
          "name": "dfs_data_dir"
        }
      ];
      expect(res).to.be.eql(expected);
    });
  });

  describe('#selectedComponentName', function () {
    afterEach(function () {
      App.router.get.restore();
    });
    it('should return selected component name HDFS', function () {
      sinon.stub(App.router, 'get').returns('HDFS');
      expect(controller.get('selectedComponentName')).to.be.eql({
        name: 'DATANODE',
        displayName: 'DataNode'
      });
    });
    it('should return selected component name HBASE', function () {
      sinon.stub(App.router, 'get').returns('HBASE');
      expect(controller.get('selectedComponentName')).to.be.eql({
        name: 'HBASE_REGIONSERVER',
        displayName: 'RegionServer'
      });
    });
    it('should return null', function () {
      sinon.stub(App.router, 'get').returns('undefined');
      expect(controller.get('selectedComponentName')).to.be.null;
    });
  });

  describe('#selectedSlaveComponent', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configCategories: Em.A([
            Em.Object.create({
              isForSlaveComponent: true,
              primaryName: 'sl1',
              slaveConfigs: Em.A([]),
              name: 'name'
            })
          ])
        })
      ]));
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it('should return selected component name', function () {
      var controller = App.SlaveComponentGroupsController.create({
        content: {}
      });
      controller.set('selectedComponentName', Em.Object.create({
        displayName: 'name'
      }));
      controller.set('selectedComponentName', 'value')
      expect(controller.get('selectedSlaveComponent')).to.be.null;
    });
  });

  describe('#removeSlaveComponentGroup', function () {
    beforeEach(function() {
      sinon.stub(controller, 'componentProperties').returns(Em.A([]));
    });
    afterEach(function() {
      controller.componentProperties.restore();
    });
    it('should return empty selected component', function () {
      var selectedSlaveComponent = Em.Object.create({
        newGroupIndex: 0,
        hosts: Em.A([]),
        groups: Em.A([
          Em.Object.create({
            active: true,
            name: 'New Group',
            type: 'new'
          })
        ])
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      var ev = Em.Object.create({
        context: selectedSlaveComponent.groups[0]
      });
      controller.removeSlaveComponentGroup(ev);
      var expected = {
        "newGroupIndex": 0,
        "hosts": [],
        "groups": []
      };

      var res = JSON.parse(JSON.stringify(controller.get('selectedSlaveComponent')));
      expect(res).to.be.eql(expected);
    });
  });

  describe('#showSlaveComponentGroup', function () {
    it('should make all groups active', function () {
      var selectedSlaveComponent = Em.Object.create({
        newGroupIndex: 0,
        hosts: Em.A([]),
        groups: Em.A([
          Em.Object.create({
            active: false,
            name: 'New Group',
            type: 'new'
          })
        ])
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      var ev = Em.Object.create({
        context: selectedSlaveComponent.groups[0]
      });
      controller.showSlaveComponentGroup(ev);
      var expected = {
        "newGroupIndex": 0,
        "hosts": [],
        "groups": [
          {
            "active": true,
            "name": "New Group",
            "type": "new"
          }
        ]
      };

      var res = JSON.parse(JSON.stringify(controller.get('selectedSlaveComponent')));
      expect(res).to.be.eql(expected);
    });
  });

  describe('#selectedComponentDisplayName', function () {
    beforeEach(function () {
      sinon.stub(App.format, 'role').returns('name')
    });
    afterEach(function () {
      App.format.role.restore();
    });
    it('should return selected component name', function () {
      expect(controller.get('selectedComponentDisplayName')).to.be.equal('name');
    });
  });

  describe('#hosts', function () {
    it('should return hosts', function () {
      var selectedSlaveComponent = Em.Object.create({
        newGroupIndex: 0,
        hosts: Em.A([{name: 'h1'}]),
        groups: Em.A([
          Em.Object.create({
            active: false,
            name: 'New Group',
            type: 'new'
          })
        ])
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      expect(controller.get('hosts')).to.be.eql(Em.A([{name: 'h1'}]));
    });
  });

  describe('#componentGroups', function () {
    it('should return groups', function () {
      var selectedSlaveComponent = Em.Object.create({
        newGroupIndex: 0,
        hosts: Em.A([{name: 'h1', group: 'one'}, {name: 'h2', group: 'one'}]),
        groups: Em.A([
          Em.Object.create({
            active: false,
            name: 'New Group',
            type: 'new'
          })
        ])
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      expect(controller.get('componentGroups')).to.be.eql(Em.A([
        Em.Object.create({
          active: false,
          name: 'New Group',
          type: 'new'
        })
      ]));
    });
  });

  describe('#activeGroup', function () {
    it('should return active group', function () {
      var selectedSlaveComponent = Em.Object.create({
        newGroupIndex: 0,
        hosts: Em.A([{name: 'h1', group: 'one'}, {name: 'h2', group: 'one'}]),
        groups: Em.A([
          Em.Object.create({
            active: false,
            name: 'New Group',
            type: 'new'
          }),
          Em.Object.create({
            active: true,
            name: 'New Group',
            type: 'new'
          })
        ])
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      expect(controller.get('activeGroup')).to.be.eql(Em.Object.create({
        active: true,
        name: 'New Group',
        type: 'new'
      }));
    });
  });

  describe('#groups', function () {
    it('should return uniq groups names', function () {
      var selectedSlaveComponent = Em.Object.create({
        newGroupIndex: 0,
        hosts: Em.A([{name: 'h1', group: 'one'}, {name: 'h2', group: 'one'}]),
        groups: Em.A([
          Em.Object.create({
            active: false,
            name: 'New Group',
            type: 'new'
          })
        ])
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      expect(controller.get('groups')).to.be.eql(['one']);
    });
  });

  describe('#addSlaveComponentGroup', function () {
    beforeEach(function() {
      sinon.stub(controller, 'componentProperties').returns(Em.A([]));
    });
    afterEach(function() {
      controller.componentProperties.restore();
    });
    it('should return selected component name', function () {
      var selectedSlaveComponent = Em.Object.create({
        newGroupIndex: 0,
        groups: Em.A([
          Em.Object.create({
            active: true,
            name: 'New Group'
          })
        ])
      });
      controller.set('selectedSlaveComponent', selectedSlaveComponent);
      controller.addSlaveComponentGroup();
      var expected = {
        "newGroupIndex": 1,
        "groups": [
          {
            "active": false,
            "name": "New Group"
          },
          {
            "name": "New Group 1",
            "index": 1,
            "type": "new",
            "active": true,
            "properties": []
          }
        ]
      };

      var res = JSON.parse(JSON.stringify(controller.get('selectedSlaveComponent')));
      expect(res).to.be.eql(expected);
    });
  });

  describe('#checkGroupName', function () {
    it('should make equal to 2', function () {
      var selectedSlaveComponent = Em.Object.create({
        groups: Em.A([
          Em.Object.create({
            name: 'New Group 1'
          })
        ]),
        newGroupIndex: 0
      });
      var group = {};
      controller.set('selectedSlaveComponent',selectedSlaveComponent);
      controller.checkGroupName();
      expect(controller.get('selectedSlaveComponent').newGroupIndex).to.be.equal(2);
    });
  });

  describe('#changeHostGroup', function () {
    it('should push 1 host group', function () {
      var selectedSlaveComponent = Em.Object.create({
        tempSelectedGroups: undefined
      });
      var host = Em.Object.create({
        hostName: 'h1'
      });
      controller.set('selectedSlaveComponent',selectedSlaveComponent);
      controller.changeHostGroup(host, 'g1');
      var expected = [
        {
          "hostName": "h1",
          "groupName": "g1"
        }
      ];
      var result = JSON.parse(JSON.stringify(controller.get('selectedSlaveComponent').tempSelectedGroups));
      expect(result).to.be.eql(expected);
    });
    it('should push change host group name', function () {
      var selectedSlaveComponent = Em.Object.create({
        tempSelectedGroups: [
          Em.Object.create({
            hostName: 'h1',
            groupName: ''
          })
        ]
      });
      var host = Em.Object.create({
        hostName: 'h1'
      });
      controller.set('selectedSlaveComponent',selectedSlaveComponent);
      controller.changeHostGroup(host, 'g1');
      var expected = [
        Em.Object.create({
          "hostName": "h1",
          "groupName": "g1"
        })
      ]
      expect(controller.get('selectedSlaveComponent').tempSelectedGroups).to.be.eql(expected);
    });
  });

  describe('#loadGroups', function () {
    beforeEach(function () {
      sinon.stub(App.SlaveConfigs, 'create').returns(Em.Object.create({
        groups: false,
        componentName: '',
        displayName: ''
      }));
      sinon.stub(App.config, 'get').returns(Em.A([
        Em.Object.create({
          category: 'HDFS',
          serviceName: 'HDFS',
          configs: Em.A([])
        })
      ]));
    });
    afterEach(function () {
      App.SlaveConfigs.create.restore();
      App.config.get.restore();
    });
    it('should modefie step confgigs', function () {
      var stepConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configCategories: Em.A([
            Em.Object.create({
              isForSlaveComponent: true,
              primaryName: 'sl1',
              slaveConfigs: Em.A([])
            })
          ])
        })
      ]);
      var content = Em.A([
        Em.Object.create({
          componentName: 'sl1',
          displayName: 'd1',
          groups: Em.A([
            Em.Object.create({
              name: 'g1'
            })
          ])
        })
      ]);
      controller.set('content',content);
      controller.set('stepConfigs',stepConfigs);
      controller.loadGroups();
      var expected = [
        {
          "serviceName": "HDFS",
          "configCategories": [
            {
              "isForSlaveComponent": true,
              "primaryName": "sl1",
              "slaveConfigs": {
                "groups": [
                  {
                    "name": "g1"
                  }
                ],
                "componentName": "sl1",
                "displayName": "d1"
              }
            }
          ]
        }
      ];
      var result = JSON.parse(JSON.stringify(controller.get('stepConfigs')));
      expect(result).to.be.eql(expected);
    });
    it('should add groups to stepConfgig', function () {
      var stepConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configCategories: Em.A([
            Em.Object.create({
              isForSlaveComponent: true,
              primaryName: 'sl1',
              slaveConfigs: Em.A([])
            })
          ])
        })
      ]);
      var content = Em.A([
        Em.Object.create({
          componentName: 'sl1',
          displayName: 'd1'
        })
      ]);
      controller.set('content',content);
      controller.set('stepConfigs',stepConfigs);
      controller.loadGroups();
      var expected = [
        {
          "serviceName": "HDFS",
          "configCategories": [
            {
              "isForSlaveComponent": true,
              "primaryName": "sl1",
              "slaveConfigs": {
                "groups": [
                  {
                   "name": "Default",
                   "index":
                   "default",
                   "type": "default",
                   "active": true,
                   "properties": []
                  }
                ],

                "componentName": "sl1",
                "displayName": "d1"
              }
            }
          ]
        }
      ];
      var result = JSON.parse(JSON.stringify(controller.get('stepConfigs')))
      expect(result).to.be.eql(expected);
    });
  });

});

});

;require.register("test/controllers/wizard/step0_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster_states');
require('controllers/wizard/step0_controller');
var wizardStep0Controller;

describe('App.WizardStep0Controller', function () {

  beforeEach(function() {
    wizardStep0Controller = App.WizardStep0Controller.create({content: {cluster: {}}});
    sinon.stub(App.clusterStatus, 'set', Em.K);
    sinon.stub(App.router, 'send', Em.K);
  });

  afterEach(function() {
    App.clusterStatus.set.restore();
    App.router.send.restore();
  });

  describe('#invalidClusterName', function () {
    it('should return true if no cluster name is present', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':''}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains white spaces', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'the cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    });
    it('should return true if cluster name contains special chars', function () {
      wizardStep0Controller.set('hasSubmitted', true);
      wizardStep0Controller.set('content', {'cluster':{'name':'$cluster'}});
      expect(wizardStep0Controller.get('invalidClusterName')).to.equal(true);
    })
  });

  describe('#loadStep', function() {
    it('should clear step data', function() {
      wizardStep0Controller.loadStep();
      expect(wizardStep0Controller.get('hasSubmitted')).to.equal(false);
      expect(wizardStep0Controller.get('clusterNameError')).to.equal('');
    });
  });

  describe('#submit', function() {
    it('if cluster name is valid should proceed', function() {
      wizardStep0Controller.set('content.cluster.name', 'tdk');
      wizardStep0Controller.submit();
      expect(wizardStep0Controller.get('content.cluster.status')).to.equal('PENDING');
      expect(wizardStep0Controller.get('content.cluster.isCompleted')).to.equal(false);
      expect(App.router.send.calledWith('next')).to.equal(true);
      expect(App.clusterStatus.set.calledWith('clusterName', 'tdk')).to.equal(true);
    });

    it('if cluster name isn\'t valid shouldn\'t proceed', function() {
      wizardStep0Controller.set('content.cluster.name', '@@@@');
      wizardStep0Controller.submit();
      expect(App.router.send.called).to.equal(false);
      expect(App.clusterStatus.set.called).to.equal(false);
    });
  });

});
});

;require.register("test/controllers/wizard/step10_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */



var App = require('app');
require('controllers/wizard/step10_controller');

var controller;

describe('App.WizardStep10Controller', function () {

  beforeEach(function() {
    controller = App.WizardStep10Controller.create();
    controller.set('content', {cluster: {status: 'INSTALL COMPLETE'}});
  });

  afterEach(function() {
    controller.clearStep();
  });

  describe('#clearStep', function() {
    it('should clear clusterInfo', function() {
      controller.get('clusterInfo').pushObject({});
      controller.clearStep();
      expect(controller.get('clusterInfo.length')).to.equal(0);
    });
  });

  describe('#loadStep', function() {
    beforeEach(function() {
      sinon.spy(controller, 'clearStep');
      sinon.stub(controller, 'loadRegisteredHosts', Em.K);
      sinon.stub(controller, 'loadInstalledHosts', Em.K);
      sinon.stub(controller, 'loadInstallTime', Em.K);
    });
    afterEach(function() {
      controller.clearStep.restore();
      controller.loadRegisteredHosts.restore();
      controller.loadInstalledHosts.restore();
      controller.loadInstallTime.restore();
    });
    it('should call clearStep', function() {
      controller.loadStep();
      expect(controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadInstalledHosts', function() {
      controller.loadStep();
      expect(controller.loadInstalledHosts.calledOnce).to.equal(true);
    });
    it('should loadInstallTime if not installerController', function() {
      controller.set('content.controllerName', 'addServiceController');
      controller.loadStep();
      expect(controller.loadInstallTime.calledOnce).to.equal(true);
    });
    var testsForLoadInstallTime = Em.A([
      {
        loadMasterComponents: true,
        loadStartedServices: true,
        e: true
      },
      {
        loadMasterComponents: true,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      },
      {
        loadMasterComponents: false,
        loadStartedServices: false,
        e: false
      }
    ]);
    testsForLoadInstallTime.forEach(function(test) {
      it('loadMasterComponents: ' + test.loadMasterComponents.toString() + ' loadStartedServices: ' + test.loadStartedServices.toString(), function() {
        controller.set('content.controllerName', 'installerController');
        sinon.stub(controller, 'loadMasterComponents', function() {return test.loadMasterComponents;});
        sinon.stub(controller, 'loadStartedServices', function() {return test.loadStartedServices;});
        controller.loadStep();
        expect(controller.loadInstallTime.called).to.equal(test.e);
        controller.loadMasterComponents.restore();
        controller.loadStartedServices.restore();
      });
    });
  });

  describe('#loadInstalledHosts', function() {
    var tests = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({status: 'success', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'success', tasks: []})
        },
        m: 'all success',
        e: Em.A([
          {id: 1, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'warning', tasks: []}),
          'h2': Em.Object.create({status: 'failed', tasks: []}),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'some failed, some warning',
        e: Em.A([
          {id: 2, l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({status: 'failed', tasks: []}),
          'h2': Em.Object.create({status: 'success', tasks: []}),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'sone failed, some success, some warning',
        e: Em.A([
          {id: 1, l: 1},
          {id: 2, l: 2}
        ])
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        controller.set('content.hosts', test.hosts);
        controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
        controller.loadInstalledHosts();
        test.e.forEach(function(ex) {
          expect(controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', ex.id).get('displayStatement').contains(ex.l)).to.equal(true);
        });
      })
    });
    var testsForFailedTasks = Em.A([
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'failed', tasks: []})
        },
        m: 'only failed tasks',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'failed',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'failed',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}},
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'FAILED'}}
            ]
          }),
          'h3': Em.Object.create({status: 'warning', tasks: []})
        },
        m: 'only failed tasks, warning hosts',
        e: Em.A([
          {st: 'failed', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'TIMEDOUT'}}
            ]
          })
        },
        m: 'only timedout tasks, warning hosts',
        e: Em.A([
          {st: 'timedout', l: 3}
        ])
      },
      {
        hosts: {
          'h1': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h2': Em.Object.create({
            status: 'warning',
            tasks: []
          }),
          'h3': Em.Object.create({
            status: 'warning',
            tasks: [
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}},
              {Tasks: {status: 'ABORTED'}}
            ]
          })
        },
        m: 'only aborted tasks, warning hosts',
        e: Em.A([
          {st: 'aborted', l: 3}
        ])
      }
    ]);
    testsForFailedTasks.forEach(function(test) {
      it(test.m, function() {
        controller.set('content.hosts', test.hosts);
        controller.set('clusterInfo', Em.A([Em.Object.create({id: 1, status: []})]));
        controller.loadInstalledHosts();
        test.e.forEach(function(ex) {
          expect(controller.get('clusterInfo').findProperty('id', 1).get('status').findProperty('id', 2).get('statements').mapProperty('status', ex.st).length).to.equal(ex.l);
        });
      })
    });
  });

  describe('#loadMasterComponent', function() {
    var tests = Em.A([
      {
        component: Em.Object.create({hostName: 'h1'}),
        e: 1
      },
      {
        component: Em.Object.create({}),
        e: 0
      }
    ]);

    tests.forEach(function(test) {
      it(test.component.get('hostName') ? 'Has hosNBame' : 'Doesn\'t have hostName', function() {
        controller.clearStep();
        controller.get('clusterInfo').pushObject(Em.Object.create({id: 2, status: []}));
        controller.loadMasterComponent(test.component);
        expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(test.e);
      })
    });
  });

  describe('#loadStartedServices', function() {
    var tests = Em.A([
      {
        status: 'STARTED',
        e: {
          ids: [3, 4],
          r: true
        }
      },
      {
        status: 'FAILED',
        e: {
          ids: [3],
          r: false
        }
      },
      {
        status: 'START_SKIPPED',
        e: {
          ids: [3],
          r: false
        }
      }
    ]);
    tests.forEach(function(test) {
      it(test.status, function() {
        controller.set('content', {cluster: {status: test.status}});
        var r = controller.loadStartedServices();
        expect(r).to.equal(test.e.r);
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e.ids);
      });
    });
  });

  describe('#loadInstallTime', function() {
    var tests = Em.A([
      {
        installTime: 123,
        e: [5]
      },
      {
        installTime: null,
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it('Install time' + test.installTime ? ' available' : ' not available', function() {
        controller.set('content', {cluster: {installTime: test.installTime}});
        var r = controller.loadInstallTime();
        expect(controller.get('clusterInfo').mapProperty('id')).to.eql(test.e);
      });
    });
  });

  describe('#calculateInstallTime', function () {
    it('from "9.21" to 9 minutes 12 seconds', function () {
      expect(controller.calculateInstallTime('9.21')).to.eql({minutes: 9, seconds: 12});
    });
    it('from "0" to 0 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('0')).to.eql({minutes: 0, seconds: 0});
    });
    it('from "10" to 10 minutes 0 seconds', function () {
      expect(controller.calculateInstallTime('10')).to.eql({minutes: 10, seconds: 0});
    });
    it('from "0.5" to 0 minutes 30 seconds', function () {
      expect(controller.calculateInstallTime('0.5')).to.eql({minutes: 0, seconds: 30});
    });
  });

  describe('#loadMasterComponents', function() {

    var components = Em.A(['NAMENODE','SECONDARY_NAMENODE','JOBTRACKER','HISTORYSERVER','RESOURCEMANAGER','HBASE_MASTER','HIVE_SERVER','OOZIE_SERVER','GANGLIA_SERVER']);

    d3.range(1, components.length).forEach(function(i) {
      d3.range(1, i).forEach(function(j) {
        var c = components.slice(0, j);
        it(c.join(', '), function() {
          var m = c.map(function(component){return {component: component, displayName: component, hostName: 'h1'};});
          controller.set('content.masterComponentHosts', m);
          controller.loadMasterComponents();
          expect(controller.get('clusterInfo').findProperty('id', 2).get('status').length).to.equal(m.length);
        });
      });
    });

  });

  describe('#loadRegisteredHosts', function() {
    it('should add object to clusterInfo', function() {
      var masterComponentHosts = [{hostName: 'h1'}, {hostName: 'h2'}, {hostName: 'h3'}],
        slaveComponentHosts = [{hosts: [{hostName: 'h1'}, {hostName: 'h4'}]}, {hosts: [{hostName: 'h2'}, {hostName: 'h5'}]}],
        hosts = [{hostName: 'h6'}, {hostName: 'h3'}, {hostName: 'h7'}];
      controller.set('content.masterComponentHosts', masterComponentHosts);
      controller.set('content.slaveComponentHosts', slaveComponentHosts);
      controller.set('clusterInfo', []);
      sinon.stub(App.Host, 'find', function() {
        return hosts;
      });
      var obj = controller.loadRegisteredHosts();
      App.Host.find.restore();
      expect(obj.id).to.equal(1);
      expect(obj.color).to.equal('text-info');
      expect(obj.displayStatement).to.equal(Em.I18n.t('installer.step10.hostsSummary').format(7));
      expect(obj.status).to.eql([]);
      expect(controller.get('clusterInfo.firstObject')).to.eql(obj);
    });
  });

});
});

;require.register("test/controllers/wizard/step2_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var Ember = require('ember');
require('controllers/wizard/step2_controller');
require('models/host');
require('models/host_component');
require('messages');
var c;
describe('App.WizardStep2Controller', function () {

  var userErrorTests = Em.A([
    {
      manualInstall: false,
      user: '',
      e: ''
    },
    {
      manualInstall: true,
      user: '',
      e: null
    },
    {
      manualInstall: true,
      user: 'nobody',
      e: null
    },
    {
      manualInstall: false,
      user: 'nobody',
      e: null
    }
  ]);


  beforeEach(function() {
    c = App.WizardStep2Controller.create();
  });

  describe('#isInstaller', function() {
    it('true if controllerName is installerController', function() {
      var controller = App.WizardStep2Controller.create({content: {controllerName: 'installerController'}});
      expect(controller.get('isInstaller')).to.equal(true);
    });
    it('false if controllerName isn\'t installerController', function() {
      var controller = App.WizardStep2Controller.create({content: {controllerName: 'addServiceController'}});
      expect(controller.get('isInstaller')).to.equal(false);
    });
  });

  describe('#manualInstall', function() {
    it('should be equal to content.installOptions.manualInstall', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: true}}});
      expect(controller.get('manualInstall')).to.equal(true);
      controller.toggleProperty('content.installOptions.manualInstall');
      expect(controller.get('manualInstall')).to.equal(false);
    });
  });

  describe('#hostNames', function() {
    it('should be equal to content.installOptions.hostNames', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {hostNames: 'A,b,C'}}});
      expect(controller.get('hostNames')).to.equal('a,b,c');
      controller.set('content.installOptions.hostNames', 'a,B');
      expect(controller.get('hostNames')).to.equal('a,b');
    });
  });

  describe('#sshKey', function() {
    it('should be equal to content.installOptions.sshKey', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {sshKey: '123'}}});
      expect(controller.get('sshKey')).to.equal('123');
      controller.set('content.installOptions.sshKey', '321');
      expect(controller.get('sshKey')).to.equal('321');
    });
  });

  describe('#sshUser', function() {
    it('should be equal to content.installOptions.sshUser', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {sshUser: '123'}}});
      expect(controller.get('sshUser')).to.equal('123');
      controller.set('content.installOptions.sshUser', '321');
      expect(controller.get('sshUser')).to.equal('321');
    });
  });

  describe('#agentUser', function() {
    it('should be equal to content.installOptions.agentUser', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {agentUser: '123'}}});
      expect(controller.get('agentUser')).to.equal('123');
      controller.set('content.installOptions.agentUser', '321');
      expect(controller.get('agentUser')).to.equal('321');
    });
  });

  describe('#installType', function() {
    it('should be manualDriven if manualInstall is selected', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: true}}});
      expect(controller.get('installType')).to.equal('manualDriven');
    });
    it('should be ambariDriven if manualInstall isn\'t selected', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: false}}});
      expect(controller.get('installType')).to.equal('ambariDriven');
    });
  });

  describe('#updateHostNameArr()', function () {

    var controller = App.WizardStep2Controller.create({
      hostNames: 'apache.ambari'
    });
    controller.updateHostNameArr();

    it('should push to hostNameArr only new host names', function(){
      expect(controller.get('hostNameArr').length).to.equal(1);
    });

    it('should push to inputtedAgainHostNames already installed host names', function(){
      expect(controller.get('inputtedAgainHostNames').length).to.equal(0);
    })
  });

  describe('#isAllHostNamesValid()', function () {

    var controller = App.WizardStep2Controller.create({
      hostNames: ''
    });

    it('should return true if all host names are valid', function(){
      controller.set('hostNames', 'amache.org ambari.com');
      expect(controller.isAllHostNamesValid()).to.equal(true);
    });

    var tests = Em.A([
      'hostname',
      '-hostname.com',
      'hostname-.com',
      'host_name.com',
      '123.123.123.123',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname',
      'hostnamehostnamehostnamehostnamehostnamehostnamehostnamehostnamehostname.hostname'
    ]);
    tests.forEach(function (test) {
      it('should return false for invalid host names ' + test + ' ', function () {
        controller.set('hostNames', test);
        expect(controller.isAllHostNamesValid()).to.equal(false);
      });
    });
  });

  describe('#checkHostError()', function () {

    var controller = App.WizardStep2Controller.create();

    it('should set hostsError if hostNames is ""', function () {
      controller.set('content', {'installOptions': {'hostNames': ''}});
      controller.checkHostError();
      expect(controller.get('hostsError').length).to.be.above(2);
    });

    it('should set hostsError to null if hostNames is valid', function () {
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
      controller.checkHostError();
      expect(controller.get('hostsError')).to.equal(null);
    })
  });

  describe('#checkHostAfterSubmitHandler()', function () {

    it('should be called after changing hasSubmitted', function (done) {
      var controller = App.WizardStep2Controller.create({
        checkHostError: function () {
          done();
        }
      });
      controller.set('hasSubmitted', true);
    });

    it('should be called after changing hostNames', function (done) {
      var controller = App.WizardStep2Controller.create({
        hasSubmitted: true,
        checkHostError: function () {
          done();
        }
      });
      controller.set('content', {'installOptions': {'hostNames': 'ambari'}});
    })
  });

  describe('#sshKeyError', function () {

    var tests = Em.A([
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: false,
        e: null
      },
      {
        manualInstall: false,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: '',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: true,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      },
      {
        manualInstall: false,
        sshKey: 'nobody',
        hasSubmitted: true,
        e: null
      }
    ]);

    tests.forEach(function(test) {
      it(test.sshKey + ' ' + test.manualInstall.toString() + ' ' + test.hasSubmitted.toString(), function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshKey: test.sshKey}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshKeyError')).to.equal(null);
        }
        else {
          expect(controller.get('sshKeyError').length).to.be.above(2);
        }
      });
    });
  });

  describe('#sshUserError', function () {

    userErrorTests.forEach(function(test) {
      it('', function() {
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, sshUser: test.user}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('sshUserError')).to.equal(null);
        }
        else {
          expect(controller.get('sshUserError').length).to.be.above(2);
        }
      });
    });

  });

  describe('#agentUserError', function () {

    afterEach(function () {
      App.get.restore();
    });

    userErrorTests.forEach(function(test) {
      it('Ambari Agent user account customize enabled', function() {
        sinon.stub(App, 'get').withArgs('supports.customizeAgentUserAccount').returns(true);
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, agentUser: test.user}}});
        if(Em.isNone(test.e)) {
          expect(controller.get('agentUserError')).to.be.null;
        }
        else {
          expect(controller.get('agentUserError').length).to.be.above(2);
        }
      });
    });

    userErrorTests.forEach(function(test) {
      it('Ambari Agent user account customize disabled', function() {
        sinon.stub(App, 'get').withArgs('supports.customizeAgentUserAccount').returns(false);
        var controller = App.WizardStep2Controller.create({content: {installOptions: {manualInstall: test.manualInstall, agentUser: test.user}}});
        expect(controller.get('agentUserError')).to.be.null;
      });
    });

  });

  describe('#getHostInfo()', function () {

    it('should return object with bootStatus, installType and name for every element in hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['apache', 'ambari'],
        installType: 'manualDriven'
      });

      var test = controller.getHostInfo();
      expect(test).to.eql({
        'apache':{'name':'apache', 'installType': 'manualDriven', 'bootStatus': 'PENDING', isInstalled: false},
        'ambari':{'name':'ambari', 'installType': 'manualDriven', 'bootStatus': 'PENDING', isInstalled: false}
      });
    })
  });

  describe('#setSshKey()', function () {

    it('should set content.installOptions.sshKey', function () {
      var controller = App.WizardStep2Controller.create({
        content: {'installOptions': {'sshKey': '111'}}
      });
      controller.setSshKey('222');
      expect(controller.get('content.installOptions.sshKey')).to.equal('222');
    })
  });

  describe('#evaluateStep()', function () {

    it('should return false if isSubmitDisabled is true', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({isSubmitDisabled: true});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostsError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.set('hostsError', 'error');
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if sshKeyError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({sshKeyError: 'error'});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if sshUserError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({sshUserError: 'error'});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if agentUserError is not empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        parseHostNamesAsPatternExpression: Em.K
      });
      controller.reopen({agentUserError: 'error'});
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if hostNameArr is empty', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: '',
        parseHostNamesAsPatternExpression: Em.K
      });
      expect(controller.evaluateStep()).to.equal(false);
    });

    it('should return false if isPattern is true', function () {
      var controller = App.WizardStep2Controller.create({
        hostNames: 'apache.ambari',
        isPattern: true,
        parseHostNamesAsPatternExpression: Em.K
      });
      expect(controller.evaluateStep()).to.equal(false);
    })
  });

  describe('#parseHostNamesAsPatternExpression()', function () {

    it('should parse hosts from pattern expression to hostNameArr', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['host[001-011]']
      });
      controller.parseHostNamesAsPatternExpression();
      var result = true;
      var hosts = controller.get('hostNameArr');
      for (var i = 1; i<12; i++) {
        var extra = (i.toString().length == 1) ? 0 : '';
        if (hosts[i-1] !== 'host0' + extra + i) {
          result = false;
        }
      }
      expect(result).to.equal(true);
    });

    it('should skip duplicates', function () {
      var controller = App.WizardStep2Controller.create({
        hostNameArr: ['host[1-3]', 'host2']
      });
      controller.parseHostNamesAsPatternExpression();
      expect(controller.get('hostNameArr')).to.eql(['host1', 'host2', 'host3']);
    });

  });

  describe('#proceedNext()', function () {

    it('should call warningPopup if not isAllHostNamesValid and no warningConfirmed', function() {
      c.reopen({
        isAllHostNamesValid: function() {
          return false;
        },
        warningPopup: Em.K
      });
      sinon.spy(c, 'warningPopup');
      var r = c.proceedNext(false);
      expect(r).to.equal(false);
      expect(c.warningPopup.calledOnce).to.equal(true);
    });

    it('should call manualInstallPopup if manualInstall is true', function () {
      c.reopen({
        hostNames: '',
        manualInstall: true,
        manualInstallPopup: Em.K
      });
      sinon.spy(c, 'manualInstallPopup');
      var r = c.proceedNext(true);
      expect(r).to.equal(false);
      expect(c.manualInstallPopup.calledOnce).to.equal(true);
    });

    it ('should save hosts and proceed next if manualInstall is false', function() {
      sinon.stub(App.router, 'send', Em.K);
      c.reopen({
        hostNameArr: ['h1'],
        manualInstall: false,
        isAllHostNamesValid: function() {return true;},
        content: {
          installOptions: {},
          hosts: null
        }
      });
      var r = c.proceedNext();
      expect(r).to.equal(true);
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });

  });

  describe('#isSubmitDisabled', function () {

    var controller = App.WizardStep2Controller.create({
      hostsError: '',
      sshKeyError: '',
      sshUserError: '',
      agentUserError: ''
    });

    it('should return value if hostsError is not empty', function () {
      controller.set('hostsError', 'error');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    });

    it('should return value if sshKeyError is not empty', function () {
      controller.set('sshKeyError', 'error');
      controller.set('hostsError', '');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    });

    it('should return value if sshUserError is not empty', function () {
      controller.set('sshUserError', 'error');
      controller.set('sshKeyError', '');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    });

    it('should return value if agentUserError is not empty', function () {
      controller.set('agentUserError', 'error');
      controller.set('sshUserError', '');
      expect(controller.get('isSubmitDisabled').length).to.above(0);
    });
  });

  describe('#installedHostsPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.installedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.installedHostsPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#warningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();

    });
    it('should call App.ModalPopup.show', function() {
      c.warningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.warningPopup().onPrimary();
      expect(c.proceedNext.calledWith(true)).to.equal(true);
    });
  });

  describe('#hostNamePatternPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'proceedNext', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      c.proceedNext.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.hostNamePatternPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should proceed next on primary', function() {
      c.hostNamePatternPopup().onPrimary();
      expect(c.proceedNext.calledOnce).to.equal(true);
    });
  });

  describe('#manualInstallPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(c, 'saveHosts', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
      App.router.send.restore();
      c.saveHosts.restore();
    });
    it('should call App.ModalPopup.show', function() {
      c.manualInstallPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('should save hosts and go next on primary', function() {
      c.manualInstallPopup().onPrimary();
      expect(c.saveHosts.calledOnce).to.equal(true);
      expect(App.router.send.calledWith('next')).to.equal(true);
    });
  });

  describe('#manualInstallWarningPopup', function() {
    beforeEach(function() {
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
    });
    it('should call App.ModalPopup.show if content.installOptions.useSsh is false', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: false}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
    it('shouldn\'t call App.ModalPopup.show if content.installOptions.useSsh is true', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {useSsh: true}}});
      controller.manualInstallWarningPopup();
      expect(App.ModalPopup.show.called).to.equal(false);
    });
  });

  describe('#setAmbariJavaHome', function() {
    beforeEach(function() {
      sinon.spy($, 'ajax');
    });
    afterEach(function() {
      $.ajax.restore();
    });
    it('should do ajax-request', function() {
      var controller = App.WizardStep2Controller.create({onGetAmbariJavaHomeSuccess: Em.K, onGetAmbariJavaHomeError: Em.K});
      controller.setAmbariJavaHome();
      expect($.ajax.calledOnce).to.equal(true);
    });
  });

  describe('#onGetAmbariJavaHomeSuccess', function() {
    it('should set java.home value receiced from server', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      var test = {RootServiceComponents: {properties: {'java.home': '/root'}}};
      controller.onGetAmbariJavaHomeSuccess(test);
      expect(controller.content.installOptions.javaHome).to.equal('/root');
    });
  });

  describe('#onGetAmbariJavaHomeError', function() {
    it('should set default java.home value', function() {
      var controller = App.WizardStep2Controller.create({content: {installOptions: {}}});
      controller.onGetAmbariJavaHomeError();
      expect(controller.content.installOptions.javaHome).to.equal(App.get('defaultJavaHome'));
    });
  });

  describe('#saveHosts', function() {
    beforeEach(function() {
      sinon.stub(c, 'setAmbariJavaHome', Em.K);
      c.reopen({
        hostNameArr: ['h1'],
        content: {
          hosts: null
        }
      });
    });
    afterEach(function() {
      c.setAmbariJavaHome.restore();
    });
    it('should call setAmbariJavaHome', function() {
      c.saveHosts();
      expect(c.setAmbariJavaHome.calledOnce).to.equal(true);
    });
    it('should set content.hosts', function() {
      c.saveHosts();
      expect(Em.keys(c.get('content.hosts'))).to.eql(['h1']);
    });
  });

});

});

;require.register("test/controllers/wizard/step3_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Ember = require('ember');
var App = require('app');
var c;
require('utils/ajax/ajax');
require('utils/http_client');
require('models/host');
require('controllers/wizard/step3_controller');

describe('App.WizardStep3Controller', function () {

  beforeEach(function () {

    c = App.WizardStep3Controller.create({
      content: Em.Object.create({installedHosts: Em.A([]), installOptions: {}}),
      wizardController: App.InstallerController.create(),
      setRegistrationInProgressOnce: Em.K,
      disablePreviousSteps: Em.K
    });

    sinon.stub(App.db, 'getDisplayLength', Em.K);
    sinon.stub(App.db, 'getFilterConditions').returns([]);
    sinon.stub(App.router, 'send', Em.K);
  });

  afterEach(function () {
    App.db.getDisplayLength.restore();
    App.router.send.restore();
    App.db.getFilterConditions.restore();
  });

  describe('#getAllRegisteredHostsCallback', function () {

    it('One host is already in the cluster, one host is registered', function () {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          Em.Object.create({name: 'wst3_host1'}),
          Em.Object.create({name: 'wst3_host2'})
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host2'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(test_data);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(true);
      expect(c.get('registeredHosts').length).to.equal(1);
    });

    it('All hosts are new', function () {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          {name: 'wst3_host3'},
          {name: 'wst3_host4'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host3'
            }
          },
          {
            Hosts: {
              host_name: 'wst3_host4'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(test_data);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(c.get('registeredHosts')).to.equal('');
    });

    it('No new hosts', function () {
      c.get('content.installedHosts').pushObject({
        name: 'wst3_host1'
      });
      c.reopen({
        bootHosts: [
          {name: 'wst3_host1'}
        ]
      });
      var test_data = {
        items: [
          {
            Hosts: {
              host_name: 'wst3_host1'
            }
          }
        ]
      };
      c.getAllRegisteredHostsCallback(test_data);
      expect(c.get('hasMoreRegisteredHosts')).to.equal(false);
      expect(c.get('registeredHosts')).to.equal('');
    });

  });

  describe('#registrationTimeoutSecs', function () {

    it('Manual install', function () {
      c.set('content.installOptions.manualInstall', true);
      expect(c.get('registrationTimeoutSecs')).to.equal(15);
    });

    it('Not manual install', function () {
      c.set('content.installOptions.manualInstall', false);
      expect(c.get('registrationTimeoutSecs')).to.equal(120);
    });

  });

  describe('#isHostHaveWarnings', function () {

    var tests = [
      {
        warnings: [
          {},
          {}
        ],
        m: 'Warnings exist',
        e: true
      },
      {
        warnings: [],
        m: 'Warnings don\'t exist',
        e: false
      }
    ];

    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('warnings', test.warnings);
        expect(c.get('isHostHaveWarnings')).to.equal(test.e);
      });
    });

  });

  describe('#isWarningsBoxVisible', function () {

    afterEach(function () {
      App.get.restore();
    });

    it('for testMode should be always true', function () {
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      expect(c.get('isWarningsBoxVisible')).to.equal(true);
    });

    it('for "real" mode should be based on isRegistrationInProgress', function () {
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.set('isRegistrationInProgress', false);
      expect(c.get('isWarningsBoxVisible')).to.equal(true);
      c.set('isRegistrationInProgress', true);
      expect(c.get('isWarningsBoxVisible')).to.equal(false);
    });

  });

  describe('#clearStep', function () {

    it('should clear hosts', function () {
      c.set('hosts', [
        {},
        {}
      ]);
      c.clearStep();
      expect(c.get('hosts')).to.eql([]);
    });

    it('should clear bootHosts', function () {
      c.set('bootHosts', [
        {},
        {}
      ]);
      c.clearStep();
      expect(c.get('bootHosts').length).to.equal(0);
    });

    it('should set stopBootstrap to false', function () {
      c.set('stopBootstrap', true);
      c.clearStep();
      expect(c.get('stopBootstrap')).to.equal(false);
    });

    it('should set wizardController DBProperty bootStatus to false', function () {
      c.get('wizardController').setDBProperty('bootStatus', true);
      c.clearStep();
      expect(c.get('wizardController').getDBProperty('bootStatus')).to.equal(false);
    });

    it('should set isSubmitDisabled to true', function () {
      c.set('isSubmitDisabled', false);
      c.clearStep();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });

    it('should set isSubmitDisabled to true', function () {
      c.set('isRetryDisabled', false);
      c.clearStep();
      expect(c.get('isRetryDisabled')).to.equal(true);
    });
  });

  describe('#loadStep', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('clusterController').returns({
        loadAmbariProperties: Em.K
      });
      sinon.spy(c, 'clearStep');
      sinon.stub(c, 'loadHosts', Em.K);
      sinon.stub(c, 'disablePreviousSteps', Em.K);
    });

    afterEach(function () {
      App.router.get.restore();
      c.clearStep.restore();
      c.disablePreviousSteps.restore();
      c.loadHosts.restore();
    });

    it('should set registrationStartedAt to null', function () {
      c.set('registrationStartedAt', {});
      c.loadStep();
      expect(c.get('registrationStartedAt')).to.be.null;
    });

    it('should call clearStep', function () {
      c.loadStep();
      expect(c.get('clearStep').calledOnce).to.equal(true);
    });

    it('should call loadHosts', function () {
      c.loadStep();
      expect(c.get('loadHosts').calledOnce).to.equal(true);
    });

    it('should call disablePreviousSteps', function () {
      c.loadStep();
      expect(c.get('disablePreviousSteps').calledOnce).to.equal(true);
    });

  });

  describe('#loadHosts', function () {

    beforeEach(function () {
      sinon.stub(c, 'navigateStep');
    });

    afterEach(function () {
      c.navigateStep.restore();
      App.set('testMode', false);
    });

    it('should set isLoaded to true', function () {
      App.set('testMode', true);
      c.set('content', {hosts: {}});
      c.loadHosts();
      expect(c.get('isLoaded')).to.equal(true);
    });

    it('should set bootStatus REGISTERED on testMode', function () {
      App.set('testMode', true);
      c.set('content', {hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'REGISTERED')).to.equal(true);
    });

    it('should set bootStatus DONE on "real" mode and when installOptions.manualInstall is selected', function () {
      App.set('testMode', false);
      c.set('content.installOptions', {manualInstall: true});
      c.set('content.hosts', {c: {name: 'name'}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'DONE')).to.equal(true);
    });

    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected', function () {
      App.set('testMode', false);
      c.set('content', {installOptions: {manualInstall: false}, hosts: {c: {name: 'name'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('bootStatus', 'PENDING')).to.equal(true);
    });

    it('should set bootStatus PENDING on "real" mode and when installOptions.manualInstall is not selected', function () {
      App.set('testMode', true);
      c.set('content', {hosts: {c: {name: 'name'}, d: {name: 'name1'}}});
      c.loadHosts();
      expect(c.get('hosts').everyProperty('isChecked', false)).to.equal(true);
    });

  });

  describe('#parseHostInfo', function () {

    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'RUNNING', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, one is RUNNING',
        e: {
          c: true,
          r: true
        }
      },
      {
        bootHosts: Em.A([]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'RUNNING', log: 'c3'}
        ]),
        m: 'bootHosts is empty',
        e: {
          c: false,
          r: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({name: 'c1', bootStatus: 'REGISTERED', bootLog: ''}),
          Em.Object.create({name: 'c2', bootStatus: 'REGISTERING', bootLog: ''}),
          Em.Object.create({name: 'c3', bootStatus: 'REGISTERED', bootLog: ''})
        ]),
        hostsStatusFromServer: Em.A([
          {hostName: 'c1', status: 'REGISTERED', log: 'c1'},
          {hostName: 'c2', status: 'REGISTERED', log: 'c2'},
          {hostName: 'c3', status: 'REGISTERED', log: 'c3'}
        ]),
        m: 'bootHosts not empty, hostsStatusFromServer not empty, no one is RUNNING',
        e: {
          c: true,
          r: false
        }
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('bootHosts', test.bootHosts);
        var r = c.parseHostInfo(test.hostsStatusFromServer);
        expect(r).to.equal(test.e.r);
        if (test.e.c) {
          test.hostsStatusFromServer.forEach(function (h) {
            var r = c.get('bootHosts').findProperty('name', h.hostName);
            if (!['REGISTERED', 'REGISTERING'].contains(r.get('bootStatus'))) {
              expect(r.get('bootStatus')).to.equal(h.status);
              expect(r.get('bootLog')).to.equal(h.log);
            }
          });
        }
      });
    });
  });

  describe('#removeHosts', function () {

    beforeEach(function () {
      sinon.spy(App, 'showConfirmationPopup');
    });

    afterEach(function () {
      App.showConfirmationPopup.restore();
    });

    it('should call App.showConfirmationPopup', function () {
      c.removeHosts(Em.A([]));
      expect(App.showConfirmationPopup.calledOnce).to.equal(true);
    });

    it('primary should disable Submit if no more hosts', function () {
      var hosts = [
        {}
      ];
      c.set('hosts', hosts);
      c.removeHosts(hosts).onPrimary();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });

  });

  describe('#removeHost', function () {

    beforeEach(function () {
      sinon.stub(c, 'removeHosts', Em.K);
    });

    afterEach(function () {
      c.removeHosts.restore();
    });

    it('should call removeHosts with array as arg', function () {
      var host = {a: ''};
      c.removeHost(host);
      expect(c.removeHosts.calledWith([host]));
    });

  });

  describe('#removeSelectedHosts', function () {

    beforeEach(function () {
      sinon.stub(c, 'removeHosts', Em.K);
    });

    afterEach(function () {
      c.removeHosts.restore();
    });

    it('should remove selected hosts', function () {
      c.set('hosts', [
        {isChecked: true, name: 'c1'},
        {isChecked: false, name: 'c2'}
      ]);
      c.removeSelectedHosts();
      expect(c.removeHosts.calledWith([
        {isChecked: true, name: 'c1'}
      ])).to.be.true;
    });

  });

  describe('#selectedHostsPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show App.ModalPopup', function () {
      c.selectedHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

  });

  describe('#retryHosts', function () {
    var s;
    var agentUserCases = [
      {
        customizeAgentUserAccount: true,
        userRunAs: 'user',
        title: 'Ambari Agent user account customize enabled'
      },
      {
        customizeAgentUserAccount: false,
        userRunAs: 'root',
        title: 'Ambari Agent user account customize disabled'
      }
    ];
    var installer = {launchBootstrap: Em.K};

    beforeEach(function () {
      sinon.spy(installer, "launchBootstrap");
      s = sinon.stub(App.router, 'get', function () {
        return installer;
      });
      sinon.stub(c, 'doBootstrap', Em.K);
      sinon.spy(c, 'startRegistration');
    });

    afterEach(function () {
      c.doBootstrap.restore();
      s.restore();
      installer.launchBootstrap.restore();
      c.startRegistration.restore();
    });

    it('should set numPolls to 0', function () {
      c.set('content', {installOptions: {}});
      c.set('numPolls', 123);
      c.retryHosts(Em.A([]));
      expect(c.get('numPolls')).to.equal(0);
    });

    it('should set registrationStartedAt to null', function () {
      c.set('content', {installOptions: {}});
      c.retryHosts(Em.A([]));
      expect(c.get('registrationStartedAt')).to.be.null;
    });

    it('should startRegistration if installOptions.manualInstall is true', function () {
      c.set('content', {installOptions: {manualInstall: true}});
      c.retryHosts(Em.A([]));
      expect(c.startRegistration.calledOnce).to.equal(true);
    });

    it('should launchBootstrap if installOptions.manualInstall is false', function () {
      c.set('content', {installOptions: {manualInstall: false}});
      c.retryHosts(Em.A([]));
      expect(installer.launchBootstrap.calledOnce).to.be.true;
    });

    agentUserCases.forEach(function (item) {
      it(item.title, function () {
        var controller = App.WizardStep3Controller.create({
          content: {
            installOptions: {
              sshKey: 'key',
              sshUser: 'root',
              agentUser: 'user'
            },
            hosts: { "host0": { "name": "host0" }, "host1": { "name": "host1" } }
          }
        });
        sinon.stub(App, 'get').withArgs('supports.customizeAgentUserAccount').returns(item.customizeAgentUserAccount);
        controller.setupBootStrap();
        App.get.restore();
        expect(installer.launchBootstrap.firstCall.args[0]).to.equal(JSON.stringify({
          verbose: true,
          sshKey: 'key',
          hosts: ['host0', 'host1'],
          user: 'root',
          userRunAs: item.userRunAs
        }));
      });
    });
  });

  describe('#retryHost', function () {

    beforeEach(function () {
      sinon.spy(c, 'retryHosts');
      sinon.stub(App.router, 'get', function () {
        return {launchBootstrap: Em.K}
      });
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.retryHosts.restore();
      App.router.get.restore();
      c.doBootstrap.restore();
    });

    it('should callretryHosts with array as arg', function () {
      var host = {n: 'c'};
      c.set('content', {installOptions: {}});
      c.retryHost(host);
      expect(c.retryHosts.calledWith([host])).to.equal(true);
    });

  });

  describe('#retrySelectedHosts', function () {

    beforeEach(function () {
      sinon.spy(c, 'retryHosts');
      sinon.stub(App.router, 'get', function () {
        return {launchBootstrap: Em.K}
      });
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.retryHosts.restore();
      App.router.get.restore();
      c.doBootstrap.restore();
    });

    it('shouldn\'t do nothing if isRetryDisabled is true', function () {
      c.set('isRetryDisabled', true);
      c.retrySelectedHosts();
      expect(c.retryHosts.called).to.equal(false);
    });

    it('should retry hosts with FAILED bootStatus and set isRetryDisabled to true', function () {
      c.set('isRetryDisabled', false);
      c.set('bootHosts', Em.A([Em.Object.create({name: 'c1', bootStatus: 'FAILED'}), Em.Object.create({name: 'c2', bootStatus: 'REGISTERED'})]));
      c.retrySelectedHosts();
      expect(c.retryHosts.calledWith([
        {name: 'c1', bootStatus: 'RUNNING'}
      ]));
      expect(c.get('isRetryDisabled')).to.equal(true);
    });

  });

  describe('#startBootstrap', function () {

    beforeEach(function () {
      sinon.stub(c, 'doBootstrap', Em.K);
    });

    afterEach(function () {
      c.doBootstrap.restore();
    });

    it('should drop numPolls and registrationStartedAt', function () {
      c.set('numPolls', 123);
      c.set('registrationStartedAt', 1234);
      c.startBootstrap();
      expect(c.get('numPolls')).to.equal(0);
      expect(c.get('registrationStartedAt')).to.be.null;
    });

    it('should drop numPolls and registrationStartedAt', function () {
      c.set('hosts', Em.A([
        {name: 'c1'},
        {name: 'c2'}
      ]));
      c.startBootstrap();
      expect(c.get('bootHosts').mapProperty('name')).to.eql(['c1', 'c2']);
    });

  });

  describe('#setRegistrationInProgress', function () {

    var tests = Em.A([
      {
        bootHosts: [],
        isLoaded: false,
        e: true,
        m: 'no bootHosts and isLoaded is false'
      },
      {
        bootHosts: [],
        isLoaded: true,
        e: false,
        m: 'no bootHosts and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: true,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts without REGISTERED/FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one REGISTERED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: false,
        e: true,
        m: 'bootHosts with one FAILED and isLoaded is false'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: true,
        m: 'bootHosts with one REGISTERED and isLoaded is true'
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        isLoaded: true,
        e: true,
        m: 'bootHosts with one FAILED and isLoaded is true'
      }
    ]);

    beforeEach(function () {
      sinon.stub(c, 'getAllRegisteredHosts', Em.K);
      sinon.stub(c, 'disablePreviousSteps', Em.K);
      sinon.stub(c, 'navigateStep', Em.K);
    });

    afterEach(function () {
      c.disablePreviousSteps.restore();
      c.getAllRegisteredHosts.restore();
      c.navigateStep.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('bootHosts', test.bootHosts);
        c.set('isLoaded', test.isLoaded);
        c.setRegistrationInProgress();
        expect(c.get('isRegistrationInProgress')).to.equal(test.e);
      });
    });
  });

  describe('#doBootstrap()', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('shouldn\'t do nothing if stopBootstrap is true', function () {
      c.set('stopBootstrap', true);
      c.doBootstrap();
      expect(App.ajax.send.called).to.equal(false);
    });

    it('should increment numPolls if stopBootstrap is false', function () {
      c.set('numPolls', 0);
      c.set('stopBootstrap', false);
      c.doBootstrap();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(c.get('numPolls')).to.equal(1);
    });

  });

  describe('#startRegistration', function () {

    beforeEach(function () {
      sinon.spy(c, 'isHostsRegistered');
    });

    afterEach(function () {
      c.isHostsRegistered.restore();
    });

    it('shouldn\'t do nothing if registrationStartedAt isn\'t null', function () {
      c.set('registrationStartedAt', 1234);
      c.startRegistration();
      expect(c.isHostsRegistered.called).to.equal(false);
      expect(c.get('registrationStartedAt')).to.equal(1234);
    });

    it('shouldn\'t do nothing if registrationStartedAt isn\'t null', function () {
      c.set('registrationStartedAt', null);
      c.startRegistration();
      expect(c.isHostsRegistered.calledOnce).to.equal(true);
    });
  });

  describe('#isHostsRegistered', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', function () {
        return {retry: function () {
          return {then: Em.K}
        }}
      });
    });
    afterEach(function () {
      App.ajax.send.restore();
    });

    it('shouldn\'t do nothing if stopBootstrap is true', function () {
      c.set('stopBootstrap', true);
      c.isHostsRegistered();
      expect(App.ajax.send.called).to.equal(false);
    });

    it('should do ajax call if stopBootstrap is false', function () {
      c.set('stopBootstrap', false);
      c.isHostsRegistered();
      expect(App.ajax.send.called).to.equal(true);

    });
  });

  describe('#isHostsRegisteredSuccessCallback', function () {

    var tests = Em.A([
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'DONE'})
        ]),
        data: {items: []},
        registrationStartedAt: 1000000,
        m: 'one host DONE',
        e: {
          bs: 'REGISTERING',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c1'}}
        ]},
        m: ' one host REGISTERING',
        e: {
          bs: 'REGISTERED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c2'}}
        ]},
        registrationStartedAt: 0,
        m: 'one host REGISTERING but data missing info about it, timeout',
        e: {
          bs: 'FAILED',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'REGISTERING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c2'}}
        ]},
        registrationStartedAt: 1000000,
        m: 'one host REGISTERING but data missing info about it',
        e: {
          bs: 'REGISTERING',
          getHostInfoCalled: false
        }
      },
      {
        bootHosts: Em.A([
          Em.Object.create({bootStatus: 'RUNNING', name: 'c1'})
        ]),
        data: {items: [
          {Hosts: {host_name: 'c1'}}
        ]},
        m: ' one host RUNNING',
        e: {
          bs: 'RUNNING',
          getHostInfoCalled: false
        }
      }
    ]);

    beforeEach(function () {
      sinon.spy(c, 'getHostInfo');
      sinon.stub(App, 'dateTime').returns(1000000);
    });

    afterEach(function () {
      c.getHostInfo.restore();
      App.dateTime.restore();
    });

    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('content.installedHosts', []);
        c.set('bootHosts', test.bootHosts);
        c.set('registrationStartedAt', test.registrationStartedAt);
        c.isHostsRegisteredSuccessCallback(test.data);
        expect(c.get('bootHosts')[0].get('bootStatus')).to.equal(test.e.bs);
        expect(c.getHostInfo.called).to.equal(test.e.getHostInfoCalled);
      });
    });

  });

  describe('#getAllRegisteredHosts', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should call App.ajax.send', function () {
      c.getAllRegisteredHosts();
      expect(App.ajax.send.calledOnce).to.equal(true);
    });
  });

  describe('#getAllRegisteredHostsCallback', function () {

    var tests = Em.A([
      {
        hostsInCluster: ['c3'],
        bootHosts: [
          {name: 'c1'},
          {name: 'c2'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: 'No registered hosts',
        e: {
          hasMoreRegisteredHosts: false,
          registeredHosts: ''
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [
          {name: 'c3'},
          {name: 'c5'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: '2 registered hosts',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c1', 'c2']
        }
      },
      {
        hostsInCluster: ['c4'],
        bootHosts: [
          {name: 'c1'},
          {name: 'c5'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: '1 registered host',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      },
      {
        hostsInCluster: ['c1'],
        bootHosts: [
          {name: 'c3'},
          {name: 'c5'}
        ],
        hosts: Em.A([
          {Hosts: {host_name: 'c1'}},
          {Hosts: {host_name: 'c2'}}
        ]),
        m: '1 registered host (2)',
        e: {
          hasMoreRegisteredHosts: true,
          registeredHosts: ['c2']
        }
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({setRegistrationInProgress: Em.K, hostsInCluster: test.hostsInCluster});
        c.set('bootHosts', test.bootHosts);
        c.getAllRegisteredHostsCallback({items: test.hosts});
        expect(c.get('hasMoreRegisteredHosts')).to.equal(test.e.hasMoreRegisteredHosts);
        expect(c.get('registeredHosts')).to.eql(test.e.registeredHosts);
      });
    });

  });

  describe('#registerErrPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should call App.ModalPopup.show', function () {
      c.registerErrPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
  });

  describe('#getHostInfo', function () {

    beforeEach(function () {
      sinon.spy(App.ajax, 'send');
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should do ajax request', function () {
      c.getHostInfo();
      expect(App.ajax.send.calledOnce).to.equal(true);
    });

  });

  describe('#getHostInfoErrorCallback', function () {

    beforeEach(function () {
      sinon.spy(c, 'registerErrPopup');
    });

    afterEach(function () {
      c.registerErrPopup.restore();
    });

    it('should call registerErrPopup', function () {
      c.getHostInfoErrorCallback();
      expect(c.registerErrPopup.calledOnce).to.equal(true);
    });

  });

  describe('#stopRegistration', function () {

    var tests = Em.A([
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'REGISTERED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        e: {isSubmitDisabled: false}
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        e: {isSubmitDisabled: true}
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'FAILED'}),
          Em.Object.create({bootStatus: 'REGISTERED'})
        ],
        e: {isSubmitDisabled: false}
      },
      {
        bootHosts: [
          Em.Object.create({bootStatus: 'RUNNING'}),
          Em.Object.create({bootStatus: 'RUNNING'})
        ],
        e: {isSubmitDisabled: true}
      }
    ]);
    tests.forEach(function (test) {
      it(test.bootHosts.mapProperty('bootStatus').join(', '), function () {
        c.reopen({bootHosts: test.bootHosts});
        c.stopRegistration();
        expect(c.get('isSubmitDisabled')).to.equal(test.e.isSubmitDisabled);
      });
    });

  });

  describe('#submit', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('if isHostHaveWarnings should show confirmation popup', function () {
      c.reopen({isHostHaveWarnings: true});
      c.submit();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

    it('if isHostHaveWarnings should show confirmation popup. on Primary should set bootHosts to content.hosts', function () {
      var bootHosts = [
        Em.Object.create({name: 'c1'})
      ];
      c.reopen({isHostHaveWarnings: true, bootHosts: bootHosts, hosts: []});
      c.submit().onPrimary();
      expect(c.get('confirmedHosts')).to.eql(bootHosts);
    });

    it('if isHostHaveWarnings is false should set bootHosts to content.hosts', function () {
      var bootHosts = [
        Em.Object.create({name: 'c1'})
      ];
      c.reopen({isHostHaveWarnings: false, bootHosts: bootHosts, hosts: []});
      c.submit();
      expect(c.get('confirmedHosts')).to.eql(bootHosts);
    });

  });

  describe('#hostLogPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show App.ModalPopup', function () {
      c.hostLogPopup({context: Em.Object.create({})});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

  });

  describe('#rerunChecksSuccessCallback', function () {

    beforeEach(function () {
      sinon.stub(c, 'parseWarnings', Em.K);
    });

    afterEach(function () {
      c.parseWarnings.restore();
    });

    it('should set checksUpdateProgress to 100', function () {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksSuccessCallback({items: []});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });

    it('should set checksUpdateStatus to SUCCESS', function () {
      c.set('checksUpdateStatus', '');
      c.rerunChecksSuccessCallback({items: []});
      expect(c.get('checksUpdateStatus')).to.equal('SUCCESS');
    });

    it('should call parseWarnings', function () {
      c.rerunChecksSuccessCallback({items: []});
      expect(c.parseWarnings.calledOnce).to.equal(true);
    });

  });

  describe('#rerunChecksErrorCallback', function () {

    it('should set checksUpdateProgress to 100', function () {
      c.set('checksUpdateProgress', 0);
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateProgress')).to.equal(100);
    });

    it('should set checksUpdateStatus to FAILED', function () {
      c.set('checksUpdateStatus', '');
      c.rerunChecksErrorCallback({});
      expect(c.get('checksUpdateStatus')).to.equal('FAILED');
    });

  });

  describe('#filterBootHosts', function () {
    var tests = Em.A([
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c1'}}
          ]
        },
        m: 'one host',
        e: ['c1']
      },
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c3'}}
          ]
        },
        m: 'no hosts',
        e: []
      },
      {
        bootHosts: [
          Em.Object.create({name: 'c1'}),
          Em.Object.create({name: 'c2'})
        ],
        data: {
          items: [
            {Hosts: {host_name: 'c1'}},
            {Hosts: {host_name: 'c2'}}
          ]
        },
        m: 'many hosts',
        e: ['c1', 'c2']
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({bootHosts: test.bootHosts});
        var filteredData = c.filterBootHosts(test.data);
        expect(filteredData.items.mapProperty('Hosts.host_name')).to.eql(test.e);
      });
    });
  });

  describe('#hostWarningsPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(c, 'rerunChecks', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      c.rerunChecks.restore();
    });

    it('should show App.ModalPopup', function () {
      c.hostWarningsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });

    it('should clear checksUpdateStatus on primary', function () {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onPrimary();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });

    it('should clear checksUpdateStatus on close', function () {
      c.set('checksUpdateStatus', 'not null value');
      c.hostWarningsPopup().onClose();
      expect(c.get('checksUpdateStatus')).to.be.null;
    });

    it('should rerunChecks onSecondary', function () {
      c.hostWarningsPopup().onSecondary();
      expect(c.rerunChecks.calledOnce).to.equal(true);
    });
  });

  describe('#registeredHostsPopup', function () {

    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show App.ModalPopup', function () {
      c.registeredHostsPopup();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
    });
  });

  describe('#parseWarnings', function () {

    beforeEach(function () {
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      sinon.stub(c, 'filterBootHosts', function (k) {
        return k;
      });
    });

    afterEach(function () {
      App.get.restore();
      c.filterBootHosts.restore();
    });

    it('no warnings if last_agent_env isn\'t specified', function () {
      c.set('warnings', [
        {}
      ]);
      c.set('warningsByHost', [
        {},
        {}
      ]);
      c.parseWarnings({items: [
        {Hosts: {host_name: 'c1'}}
      ]});
      expect(c.get('warnings')).to.eql([]);
      expect(c.get('warningsByHost.length')).to.equal(1); // default group
    });

    Em.A([
        {
          m: 'parse stackFoldersAndFiles',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {stackFoldersAndFiles: []}}}
              ],
              m: 'empty stackFoldersAndFiles',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty stackFoldersAndFiles',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'fileFolders'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}},
                {Hosts: {host_name: 'c2', last_agent_env: {stackFoldersAndFiles: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty stackFoldersAndFiles on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'fileFolders'
                  }
                ],
                warningsByHost: [1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.liveServices',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: []}}}
              ],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {liveServices: []}}}}
              ],
              m: 'empty liveServices',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {liveServices: [
                  {status: 'Unhealthy', name: 'n1'}
                ]}}}}
              ],
              m: 'not empty hostHealth.liveServices',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'services'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {liveServices: [
                  {status: 'Unhealthy', name: 'n1'}
                ]}}}},
                {Hosts: {host_name: 'c2', last_agent_env: {hostHealth: {liveServices: [
                  {status: 'Unhealthy', name: 'n1'}
                ]}}}}
              ],
              m: 'not empty hostHealth.liveServices on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'services'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse existingUsers',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {existingUsers: []}}}
              ],
              m: 'empty existingUsers',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {existingUsers: [
                  {userName: 'n1'}
                ]}}}
              ],
              m: 'not empty existingUsers',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'users'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {existingUsers: [
                  {userName: 'n1'}
                ]}}},
                {Hosts: {host_name: 'c2', last_agent_env: {existingUsers: [
                  {userName: 'n1'}
                ]}}}
              ],
              m: 'not empty existingUsers on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'users'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse alternatives',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {alternatives: []}}}
              ],
              m: 'empty alternatives',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {alternatives: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty alternatives',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'alternatives'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {alternatives: [
                  {name: 'n1'}
                ]}}},
                {Hosts: {host_name: 'c2', last_agent_env: {alternatives: [
                  {name: 'n1'}
                ]}}}
              ],
              m: 'not empty alternatives on two hosts',
              e: {
                warnings: [
                  {
                    name: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'alternatives'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        },
        {
          m: 'parse hostHealth.activeJavaProcs',
          tests: Em.A([
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: [], javaProcs: []}}}
              ],
              m: 'empty hostHealth',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {activeJavaProcs: []}}}}
              ],
              m: 'empty activeJavaProcs',
              e: {
                warnings: [],
                warningsByHost: [0]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {activeJavaProcs: [
                  {pid: 'n1', command: ''}
                ]}}}}
              ],
              m: 'not empty hostHealth.activeJavaProcs',
              e: {
                warnings: [
                  {
                    pid: 'n1',
                    hosts: ['c1'],
                    onSingleHost: true,
                    category: 'processes'
                  }
                ],
                warningsByHost: [1]
              }
            },
            {
              items: [
                {Hosts: {host_name: 'c1', last_agent_env: {hostHealth: {activeJavaProcs: [
                  {pid: 'n1', command: ''}
                ]}}}},
                {Hosts: {host_name: 'c2', last_agent_env: {hostHealth: {activeJavaProcs: [
                  {pid: 'n1', command: ''}
                ]}}}}
              ],
              m: 'not empty hostHealth.activeJavaProcs on two hosts',
              e: {
                warnings: [
                  {
                    pid: 'n1',
                    hosts: ['c1', 'c2'],
                    onSingleHost: false,
                    category: 'processes'
                  }
                ],
                warningsByHost: [1, 1]
              }
            }
          ])
        }
      ]).forEach(function (category) {
        describe(category.m, function () {
          category.tests.forEach(function (test) {
            it(test.m, function () {
              c.parseWarnings({items: test.items});
              c.get('warnings').forEach(function (w, i) {
                Em.keys(test.e.warnings[i]).forEach(function (k) {
                  expect(w[k]).to.eql(test.e.warnings[i][k]);
                });
              });
              for (var i in test.e.warningsByHost) {
                if (test.e.warningsByHost.hasOwnProperty(i)) {
                  expect(c.get('warningsByHost')[i].warnings.length).to.equal(test.e.warningsByHost[i]);
                }
              }
            });
          });
        });
      });

    it('should parse umask warnings', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {umask: 24}}},
        {Hosts: {host_name: 'c2', last_agent_env: {umask: 1}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse umask warnings (2)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {umask: 24}}},
        {Hosts: {host_name: 'c2', last_agent_env: {umask: 25}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(2);
      expect(warnings.mapProperty('hosts')).to.eql([
        ['c1'],
        ['c2']
      ]);

    });

    it('should parse firewall warnings', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {firewallRunning: true, firewallName: "iptables"}}},
        {Hosts: {host_name: 'c2', last_agent_env: {firewallRunning: false, firewallName: "iptables"}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse firewall warnings (2)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {firewallRunning: true, firewallName: "iptables"}}},
        {Hosts: {host_name: 'c2', last_agent_env: {firewallRunning: true, firewallName: "iptables"}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1', 'c2']);
      expect(warnings[0].hostsLong).to.eql(['c1', 'c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });

    it('should parse reverseLookup warnings', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {reverseLookup: true}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(0);

    });

    it('should parse reverseLookup warnings (2)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {reverseLookup: false}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1']);
      expect(warnings[0].hostsLong).to.eql(['c1']);
      expect(warnings[0].onSingleHost).to.equal(true);

    });

    it('should parse reverseLookup warnings (3)', function () {

      var items = [
        {Hosts: {host_name: 'c1', last_agent_env: {reverseLookup: false}}},
        {Hosts: {host_name: 'c2', last_agent_env: {reverseLookup: false}}}
      ];

      c.parseWarnings({items: items});
      var warnings = c.get('warnings');
      expect(warnings.length).to.equal(1);
      expect(warnings[0].hosts).to.eql(['c1', 'c2']);
      expect(warnings[0].hostsLong).to.eql(['c1', 'c2']);
      expect(warnings[0].onSingleHost).to.equal(false);

    });

  });

  describe('#navigateStep', function () {

    beforeEach(function () {
      sinon.stub(c, 'setupBootStrap', Em.K);
    });

    afterEach(function () {
      c.setupBootStrap.restore();
    });

    Em.A([
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: false,
          m: 'should call setupBootStrap',
          e: true
        },
        {
          isLoaded: true,
          manualInstall: false,
          bootStatus: true,
          m: 'shouldn\'t call setupBootStrap (1)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: false,
          bootStatus: false,
          m: 'shouldn\'t call setupBootStrap (2)',
          e: false
        },
        {
          isLoaded: false,
          manualInstall: true,
          bootStatus: false,
          m: 'shouldn\'t call setupBootStrap (3)',
          e: false
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.reopen({
            isLoaded: test.isLoaded,
            content: {
              installedHosts: [],
              installOptions: {
                manualInstall: test.manualInstall
              }
            },
            wizardController: Em.Object.create({
              getDBProperty: function () {
                return test.bootStatus
              }
            })
          });
          c.navigateStep();
          if (test.e) {
            expect(c.setupBootStrap.calledOnce).to.equal(true);
          }
          else {
            expect(c.setupBootStrap.called).to.equal(false);
          }
        });
      });

    it('should set test data if testMode is true', function () {
      c.reopen({
        isLoaded: true,
        hosts: [
          {},
          {},
          {}
        ],
        content: {
          installedHosts: [],
          installOptions: {
            manualInstall: true
          }
        },
        setRegistrationInProgress: Em.K
      });
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      c.navigateStep();
      App.get.restore();
      expect(c.get('bootHosts.length')).to.equal(c.get('hosts.length'));
      expect(c.get('bootHosts').everyProperty('cpu', '2')).to.equal(true);
      expect(c.get('bootHosts').everyProperty('memory', '2000000')).to.equal(true);
      expect(c.get('isSubmitDisabled')).to.equal(false);
    });

    it('should start registration', function () {
      c.reopen({
        isLoaded: true,
        hosts: [
          {},
          {},
          {}
        ],
        content: {
          installedHosts: [],
          installOptions: {
            manualInstall: true
          }
        },
        setRegistrationInProgress: Em.K,
        startRegistration: Em.K
      });
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      sinon.spy(c, 'startRegistration');
      c.navigateStep();
      App.get.restore();
      expect(c.startRegistration.calledOnce).to.equal(true);
      c.startRegistration.restore();
      expect(c.get('bootHosts.length')).to.equal(c.get('hosts.length'));
      expect(c.get('registrationStartedAt')).to.be.null;
    });

  });

  describe('#setupBootStrap', function () {

    var cases = [
        {
          customizeAgentUserAccount: true,
          userRunAs: 'user',
          title: 'Ambari Agent user account customize enabled'
        },
        {
          customizeAgentUserAccount: false,
          userRunAs: 'root',
          title: 'Ambari Agent user account customize disabled'
        }
      ],

      controller = App.WizardStep3Controller.create({
        content: {
          installOptions: {
            sshKey: 'key',
            sshUser: 'root',
            agentUser: 'user'
          },
          hosts: { "host0": { "name": "host0" }, "host1": { "name": "host1" } },
          controllerName: 'installerController'
        }
      });

    beforeEach(function () {
      sinon.stub(App.router.get('installerController'), 'launchBootstrap', Em.K);
      this.mock = sinon.stub(App, 'get');
    });

    afterEach(function () {
      App.router.get('installerController').launchBootstrap.restore();
      this.mock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        this.mock.withArgs('supports.customizeAgentUserAccount').returns(item.customizeAgentUserAccount);
        controller.setupBootStrap();
        expect(App.router.get('installerController.launchBootstrap').firstCall.args[0]).to.equal(JSON.stringify({
          verbose: true,
          sshKey: 'key',
          hosts: ['host0', 'host1'],
          user: 'root',
          userRunAs: item.userRunAs
        }));
      });
    });

  });

  describe('#checkHostDiskSpace', function () {
    Em.A([
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 - 1024,
              mountpoint: '/'
            }
          ],
          m: 'available less than App.minDiskSpace',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (1)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 - 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available less than App.minDiskSpaceUsrLib (2)',
          e: false
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpace * 1024 * 1024 + 1024,
              mountpoint: '/'
            }
          ],
          m: 'available greater than App.minDiskSpace',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (1)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/usr/lib'
            }
          ],
          m: 'available greater than App.minDiskSpaceUsrLib (2)',
          e: true
        },
        {
          diskInfo: [
            {
              available: App.minDiskSpaceUsrLib * 1024 * 1024 + 1024,
              mountpoint: '/home/tdk'
            }
          ],
          m: 'mount point without free space checks',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          var r = c.checkHostDiskSpace('', test.diskInfo);
          expect(Em.isEmpty(r)).to.equal(test.e);
        });
      });
  });

  describe('#checkHostOSType', function () {

    it('should return empty string if no stacks provided', function () {
      c.reopen({content: {stacks: null}});
      expect(c.checkHostOSType()).to.equal('');
    });

    it('os type is valid', function () {
      var osType = 'redhat6';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [Em.Object.create({isSelected: true, osType: osType})]})
          ]
        }
      });
      expect(c.checkHostOSType(osType, '')).to.equal('');
    });

    it('os type is invalid', function () {
      var osType = 'os2';
      c.reopen({
        content: {
          stacks: [
            Em.Object.create({isSelected: true, operatingSystems: [Em.Object.create({isSelected: true, osType: 'os1'})]})
          ]
        }
      });
      expect(Em.isEmpty(c.checkHostOSType(osType, ''))).to.equal(false);
    });

  });

  describe('#getHostInfoSuccessCallback', function () {

    beforeEach(function () {
      sinon.stub(c, 'parseWarnings', Em.K);
      sinon.stub(c, 'stopRegistration', Em.K);
      sinon.stub(c, 'checkHostDiskSpace', Em.K);
      sinon.stub(c, '_setHostDataFromLoadedHostInfo', Em.K);
      sinon.spy(c, '_setHostDataWithSkipBootstrap');
    });

    afterEach(function () {
      c.parseWarnings.restore();
      c.stopRegistration.restore();
      c.checkHostDiskSpace.restore();
      c._setHostDataFromLoadedHostInfo.restore();
      c._setHostDataWithSkipBootstrap.restore();
    });

    it('should call _setHostDataWithSkipBootstrap if skipBootstrap is true', function () {
      sinon.stub(App, 'get', function (k) {
        if ('skipBootstrap' === k) return true;
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });
      var jsonData = {items: [
        {Hosts: {host_name: 'h1'}}
      ]};
      c.getHostInfoSuccessCallback(jsonData);
      expect(c._setHostDataWithSkipBootstrap.calledOnce).to.equal(true);
      App.get.restore();
    });

    it('should add repo warnings', function () {

      var jsonData = {items: [
        {Hosts: {host_name: 'h1'}}
      ]};

      sinon.stub(c, 'checkHostOSType', function () {
        return 'not_null_value';
      });
      sinon.stub(App, 'get', function (k) {
        if ('skipBootstrap' === k) return false;
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });

      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });

      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('repoCategoryWarnings.length')).to.equal(1);
      expect(c.get('repoCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);

      c.checkHostOSType.restore();
      App.get.restore();
    });

    it('should add disk warnings', function () {

      var jsonData = {items: [
        {Hosts: {host_name: 'h1'}}
      ]};

      sinon.stub(App, 'get', function (k) {
        if ('skipBootstrap' === k) return false;
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });

      c.reopen({
        bootHosts: [Em.Object.create({name: 'h1'})]
      });

      c.getHostInfoSuccessCallback(jsonData);
      expect(c.get('diskCategoryWarnings.length')).to.equal(1);
      expect(c.get('diskCategoryWarnings.firstObject.hostsNames').contains('h1')).to.equal(true);

      App.get.restore();
    });

  });

  describe('#_setHostDataWithSkipBootstrap', function () {

    it('should set mock-data', function () {
      var host = Em.Object.create({});
      c._setHostDataWithSkipBootstrap(host);
      expect(host.get('cpu')).to.equal(2);
      expect(host.get('memory')).to.equal('2000000.00');
      expect(host.get('disk_info.length')).to.equal(4);
    });

  });

  describe('#_setHostDataFromLoadedHostInfo', function () {

    it('should set data from hostInfo', function () {
      var host = Em.Object.create(),
        hostInfo = {
          Hosts: {
            cpu_count: 2,
            total_mem: 12345,
            os_type: 't1',
            os_arch: 'os1',
            os_family: 'osf1',
            ip: '0.0.0.0',
            disk_info: [
              {mountpoint: '/boot'},
              {mountpoint: '/usr'},
              {mountpoint: '/no-boot'},
              {mountpoint: '/boot'}
            ]
          }
        };
      c._setHostDataFromLoadedHostInfo(host, hostInfo);
      expect(host.get('cpu')).to.equal(2);
      expect(host.get('os_type')).to.equal('t1');
      expect(host.get('os_arch')).to.equal('os1');
      expect(host.get('os_family')).to.equal('osf1')
      expect(host.get('ip')).to.equal('0.0.0.0');
      expect(host.get('memory')).to.equal('12345.00');
      expect(host.get('disk_info.length')).to.equal(2);
    });

  });

  describe('#getJDKName', function () {

    beforeEach(function () {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
    });

    afterEach(function () {
      $.ajax.restore();
      App.get.restore();
    });

    it('should do proper request to ambari-server', function () {
      c.getJDKName();
      expect($.ajax.args[0][0].type).to.contain('GET');
      expect($.ajax.args[0][0].url).to.contain('/services/AMBARI/components/AMBARI_SERVER?fields=RootServiceComponents/properties/jdk.name,RootServiceComponents/properties/java.home,RootServiceComponents/properties/jdk_location');
    });

  });

  describe('#getJDKNameSuccessCallback', function () {

    it('should set proper data to controller properties', function () {

      var expected = {
          name: 'name',
          home: 'home',
          location: 'location'
        },
        data = {
          RootServiceComponents: {
            properties: {
              'jdk.name': expected.name,
              'java.home': expected.home,
              'jdk_location': expected.location
            }
          }
        };

      c.getJDKNameSuccessCallback(data);
      expect(c.get('needJDKCheckOnHosts')).to.equal(false);
      expect(c.get('jdkLocation')).to.equal(expected.location);
      expect(c.get('javaHome')).to.equal(expected.home);
    });

  });

  describe('#doCheckJDK', function () {

    beforeEach(function () {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
    });

    afterEach(function () {
      $.ajax.restore();
      App.get.restore();
    });

    it('should do proper request to the ambari-server', function () {

      var bootHosts = [
          Em.Object.create({name: 'n1', bootStatus: 'REGISTERED'}),
          Em.Object.create({name: 'n2', bootStatus: 'REGISTERED'})
        ],
        javaHome = '/java',
        jdkLocation = '/jdk';
      c.reopen({
        bootHosts: bootHosts,
        javaHome: javaHome,
        jdkLocation: jdkLocation
      });
      c.doCheckJDK();
      var request = $.ajax.args[0][0], data = JSON.parse(request.data);
      expect(request.type).to.equal('POST');
      expect(request.url).to.contain('/requests');
      expect(data.RequestInfo.parameters.java_home).to.equal(javaHome);
      expect(data.RequestInfo.parameters.jdk_location).to.equal(jdkLocation);
      expect(data['Requests/resource_filters'][0].hosts).to.equal('n1,n2');
    });

  });

  describe('#doCheckJDKsuccessCallback', function () {

    beforeEach(function () {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(App, 'get', function (k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });
    });

    afterEach(function () {
      $.ajax.restore();
      App.get.restore();
    });

    it('should set jdkRequestIndex if data provided', function () {

      var data = {
          href: '/a/b/c'
        },
        expected = 'c';
      c.set('jdkRequestIndex', null);
      c.doCheckJDKsuccessCallback(data);
      expect(c.get('jdkRequestIndex')).to.equal(expected);
    });

    it('should set isJDKWarningsLoaded to true if jdkCategoryWarnings is not null', function () {

      var data = null,
        expected = true;
      c.set('isJDKWarningsLoaded', false);
      c.set('jdkCategoryWarnings', {});
      c.doCheckJDKsuccessCallback(data);
      expect(c.get('isJDKWarningsLoaded')).to.equal(expected);
    });

    it('should do proper request to ambari-server', function () {

      var data = null,
        jdkRequestIndex = 'jdkRequestIndex',
        url = '/requests/' + jdkRequestIndex + '?fields=*,tasks/Tasks/host_name,tasks/Tasks/status,tasks/Tasks/structured_out';
      c.set('jdkRequestIndex', jdkRequestIndex);
      c.set('jdkCategoryWarnings', null);
      c.doCheckJDKsuccessCallback(data);
      expect($.ajax.args[0][0].type).to.equal('GET');
      expect($.ajax.args[0][0].url).to.contain(url);
    });

  });

  describe('#doCheckJDKerrorCallback', function () {

    it('should set isJDKWarningsLoaded to true', function () {

      c.set('isJDKWarningsLoaded', false);
      c.doCheckJDKerrorCallback();
      c.set('isJDKWarningsLoaded', true);

    });

  });

  describe('#parseJDKCheckResults', function () {

    beforeEach(function () {
      sinon.stub(c, 'doCheckJDKsuccessCallback', Em.K);
    });

    afterEach(function () {
      c.doCheckJDKsuccessCallback.restore();
    });

    it('should set jdkCategoryWarnings to null if no data', function () {

      var data = {Requests: {}};
      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      expect(c.get('jdkCategoryWarnings')).to.be.null;

    });

    it('should parse warnings (1)', function () {

      var data = {
        Requests: {
          end_time: 1
        },
        tasks: []
      };

      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      expect(c.get('jdkCategoryWarnings')).to.eql([]);

    });

    it('should parse warnings (2)', function () {

      var data = {
        Requests: {
          end_time: 1
        },
        tasks: [
          {
            Tasks: {
              host_name: 'h1',
              structured_out: {
                java_home_check: {
                  exit_code: 1
                }
              }
            }
          },
          {
            Tasks: {
              host_name: 'h2',
              structured_out: {
                java_home_check: {
                  exit_code: 0
                }
              }
            }
          }
        ]
      };

      c.set('jdkCategoryWarnings', {});
      c.parseJDKCheckResults(data);
      var result = c.get('jdkCategoryWarnings');
      expect(result.length).to.equal(1);
      expect(result[0].hostsNames).to.eql(['h1']);

    });

  });

  describe('#getHostCheckTasksSuccess', function() {

    beforeEach(function() {
      sinon.stub($, 'ajax', Em.K);
      sinon.stub(c, 'getHostInfo', Em.K);
      sinon.stub(c, 'parseHostNameResolution', Em.K);
      sinon.stub(c, 'getGeneralHostCheck', Em.K);
      sinon.stub(c, 'getHostCheckTasks', Em.K);

    });

    afterEach(function() {
      $.ajax.restore();
      c.getHostInfo.restore();
      c.parseHostNameResolution.restore();
      c.getGeneralHostCheck.restore();
      c.getHostCheckTasks.restore();
    });

    var dataInProgress = {
      Requests: {
        request_status: "IN_PROGRESS"
      }
    };
    it('run getHostCheckTasks', function() {
      c.getHostCheckTasksSuccess(dataInProgress);
      expect(c.getHostCheckTasks.calledOnce).to.be.true;
    });

    var hostResolutionCheckComplete = {
      Requests: {
        request_status: "COMPLETED",
        inputs: "host_resolution_check"
      }
    };
    it('run parseHostNameResolution and getGeneralHostCheck', function() {
      c.getHostCheckTasksSuccess(hostResolutionCheckComplete);
      expect(c.parseHostNameResolution.calledWith(hostResolutionCheckComplete)).to.be.true;
      expect(c.getGeneralHostCheck.calledOnce).to.be.true;
    });

    var lastAgentEnvCheckComplete = {
      Requests: {
        request_status: "COMPLETED",
        inputs: "last_agent_env_check"
      },
      tasks: [
        {
          Tasks: {
            host_name: 'h1',
            structured_out: {
              "installed_packages": [
                {
                  "version": "b1",
                  "name": "n1",
                  "repoName": "r1"
                },
                {
                  "version": "b2",
                  "name": "n2",
                  "repoName": "r2"
                }
              ]
            }
          }
        }
      ]
    };
    it('run getHostInfo', function() {
      c.getHostCheckTasksSuccess(lastAgentEnvCheckComplete);
      expect(c.get('stopChecking')).to.be.true;
      expect(c.getHostInfo.calledOnce).to.be.true;
      expect(JSON.parse(JSON.stringify(c.get('hostsPackagesData')))).eql([
        {
          hostName: 'h1',
          installedPackages: [
            {
              "version": "b1",
              "name": "n1",
              "repoName": "r1"
            },
            {
              "version": "b2",
              "name": "n2",
              "repoName": "r2"
            }
          ]
        }
      ]);
    });

  });

  describe('#getDataForCheckRequest', function() {
    var tests = [
      {
        bootHosts: [
          Em.Object.create({'bootStatus': 'REGISTERED', 'name': 'h1'}),
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h2'})
        ],
        addHosts: true,
        rez: {
          RequestInfo: {
            "action": "check_host",
            "context": "Check host",
            "parameters": {
              "check_execute_list": 'checkExecuteList',
              "jdk_location" : "jdk_location",
              "threshold": "20",
              "hosts": "h1"
            }
          },
          resource_filters: {
              "hosts": "h1"
          }
        },
        m: 'with add host param'
      },
      {
        bootHosts: [
          Em.Object.create({'bootStatus': 'REGISTERED', 'name': 'h1'}),
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h2'})
        ],
        addHosts: false,
        rez: {
          RequestInfo: {
            "action": "check_host",
            "context": "Check host",
            "parameters": {
              "check_execute_list": 'checkExecuteList',
              "jdk_location" : "jdk_location",
              "threshold": "20"
            }
          },
          resource_filters: {
            "hosts": "h1"
          }
        },
        m: 'without add host param'
      },
      {
        bootHosts: [
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h1'}),
          Em.Object.create({'bootStatus': 'FAILED', 'name': 'h2'})
        ],
        rez: null,
        m: 'with all hosts failed'
      }
    ];

    beforeEach(function() {
      sinon.stub(App.get('router'), 'get' , function(p) {
        return p === 'clusterController.ambariProperties.jdk_location' ? 'jdk_location' : Em.get(App.get('router'), p);
      })
    });
    afterEach(function() {
      App.get('router').get.restore();
    });
    tests.forEach(function(t) {
      it(t.m, function() {
        c.set('bootHosts', t.bootHosts);
        expect(c.getDataForCheckRequest('checkExecuteList', t.addHosts)).to.be.eql(t.rez);
      });
    })
  });
});

});

;require.register("test/controllers/wizard/step4_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
var modelSetup = require('test/init_model_test');

require('controllers/wizard/step4_controller');
describe('App.WizardStep4Controller', function () {

  var services = [
    'HDFS', 'GANGLIA', 'OOZIE', 'HIVE', 'HBASE', 'PIG', 'SCOOP', 'ZOOKEEPER',
    'YARN', 'MAPREDUCE2', 'FALCON', 'TEZ', 'STORM', 'AMBARI_METRICS', 'RANGER', 'SPARK'
  ];

  var controller = App.WizardStep4Controller.create();

  var generateSelectedServicesContent = function(selectedServiceNames) {
    var allServices = services.slice(0);
    modelSetup.setupStackServiceComponent();
    if (selectedServiceNames.contains('GLUSTERFS')) allServices.push('GLUSTERFS');
    allServices = allServices.map(function(serviceName) {
      return [Ember.Object.create({
        'serviceName': serviceName,
        'isSelected': false,
        'canBeSelected': true,
        'isInstalled': false,
        isPrimaryDFS: serviceName == 'HDFS',
        isDFS: ['HDFS','GLUSTERFS'].contains(serviceName),
        isMonitoringService: ['GANGLIA'].contains(serviceName),
        requiredServices: App.StackService.find(serviceName).get('requiredServices'),
        displayNameOnSelectServicePage: App.format.role(serviceName, true),
        coSelectedServices: function() {
          return App.StackService.coSelected[this.get('serviceName')] || [];
        }.property('serviceName')
      })];
    }).reduce(function(current, prev) { return current.concat(prev); });

    selectedServiceNames.forEach(function(serviceName) {
      allServices.findProperty('serviceName', serviceName).set('isSelected', true);
    });

    return allServices;
  };

  services.forEach(function(serviceName, index){
    controller.pushObject(Ember.Object.create({
      'serviceName':serviceName, 'isSelected': true, 'isHiddenOnSelectServicePage': false, 'isInstalled': false, 'isDisabled': 'HDFS' === serviceName, isDFS: 'HDFS' === serviceName
    }));
  });

  describe('#isSubmitDisabled', function () {
    it('should return false if at least one selected service is not installed', function () {
      expect(controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should return true if all selected services are already installed', function () {
      controller.setEach('isInstalled', true);
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isSubmitDisabled')).to.equal(true);
    });
  });

  describe('#isAllChecked', function () {
    it('should return true if all services are selected', function () {
      controller.setEach('isInstalled', false);
      controller.findProperty('serviceName', 'HDFS').set('isSelected', true);
      expect(controller.get('isAllChecked')).to.equal(true);
    });

    it('should return false if at least one service is not selected', function () {
      controller.findProperty('serviceName', 'HDFS').set('isSelected', false);
      expect(controller.get('isAllChecked')).to.equal(false);
    });
  });

  describe('#multipleDFSs()', function () {
    it('should return true if HDFS is selected and GLUSTERFS is selected', function () {
      controller.set('content', generateSelectedServicesContent(['HDFS', 'GLUSTERFS']));
      expect(controller.multipleDFSs()).to.equal(true);
    });
    it('should return false if HDFS is not selected and GLUSTERFS is selected', function () {
      controller.set('content', generateSelectedServicesContent(['GLUSTERFS']));
      expect(controller.multipleDFSs()).to.equal(false);
    });
    it('should return false if HDFS is selected and GLUSTERFS is not selected', function () {
      controller.set('content', generateSelectedServicesContent(['HDFS']));
      expect(controller.multipleDFSs()).to.equal(false);
    });
  });

  describe('#setGroupedServices()', function () {
    var testCases = [
      {
        title: 'should set MapReduce2 isSelected to true when YARN is selected',
        condition: {
          'YARN': true,
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': true
        }
      },
      {
        title: 'should set MapReduce2 isSelected to false when YARN is not selected',
        condition: {
          'YARN': false,
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': false
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to true when YARN is selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': false,
          'YARN': true,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': true
        }
      },
      {
        title: 'should set MAPREDUCE2 isSelected to false when YARN is not selected',
        condition: {
          'HBASE': true,
          'ZOOKEEPER': true,
          'HIVE': true,
          'YARN': false,
          'MAPREDUCE2': true
        },
        result: {
          'MAPREDUCE2': false
        }
      }
    ];

    testCases.forEach(function(testCase){
      it(testCase.title, function () {
        controller.clear();
        for(var id in testCase.condition) {
          controller.pushObject(Ember.Object.create({
            'serviceName':id, 'isSelected': testCase.condition[id], 'canBeSelected': true, 'isInstalled': false,
            coSelectedServices: function() {
              return App.StackService.coSelected[this.get('serviceName')] || [];
            }.property('serviceName')
          }));
        }
        controller.setGroupedServices();
        for(var service in testCase.result) {
          expect(controller.findProperty('serviceName', service).get('isSelected')).to.equal(testCase.result[service]);
        }
      });
    }, this);
  });

  describe('#addValidationError()', function() {
    var tests = [
      {
        errorObjects: [
          {
            id: 'serviceCheck_ZOOKEEPER',
            shouldBeAdded: true
          },
          {
            id: 'serviceCheck_YARN',
            shouldBeAdded: true
          }
        ],
        expectedIds: ['serviceCheck_ZOOKEEPER', 'serviceCheck_YARN']
      },
      {
        errorObjects: [
          {
            id: 'fsCheck',
            shouldBeAdded: true
          },
          {
            id: 'fsCheck',
            shouldBeAdded: false
          }
        ],
        expectedIds: ['fsCheck']
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    tests.forEach(function(test) {
      var message = 'Erorrs {0} thrown. errorStack property should contains ids: {1}'
        .format(test.errorObjects.mapProperty('id').join(', '), test.expectedIds.join(', '));
      it(message, function() {
        test.errorObjects.forEach(function(errorObject) {
          expect(controller.addValidationError(errorObject)).to.equal(errorObject.shouldBeAdded);
        });
        expect(controller.get('errorStack').mapProperty('id')).to.eql(test.expectedIds);
      });
    })
  });

  describe('#validate()', function() {
    var tests = [
        {
          services: ['HDFS','ZOOKEEPER'],
          errorsExpected: ['ambariMetricsCheck']
        },
        {
          services: ['ZOOKEEPER'],
          errorsExpected: ['ambariMetricsCheck']
        },
        {
          services: ['HDFS'],
          errorsExpected: ['serviceCheck_ZOOKEEPER', 'ambariMetricsCheck']
        },
        {
          services: ['HDFS', 'TEZ', 'ZOOKEEPER'],
          errorsExpected: ['serviceCheck_YARN', 'ambariMetricsCheck']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'FALCON'],
          errorsExpected: ['serviceCheck_OOZIE', 'ambariMetricsCheck']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'GANGLIA', 'HIVE'],
          errorsExpected: ['serviceCheck_YARN', 'ambariMetricsCheck']
        },
        {
          services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE'],
          errorsExpected: ['serviceCheck_YARN', 'multipleDFS', 'ambariMetricsCheck']
        },
        {
          services: ['HDFS','ZOOKEEPER', 'GANGLIA'],
          errorsExpected: ['ambariMetricsCheck']
        },
        {
          services: ['HDFS','ZOOKEEPER', 'AMBARI_METRICS'],
          errorsExpected: []
        },
        {
          services: ['ZOOKEEPER', 'AMBARI_METRICS'],
          errorsExpected: []
        },
        {
          services: ['HDFS', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_ZOOKEEPER']
        },
        {
          services: ['HDFS', 'TEZ', 'ZOOKEEPER', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_YARN']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'FALCON', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_OOZIE']
        },
        {
          services: ['HDFS', 'ZOOKEEPER', 'GANGLIA', 'HIVE', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_YARN']
        },
        {
          services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE', 'AMBARI_METRICS'],
          errorsExpected: ['serviceCheck_YARN', 'multipleDFS']
        },
        {
          services: ['HDFS','ZOOKEEPER', 'GANGLIA', 'AMBARI_METRICS'],
          errorsExpected: []
        },
        {
          services: ['RANGER'],
          errorsExpected: ['ambariMetricsCheck', 'rangerRequirements']
        }
      ],
      controllerNames = ['installerController', 'addServiceController'],
      wizardNames = {
        installerController: 'Install Wizard',
        addServiceController: 'Add Service Wizard'
      },
      sparkCases = [
        {
          currentStackName: 'HDP',
          currentStackVersionNumber: '2.2',
          sparkWarningExpected: true,
          title: 'HDP 2.2'
        },
        {
          currentStackName: 'HDP',
          currentStackVersionNumber: '2.3',
          sparkWarningExpected: false,
          title: 'HDP 2.3'
        },
        {
          currentStackName: 'BIGTOP',
          currentStackVersionNumber: '0.8',
          sparkWarningExpected: false,
          title: 'Non-HDP stack'
        }
      ];

    beforeEach(function () {
      controller.clear();
    });

    controllerNames.forEach(function (name) {
      tests.forEach(function(test) {
        var errorsExpected = test.errorsExpected;
        if (name != 'installerController') {
          errorsExpected = test.errorsExpected.without('ambariMetricsCheck');
        }
        var message = '{0}, {1} selected validation should be {2}, errors: {3}'
          .format(wizardNames[name], test.services.join(','), errorsExpected.length ? 'passed' : 'failed',
            errorsExpected.length ? errorsExpected.join(',') : 'absent');
        it(message, function() {
          controller.setProperties({
            content: generateSelectedServicesContent(test.services),
            errorStack: [],
            wizardController: Em.Object.create({
              name: name
            })
          });
          controller.validate();
          expect(controller.get('errorStack').mapProperty('id')).to.eql(errorsExpected.toArray());
        });
      })
    });

    sparkCases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App, 'get').withArgs('currentStackName').returns(item.currentStackName).
          withArgs('currentStackVersionNumber').returns(item.currentStackVersionNumber);
        controller.set('errorStack', []);
        controller.set('content', generateSelectedServicesContent(['SPARK']));
        controller.validate();
        expect(controller.get('errorStack').someProperty('id', 'sparkWarning')).to.equal(item.sparkWarningExpected);
        App.get.restore();
      });
    });

  });

  describe('#onPrimaryPopupCallback()', function() {
    var c;
    var tests = [
      {
        services: ['HDFS','ZOOKEEPER'],
        confirmPopupCount: 0,
        errorsExpected: []
      },
      {
        services: ['ZOOKEEPER'],
        confirmPopupCount: 0,
        errorsExpected: []
      },
      {
        services: ['HDFS', 'GLUSTERFS', 'ZOOKEEPER', 'HIVE'],
        confirmPopupCount: 2,
        errorsExpected: ['serviceCheck_YARN', 'serviceCheck_TEZ', 'multipleDFS']
      },
      {
        services: ['HDFS','ZOOKEEPER', 'GANGLIA'],
        confirmPopupCount: 0,
        errorsExpected: []
      }
    ];

    beforeEach(function() {
      c = App.WizardStep4Controller.create({});
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(c, 'submit', Em.K);
      sinon.spy(c, 'onPrimaryPopupCallback');
    });

    afterEach(function() {
      App.router.send.restore();
      c.submit.restore();
      c.onPrimaryPopupCallback.restore();
    });


    tests.forEach(function(test) {
      var message = 'Selected services: {0}. {1} errors should be confirmed'
        .format(test.services.join(', '), test.confirmPopupCount);

      it(message, function() {
        var runValidations = function() {
          c.serviceDependencyValidation();
          c.fileSystemServiceValidation();
        };

        c.set('content', generateSelectedServicesContent(test.services));
        runValidations();
        // errors count validation
        expect(c.get('errorStack.length')).to.equal(test.confirmPopupCount);
        // if errors detected than it should be shown
        if (test.errorsExpected) {
          test.errorsExpected.forEach(function(error, index, errors) {
            // validate current error
            var currentErrorObject = c.get('errorStack').findProperty('isShown', false);
            if (currentErrorObject) {
              expect(error).to.be.equal(currentErrorObject.id);
              // show current error
              var popup = c.showError(currentErrorObject);
              // submit popup
              popup.onPrimary();
              // onPrimaryPopupCallback should be called
              expect(c.onPrimaryPopupCallback.called).to.equal(true);
              // submit called
              expect(c.submit.called).to.equal(true);
              if (c.get('errorStack').length) {
                // current error isShown flag changed to true
                expect(currentErrorObject.isShown).to.equal(true);
              }
              runValidations();
            }
          });
        }
      });
    });

  });

  describe('#needToAddServicePopup', function() {
    Em.A([
        {
          m: 'one service',
          services: {selected: true, serviceName: 's1'},
          content: [Em.Object.create({serviceName: 's1', isSelected: false})],
          e: [true]
        },
        {
          m: 'many services',
          services: [{selected: true, serviceName: 's1'}, {selected: false, serviceName: 's2'}],
          content: [Em.Object.create({serviceName: 's1', isSelected: false}),
            Em.Object.create({serviceName: 's2', isSelected: true})],
          e: [true, false]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(controller, 'submit', Em.K);
          controller.set('content', test.content);
          controller.needToAddServicePopup(test.services, '').onPrimary();
          expect(controller.submit.calledOnce).to.equal(true);
          expect(controller.mapProperty('isSelected')).to.eql(test.e);
          controller.submit.restore();
        });
      });
  });

  describe('#submit', function() {
    var c;
    var tests = [
      {
        isSubmitDisabled: true,
        validate: false,
        userCanProceed: false
      },
      {
        isSubmitDisabled: false,
        validate: false,
        userCanProceed: false
      },
      {
        isSubmitDisabled: false,
        validate: true,
        userCanProceed: true
      }
    ];

    beforeEach(function() {
      c = App.WizardStep4Controller.create();
      sinon.stub(App.router, 'send', Em.K);
    });

    afterEach(function() {
      App.router.send.restore();
    });

    tests.forEach(function(test) {
      var messageFormat = [
        test.isSubmitDisabled ? 'disabled' : 'enabled',
        test.validate ? 'success' : 'failed',
        test.userCanProceed ? '' : 'not'
      ];
      var message = String.prototype.format.apply('Submit btn: {0}. Validation: {1}. Can{2} move to the next step.', messageFormat);

      it(message, function() {
        c.reopen({
          isSubmitDisabled: test.isSubmitDisabled,
          validate: function() { return test.validate; }
        });
        c.clear();
        c.submit();

        expect(App.router.send.calledOnce).to.equal(test.userCanProceed);
      });

    })
  });

  describe('#dependencies', function() {
    var tests = [
      {
        services: ['HDFS'],
        dependencies: ['ZOOKEEPER'] 
      },
      {
        services: ['STORM'],
        dependencies: ['ZOOKEEPER'] 
      }
    ];
    tests.forEach(function(test) {
      var message = '{0} dependency should be {1}'.format(test.services.join(','), test.dependencies.join(','));
      it(message, function() {
        
        controller.clear();
        controller.set('content', generateSelectedServicesContent(test.services));
        
        var dependentServicesTest = [];
        
        test.services.forEach(function(serviceName) {
          var service = controller.filterProperty('serviceName', serviceName);
          service.forEach(function(item) {
            var dependencies = item.get('requiredServices');
            if(!!dependencies) {
              dependentServicesTest = dependentServicesTest.concat(dependencies);
            }
          });
        });

        expect(dependentServicesTest).to.be.eql(test.dependencies);
      });
    })
  });

  describe('#ambariMetricsValidation', function () {

    var cases = [
      {
        services: ['HDFS'],
        isAmbariMetricsWarning: false,
        title: 'Ambari Metrics not available'
      },
      {
        services: ['AMBARI_METRICS'],
        isAmbariMetricsSelected: false,
        isAmbariMetricsWarning: true,
        title: 'Ambari Metrics not selected'
      },
      {
        services: ['AMBARI_METRICS'],
        isAmbariMetricsSelected: true,
        isAmbariMetricsWarning: false,
        title: 'Ambari Metrics selected'
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('content', generateSelectedServicesContent(item.services));
        var ams = controller.findProperty('serviceName', 'AMBARI_METRICS');
        if (item.services.contains('AMBARI_METRICS')) {
          ams.set('isSelected', item.isAmbariMetricsSelected);
        } else {
          controller.removeObject(ams);
        }
        controller.ambariMetricsValidation();
        expect(controller.get('errorStack').mapProperty('id').contains('ambariMetricsCheck')).to.equal(item.isAmbariMetricsWarning);
      });
    });

  });

  describe('#rangerValidation', function () {

    var cases = [
      {
        services: ['HDFS'],
        isRangerWarning: false,
        title: 'Ranger not available'
      },
      {
        services: ['RANGER'],
        isRangerSelected: false,
        isRangerInstalled: false,
        isRangerWarning: false,
        title: 'Ranger not selected'
      },
      {
        services: ['RANGER'],
        isRangerSelected: true,
        isRangerInstalled: false,
        isRangerWarning: true,
        title: 'Ranger selected'
      },
      {
        services: ['RANGER'],
        isRangerSelected: true,
        isRangerInstalled: true,
        isRangerWarning: false,
        title: 'Ranger installed'
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('content', generateSelectedServicesContent(item.services));
        var ranger = controller.findProperty('serviceName', 'RANGER');
        if (item.services.contains('RANGER')) {
          ranger.setProperties({
            isSelected: item.isRangerSelected,
            isInstalled: item.isRangerInstalled
          });
        } else {
          controller.removeObject(ranger);
        }
        controller.rangerValidation();
        expect(controller.get('errorStack').mapProperty('id').contains('rangerRequirements')).to.equal(item.isRangerWarning);
      });
    });

  });

  describe('#sparkValidation', function () {

    var cases = [
      {
        services: ['HDFS'],
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark not available'
      },
      {
        services: ['HDFS'],
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark not available'
      },
      {
        services: ['HDFS'],
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark not available'
      },
      {
        services: ['SPARK'],
        isSparkSelected: false,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark not selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: false,
        isSparkWarning: true,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: true,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.2',
        title: 'HDP 2.2, Spark installed'
      },
      {
        services: ['SPARK'],
        isSparkSelected: false,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark not selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: true,
        isSparkWarning: false,
        currentStackName: 'HDP',
        currentStackVersionNumber: '2.3',
        title: 'HDP 2.3, Spark installed'
      },
      {
        services: ['SPARK'],
        isSparkSelected: false,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark not selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: false,
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark selected'
      },
      {
        services: ['SPARK'],
        isSparkSelected: true,
        isSparkInstalled: true,
        isSparkWarning: false,
        currentStackName: 'BIGTOP',
        currentStackVersionNumber: '0.8',
        title: 'Non-HDP stack, Spark installed'
      }
    ];

    beforeEach(function() {
      controller.clear();
      controller.set('errorStack', []);
    });

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App, 'get').withArgs('currentStackName').returns(item.currentStackName).
          withArgs('currentStackVersionNumber').returns(item.currentStackVersionNumber);
        controller.set('content', generateSelectedServicesContent(item.services));
        var spark = controller.findProperty('serviceName', 'SPARK');
        if (item.services.contains('SPARK')) {
          spark.setProperties({
            isSelected: item.isSparkSelected,
            isInstalled: item.isSparkInstalled
          });
        } else {
          controller.removeObject(spark);
        }
        controller.sparkValidation();
        expect(controller.get('errorStack').mapProperty('id').contains('sparkWarning')).to.equal(item.isSparkWarning);
      });
    });

  });

  describe('#clearErrors', function () {

    var cases = [
      {
        isValidating: true,
        errorStack: [{}],
        title: 'error stack shouldn\'t be cleared during validation'
      },
      {
        isValidating: false,
        errorStack: [],
        title: 'error stack should be cleared'
      }
    ];

    beforeEach(function () {
      controller.set('errorStack', [{}]);
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.set('isValidating', item.isValidating);
        controller.propertyDidChange('@each.isSelected');
        expect(controller.get('errorStack')).to.eql(item.errorStack);
      });
    });

  });

});

});

;require.register("test/controllers/wizard/step5_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('controllers/wizard/step5_controller');
var modelSetup = require('test/init_model_test');
require('utils/ajax/ajax');
var c;
describe('App.WizardStep5Controller', function () {

  beforeEach(function () {
    c = App.WizardStep5Controller.create();
  });

  var controller = App.WizardStep5Controller.create();
  controller.set('content', {});
  var cpu = 2, memory = 4;

  controller.set('content', {});

  describe('#sortHosts', function () {

    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({memory: 4, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 3, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'memory',
        e: [1, 2, 3, 4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 4, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 3, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 4})
        ],
        m: 'cpu',
        e: [1, 2, 3, 4]
      },
      {
        hosts: [
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 1}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host3', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host1', id: 4})
        ],
        m: 'host_name',
        e: [4, 2, 3, 1]
      },
      {
        hosts: [
          Em.Object.create({memory: 2, cpu: 1, host_name: 'host1', id: 1}),
          Em.Object.create({memory: 1, cpu: 2, host_name: 'host3', id: 2}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host4', id: 3}),
          Em.Object.create({memory: 1, cpu: 1, host_name: 'host2', id: 4})
        ],
        m: 'mix',
        e: [1, 2, 4, 3]
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        var hosts = Em.copy(test.hosts);
        controller.sortHosts(hosts);
        expect(Em.A(hosts).mapProperty('id')).to.eql(test.e);
      });
    });

  });

  describe('#renderHostInfo', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'INIT'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'INIT'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'INIT'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'INIT'}
        },
        m: 'no one host is REGISTERED',
        e: []
      },
      {
        hosts: {
          h1: {memory: 4, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 3, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 2, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, memory',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 4, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 3, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, cpu',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'REGISTERED'},
          h3: {memory: 1, cpu: 1, name: 'host3', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'}
        },
        m: 'all hosts are REGISTERED, host_name',
        e: ['host1', 'host2', 'host3', 'host4']
      },
      {
        hosts: {
          h1: {memory: 2, cpu: 1, name: 'host1', bootStatus: 'REGISTERED'},
          h2: {memory: 1, cpu: 2, name: 'host3', bootStatus: 'INIT'},
          h3: {memory: 1, cpu: 1, name: 'host4', bootStatus: 'REGISTERED'},
          h4: {memory: 1, cpu: 1, name: 'host2', bootStatus: 'INIT'}
        },
        m: 'mix',
        e: ['host1', 'host4']
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content', {hosts: test.hosts});
        controller.renderHostInfo();
        var r = controller.get('hosts');
        expect(Em.A(r).mapProperty('host_name')).to.eql(test.e);
      });
    });

  });

  describe('#last', function () {

    var tests = Em.A([
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components exists',
        c: 'c1',
        e: 2
      },
      {
        selectedServicesMasters: Em.A([
          {component_name: 'c1', indx: 1},
          {component_name: 'c2', indx: 2},
          {component_name: 'c1', indx: 2}
        ]),
        m: 'Components don\'t exists',
        c: 'c3',
        e: null
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('selectedServicesMasters', test.selectedServicesMasters);
        if (!Em.isNone(test.e)) {
          expect(controller.last(test.c).indx).to.equal(test.e);
        }
        else {
          expect(Em.isNone(controller.last(test.c))).to.equal(true);
        }
      })
    });

  });

  describe('#remainingHosts', function () {
    it('should show count of hosts without masters', function () {
      c.reopen({masterHostMapping: [
        {}
      ]});
      c.set('hosts', [
        {},
        {},
        {}
      ]);
      expect(c.get('remainingHosts')).to.equal(2);
    });
  });

  describe('#clearStep', function () {
    var tests = Em.A([
      {p: 'hosts'},
      {p: 'selectedServicesMasters'},
      {p: 'servicesMasters'}
    ]);
    tests.forEach(function (test) {
      it('should cleanup ' + test.p, function () {
        c.set(test.p, [Em.Object.create({}), Em.Object.create({})]);
        c.clearStep();
        expect(c.get(test.p).length).to.equal(0);
      });
    });
  });

  describe('#updateComponent', function () {
    var tests = Em.A([
      {
        componentName: 'HBASE_SERVER',
        serviceComponents: [
          Em.Object.create({
            componentName: 'HBASE_SERVER',
            stackService: Em.Object.create({isInstalled: true, serviceName: 'HBASE'})
          })
        ],
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'}),
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service is installed',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        serviceComponents: [
          Em.Object.create({
            componentName: 'HBASE_SERVER',
            stackService: Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
          })
        ],
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: true, showRemoveControl: false, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({})
        ]),
        controllerName: 'addServiceController',
        m: 'service not installed, but all host already have provided component',
        e: {
          showAddControl: true,
          showRemoveControl: false
        }
      },
      {
        componentName: 'HBASE_SERVER',
        serviceComponents: [
          Em.Object.create({
            componentName: 'HBASE_SERVER',
            stackService:  Em.Object.create({isInstalled: false, serviceName: 'HBASE'})
          })
        ],
        selectedServicesMasters: Em.A([
          Em.Object.create({showAddControl: false, showRemoveControl: true, component_name: 'HBASE_SERVER'})
        ]),
        hosts: Em.A([
          Em.Object.create({}),
          Em.Object.create({})
        ]),
        controllerName: 'reassignMasterController',
        m: 'service not installed, not all host already have provided component, but is reassignMasterController',
        e: {
          showAddControl: false,
          showRemoveControl: false
        }
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        sinon.stub(App.StackServiceComponent, 'find', function () {
          return test.serviceComponents;
        });
        c.reopen({
          content: Em.Object.create({
            controllerName: test.controllerName
          }),
          selectedServicesMasters: test.selectedServicesMasters,
          hosts: test.hosts
        });
        c.updateComponent(test.componentName);
        App.StackServiceComponent.find.restore();
        Em.keys(test.e).forEach(function (k) {
          expect(c.last(test.componentName).get(k)).to.equal(test.e[k]);
        });

      });
    });
  });

  describe('#renderComponents', function () {
    var tests = Em.A([
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: false, isSelected: true})
        ]),
        controllerName: 'reassignMasterController',
        m: 'One component',
        isHaEnabled: false,
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          isInstalled: [false],
          serviceComponentId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: false, isSelected: true})
        ]),
        controllerName: 'addServiceController',
        m: 'One component, service is not installed',
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER'],
          showRemoveControl: [false],
          serviceComponentId: [1]
        }
      },
      {
        masterComponents: Em.A([
          {component_name: 'ZOOKEEPER_SERVER'},
          {component_name: 'ZOOKEEPER_SERVER'}
        ]),
        services: Em.A([
          Em.Object.create({serviceName: 'ZOOKEEPER', isInstalled: true})
        ]),
        controllerName: 'addServiceController',
        m: 'Two components, but service is installed',
        component_name: 'ZOOKEEPER_SERVER',
        e: {
          selectedServicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          servicesMasters: ['ZOOKEEPER_SERVER', 'ZOOKEEPER_SERVER'],
          showRemoveControl: [false, false],
          serviceComponentId: [1, 2]
        }
      }
    ]);
    tests.forEach(function (test) {
      beforeEach(function () {
        App.reopen({isHaEnabled: test.isHaEnabled});
      });
      it(test.m, function () {
        modelSetup.setupStackServiceComponent();
        sinon.stub(App.StackService, 'find', function () {
          return test.services;
        });
        App.set('isHaEnabled', test.isHaEnabled);
        c.reopen({
          content: Em.Object.create({
            services: test.services,
            controllerName: test.controllerName,
            reassign: {component_name: test.component_name}
          })
        });
        c.renderComponents(test.masterComponents);
        App.StackService.find.restore();
        modelSetup.cleanStackServiceComponent();
        expect(c.get('selectedServicesMasters').mapProperty('component_name')).to.eql(test.e.selectedServicesMasters);
        expect(c.get('servicesMasters').mapProperty('component_name')).to.eql(test.e.servicesMasters);
        expect(c.get('selectedServicesMasters').mapProperty('showRemoveControl')).to.eql(test.e.showRemoveControl);
        expect(c.get('selectedServicesMasters').mapProperty('serviceComponentId')).to.eql(test.e.serviceComponentId);
        if (c.get('isReasignController')) {
          expect(c.get('servicesMasters').mapProperty('isInstalled')).to.eql(test.e.isInstalled);
        }
      });
    });
  });

  describe('#assignHostToMaster', function () {
    var tests = Em.A([
        {
          componentName: 'c1',
          selectedHost: 'h2',
          serviceComponentId: '1',
          e: {
            indx: 0
          }
        },
        {
          componentName: 'c2',
          selectedHost: 'h3',
          serviceComponentId: '2',
          e: {
            indx: 3
          }
        },
        {
          componentName: 'c3',
          selectedHost: 'h1',
          e: {
            indx: 2
          }
        },
        {
          componentName: 'c2',
          selectedHost: 'h4',
          e: {
            indx: 1
          }
        }
      ]),
      selectedServicesMasters = Em.A([
        Em.Object.create({component_name: 'c1', serviceComponentId: '1', selectedHost: 'h1'}),
        Em.Object.create({component_name: 'c2', serviceComponentId: '1', selectedHost: 'h1'}),
        Em.Object.create({component_name: 'c3', serviceComponentId: '1', selectedHost: 'h3'}),
        Em.Object.create({component_name: 'c2', serviceComponentId: '2', selectedHost: 'h2'})
      ]);

    tests.forEach(function (test) {
      it(test.componentName + ' ' + test.selectedHost + ' ' + test.serviceComponentId, function () {
        c.set('selectedServicesMasters', selectedServicesMasters);
        c.assignHostToMaster(test.componentName, test.selectedHost, test.serviceComponentId);
        expect(c.get('selectedServicesMasters').objectAt(test.e.indx).get('selectedHost')).to.equal(test.selectedHost);
      })
    });
  });

  describe('#removeComponent', function () {

    beforeEach(function () {
      sinon.stub(c, 'getMaxNumberOfMasters', function () {
        return Infinity;
      });
    });

    afterEach(function(){
      c.getMaxNumberOfMasters.restore();
    });

    var tests = Em.A([
      {
        componentName: 'c1',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 1,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER'})
        ]),
        hosts: [],
        m: 'component is only 1',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [
          {},
          {}
        ],
        m: 'two components, add allowed, remove not allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        serviceComponentId: 2,
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 3, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: true})
        ]),
        hosts: [
          {},
          {},
          {}
        ],
        m: 'three components, add allowed, remove allowed',
        e: true,
        showAddControl: true,
        showRemoveControl: true
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('hosts', test.hosts);
        expect(c.removeComponent(test.componentName, test.serviceComponentId)).to.equal(test.e);
        if (test.e) {
          expect(c.get('selectedServicesMasters.lastObject.showRemoveControl')).to.equal(test.showRemoveControl);
          expect(c.get('selectedServicesMasters.lastObject.showAddControl')).to.equal(test.showAddControl);
        }
      })
    });
  });

  describe('#addComponent', function () {

    beforeEach(function () {
      sinon.stub(c, 'getMaxNumberOfMasters', function () {
        return Infinity;
      });
    });

    afterEach(function(){
      c.getMaxNumberOfMasters.restore();
    });

    var tests = Em.A([
      {
        componentName: 'c1',
        selectedServicesMasters: Em.A([]),
        hosts: [],
        m: 'empty selectedServicesMasters',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'HBASE_SERVER'})
        ]),
        hosts: [],
        m: 'no such components',
        e: false
      },
      {
        componentName: 'ZOOKEPEER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({serviceComponentId: 1, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false}),
          Em.Object.create({serviceComponentId: 2, component_name: 'ZOOKEPEER_SERVER', showAddControl: false, showRemoveControl: false})
        ]),
        hosts: [Em.Object.create({}), Em.Object.create({}), Em.Object.create({})],
        m: 'two components, 3 hosts',
        e: true
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.set('selectedServicesMasters', test.selectedServicesMasters);
        c.set('hosts', test.hosts);
        expect(c.addComponent(test.componentName)).to.equal(test.e);
      });
    });
  });

  describe('#masterHostMapping', function () {
    Em.A([
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h2'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}}),
            Em.Object.create({host_name: 'h2', host_info: {}})
          ],
          m: 'Two hosts',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [
              {},
              {}
            ]},
            {host_name: 'h2', hostInfo: {}, masterServices: [
              {}
            ]}
          ]
        },
        {
          selectedServicesMasters: [],
          hosts: [],
          m: 'No hosts',
          e: []
        },
        {
          selectedServicesMasters: [
            Em.Object.create({selectedHost: 'h1'}),
            Em.Object.create({selectedHost: 'h1'})
          ],
          hosts: [
            Em.Object.create({host_name: 'h1', host_info: {}})
          ],
          m: 'One host',
          e: [
            {host_name: 'h1', hostInfo: {}, masterServices: [
              {},
              {}
            ]}
          ]
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.reopen({
            selectedServicesMasters: test.selectedServicesMasters,
            hosts: test.hosts
          });
          var result = c.get('masterHostMapping');
          expect(result.length).to.equal(test.e.length);
          result.forEach(function (r, i) {
            expect(r.get('host_name')).to.equal(test.e[i].host_name);
            expect(r.get('masterServices.length')).to.equal(test.e[i].masterServices.length);
            expect(r.get('hostInfo')).to.be.an.object;
          });
        });
      });
  });

  describe('#anyError', function () {

    Em.A([
        {
          servicesMasters: [
            Em.Object.create({errorMessage: 'some message'}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: [],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: ''}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: [],
          e: false
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: 'some message'}),
            Em.Object.create({errorMessage: 'some message 2'})
          ],
          generalErrorMessages: ['some message'],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({errorMessage: ''}),
            Em.Object.create({errorMessage: ''})
          ],
          generalErrorMessages: ['some message'],
          e: true
        }
      ]).forEach(function (test, i) {
        it('test #' + i.toString(), function () {
          c.setProperties({
            servicesMasters: test.servicesMasters,
            generalErrorMessages: test.generalErrorMessages
          });
          expect(c.get('anyError')).to.equal(test.e);
        });
      });

  });

  describe('#anyWarning', function () {

    Em.A([
        {
          servicesMasters: [
            Em.Object.create({warnMessage: 'some message'}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: [],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: ''}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: [],
          e: false
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: 'some message'}),
            Em.Object.create({warnMessage: 'some message 2'})
          ],
          generalWarningMessages: ['some message'],
          e: true
        },
        {
          servicesMasters: [
            Em.Object.create({warnMessage: ''}),
            Em.Object.create({warnMessage: ''})
          ],
          generalWarningMessages: ['some message'],
          e: true
        }
      ]).forEach(function (test, i) {
        it('test #' + i.toString(), function () {
          c.setProperties({
            servicesMasters: test.servicesMasters,
            generalWarningMessages: test.generalWarningMessages
          });
          expect(c.get('anyWarning')).to.equal(test.e);
        });
      });

  });

  describe('#clearRecommendations', function () {

    it('should clear content.recommendations', function () {

      c.set('content', {recommendations: {'s': {}}});
      c.clearRecommendations();
      expect(c.get('content.recommendations')).to.be.null;

    });

  });

  describe('#updateIsSubmitDisabled', function () {

    var clearCases = [
      {
        isHostNameValid: true,
        isInitialLayout: true,
        isInitialLayoutResulting: false,
        clearRecommendationsCallCount: 0,
        recommendAndValidateCallCount: 1,
        title: 'initial masters-hosts layout'
      },
      {
        isHostNameValid: true,
        isInitialLayout: false,
        isInitialLayoutResulting: false,
        clearRecommendationsCallCount: 1,
        recommendAndValidateCallCount: 1,
        title: 'master-hosts layout changed'
      },
      {
        isHostNameValid: false,
        isInitialLayout: false,
        isInitialLayoutResulting: false,
        clearRecommendationsCallCount: 0,
        recommendAndValidateCallCount: 0,
        title: 'invalid host name specified'
      }
    ];

    beforeEach(function () {
      c.set('selectedServicesMasters', [
        {isInstalled: false}
      ]);
      sinon.stub(c, 'clearRecommendations', Em.K);
      sinon.stub(c, 'recommendAndValidate', Em.K);
    });

    afterEach(function () {
      c.clearRecommendations.restore();
      c.recommendAndValidate.restore();
    });

    it('shouldn\'t change submitDisabled if thereIsNoMasters returns false', function () {

      c.set('selectedServicesMasters', [
        {isInstalled: true}
      ]);
      c.set('submitDisabled', false);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(false);

    });

    it('should check servicesMasters.@each.isHostNameValid if useServerValidation is false', function () {

      c.set('useServerValidation', false);
      c.set('servicesMasters', [
        {isHostNameValid: false},
        {isHostNameValid: true}
      ]);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(true);

      c.set('servicesMasters', [
        {isHostNameValid: true},
        {isHostNameValid: true}
      ]);
      c.updateIsSubmitDisabled();
      expect(c.get('submitDisabled')).to.equal(false);

    });

    clearCases.forEach(function (item) {
      it(item.title, function () {
        c.setProperties({
          isInitialLayout: item.isInitialLayout,
          servicesMasters: [{
            isHostNameValid: item.isHostNameValid
          }]
        });
        expect(c.get('isInitialLayout')).to.equal(item.isInitialLayoutResulting);
        expect(c.clearRecommendations.callCount).to.equal(item.clearRecommendationsCallCount);
        expect(c.recommendAndValidate.callCount).to.equal(item.recommendAndValidateCallCount);
      });
    });

  });

  describe('#isHostNameValid', function () {

    beforeEach(function () {
      c.setProperties({
        hosts: [
          {host_name: 'h1'},
          {host_name: 'h2'},
          {host_name: 'h3'}
        ],
        selectedServicesMasters: [
          {component_name: 'c1', selectedHost: 'h1'},
          {component_name: 'c2', selectedHost: 'h2'},
          {component_name: 'c3', selectedHost: 'h3'},
          {component_name: 'c3', selectedHost: 'h1'}
        ]
      });
    });

    Em.A([
        {
          componentName: 'c1',
          selectedHost: '   ',
          m: 'empty hostName is invalid',
          e: false
        },
        {
          componentName: 'c1',
          selectedHost: 'h4',
          m: 'hostName not exists',
          e: false
        },
        {
          componentName: 'c4',
          selectedHost: 'h3',
          m: 'component not exists on host',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          expect(c.isHostNameValid(test.componentName, test.selectedHost)).to.equal(test.e);
        });
      });

  });

  describe('#createComponentInstallationObject', function () {

    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });

    Em.A([
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          mastersToMove: ['c1'],
          savedComponent: {
            hostName: 'h2',
            isInstalled: true
          },
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: true})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h2',
            isInstalled: true,
            isServiceCoHost: false
          }
        },
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          mastersToMove: [],
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: false})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h1',
            isInstalled: false,
            isServiceCoHost: false
          }
        },
        {
          fullComponent: Em.Object.create({
            componentName: 'c1',
            serviceName: 's1'
          }),
          hostName: 'h1',
          mastersToMove: [],
          stackServiceComponents: [Em.Object.create({componentName: 'c1', isCoHostedComponent: true})],
          e: {
            component_name: 'c1',
            display_name: 'C1',
            serviceId: 's1',
            selectedHost: 'h1',
            isInstalled: false,
            isServiceCoHost: true
          }
        }
      ]).forEach(function (test, i) {
        it('test #' + i, function () {
          sinon.stub(App.StackServiceComponent, 'find', function () {
            return test.stackServiceComponents;
          });
          c.set('mastersToMove', test.mastersToMove);
          c.set('content', {controllerName: test.controllerName});
          expect(c.createComponentInstallationObject(test.fullComponent, test.hostName, test.savedComponent)).to.eql(test.e);
        });
      });

  });

  describe('#createComponentInstallationObjects', function () {

    beforeEach(function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return [
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c1', serviceName: 's1'}),
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c2', serviceName: 's2'}),
          Em.Object.create({isShownOnAddServiceAssignMasterPage: true, componentName: 'c4', serviceName: 's2'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c1', serviceName: 's1'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c2', serviceName: 's2'}),
          Em.Object.create({isShownOnInstallerAssignMasterPage: true, componentName: 'c4', serviceName: 's2'})
        ];
      });

      c.set('content', {
        masterComponentHosts: [],
        services: [
          {serviceName: 's1', isSelected: true, isInstalled: false},
          {serviceName: 's2', isSelected: true, isInstalled: false}
        ],
        recommendations: {
          "blueprint": {
            "host_groups": [
              {
                "name": "host-group-1",
                "components": [ {"name": "c1"}, {"name": "c2"} ]
              },
              {
                "name": "host-group-2",
                "components": [ {"name": "c1"}, {"name": "c2"} ]
              },
              {
                "name": "host-group-3",
                "components": [ {"name": "c1"} ]
              }
            ]
          },
          "blueprint_cluster_binding": {
            "host_groups": [
              {
                "name": "host-group-1",
                "hosts": [ {"fqdn": "h1"} ]
              },
              {
                "name": "host-group-2",
                "hosts": [ {"fqdn": "h2"} ]
              },
              {
                "name": "host-group-3",
                "hosts": [ {"fqdn": "h3"} ]
              }
            ]
          }
        }
      });

    });

    afterEach(function() {
      App.StackServiceComponent.find.restore();
    });

    it('simple map without nothing stored/saved etc', function() {
      var r = c.createComponentInstallationObjects();
      expect(r.mapProperty('component_name')).to.eql(['c1', 'c2', 'c1', 'c2', 'c1']);
      expect(r.mapProperty('serviceId')).to.eql(['s1', 's2', 's1', 's2', 's1']);
      expect(r.mapProperty('selectedHost')).to.eql(['h1', 'h1', 'h2', 'h2', 'h3']);
    });

    it('some saved components exist', function() {
      c.set('content.controllerName', 'addServiceController');
      c.get('multipleComponents').push('c4');
      c.set('content.masterComponentHosts', [
        {hostName: 'h3', component: 'c4'}
      ]);
      c.get('content.recommendations.blueprint.host_groups')[2].components.push({name: 'c4'});
      var r = c.createComponentInstallationObjects();
      expect(r.mapProperty('component_name')).to.eql(['c1', 'c2', 'c1', 'c2', 'c1', 'c4']);
      expect(r.mapProperty('serviceId')).to.eql(['s1', 's2', 's1', 's2', 's1', 's2']);
      expect(r.mapProperty('selectedHost')).to.eql(['h1', 'h1', 'h2', 'h2', 'h3', 'h3']);
    });

  });

  describe('#getCurrentBlueprint', function () {

    beforeEach(function() {
      sinon.stub(c, 'getCurrentSlaveBlueprint', function() {
        return {
          blueprint_cluster_binding: {
            host_groups: []
          },
          blueprint: {
            host_groups: []
          }
        };
      });
    });

    afterEach(function() {
      c.getCurrentSlaveBlueprint.restore();
    });

    it('should map masterHostMapping', function () {

      c.reopen({masterHostMapping: [
        {host_name: 'h1', hostInfo:{}, masterServices: [
          {serviceId: 's1', component_name: 'c1'},
          {serviceId: 's2', component_name: 'c2'}
        ]},
        {host_name: 'h2', hostInfo:{}, masterServices: [
          {serviceId: 's1', component_name: 'c1'},
          {serviceId: 's3', component_name: 'c3'}
        ]}
      ]});

      var r = c.getCurrentBlueprint();
      expect(r).to.eql({"blueprint": {"host_groups": [
          {"name": "host-group-1", "components": [
            {"name": "c1"},
            {"name": "c2"}
          ]},
          {"name": "host-group-2", "components": [
            {"name": "c1"},
            {"name": "c3"}
          ]}
        ]}, "blueprint_cluster_binding": {"host_groups": [
          {"name": "host-group-1", "hosts": [
            {"fqdn": "h1"}
          ]},
          {"name": "host-group-2", "hosts": [
            {"fqdn": "h2"}
          ]}
        ]}}
      );
    });

  });

  describe('#updateValidationsSuccessCallback', function() {

    beforeEach(function() {
      sinon.stub(App.HostComponent, 'find', function() {
        return [];
      });
    });

    afterEach(function() {
      App.HostComponent.find.restore();
    });

    it('should map messages to generalErrorMessages, generalWarningMessages', function() {

      var data = [
          {
            type: 'host-component',
            'component-name': 'c1',
            host: 'h1',
            level: 'ERROR',
            message: 'm1'
          },
          {
            type: 'host-component',
            'component-name': 'c2',
            host: 'h2',
            level: 'WARN',
            message: 'm2'
          },
          {
            type: 'host-component',
            'component-name': 'c3',
            host: 'h3',
            level: 'ERROR',
            message: 'm3'
          },
          {
            type: 'host-component',
            'component-name': 'c4',
            host: 'h4',
            level: 'WARN',
            message: 'm4'
          }
        ],
        servicesMasters = [
          Em.Object.create({selectedHost: 'h1', component_name: 'c1'}),
          Em.Object.create({selectedHost: 'h2', component_name: 'c2'})
        ];

      c.set('servicesMasters', servicesMasters);
      c.updateValidationsSuccessCallback({resources: [{items: data}]});

      expect(c.get('submitDisabled')).to.equal(false);
      expect(c.get('servicesMasters').findProperty('component_name', 'c1').get('errorMessage')).to.equal('m1');
      expect(c.get('servicesMasters').findProperty('component_name', 'c2').get('warnMessage')).to.equal('m2');
      expect(c.get('generalErrorMessages')).to.be.empty;
      expect(c.get('generalWarningMessages')).to.be.empty;
    });

  });
});

});

;require.register("test/controllers/wizard/step6_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
var validationUtils = require('utils/validator');
require('utils/helper');
require('controllers/wizard/step6_controller');
var controller,
  services = [
    Em.Object.create({
      serviceName: 'YARN',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HBASE',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'HDFS',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'STORM',
      isSelected: true
    }),
    Em.Object.create({
      serviceName: 'FLUME',
      isSelected: true
    })
  ];
describe('App.WizardStep6Controller', function () {

  beforeEach(function () {
    controller = App.WizardStep6Controller.create();
    controller.set('content', Em.Object.create({
      hosts: {},
      masterComponentHosts: {},
      services: services
    }));

    var h = {}, m = [];
    Em.A(['host0', 'host1', 'host2', 'host3']).forEach(function (hostName) {
      var obj = Em.Object.create({
        name: hostName,
        hostName: hostName,
        bootStatus: 'REGISTERED'
      });
      h[hostName] = obj;
      m.push(obj);
    });

    controller.set('content.hosts', h);
    controller.set('content.masterComponentHosts', m);
    controller.set('isMasters', false);

  });

  describe('#isAddHostWizard', function () {
    it('true if content.controllerName is addHostController', function () {
      controller.set('content.controllerName', 'addHostController');
      expect(controller.get('isAddHostWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addHostController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddHostWizard')).to.equal(false);
    });
  });

  describe('#installedServiceNames', function () {
    it(' should filter content.services by isInstalled property', function () {
      var services = Em.A([]);
      services.pushObjects(Em.A([{isInstalled: true, serviceName: "service1"},
                           {isInstalled: false, serviceName: "service2"},
                           {isInstalled: true, serviceName: "service3"},
                           {isInstalled: false, serviceName: "service4"},
                           {isInstalled: true, serviceName: "service5"}]));
      controller.set('content.services', services);
      expect(controller.get('installedServiceNames')).to.eql(["service1", "service3", "service5"]);
    });
  });

  describe('#showValidationIssuesAcceptBox', function () {
    it('should return true if success callback', function () {
      var deffer = jQuery.Deferred();
      function callback() {
        deffer.resolve(true);
      }
      controller.showValidationIssuesAcceptBox(callback);
      jQuery.when(deffer.promise()).then(function(data) {
        expect(data).to.equal(true);    
      }); 
    });
  });

  describe('#selectAllNodes', function () {
    it('should make checkbox checked', function () {
      var hostsObj = Em.A([Em.Object.create({
        hasMaster: false,
        isInstalled: false,
        checkboxes: Em.A([
          Em.Object.create({
            title: 'l1',
            component: 'name',
            isInstalled: false,
            checked: false
          })
        ])
      })]);
      var obj = Em.Object.create({
        context: {
          name: "name"
        }
      });
      var clientComponents = Em.A([{component_name: "name1"}]);
      controller.set('hosts', hostsObj);
      controller.set('content.clients', clientComponents);
      controller.selectAllNodes(obj);
      expect(controller.get('hosts')).to.eql(Em.A([Em.Object.create({
        hasMaster: false,
        isInstalled: false,
        checkboxes: Em.A([
          Em.Object.create({
            title: 'l1',
            component: 'name',
            isInstalled: false,
            checked: true
          })
        ])
      })]));
    });
  });

  describe('#deselectAllNodes', function () {
    it('should uncheck checkbox', function () {
      var hostsObj = Em.A([Em.Object.create({
        hasMaster: false,
        isInstalled: false,
        checkboxes: Em.A([
          Em.Object.create({
            title: 'l1',
            component: 'name',
            isInstalled: false,
            checked: true
          })
        ])
      })]);
      var obj = Em.Object.create({
        context: {
          name: "name"
        }
      });
      var clientComponents = Em.A([{component_name: "name1"}]);
      controller.set('hosts', hostsObj);
      controller.set('content.clients', clientComponents);
      controller.deselectAllNodes(obj);
      expect(controller.get('hosts')).to.eql(Em.A([Em.Object.create({
        hasMaster: false,
        isInstalled: false,
        checkboxes: Em.A([
          Em.Object.create({
            title: 'l1',
            component: 'name',
            isInstalled: false,
            checked: false
          })
        ])
      })]));
    });
  });

  describe('#renderSlaves()', function () {
    var hostsObj = [{}];

    beforeEach(function() {
      sinon.stub(controller, 'selectRecommendedComponents');
      sinon.stub(controller, 'setInstalledComponents');
      sinon.stub(controller, 'restoreComponentsSelection');
      sinon.stub(controller, 'selectClientHost');
    });

    afterEach(function() {
      controller.selectRecommendedComponents.restore();
      controller.setInstalledComponents.restore();
      controller.restoreComponentsSelection.restore();
      controller.selectClientHost.restore();
    });

    describe("slaveComponents is null", function() {

      beforeEach(function() {
        controller.set('content.slaveComponentHosts', null);
      });

      it("selectRecommendedComponents should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectRecommendedComponents.calledWith(hostsObj)).to.be.true;
      });
      it("setInstalledComponents should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.setInstalledComponents.calledWith(hostsObj)).to.be.true;
      });
      it("restoreComponentsSelection should not be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.restoreComponentsSelection.called).to.be.false;
      });
      it("selectClientHost should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectClientHost.calledWith(hostsObj)).to.be.true;
      });
    });

    describe("slaveComponents is defined", function() {

      var slaveComponentHosts = [{}];

      beforeEach(function() {
        controller.set('content.slaveComponentHosts', slaveComponentHosts);
      });

      it("selectRecommendedComponents should not be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectRecommendedComponents.called).to.be.false;
      });
      it("setInstalledComponents should not be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.setInstalledComponents.called).to.be.false;
      });
      it("restoreComponentsSelection should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.restoreComponentsSelection.calledWith(hostsObj, slaveComponentHosts)).to.be.true;
      });
      it("selectClientHost should be called", function() {
        expect(controller.renderSlaves(hostsObj)).to.eql(hostsObj);
        expect(controller.selectClientHost.calledWith(hostsObj)).to.be.true;
      });
    });
  });

  describe("#setInstalledComponents()", function() {
    var hostsObj = [{
      hostName: 'host1',
      checkboxes: [
        {
          component: 'C1',
          isInstalled: false
        },
        {
          component: 'C2',
          isInstalled: false
        }
      ]
    }];

    it("installedHosts is null", function() {
      controller.set('content.installedHosts', null);
      expect(controller.setInstalledComponents(hostsObj)).to.be.false;
    });

    it("installedHosts is defined", function() {
      controller.set('content.installedHosts', {
        'host1': {
          hostComponents: [
            {
              HostRoles: {
                component_name: 'C1'
              }
            }
          ]
        }
      });
      controller.setInstalledComponents(hostsObj);
      expect(hostsObj[0].checkboxes[0].isInstalled).to.be.true;
      expect(hostsObj[0].checkboxes[1].isInstalled).to.be.false;
    });
  });

  describe("#restoreComponentsSelection()", function() {
    var getHostsObj = function() {
      return [{
        hostName: 'host1',
        checkboxes: [
          {
            component: 'C1',
            title: 'c1',
            isInstalled: false,
            checked: false
          },
          {
            component: 'C2',
            title: 'c1',
            isInstalled: true,
            checked: false
          },
          {
            component: 'C3',
            title: 'c3',
            isInstalled: false,
            checked: false
          }
        ]
      }];
    };

    var slaveComponents = [
      {
        componentName: 'C1',
        hosts: [{hostName: 'host1', isInstalled: true}]
      }
    ];

    beforeEach(function() {
      controller.set('headers', [
        Em.Object.create({
          name: 'C1',
          label: 'c1'
        }),
        Em.Object.create({
          name: 'C2',
          label: 'c2'
        }),
        Em.Object.create({
          name: 'C3',
          label: 'c3'
        })
      ]);
    });

    it("C1 components should be checked and installed", function() {
      var hostsObj = getHostsObj();
      controller.restoreComponentsSelection(hostsObj, slaveComponents);
      expect(hostsObj[0].checkboxes[0].isInstalled).to.be.true;
      expect(hostsObj[0].checkboxes[0].checked).to.be.true;
    });
    it("C2 components should not be checked and should be installed", function() {
      var hostsObj = getHostsObj();
      controller.restoreComponentsSelection(hostsObj, slaveComponents);
      expect(hostsObj[0].checkboxes[1].isInstalled).to.be.true;
      expect(hostsObj[0].checkboxes[1].checked).to.be.false;
    });
    it("C3 components should not be checked and should not be installed", function() {
      var hostsObj = getHostsObj();
      controller.restoreComponentsSelection(hostsObj, slaveComponents);
      expect(hostsObj[0].checkboxes[2].isInstalled).to.be.false;
      expect(hostsObj[0].checkboxes[2].checked).to.be.false;
    });
  });

  describe("#selectRecommendedComponents()", function() {

    var hostsObj = [{
      hostName: 'host1',
      checkboxes: [
        {
          component: 'C1',
          checked: false
        },
        {
          component: 'C2',
          checked: false
        },
        {
          component: 'CLIENT',
          checked: false
        }
      ]
    }];

    var recommendations = {
      blueprint: {
        host_groups: [
          {
            name: 'g1',
            components: [
              {name: 'C1'},
              {name: 'C_CLIENT'}
            ]
          }
        ]
      },
      blueprint_cluster_binding: {
        host_groups: [
          {
            name: 'g1',
            hosts: [{fqdn: 'host1'}]
          }
        ]
      }
    };

    beforeEach(function() {
      sinon.stub(App, 'get').returns(['C_CLIENT']);
    });

    afterEach(function() {
      App.get.restore();
    });

    it("C1 should be checked", function() {
      controller.set('content.recommendations', recommendations);
      controller.selectRecommendedComponents(hostsObj);
      expect(hostsObj[0].checkboxes[0].checked).to.be.true;
    });

    it("C2 should not be checked", function() {
      controller.set('content.recommendations', recommendations);
      controller.selectRecommendedComponents(hostsObj);
      expect(hostsObj[0].checkboxes[1].checked).to.be.false;
    });

    it("CLIENT should be checked", function() {
      controller.set('content.recommendations', recommendations);
      controller.selectRecommendedComponents(hostsObj);
      expect(hostsObj[0].checkboxes[2].checked).to.be.true;
    });
  });

  describe('#anyGeneralErrors', function () {
    beforeEach(function () {
      controller.set('errorMessage', undefined);
    });
    it('should return errorMessage', function () {
      controller.set('errorMessage', "error 404");
      expect(controller.get('anyGeneralErrors')).to.equal("error 404");
    });
    it('true if generalErrorMessages is non empty array and errorMessage is undefined', function () {
      controller.set('generalErrorMessages', ["error1", "error2"]);
      expect(controller.get('anyGeneralErrors')).to.equal(true);
    });
    it('false if generalErrorMessages is empty array and errorMessage is undefined', function () {
      controller.set('generalErrorMessages', []);
      expect(controller.get('anyGeneralErrors')).to.equal(false);
    });
    it('undefined if generalErrorMessages is undefined and errorMessage is undefined', function () {
      controller.set('generalErrorMessages', undefined);
      expect(controller.get('anyGeneralErrors')).to.equal(undefined);
    });
  });

  describe('#render', function () {
    it('true if loaded', function () {
      var hosts = {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'REGISTERED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
      };
      var headers = Em.A([
        Em.Object.create({name: "c1", label: 'l1', isDisabled: true}),
        Em.Object.create({name: "c2", label: 'l2', isDisabled: false})
      ]);
      var masterComponentHosts = Em.A([
        {hostName: 'h1', component: 'c1'}
      ]);
      var recommendations = {
        blueprint: {
          host_groups: [
            {
              components: [
                {
                  name: 'c6'
                }
              ],
              name: 'host-group-1'
            },
            {
              components: [
                {
                  name: 'c8'
                }
              ],
              name: 'host-group-2'
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              hosts: [
                {
                  fqdn: 'h0'
                }
              ],
              name: 'host-group-1'
            },
            {
              hosts: [
                {
                  fqdn: 'h1'
                }
              ],
              name: 'host-group-2'
            }]
        }
      };
      controller.set('content.hosts', hosts);
      controller.set('content.masterComponentHosts', masterComponentHosts);
      controller.set('content.recommendations', recommendations)
      controller.set('headers', headers);
      controller.render();
      expect(controller.get('isLoaded')).to.equal(true);
    });
  });

  describe('#anyGeneralWarnings', function () {
    it('true if generalWarningMessages is non empty array and warningMessage is undefined', function () {
      controller.set('generalWarningMessages', ["warning1", "warning2"]);
      expect(controller.get('anyGeneralWarnings')).to.equal(true);
    });
    it('false if generalWarningMessages is empty array', function () {
      controller.set('generalWarningMessages', []);
      expect(controller.get('anyGeneralWarnings')).to.equal(false);
    });
    it('undefined if generalWarningMessages is undefined', function () {
      controller.set('generalWarningMessages', undefined);
      expect(controller.get('anyGeneralWarnings')).to.equal(undefined);
    });
  });

  describe('#anyGeneralIssues', function () {
    it('should return error message if errorMessage', function () {
      controller.set('errorMessage', "error 404");
      expect(controller.get('anyGeneralIssues')).to.equal("error 404");
    });
    it('should return true if we have several errors', function () {
      controller.set('generalErrorMessages', ["error 404", "error"]);
      expect(controller.get('anyGeneralIssues')).to.equal(true);
    });
    it('should return true if we have several warnings', function () {
      controller.set('generalWarningMessages', ["error 404", "error"]);
      expect(controller.get('anyGeneralIssues')).to.equal(true);
    });
  });

  describe('#anyErrors', function () {
    it('true if generalErrorMessages is non empty', function () {
      controller.set('generalErrorMessages', ["error 404", "error"]);
      expect(controller.get('anyErrors')).to.equal(true);
    });
    it('false if generalErrorMessages is empty', function () {
      controller.set('generalErrorMessages', []);
      expect(controller.get('anyErrors')).to.equal(false);
    });
  });

  describe('#anyWarnings', function () {
    it('true if generalWarningMessages is non empty', function () {
      controller.set('generalWarningMessages', ["error 404", "error"]);
      expect(controller.get('anyWarnings')).to.equal(true);
    });
    it('false if generalWarningMessages is empty', function () {
      controller.set('generalWarningMessages', []);
      expect(controller.get('anyWarnings')).to.equal(false);
    });
  });

  describe('#isInstallerWizard', function () {
    it('true if content.controllerName is addHostController', function () {
      controller.set('content.controllerName', 'installerController');
      expect(controller.get('isInstallerWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addHostController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isInstallerWizard')).to.equal(false);
    });
  });

  describe('#isAddServiceWizard', function () {
    it('true if content.controllerName is addServiceController', function () {
      controller.set('content.controllerName', 'addServiceController');
      expect(controller.get('isAddServiceWizard')).to.equal(true);
    });
    it('false if content.controllerName is not addServiceController', function () {
      controller.set('content.controllerName', 'mainController');
      expect(controller.get('isAddServiceWizard')).to.equal(false);
    });
  });

  describe('#selectClientHost', function () {
    it('true if isClientsSet false', function () {
      var hostsObj = Em.A([Em.Object.create({
        hasMaster: false,
        checkboxes: Em.A([
          Em.Object.create({
            component: 'c1',
            isInstalled: false,
            checked: true
          })
        ])
      })]);
      controller.set('isClientsSet', false);
      controller.selectClientHost(hostsObj);
      expect(controller.get('isClientsSet')).to.equal(true);
    });
  });

  describe('#updateValidationsSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(validationUtils, 'filterNotInstalledComponents', function () {
        return  Em.A([Em.Object.create({
              componentName: 'c0',
              isSlave: true,
              type: 'host-component',
              level: 'ERROR'
            }),
            Em.Object.create({
              componentName: 'c1',
              isSlave: true,
              type: 'host-component',
              level: 'WARN',
              isShownOnInstallerSlaveClientPage: true
          })]);
      });
      sinon.stub(App.StackServiceComponent, 'find', function () {
          return [
            Em.Object.create({
              componentName: 'c0',
              isSlave: true
            }),
            Em.Object.create({
              componentName: 'c1',
              isSlave: true,
              isShownOnInstallerSlaveClientPage: true
            }),
            Em.Object.create({
              componentName: 'c2',
              isSlave: true,
              isShownOnInstallerSlaveClientPage: false
            }),
            Em.Object.create({
              componentName: 'c3',
              isClient: true
            }),
            Em.Object.create({
              componentName: 'c4',
              isClient: true,
              isRequiredOnAllHosts: false
            }),
            Em.Object.create({
              componentName: 'c5',
              isClient: true,
              isRequiredOnAllHosts: true
            }),
            Em.Object.create({
              componentName: 'c6',
              isMaster: true,
              isShownOnInstallerAssignMasterPage: true
            }),
            Em.Object.create({
              componentName: 'c7',
              isMaster: true,
              isShownOnInstallerAssignMasterPage: false
            }),
            Em.Object.create({
              componentName: 'HDFS_CLIENT',
              isMaster: true,
              isShownOnAddServiceAssignMasterPage: true
            }),
            Em.Object.create({
              componentName: 'c9',
              isMaster: true,
              isShownOnAddServiceAssignMasterPage: false
            })
          ];
        });
    });
    afterEach(function () {
      App.StackServiceComponent.find.restore();
      validationUtils.filterNotInstalledComponents.restore();
    });
    it('should return modified hosts', function () {
      var hosts = Em.A([Em.Object.create({
        warnMessages: "warn",
        errorMessages: "error",
        anyMessage: true,
        checkboxes: Em.A([Em.Object.create({
          hasWarnMessage: true,
          hasErrorMessage: true
        })])
      })]);
      controller.set('hosts', hosts);
      var validationData = Em.Object.create({
          resources: Em.A([
            Em.Object.create({
              items: Em.A([
                Em.Object.create({
                  "component-name": 'HDFS_CLIENT',
                  host: "1",
                  isMaster: true
                })
              ])
            })
          ])
      })
      controller.updateValidationsSuccessCallback(validationData);
      expect(controller.get('generalErrorMessages').length).to.equal(0);
      expect(controller.get('generalWarningMessages').length).to.equal(0);
      expect(JSON.parse(JSON.stringify(controller.get('hosts')))).to.eql(JSON.parse(JSON.stringify(Em.A([Em.Object.create({
        warnMessages: [null],
        errorMessages: [null],
        anyMessage: true,
        checkboxes: Em.A([Em.Object.create({
          hasWarnMessage: true,
          hasErrorMessage: true
        })])
      })]))));
    });
  });

  describe('#clearError', function () {
    it('true if is one of checkboxes checked false', function () {
      var hosts = Em.A([
        Em.Object.create({
          checkboxes: Em.A([
            Em.Object.create({
              component: 'c1',
              isInstalled: false,
              checked: true
            }),
            Em.Object.create({
              component: 'c2',
              isInstalled: false,
              checked: true
            })])
        })
      ]);
      var headers = Em.A([
        Em.Object.create({name: "c1"}),
        Em.Object.create({name: "c2"})]);
      controller.set('errorMessage', 'error');
      controller.set('hosts', hosts);
      controller.set('headers', headers);
      controller.clearError();
      expect(controller.get('errorMessage')).to.equal('');
    });
    it('true if is one of checkboxes checked false', function () {
      var hosts = Em.A([
        Em.Object.create({
          checkboxes: Em.A([
            Em.Object.create({
              title: "t1",
              component: 'c1',
              isInstalled: false,
              checked: false
            }),
            Em.Object.create({
              title: "t2",
              component: 'c2',
              isInstalled: false,
              checked: true
            })])
        })
      ]);
      var headers = Em.A([
        Em.Object.create({name: "c1", label: 't1'}),
        Em.Object.create({name: "c2", label: 't2'})]);
      controller.set('errorMessage', 'error');
      controller.set('hosts', hosts);
      controller.set('headers', headers);
      controller.set('isAddHostWizard', true);
      controller.clearError();
      expect(controller.get('errorMessage')).to.equal('error');
    });
  });

  describe('#clearStep', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.clearStep();
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    it('should clear hosts', function () {
      controller.set('hosts', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('hosts')).to.eql([]);
    });
    it('should clear headers', function () {
      controller.set('headers', [
        {},
        {}
      ]);
      controller.clearStep();
      expect(controller.get('headers')).to.eql([]);
    });
    it('should set isLoaded to false', function () {
      controller.set('isLoaded', true);
      controller.clearStep();
      expect(controller.get('isLoaded')).to.equal(false);
    });
  });

  describe('#checkCallback', function () {
    beforeEach(function () {
      sinon.stub(controller, 'clearError', Em.K);
    });
    afterEach(function () {
      controller.clearError.restore();
    });
    it('should call clearError', function () {
      controller.checkCallback('');
      expect(controller.clearError.calledOnce).to.equal(true);
    });
    Em.A([
        {
          m: 'all checked, isInstalled false',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: false
          }
        },
        {
          m: 'all checked, isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'no one checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        },
        {
          m: 'some checked',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: false
          }
        },
        {
          m: 'some checked, some isInstalled true',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: true,
            noChecked: true
          }
        },
        {
          m: 'some checked, some isInstalled true (2)',
          headers: Em.A([
            Em.Object.create({name: 'c1'})
          ]),
          hosts: Em.A([
            Em.Object.create({
              checkboxes: Em.A([
                Em.Object.create({
                  component: 'c1',
                  isInstalled: false,
                  checked: false
                }),
                Em.Object.create({
                  component: 'c1',
                  isInstalled: true,
                  checked: true
                })
              ])
            })
          ]),
          component: 'c1',
          e: {
            allChecked: false,
            noChecked: true
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          controller.clearStep();
          controller.set('headers', test.headers);
          controller.set('hosts', test.hosts);
          controller.checkCallback(test.component);
          var header = controller.get('headers').findProperty('name', test.component);
          expect(header.get('allChecked')).to.equal(test.e.allChecked);
          expect(header.get('noChecked')).to.equal(test.e.noChecked);
        });
      });
  });

  describe('#getHostNames', function () {
    var tests = Em.A([
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'REGISTERED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'All REGISTERED',
        e: ['h1', 'h2', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'REGISTERED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'REGISTERED', name: 'h3'}
        },
        m: 'Some REGISTERED',
        e: ['h1', 'h3']
      },
      {
        hosts: {
          h1: {bootStatus: 'FAILED', name: 'h1'},
          h2: {bootStatus: 'FAILED', name: 'h2'},
          h3: {bootStatus: 'FAILED', name: 'h3'}
        },
        m: 'No one REGISTERED',
        e: []
      },
      {
        hosts: {},
        m: 'Empty hosts',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.hosts', test.hosts);
        var r = controller.getHostNames();
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#getMasterComponentsForHost', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h1',
        m: 'host exists',
        e: ['c1']
      },
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hostName: 'h2',
        m: 'host donesn\'t exists',
        e: []
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.getMasterComponentsForHost(test.hostName);
        expect(r).to.eql(test.e);
      });
    });
  });

  describe('#selectMasterComponents', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c1'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: true,
        m: 'host and component exist'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h1',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host exists'
      },
      {
        masterComponentHosts: Em.A([
          {
            hostName: 'h2',
            component: 'c2'
          }
        ]),
        hostsObj: [
          Em.Object.create({
            hostName: 'h1',
            checkboxes: [
              Em.Object.create({
                component: 'c1',
                checked: false
              })
            ]
          })
        ],
        e: false,
        m: 'host and component don\'t exist'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        var r = controller.selectMasterComponents(test.hostsObj);
        expect(r.findProperty('hostName', 'h1').get('checkboxes').findProperty('component', 'c1').get('checked')).to.equal(test.e);
      });
    });
  });

  describe('#getCurrentMastersBlueprint', function () {
    var tests = Em.A([
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'}
        ]),
        hosts: {'h1': {}},
        m: 'one host and one component',
        e:{
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  { fqdn: 'h1' }
                ]
              }
            ]
          }
        }
      },
      {
        masterComponentHosts: Em.A([
          {hostName: 'h1', component: 'c1'},
          {hostName: 'h2', component: 'c2'},
          {hostName: 'h2', component: 'c3'}
        ]),
        hosts: {'h1': {}, 'h2': {}, 'h3': {}},
        m: 'multiple hosts and multiple components',
        e: {
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' }
                ]
              },
              {
                name: 'host-group-2',
                components: [
                  { name: 'c2' },
                  { name: 'c3' }
                ]
              },
              {
                name: 'host-group-3',
                components: []
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  { fqdn: 'h1' }
                ]
              },
              {
                name: 'host-group-2',
                hosts: [
                  { fqdn: 'h2' }
                ]
              },
              {
                name: 'host-group-3',
                hosts: [
                  { fqdn: 'h3' }
                ]
              }
            ]
          }
        }
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.masterComponentHosts', test.masterComponentHosts);
        controller.set('content.hosts', test.hosts);
        var r = controller.getCurrentMastersBlueprint();
        expect(r).to.eql(test.e);
      });
    });
  });

describe('#getCurrentBlueprint', function () {
    var tests = Em.A([
      {
        clientComponents: Em.A([{component_name: "name1"}]),
        hosts: Em.A([
          Em.Object.create({
            checkboxes: Em.A([
              Em.Object.create({
                component: 'c1',
                checked: true
              }),
              Em.Object.create({
                component: 'CLIENT',
                checked: true
              })
            ])
          })
        ]),
        m: 'one host and one component',
        e:{
          blueprint: {
            host_groups: [
              {
                name: 'host-group-1',
                components: [
                  { name: 'c1' },
                  { name: 'name1' }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: 'host-group-1',
                hosts: [
                  {}
                ]
              }
            ]
          }
        }
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        controller.set('content.clients', test.clientComponents);
        controller.set('hosts', test.hosts);
        var r = controller.getCurrentBlueprint();
        expect(JSON.parse(JSON.stringify(r))).to.eql(JSON.parse(JSON.stringify(test.e)));
      });
    });
  });

  describe('#callServerSideValidation', function () {

    var cases = [
        {
          controllerName: 'installerController',
          hosts: [
            {
              hostName: 'h0'
            },
            {
              hostName: 'h1'
            }
          ],
          expected: [
            ['c0', 'c6'],
            ['c1', 'c3', 'c8']
          ]
        },
        {
          controllerName: 'addServiceController',
          hosts: [
            {
              hostName: 'h0'
            },
            {
              hostName: 'h1'
            }
          ],
          expected: [
            ['c0', 'c6'],
            ['c1', 'c3', 'c8']
          ]
        },
        {
          controllerName: 'addHostController',
          hosts: [
            {
              hostName: 'h0'
            }
          ],
          expected: [
            ['c0', 'c2', 'c5', 'c6'],
            ['c1', 'c2', 'c3', 'c5', 'c8']
          ]
        }
      ],
      expectedHostGroups = [
        {
          name: 'host-group-1',
          fqdn: 'h0'
        },
        {
          name: 'host-group-2',
          fqdn: 'h1'
        }
      ];

    beforeEach(function () {
      controller.get('content').setProperties({
        recommendations: {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c6'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c8'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        },
        clients: [
          {
            component_name: 'c3'
          }
        ]
      });
      sinon.stub(App.StackService, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 's0',
            isSelected: true
          }),
          Em.Object.create({
            serviceName: 's1',
            isInstalled: true,
            isSelected: true
          })
        ];
      });
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return [
          Em.Object.create({
            componentName: 'c0',
            isSlave: true
          }),
          Em.Object.create({
            componentName: 'c1',
            isSlave: true,
            isShownOnInstallerSlaveClientPage: true
          }),
          Em.Object.create({
            componentName: 'c2',
            isSlave: true,
            isShownOnInstallerSlaveClientPage: false
          }),
          Em.Object.create({
            componentName: 'c3',
            isClient: true
          }),
          Em.Object.create({
            componentName: 'c4',
            isClient: true,
            isRequiredOnAllHosts: false
          }),
          Em.Object.create({
            componentName: 'c5',
            isClient: true,
            isRequiredOnAllHosts: true
          }),
          Em.Object.create({
            componentName: 'c6',
            isMaster: true,
            isShownOnInstallerAssignMasterPage: true
          }),
          Em.Object.create({
            componentName: 'c7',
            isMaster: true,
            isShownOnInstallerAssignMasterPage: false
          }),
          Em.Object.create({
            componentName: 'c8',
            isMaster: true,
            isShownOnAddServiceAssignMasterPage: true
          }),
          Em.Object.create({
            componentName: 'c9',
            isMaster: true,
            isShownOnAddServiceAssignMasterPage: false
          })
        ];
      });
      sinon.stub(controller, 'getCurrentBlueprint', function () {
        return {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c1'
                  },
                  {
                    name: 'c3'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        };
      });
      sinon.stub(controller, 'getCurrentMastersBlueprint', function () {
        return {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c6'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c8'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        };
      });
      sinon.stub(App, 'get').withArgs('components.clients').returns(['c3', 'c4']);
      sinon.stub(controller, 'getCurrentMasterSlaveBlueprint', function () {
        return {
          blueprint: {
            host_groups: [
              {
                components: [
                  {
                    name: 'c6'
                  }
                ],
                name: 'host-group-1'
              },
              {
                components: [
                  {
                    name: 'c8'
                  }
                ],
                name: 'host-group-2'
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                hosts: [
                  {
                    fqdn: 'h0'
                  }
                ],
                name: 'host-group-1'
              },
              {
                hosts: [
                  {
                    fqdn: 'h1'
                  }
                ],
                name: 'host-group-2'
              }]
          }
        };
      });
      sinon.stub(App.Host, 'find', function () {
        return [
          {
            hostName: 'h1'
          }
        ];
      });
      sinon.stub(App.ajax, 'send', function () {
        return {
          then: Em.K
        };
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
      App.StackServiceComponent.find.restore();
      controller.getCurrentBlueprint.restore();
      controller.getCurrentMastersBlueprint.restore();
      App.get.restore();
      controller.getCurrentMasterSlaveBlueprint.restore();
      App.Host.find.restore();
      App.ajax.send.restore();
    });

    cases.forEach(function (item) {
      it(item.controllerName, function () {
        controller.set('hosts', item.hosts);
        controller.set('content.controllerName', item.controllerName);
        controller.callServerSideValidation();
        expect(controller.get('content.recommendationsHostGroups.blueprint.host_groups.length')).to.equal(expectedHostGroups.length);
        expect(controller.get('content.recommendationsHostGroups.blueprint_cluster_binding.host_groups.length')).to.equal(expectedHostGroups.length);
        controller.get('content.recommendationsHostGroups.blueprint.host_groups').forEach(function (group, index) {
          expect(group.components.mapProperty('name').sort()).to.eql(item.expected[index]);
        });
        expectedHostGroups.forEach(function (group) {
          var bpGroup = controller.get('content.recommendationsHostGroups.blueprint_cluster_binding.host_groups').findProperty('name', group.name);
          expect(bpGroup.hosts).to.have.length(1);
          expect(bpGroup.hosts[0].fqdn).to.equal(group.fqdn);
        });
      });
    });

  });

});

});

;require.register("test/controllers/wizard/step7/pre_install_checks_controller_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var preInstallChecksController;

describe('App.PreInstallChecksController', function () {

  beforeEach(function () {
    preInstallChecksController = App.PreInstallChecksController.create();
  });

  describe('#loadStep', function () {

    beforeEach(function () {
      preInstallChecksController.set('preInstallChecksWhereRun', true);
    });

    it('should set `preInstallChecksWhereRun` to false', function () {
      preInstallChecksController.loadStep();
      expect(preInstallChecksController.get('preInstallChecksWhereRun')).to.be.false;
    });

  });

  describe('#runPreInstallChecks', function () {

    it('should set `preInstallChecksWhereRun` to true', function () {
      preInstallChecksController.runPreInstallChecks();
      expect(preInstallChecksController.get('preInstallChecksWhereRun')).to.be.true;
    });

  });

  describe('#notRunChecksWarnPopup', function () {

    it('should throw error', function () {
      expect(function () {
        preInstallChecksController.notRunChecksWarnPopup()
      }).to.throw('`afterChecksCallback` should be a function');
    });

    describe('popup', function () {

      var popup;

      beforeEach(function () {
        popup = preInstallChecksController.notRunChecksWarnPopup(Em.K);
        sinon.spy(preInstallChecksController, 'runPreInstallChecks');
      });

      afterEach(function () {
        preInstallChecksController.runPreInstallChecks.restore();
      });

      it('#onPrimary', function (done) {
        preInstallChecksController.notRunChecksWarnPopup(done).onPrimary();
      });

      it('#onSecondary', function () {
        popup.onSecondary();
        expect(preInstallChecksController.runPreInstallChecks.calledOnce).to.be.true;
      });

    });

  });

});
});

;require.register("test/controllers/wizard/step7_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var numberUtils = require('utils/number_utils');
require('mixins/common/localStorage');
require('models/config_group');
require('controllers/wizard/step7_controller');

var installerStep7Controller,
  issuesFilterCases = [
    {
      isSubmitDisabled: true,
      submitButtonClicked: true,
      isIssuesFilterActive: true,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showAllProperties'),
      title: 'issues filter on, submit button clicked'
    },
    {
      isSubmitDisabled: true,
      submitButtonClicked: false,
      isIssuesFilterActive: true,
      issuesFilterText: Em.I18n.t('installer.step7.showingPropertiesWithIssues'),
      issuesFilterLinkText: Em.I18n.t('installer.step7.showAllProperties'),
      title: 'issues filter on, submit button disabled'
    },
    {
      isSubmitDisabled: true,
      submitButtonClicked: true,
      isIssuesFilterActive: false,
      issuesFilterText: '',
      issuesFilterLinkText: '',
      title: 'issues filter off, submit button clicked'
    },
    {
      isSubmitDisabled: true,
      submitButtonClicked: false,
      isIssuesFilterActive: false,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showPropertiesWithIssues'),
      title: 'issues filter off, submit button disabled'
    },
    {
      isSubmitDisabled: false,
      submitButtonClicked: false,
      isIssuesFilterActive: true,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showAllProperties'),
      title: 'issues filter on, submit button enabled'
    },
    {
      isSubmitDisabled: false,
      submitButtonClicked: false,
      isIssuesFilterActive: false,
      issuesFilterText: '',
      issuesFilterLinkText: '',
      title: 'issues filter off, submit button enabled'
    },
    {
      isSubmitDisabled: false,
      submitButtonClicked: false,
      isIssuesFilterActive: true,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showAllProperties'),
      title: 'issues filter on, submit button not clicked but active'
    },
    {
      isSubmitDisabled: false,
      submitButtonClicked: true,
      isIssuesFilterActive: true,
      issuesFilterText: '',
      issuesFilterLinkText: Em.I18n.t('installer.step7.showAllProperties'),
      title: 'issues filter on, submit button clicked and active'
    }
  ],
  issuesFilterTestSetup = function (controller, testCase) {
    controller.set('submitButtonClicked', testCase.submitButtonClicked);
    controller.reopen({
      isSubmitDisabled: testCase.isSubmitDisabled
    });
    controller.get('filterColumns').findProperty('attributeName', 'hasIssues').set('selected', testCase.isIssuesFilterActive);
  };

describe('App.InstallerStep7Controller', function () {

  beforeEach(function () {
    sinon.stub(App.config, 'setPreDefinedServiceConfigs', Em.K);
    installerStep7Controller = App.WizardStep7Controller.create({
      content: Em.Object.create({
        advancedServiceConfig: [],
        serviceConfigProperties: []
      })
    });
  });

  afterEach(function() {
    App.config.setPreDefinedServiceConfigs.restore();
  });

  describe('#installedServiceNames', function () {

    var tests = Em.A([
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'SQOOP'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['SQOOP', 'HDFS'],
        m: 'installerController with SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'installerController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'installerController without SQOOP'
      },
      {
        content: Em.Object.create({
          controllerName: 'addServiceController',
          services: Em.A([
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HIVE'
            }),
            Em.Object.create({
              isInstalled: true,
              serviceName: 'HDFS'
            })
          ])
        }),
        e: ['HIVE', 'HDFS'],
        m: 'addServiceController without SQOOP'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep7Controller.set('content', test.content);
        expect(installerStep7Controller.get('installedServiceNames')).to.include.members(test.e);
        expect(test.e).to.include.members(installerStep7Controller.get('installedServiceNames'));
      });
    });

  });

  describe('#isSubmitDisabled', function () {
    it('should be true if miscModalVisible', function () {
      installerStep7Controller.reopen({miscModalVisible: true});
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be true if some of stepConfigs has errors', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 1
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(true);
    });
    it('should be false if all of stepConfigs don\'t have errors and miscModalVisible is false', function () {
      installerStep7Controller.reopen({
        miscModalVisible: false,
        stepConfigs: [
          {
            showConfig: true,
            errorCount: 0
          }
        ]
      });
      expect(installerStep7Controller.get('isSubmitDisabled')).to.equal(false);
    });
  });

  describe('#selectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          {isSelected: true, isInstalled: false, serviceName: 's1'},
          {isSelected: false, isInstalled: false, serviceName: 's2'},
          {isSelected: true, isInstalled: true, serviceName: 's3'},
          {isSelected: false, isInstalled: false, serviceName: 's4'},
          {isSelected: true, isInstalled: false, serviceName: 's5'},
          {isSelected: false, isInstalled: false, serviceName: 's6'},
          {isSelected: true, isInstalled: true, serviceName: 's7'},
          {isSelected: false, isInstalled: false, serviceName: 's8'}
        ]
      });
      var expected = ['s1', 's5'];
      expect(installerStep7Controller.get('selectedServiceNames')).to.eql(expected);
    });
  });

  describe('#allSelectedServiceNames', function () {
    it('should use content.services as source of data', function () {
      installerStep7Controller.set('content', {
        services: [
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's1'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's2'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's3'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's4'}),
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's5'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's6'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's7'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's8'})
        ]
      });
      var expected = ['s1', 's3', 's5', 's7'];
      expect(installerStep7Controller.get('allSelectedServiceNames')).to.eql(expected);
    });
  });

  describe('#masterComponentHosts', function () {
    it('should be equal to content.masterComponentHosts', function () {
      var masterComponentHosts = [
        {},
        {},
        {}
      ];
      installerStep7Controller.reopen({content: {masterComponentHosts: masterComponentHosts}});
      expect(installerStep7Controller.get('masterComponentHosts')).to.eql(masterComponentHosts);
    });
  });

  describe('#slaveComponentHosts', function () {
    it('should be equal to content.slaveGroupProperties', function () {
      var slaveGroupProperties = [
        {},
        {},
        {}
      ];
      installerStep7Controller.reopen({content: {slaveGroupProperties: slaveGroupProperties}});
      expect(installerStep7Controller.get('slaveComponentHosts')).to.eql(slaveGroupProperties);
    });
  });

  describe('#_createSiteToTagMap', function () {
    it('should return filtered map', function () {
      var desired_configs = {
        site1: {
          tag: "tag1"
        },
        site2: {
          tag: "tag2"
        },
        site3: {
          tag: "tag3"
        }
      };
      var sites = {
        site1: true,
        site3: true
      };
      var siteToTagMap = installerStep7Controller._createSiteToTagMap(desired_configs,sites)
      expect(siteToTagMap).to.eql({
        site1: "tag1",
        site3: "tag3"
      });
    });
  });

  describe('#checkDatabaseConnectionTest', function () {
    it('should return promise in process', function () {
      installerStep7Controller.set('content', {
        services: Em.A([
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 'OOZIE', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 'HIVE', ignored: []}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's3', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's4', ignored: []}),
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's5', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's6', ignored: []}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's7', ignored: []}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's8', ignored: []})
        ])
      });
      var obj = Em.Object.create({name:'oozie_database',value:"aa"});
      installerStep7Controller.set('stepConfigs',Em.A([Em.Object.create({serviceName: 'OOZIE', configs: Em.A([obj]) })]));
      var deffer = installerStep7Controller.checkDatabaseConnectionTest();
      expect(deffer.isResolved()).to.equal(false);
      deffer.resolve(true);
      deffer.done(function(data) {
        expect(data).to.equal(true);
      });
    });
  });

  describe.skip('#submit', function () {

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('supports.preInstallChecks').returns(false);
    });

    afterEach(function () {
      App.get.restore();
    });

    it('should return false if submit disabled', function () {
      installerStep7Controller.set('isSubmitDisabled',true);
      expect(installerStep7Controller.submit()).to.be.false;
    });
    it('sumbit button should be unclicked if no configs', function () {
      installerStep7Controller.set('isSubmitDisabled',false);
      installerStep7Controller.submit();
      expect(installerStep7Controller.get('submitButtonClicked')).to.be.false;
    });
  });

  describe('#activateSpecialConfigs', function () {
    var expected = [{
       "smokeuser": {
         "isEditable": true
       },
       "group": {
         "isEditable": true
       },
       "services": [
         {
           "serviceName": "s1",
           "isSelected": true,
           "isInstalled": false
         },
         {
           "serviceName": "s2",
           "isSelected": false,
           "isInstalled": false
         },
         {
           "serviceName": "s3",
           "isSelected": true,
           "isInstalled": true
         },
         {
           "serviceName": "s4",
           "isSelected": false,
           "isInstalled": false
         },
         {
           "serviceName": "s5",
           "isSelected": true,
           "isInstalled": false
         },
         {
           "serviceName": "s6",
           "isSelected": false,
           "isInstalled": false
         },
         {
           "serviceName": "s7",
           "isSelected": true,
           "isInstalled": true
         },
         {
           "serviceName": "s8",
           "isSelected": false,
           "isInstalled": false
         }
       ]
      },[
        {
          "serviceName": "MISC",
          "configs": [
            {
              "name": "smokeuser",
              "value": {
                "isEditable": true
              },
              "isEditable": false
            },
            {
              "name": "user_group",
              "value": {
                "isEditable": true
              },
              "isEditable": false
            },
            {
              "name": "kdc_type"
            }
          ]
        },
        {
          "serviceName": "KERBEROS",
          "configs": [
            {
              "name": "smokeuser",
              "value": {
                "isEditable": true
              },
              "isEditable": false
            },
            {
              "name": "user_group",
              "value": {
                "isEditable": true
              },
              "isEditable": false
            },
            {
              "name": "kdc_type"
            }
          ]
        }
      ]];
      var allSelectedServiceNames = ['SLIDER', 'YARN'];
      var configs = Em.A([Em.Object.create({
        name: 'smokeuser',
        value: ''
      }),Em.Object.create({
        name: 'user_group',
        value: ''
      }),Em.Object.create({
        name: 'kdc_type',
        value: ''
      })]);
      var stepConfigs = Em.A([Em.Object.create({serviceName: 'MISC', configs: configs}),
                              Em.Object.create({serviceName: 'KERBEROS', configs: configs})]);
      var content = Em.Object.create({
        smokeuser: Em.Object.create({isEditable: true}),
        group: Em.Object.create({isEditable: true}),
        services: Em.A([
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's1'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's2'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's3'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's4'}),
          Em.Object.create({isSelected: true, isInstalled: false, serviceName: 's5'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's6'}),
          Em.Object.create({isSelected: true, isInstalled: true, serviceName: 's7'}),
          Em.Object.create({isSelected: false, isInstalled: false, serviceName: 's8'})
        ])
      });
    it('should return configs with true value', function () {
      installerStep7Controller.set('wizardController', Em.Object.create(App.LocalStorage, {name: 'addServiceController'}));
      installerStep7Controller.set('addMiscTabToPage',true);
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.set('stepConfigs', stepConfigs);
      installerStep7Controller.set('content', content);
      installerStep7Controller.activateSpecialConfigs();
      expect(JSON.parse(JSON.stringify(installerStep7Controller.get('content')))).to.be.eql(expected[0]);
    });
    it('should return stepsConfigs with true value', function () {
      installerStep7Controller.set('wizardController', Em.Object.create(App.LocalStorage, {name: 'kerberosWizardController'}));
      installerStep7Controller.set('addMiscTabToPage',true);
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.set('stepConfigs', stepConfigs);
      installerStep7Controller.set('content', content);
      installerStep7Controller.activateSpecialConfigs();
      expect(JSON.parse(JSON.stringify(installerStep7Controller.get('stepConfigs')))).to.be.eql(expected[1]);
    });
  });

  describe('#getConfigTagsSuccess', function () {
    beforeEach(function(){
      sinon.stub(App.StackService, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 's0',
            isInstalled: true,
            configTypes: {
              site3: true,
              site1: true
            }
          }),
          Em.Object.create({
            serviceName: 's1',
            isInstalled: true,
            configTypes: {
              site1: true,
              site2: true
            }
          })
        ];
      });
    });
    afterEach(function(){
      App.StackService.find.restore();
    });

    it('should return serviceConfigTags', function () {
      var desired_configs = {
        site1: {
          tag: "tag1"
        },
        site2: {
          tag: "tag2"
        },
        site3: {
          tag: "tag3"
        }
      };
      var data = {
        Clusters: {
          desired_configs: desired_configs
        }
      };
      var siteToTagMap = installerStep7Controller.getConfigTagsSuccess(data)
      expect(installerStep7Controller.get('serviceConfigTags')).to.eql([
        {
          "siteName": "site1",
          "tagName": "tag1",
          "newTagName": null
        },
        {
          "siteName": "site2",
          "tagName": "tag2",
          "newTagName": null
        },
        {
          "siteName": "site3",
          "tagName": "tag3",
          "newTagName": null
        }
      ]);
      expect(installerStep7Controller.get('isAppliedConfigLoaded')).to.equal(true);
    });
  });

  describe('#clearStep', function () {
    it('should clear stepConfigs', function () {
      installerStep7Controller.set('stepConfigs', [
        {},
        {}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('stepConfigs.length')).to.equal(0);
    });
    it('should clear filter', function () {
      installerStep7Controller.set('filter', 'filter');
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filter')).to.equal('');
    });
    it('should set for each filterColumns "selected" false', function () {
      installerStep7Controller.set('filterColumns', [
        {selected: true},
        {selected: false},
        {selected: true}
      ]);
      installerStep7Controller.clearStep();
      expect(installerStep7Controller.get('filterColumns').everyProperty('selected', false)).to.equal(true);
    });
  });

  describe('#loadInstalledServicesConfigGroups', function () {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it('should do ajax request for each received service name', function () {
      var serviceNames = ['s1', 's2', 's3'];
      installerStep7Controller.loadInstalledServicesConfigGroups(serviceNames);
      expect(App.ajax.send.callCount).to.equal(serviceNames.length);
    });
  });

  describe('#getConfigTags', function () {
    before(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    after(function () {
      App.ajax.send.restore();
    });
    it('should do ajax-request', function () {
      installerStep7Controller.getConfigTags();
      expect(App.ajax.send.calledOnce).to.equal(true);
    });
  });

  describe('#setGroupsToDelete', function () {
    beforeEach(function () {
      installerStep7Controller.set('wizardController', Em.Object.create(App.LocalStorage, {name: 'tdk'}));
    });
    it('should add new groups to groupsToDelete', function () {
      var groupsToDelete = [
          {id: '1'},
          {id: '2'}
        ],
        groups = [
          Em.Object.create({id: '3'}),
          Em.Object.create(),
          Em.Object.create({id: '5'})
        ],
        expected = [
          {id: "1"},
          {id: "2"},
          {id: "3"},
          {id: "5"}
        ];
      installerStep7Controller.set('groupsToDelete', groupsToDelete);
      installerStep7Controller.setGroupsToDelete(groups);
      expect(installerStep7Controller.get('groupsToDelete')).to.eql(expected);
      expect(installerStep7Controller.get('wizardController').getDBProperty('groupsToDelete')).to.eql(expected);
    });
  });

  describe('#checkMySQLHost', function () {
    it('should send query', function () {
      expect(installerStep7Controller.checkMySQLHost().readyState).to.equal(1);
    });
  });

  describe('#selectConfigGroup', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('should set selectedConfigGroup', function () {
      var group = {':': []};
      installerStep7Controller.selectConfigGroup({context: group});
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(group);
    });
  });

  describe('#resolveYarnConfigs', function () {
    it('should set property to true', function () {
      var allSelectedServiceNames = ['SLIDER', 'YARN'],
        configs = [
          {name: 'hadoop.registry.rm.enabled', value: 'false', recommendedValue: 'false'}
        ],
        expected = [
          {name: 'hadoop.registry.rm.enabled', value: 'true', recommendedValue: 'true'}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveYarnConfigs(configs);
      expect(configs[0]).to.eql(expected[0]);
    });

    it('should set property to false', function () {
      var allSelectedServiceNames = ['YARN'],
        configs = [
          {name: 'hadoop.registry.rm.enabled', value: 'true', recommendedValue: 'true'}
        ],
        expected = [
          {name: 'hadoop.registry.rm.enabled', value: 'false', recommendedValue: 'false'}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveYarnConfigs(configs);
      expect(configs[0]).to.eql(expected[0]);
    });

    it('should skip setting property', function () {
      var allSelectedServiceNames = ['YARN', 'SLIDER'],
        configs = [
          {name: 'hadoop.registry.rm.enabled', value: 'true', recommendedValue: 'true'}
        ],
        expected = [
          {name: 'hadoop.registry.rm.enabled', value: 'true', recommendedValue: 'true'}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveYarnConfigs(configs);
      expect(configs[0]).to.eql(expected[0]);
    });
  });

  describe('#resolveStormConfigs', function () {

    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({

          hosts: {'h1': {name: 'host1', id: 'h1'}},
          masterComponentHosts: [{component: 'GANGLIA_SERVER', host_id: 'h1'}],

          getDBProperties: function (keys) {
            return this.getProperties(keys);
          }
        })
      });
    });

    it('shouldn\'t do nothing if Ganglia and Storm are installed', function () {
      var installedServiceNames = ['GANGLIA', 'STORM'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', recommendedValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', recommendedValue: ''}
        ];
      installerStep7Controller.reopen({installedServiceNames: installedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      expect(configs).to.eql(expected);
    });

    it('shouldn\'t do nothing if Ganglia is in allSelectedServiceNames', function () {
      var allSelectedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', recommendedValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=host1', recommendedValue: '.jar=host=host1'},
          {name: 'supervisor.childopts', value: '.jar=host=host1', recommendedValue: '.jar=host=host1'},
          {name: 'worker.childopts', value: '.jar=host=host1', recommendedValue: '.jar=host=host1'}
        ];
      installerStep7Controller.reopen({allSelectedServiceNames: allSelectedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });

    it('shouldn\'t do nothing if Ganglia is in installedServiceNames (2)', function () {
      var installedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', recommendedValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=host1', recommendedValue: '.jar=host=host1'},
          {name: 'supervisor.childopts', value: '.jar=host=host1', recommendedValue: '.jar=host=host1'},
          {name: 'worker.childopts', value: '.jar=host=host1', recommendedValue: '.jar=host=host1'}
        ];
      installerStep7Controller.reopen({installedServiceNames: installedServiceNames});
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });

    it('should replace host name for *.childopts properties if Ganglia is in installedServiceNames for Add Service Wizard', function () {
      var installedServiceNames = ['GANGLIA'],
        configs = [
          {name: 'nimbus.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'supervisor.childopts', value: '.jar=host=host2', recommendedValue: ''},
          {name: 'worker.childopts', value: '.jar=host=host2', recommendedValue: ''}
        ],
        expected = [
          {name: 'nimbus.childopts', value: '.jar=host=realhost1', recommendedValue: '.jar=host=realhost1'},
          {name: 'supervisor.childopts', value: '.jar=host=realhost1', recommendedValue: '.jar=host=realhost1'},
          {name: 'worker.childopts', value: '.jar=host=realhost1', recommendedValue: '.jar=host=realhost1'}
        ];
      installerStep7Controller.reopen({
        installedServiceNames: installedServiceNames,
        wizardController: Em.Object.create({
          name: 'addServiceController',
          masterComponentHosts: [{component: 'GANGLIA_SERVER', hostName: 'realhost1'}],
          getDBProperties: function (keys) {
            return this.getProperties(keys);
          }
        })
      });
      installerStep7Controller.resolveStormConfigs(configs);
      Em.keys(expected[0]).forEach(function (k) {
        expect(configs.mapProperty(k)).to.eql(expected.mapProperty(k));
      });
    });

  });

  describe('#resolveServiceDependencyConfigs', function () {
    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'resolveStormConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'resolveYarnConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.resolveStormConfigs.restore();
      installerStep7Controller.resolveYarnConfigs.restore();
    });
    [
      {serviceName: 'STORM', method: "resolveStormConfigs"},
      {serviceName: 'YARN', method: "resolveYarnConfigs"}
    ].forEach(function(t) {
      it("should call " + t.method + " if serviceName is " + t.serviceName, function () {
        var configs = [
          {},
          {}
        ];
        installerStep7Controller.resolveServiceDependencyConfigs(t.serviceName, configs);
        expect(installerStep7Controller[t.method].calledWith(configs)).to.equal(true);
      });
    });
  });

  describe('#selectedServiceObserver', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({content: {services: []}});
      sinon.stub(installerStep7Controller, 'switchConfigGroupConfigs', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.switchConfigGroupConfigs.restore();
    });
    it('shouldn\'t do nothing if App.supports.hostOverridesInstaller is false', function () {
      App.set('supports.hostOverridesInstaller', false);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService is null', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: null, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('shouldn\'t do nothing if selectedService.serviceName is MISC', function () {
      App.set('supports.hostOverridesInstaller', true);
      var configGroups = [
          {},
          {}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: {serviceName: 'MISC'}, configGroups: configGroups, selectedConfigGroup: selectedConfigGroup});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups')).to.eql(configGroups);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(selectedConfigGroup);
    });
    it('should update configGroups and selectedConfigGroup', function () {
      App.set('supports.hostOverridesInstaller', true);
      var defaultGroup = {isDefault: true, n: 'n2'},
        configGroups = [
          {isDefault: false, n: 'n1'},
          defaultGroup,
          {n: 'n3'}
        ],
        selectedConfigGroup = {};
      installerStep7Controller.reopen({selectedService: {serviceName: 's1', configGroups: configGroups}});
      installerStep7Controller.selectedServiceObserver();
      expect(installerStep7Controller.get('configGroups').mapProperty('n')).to.eql(['n2', 'n1', 'n3']);
      expect(installerStep7Controller.get('selectedConfigGroup')).to.eql(defaultGroup);
    });
  });

  describe('#loadConfigGroups', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        wizardController: Em.Object.create({
          allHosts: [
            {hostName: 'h1'},
            {hostName: 'h2'},
            {hostName: 'h3'}
          ]
        })
      });
    });
    it('shouldn\'t do nothing if only MISC available', function () {
      var configGroups = [
        {}
      ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: 'MISC', configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups([]);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups')).to.eql(configGroups);
    });
    it('should set configGroups for service if they don\'t exist', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        serviceConfigGroups = [
          {service: {id: 's1'}}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, displayName: serviceName, configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups.length')).to.equal(1);
      var group = installerStep7Controller.get('stepConfigs.firstObject.configGroups.firstObject');
      expect(group.get('name')).to.equal('Default');
      expect(group.get('description').contains(serviceName)).to.equal(true);
      expect(group.get('isDefault')).to.equal(true);
      expect(group.get('hosts')).to.eql(['h1', 'h2', 'h3']);
      expect(group.get('service.id')).to.equal(serviceName);
      expect(group.get('serviceName')).to.equal(serviceName);
    });
    it('should update configGroups for service (only default group)', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        serviceConfigGroups = [
          {service: {id: 'HDFS'}, isDefault: true, n: 'n1'}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, displayName: serviceName, configGroups: configGroups})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault').get('n')).to.equal('n1');
    });
    it('should update configGroups for service', function () {
      var configGroups = [],
        serviceName = 'HDFS',
        properties = [
          { name: "p1", filename: "file.xml" },
          { name: "p2", filename: "file.xml" }
        ],
        serviceConfigGroups = [
          {service: {id: 'HDFS'}, properties: properties.slice(), isDefault: true, n: 'n1'},
          {service: {id: 'HDFS'}, properties: properties.slice(), isDefault: false, n: 'n2'}
        ];
      installerStep7Controller.reopen({
        stepConfigs: [Em.Object.create({serviceName: serviceName, configGroups: configGroups, configs: properties})]
      });
      installerStep7Controller.loadConfigGroups(serviceConfigGroups);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups.length')).to.equal(2);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault').get('n')).to.equal('n1');
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault', false).get('properties').everyProperty('group.n', 'n2')).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs.firstObject.configGroups').findProperty('isDefault', false).get('parentConfigGroup.n')).to.equal('n1');
    });
  });

  describe('#_getDisplayedConfigGroups', function () {
    it('should return [] if no selected group', function () {
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: null
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([]);
    });
    it('should return default config group if another selected', function () {
      var defaultGroup = Em.Object.create({isDefault: false});
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql([defaultGroup]);
    });
    it('should return other groups if default selected', function () {
      var defaultGroup = Em.Object.create({isDefault: true}),
        cfgG = Em.Object.create({isDefault: true}),
        configGroups = Em.A([
          Em.Object.create({isDefault: false}),
          Em.Object.create({isDefault: false}),
          cfgG,
          Em.Object.create({isDefault: false})
        ]);
      installerStep7Controller.reopen({
        content: {services: []},
        selectedConfigGroup: defaultGroup,
        selectedService: {configGroups: configGroups}
      });
      expect(installerStep7Controller._getDisplayedConfigGroups()).to.eql(configGroups.without(cfgG));
    });
  });

  describe('#_setEditableValue', function () {
    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({isEditable: null});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.be.null;
    });
    it('should set isEditable equal to selectedGroup.isDefault if service not installed', function () {
      var isDefault = true;
      installerStep7Controller.reopen({
        installedServiceNames: [],
        selectedService: {serviceName: 'abc'},
        selectedConfigGroup: Em.Object.create({isDefault: isDefault})
      });
      var config = Em.Object.create({isEditable: null});
      var updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(isDefault);
      installerStep7Controller.toggleProperty('selectedConfigGroup.isDefault');
      updatedConfig = installerStep7Controller._setEditableValue(config);
      expect(updatedConfig.get('isEditable')).to.equal(!isDefault);
    });
    Em.A([
        {
          isEditable: false,
          isReconfigurable: false,
          isDefault: true,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: true,
          isDefault: true,
          e: true
        },
        {
          isEditable: false,
          isReconfigurable: true,
          isDefault: false,
          e: false
        },
        {
          isEditable: true,
          isReconfigurable: false,
          isDefault: false,
          e: false
        }
      ]).forEach(function (test) {
        it('service installed, isEditable = ' + test.isEditable.toString() + ', isReconfigurable = ' + test.isReconfigurable.toString(), function () {
          var config = Em.Object.create({
            isReconfigurable: test.isReconfigurable,
            isEditable: test.isEditable
          });
          installerStep7Controller.reopen({
            installedServiceNames: Em.A(['a']),
            selectedService: Em.Object.create({serviceName: 'a'}),
            selectedConfigGroup: Em.Object.create({isDefault: test.isDefault})
          });
          var updateConfig = installerStep7Controller._setEditableValue(config);
          expect(updateConfig.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#_setOverrides', function () {
    it('shouldn\'t update config if no selectedConfigGroup', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null
      });
      var config = Em.Object.create({overrides: null});
      var updatedConfig = installerStep7Controller._setOverrides(config, []);
      expect(updatedConfig.get('overrides')).to.be.null;
    });
    it('no overrideToAdd', function () {
      var isDefault = true,
        name = 'n1',
        config = Em.Object.create({overrides: null, name: name, flag: 'flag'}),
        overrides = Em.A([
          Em.Object.create({name: name, value: 'v1'}),
          Em.Object.create({name: name, value: 'v2'}),
          Em.Object.create({name: 'n2', value: 'v3'})
        ]);
      installerStep7Controller.reopen({
        overrideToAdd: null,
        selectedConfigGroup: Em.Object.create({
          isDefault: isDefault
        })
      });
      var updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      expect(updatedConfig.get('overrides.length')).to.equal(2);
      expect(updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      expect(updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
    });
    it('overrideToAdd exists', function () {
      var isDefault = true,
        name = 'n1',
        config = Em.Object.create({overrides: null, name: name, flag: 'flag'}),
        overrides = Em.A([
          Em.Object.create({name: name, value: 'v1'}),
          Em.Object.create({name: name, value: 'v2'}),
          Em.Object.create({name: 'n2', value: 'v3'})
        ]);
      installerStep7Controller.reopen({
        overrideToAdd: Em.Object.create({name: name}),
        selectedService: {configGroups: [Em.Object.create({name: 'n', properties: []})]},
        selectedConfigGroup: Em.Object.create({
          isDefault: isDefault,
          name: 'n'
        })
      });
      var updatedConfig = installerStep7Controller._setOverrides(config, overrides);
      expect(updatedConfig.get('overrides.length')).to.equal(3);
      expect(updatedConfig.get('overrides').everyProperty('isEditable', !isDefault)).to.equal(true);
      expect(updatedConfig.get('overrides').everyProperty('parentSCP.flag', 'flag')).to.equal(true);
    });
  });

  describe('#switchConfigGroupConfigs', function () {
    it('if selectedConfigGroup is null, serviceConfigs shouldn\'t be changed', function () {
      installerStep7Controller.reopen({
        selectedConfigGroup: null,
        content: {services: []},
        serviceConfigs: {configs: [
          {overrides: []},
          {overrides: []}
        ]}
      });
      installerStep7Controller.switchConfigGroupConfigs();
      expect(installerStep7Controller.get('serviceConfigs.configs').everyProperty('overrides.length', 0)).to.equal(true);
    });
    it('should set configs for serviceConfigs', function () {
      var configGroups = [
        Em.Object.create({
          properties: [
            {name: 'g1', value: 'v1'},
            {name: 'g2', value: 'v2'}
          ]
        })
      ];
      sinon.stub(installerStep7Controller, '_getDisplayedConfigGroups', function () {
        return configGroups;
      });
      sinon.stub(installerStep7Controller, '_setEditableValue', function (config) {
        config.set('isEditable', true);
        return config;
      });
      installerStep7Controller.reopen({
        selectedConfigGroup: Em.Object.create({isDefault: true, name: 'g1'}),
        content: {services: []},
        selectedService: {configs: Em.A([Em.Object.create({name: 'g1', overrides: [], properties: []}), Em.Object.create({name: 'g2', overrides: []})])},
        serviceConfigs: {configs: [Em.Object.create({name: 'g1'})]}
      });
      installerStep7Controller.switchConfigGroupConfigs();
      var configs = installerStep7Controller.get('selectedService.configs');
      expect(configs.findProperty('name', 'g1').get('overrides').length).to.equal(1);
      expect(configs.findProperty('name', 'g2').get('overrides').length).to.equal(1);
      expect(configs.everyProperty('isEditable', true)).to.equal(true);
      installerStep7Controller._getDisplayedConfigGroups.restore();
      installerStep7Controller._setEditableValue.restore();
    });
  });

  describe('#selectProperService', function () {
    Em.A([
        {
          name: 'addServiceController',
          stepConfigs: [
            {selected: false, name: 'n1'},
            {selected: true, name: 'n2'},
            {selected: true, name: 'n3'}
          ],
          e: 'n2'
        },
        {
          name: 'installerController',
          stepConfigs: [
            {showConfig: false, name: 'n1'},
            {showConfig: false, name: 'n2'},
            {showConfig: true, name: 'n3'}
          ],
          e: 'n3'
        }
      ]).forEach(function (test) {
        it(test.name, function () {
          sinon.stub(installerStep7Controller, 'selectedServiceObserver', Em.K);
          installerStep7Controller.reopen({
            wizardController: Em.Object.create({
              name: test.name
            }),
            stepConfigs: test.stepConfigs
          });
          installerStep7Controller.selectProperService();
          expect(installerStep7Controller.get('selectedService.name')).to.equal(test.e);
          installerStep7Controller.selectedServiceObserver.restore();
        });
      });
  });

  describe('#setStepConfigs', function () {

    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (key) {
            return this.get(key);
          }
        })
      });
    });

    afterEach(function () {
      installerStep7Controller.renderConfigs.restore();
    });

    it('if wizard isn\'t addService, should set output of installerStep7Controller.renderConfigs', function () {
      var serviceConfigs = Em.A([
        {serviceName:'HDFS', configs: []},
        {}
      ]);
      sinon.stub(installerStep7Controller, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.set('wizardController.name', 'installerController');
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs')).to.eql(serviceConfigs);
    });

    it('addServiceWizard used', function () {
      var serviceConfigs = Em.A([Em.Object.create({serviceName: 'HDFS', configs: []}), Em.Object.create({serviceName: 's2'})]);
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['s2']});
      sinon.stub(installerStep7Controller, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 's2').get('selected')).to.equal(true);
    });

    it('addServiceWizard used, HA enabled', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'isHaEnabled') {
          return true;
        }
        return Em.get(App, k);
      });
      var serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            Em.Object.create({category: 'SECONDARY_NAMENODE'}),
            Em.Object.create({category: 'SECONDARY_NAMENODE'}),
            Em.Object.create({category: 'NameNode'}),
            Em.Object.create({category: 'NameNode'}),
            Em.Object.create({category: 'SECONDARY_NAMENODE'})
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      sinon.stub(installerStep7Controller, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);
      expect(installerStep7Controller.get('stepConfigs').everyProperty('showConfig', true)).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('selected')).to.equal(true);
      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(5);
      App.get.restore();
    });

    it('not windows stack', function () {

      var s = sinon.stub(App, 'get');
      s.withArgs('isHadoopWindowsStack').returns(false);
      s.withArgs('isHaEnabled').returns(false);

      var serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            {category: 'NameNode'},
            {category: 'NameNode'}
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );

      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      sinon.stub(installerStep7Controller, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);

      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(2);

      s.restore();

    });

    it('windows stack', function () {

      var s = sinon.stub(App, 'get');
      s.withArgs('isHadoopWindowsStack').returns(true);
      s.withArgs('isHaEnabled').returns(false);

      var serviceConfigs = Em.A([
        Em.Object.create({
          serviceName: 'HDFS',
          configs: [
            {category: 'NameNode'},
            {category: 'NameNode'}
          ]
        }),
        Em.Object.create({serviceName: 's2'})]
      );

      installerStep7Controller.reopen({selectedServiceNames: ['HDFS', 's2']});
      installerStep7Controller.set('installedServiceNames',['HDFS', 's2', 's3']);
      sinon.stub(installerStep7Controller, 'renderConfigs', function () {
        return serviceConfigs;
      });
      installerStep7Controller.setStepConfigs([], []);

      expect(installerStep7Controller.get('stepConfigs').findProperty('serviceName', 'HDFS').get('configs').length).to.equal(2);

      s.restore();

    });

  });

  describe('#checkHostOverrideInstaller', function () {
    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'loadConfigGroups', Em.K);
      sinon.stub(installerStep7Controller, 'loadInstalledServicesConfigGroups', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.loadConfigGroups.restore();
      installerStep7Controller.loadInstalledServicesConfigGroups.restore();
      App.get.restore();
    });
    Em.A([
        {
          installedServiceNames: [],
          m: 'installedServiceNames is empty',
          e: {
            loadConfigGroups: true,
            loadInstalledServicesConfigGroups: false
          }
        },
        {
          installedServiceNames: ['s1', 's2', 's3'],
          areInstalledConfigGroupsLoaded: false,
          m: 'installedServiceNames isn\'t empty, config groups not yet loaded',
          e: {
            loadConfigGroups: true,
            loadInstalledServicesConfigGroups: true
          }
        },
        {
          installedServiceNames: ['s1', 's2', 's3'],
          areInstalledConfigGroupsLoaded: true,
          m: 'installedServiceNames isn\'t empty, config groups already loaded',
          e: {
            loadConfigGroups: true,
            loadInstalledServicesConfigGroups: false
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          sinon.stub(App, 'get', function (k) {
            if (k === 'supports.hostOverridesInstaller') return test.hostOverridesInstaller;
            return Em.get(App, k);
          });
          installerStep7Controller.reopen({
            installedServiceNames: test.installedServiceNames,
            wizardController: {
              areInstalledConfigGroupsLoaded: test.areInstalledConfigGroupsLoaded
            }
          });
          installerStep7Controller.checkHostOverrideInstaller();
          if (test.e.loadConfigGroups) {
            expect(installerStep7Controller.loadConfigGroups.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep7Controller.loadConfigGroups.called).to.equal(false);
          }
          if (test.e.loadInstalledServicesConfigGroups) {
            expect(installerStep7Controller.loadInstalledServicesConfigGroups.calledOnce).to.equal(true);
          }
          else {
            expect(installerStep7Controller.loadInstalledServicesConfigGroups.called).to.equal(false);
          }
        });
      });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      installerStep7Controller.reopen({
        content: {services: []},
        wizardController: Em.Object.create({
          getDBProperty: function (k) {
            return this.get(k);
          },
          stackConfigsLoaded: true
        })
      });
      sinon.stub(App.config, 'mergePreDefinedWithStack', Em.K);
      sinon.stub(installerStep7Controller, 'clearStep', Em.K);
      sinon.stub(installerStep7Controller, 'getConfigTags', Em.K);
      sinon.stub(installerStep7Controller, 'setInstalledServiceConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'resolveServiceDependencyConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'setStepConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'checkHostOverrideInstaller', Em.K);
      sinon.stub(installerStep7Controller, 'activateSpecialConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'selectProperService', Em.K);
      sinon.stub(installerStep7Controller, 'applyServicesConfigs', Em.K);
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.config.mergePreDefinedWithStack.restore();
      installerStep7Controller.clearStep.restore();
      installerStep7Controller.getConfigTags.restore();
      installerStep7Controller.setInstalledServiceConfigs.restore();
      installerStep7Controller.resolveServiceDependencyConfigs.restore();
      installerStep7Controller.setStepConfigs.restore();
      installerStep7Controller.checkHostOverrideInstaller.restore();
      installerStep7Controller.activateSpecialConfigs.restore();
      installerStep7Controller.selectProperService.restore();
      installerStep7Controller.applyServicesConfigs.restore();
      App.router.send.restore();
    });
    it('should call clearStep', function () {
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.calledOnce).to.equal(true);
    });
    it('shouldn\'t do nothing if isAdvancedConfigLoaded is false', function () {
      installerStep7Controller.set('wizardController.stackConfigsLoaded', false);
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.clearStep.called).to.equal(false);
    });
    it('should use App.config to map configs', function () {
      installerStep7Controller.loadStep();
      expect(App.config.mergePreDefinedWithStack.calledOnce).to.equal(true);
    });
    it('should call setInstalledServiceConfigs for addServiceController', function () {
      installerStep7Controller.set('wizardController.name', 'addServiceController');
      installerStep7Controller.loadStep();
      expect(installerStep7Controller.setInstalledServiceConfigs.calledOnce).to.equal(true);
    });
  });

  describe('#applyServicesConfigs', function() {
    beforeEach(function() {
      installerStep7Controller.reopen({
        allSelectedServiceNames: []
      });
      sinon.stub(installerStep7Controller, 'resolveServiceDependencyConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'loadServerSideConfigsRecommendations', function() {
        return $.Deferred().resolve();
      });
      sinon.stub(installerStep7Controller, 'checkHostOverrideInstaller', Em.K);
      sinon.stub(installerStep7Controller, 'activateSpecialConfigs', Em.K);
      sinon.stub(installerStep7Controller, 'selectProperService', Em.K);
      sinon.stub(installerStep7Controller, 'setStepConfigs', Em.K);
      sinon.stub(App.router, 'send', Em.K);
      sinon.stub(App.StackService, 'find', function () {
        return {
          findProperty: function () {
            return Em.Object.create({
              isInstalled: true,
              isSelected: false
            });
          },
          filterProperty: function () {
            return [];
          }
        }
      });
     installerStep7Controller.set('content.hosts', Em.A([{hostName: 'h1'}, {hostName: 'h2'}]));
    });
    afterEach(function () {
      installerStep7Controller.resolveServiceDependencyConfigs.restore();
      installerStep7Controller.loadServerSideConfigsRecommendations.restore();
      installerStep7Controller.checkHostOverrideInstaller.restore();
      installerStep7Controller.activateSpecialConfigs.restore();
      installerStep7Controller.selectProperService.restore();
      installerStep7Controller.setStepConfigs.restore();
      App.router.send.restore();
      App.StackService.find.restore();
    });

    it('should run some methods' , function () {
     installerStep7Controller.applyServicesConfigs({name: 'configs'}, {name: 'storedConfigs'});
     expect(installerStep7Controller.loadServerSideConfigsRecommendations.calledOnce).to.equal(true);
     expect(installerStep7Controller.get('isRecommendedLoaded')).to.equal(true);
     expect(installerStep7Controller.setStepConfigs.calledWith({name: 'configs'}, {name: 'storedConfigs'})).to.equal(true);
     expect(installerStep7Controller.checkHostOverrideInstaller.calledOnce).to.equal(true);
     expect(installerStep7Controller.activateSpecialConfigs.calledOnce).to.equal(true);
     expect(installerStep7Controller.selectProperService.calledOnce).to.equal(true);
    });
  });

  describe('#_updateIsEditableFlagForConfig', function () {
    beforeEach(function(){
      this.mock = sinon.stub(App, 'isAccessible');
    });
    afterEach(function () {
      this.mock.restore();
    });
    Em.A([
        {
          isAdmin: false,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false for non-admin users',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: true,
          defaultGroupSelected: true,
          m: 'false if defaultGroupSelected is true and isHostsConfigsPage is true',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: false,
          isHostsConfigsPage: false,
          defaultGroupSelected: false,
          m: 'false if defaultGroupSelected is false and isHostsConfigsPage is false',
          e: false
        },
        {
          isAdmin: true,
          isReconfigurable: true,
          isHostsConfigsPage: false,
          defaultGroupSelected: true,
          m: 'equal to isReconfigurable if defaultGroupSelected is true and isHostsConfigsPage is false',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          this.mock.returns(test.isAdmin);
          installerStep7Controller.reopen({isHostsConfigsPage: test.isHostsConfigsPage});
          var serviceConfigProperty = Em.Object.create({
            isReconfigurable: test.isReconfigurable
          });
          installerStep7Controller._updateIsEditableFlagForConfig(serviceConfigProperty, test.defaultGroupSelected);
          expect(serviceConfigProperty.get('isEditable')).to.equal(test.e);
        });
      });
  });

  describe('#_updateOverridesForConfig', function () {

    it('should set empty array', function () {
      var serviceConfigProperty = Em.Object.create({
        overrides: null
      }), component = Em.Object.create();
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      expect(serviceConfigProperty.get('overrides')).to.eql(Em.A([]));
    });

    it('host overrides not supported', function () {
      var serviceConfigProperty = Em.Object.create({
        overrides: [
          {value: 'new value'}
        ]
      }), component = Em.Object.create({selectedConfigGroup: {isDefault: false}});
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      expect(serviceConfigProperty.get('overrides').length).to.equal(1);
      expect(serviceConfigProperty.get('overrides.firstObject.value')).to.equal('new value');
      expect(serviceConfigProperty.get('overrides.firstObject.isOriginalSCP')).to.equal(false);
      expect(serviceConfigProperty.get('overrides.firstObject.parentSCP')).to.eql(serviceConfigProperty);
    });

    it('host overrides supported', function () {
      sinon.stub(App, 'get', function (k) {
        if (k === 'supports.hostOverrides') return true;
        return Em.get(App, k);
      });
      var serviceConfigProperty = Em.Object.create({
          overrides: [
            {value: 'new value', group: Em.Object.create({name: 'n1'})}
          ]
        }),
        component = Em.Object.create({
          selectedConfigGroup: {isDefault: true},
          configGroups: Em.A([
            Em.Object.create({name: 'n1', properties: []})
          ])
        });
      installerStep7Controller._updateOverridesForConfig(serviceConfigProperty, component);
      App.get.restore();
      expect(serviceConfigProperty.get('overrides').length).to.equal(1);
      expect(serviceConfigProperty.get('overrides.firstObject.value')).to.equal('new value');
      expect(serviceConfigProperty.get('overrides.firstObject.isOriginalSCP')).to.equal(false);
      expect(serviceConfigProperty.get('overrides.firstObject.parentSCP')).to.eql(serviceConfigProperty);
      expect(component.get('configGroups.firstObject.properties').length).to.equal(1);
      expect(component.get('configGroups.firstObject.properties.firstObject.isEditable')).to.equal(false);
      expect(component.get('configGroups.firstObject.properties.firstObject.group')).to.be.object;
    });

  });

  describe('#setInstalledServiceConfigs', function () {

    var controller = App.WizardStep7Controller.create({
        installedServiceNames: ['HBASE', 'AMBARI_METRICS']
      }),
      configs = [
        {
          name: 'hbase.client.scanner.caching',
          value: '1000',
          serviceName: 'HBASE',
          filename: 'hbase-site.xml'
        },
        {
          name: 'hbase.client.scanner.caching',
          value: '2000',
          serviceName: 'AMBARI_METRICS',
          filename: 'ams-hbase-site.xml'
        }
      ],
      configsByTags = [
        {
          type: 'hbase-site',
          tag: 'version2',
          properties: {
            'hbase.client.scanner.caching': '1500'
          }
        },
        {
          type: 'ams-hbase-site',
          tag: 'version2',
          properties: {
            'hbase.client.scanner.caching': '2500'
          }
        },
        {
          type: 'site-without-properties',
          tag: 'version1'
        }
      ],
      installedServiceNames = ['HBASE', 'AMBARI_METRICS'];

    it('should handle properties with the same name', function () {
      configs = controller.setInstalledServiceConfigs(configs, configsByTags, installedServiceNames);
      var properties = configs.filterProperty('name', 'hbase.client.scanner.caching');
      expect(properties).to.have.length(2);
      expect(properties.findProperty('filename', 'hbase-site.xml').value).to.equal('1500');
      expect(properties.findProperty('filename', 'hbase-site.xml').savedValue).to.equal('1500');
      expect(properties.findProperty('filename', 'ams-hbase-site.xml').value).to.equal('2500');
      expect(properties.findProperty('filename', 'ams-hbase-site.xml').savedValue).to.equal('2500');
    });

  });

  describe('#getAmbariDatabaseSuccess', function () {

    var controller = App.WizardStep7Controller.create({
        stepConfigs: [
          {
            serviceName: 'HIVE',
            configs: [
              {
                name: 'hive_hostname',
                value: 'h0'
              }
            ]
          }
        ]
      }),
      cases = [
        {
          data: {
            hostComponents: []
          },
          mySQLServerConflict: false,
          title: 'no Ambari Server host components'
        },
        {
          data: {
            hostComponents: [
              {
                RootServiceHostComponents: {
                  properties: {
                    'server.jdbc.url': 'jdbc:mysql://h0/db0?createDatabaseIfNotExist=true'
                  }
                }
              }
            ]
          },
          mySQLServerConflict: true,
          title: 'Ambari MySQL Server and Hive Server are on the same host'
        },
        {
          data: {
            hostComponents: [
              {
                RootServiceHostComponents: {
                  properties: {
                    'server.jdbc.url': 'jdbc:mysql://h1/db1?createDatabaseIfNotExist=true'
                  }
                }
              }
            ]
          },
          mySQLServerConflict: false,
          title: 'Ambari MySQL Server and Hive Server are on different hosts'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        controller.getAmbariDatabaseSuccess(item.data);
        expect(controller.get('mySQLServerConflict')).to.equal(item.mySQLServerConflict);
      });
    });

  });

  describe('#showDatabaseConnectionWarningPopup', function () {

    var cases = [
        {
          method: 'onSecondary',
          submitButtonClicked: false,
          isRejected: true,
          title: 'Cancel button clicked'
        },
        {
          method: 'onPrimary',
          submitButtonClicked: true,
          isResolved: true,
          title: 'Proceed Anyway button clicked'
        }
      ],
      dfd,
      testObject,
      serviceNames = ['HIVE', 'OOZIE'],
      bodyMessage = 'HIVE, OOZIE';

    beforeEach(function () {
      installerStep7Controller.set('submitButtonClicked', true);
      dfd = $.Deferred(function (d) {
        d.done(function () {
          testObject.isResolved = true;
        });
        d.fail(function () {
          testObject.isRejected = true;
        })
      });
      testObject = {};
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        var popup = installerStep7Controller.showDatabaseConnectionWarningPopup(serviceNames, dfd);
        expect(popup.get('body')).to.equal(Em.I18n.t('installer.step7.popup.database.connection.body').format(bodyMessage));
        popup[item.method]();
        expect(testObject.isResolved).to.equal(item.isResolved);
        expect(testObject.isRejected).to.equal(item.isRejected);
        expect(installerStep7Controller.get('submitButtonClicked')).to.equal(item.submitButtonClicked);
      });
    });

  });

  describe('#issuesFilterText', function () {

    issuesFilterCases.forEach(function (item) {
      it(item.title, function () {
        issuesFilterTestSetup(installerStep7Controller, item);
        expect(installerStep7Controller.get('issuesFilterText')).to.equal(item.issuesFilterText);
      })
    });

  });

  describe('#loadServiceTagsSuccess', function () {
    it('should create ClusterSiteToTagMap', function () {
      var params = Em.Object.create({
        serviceName: "OOZIE",
        serviceConfigsDef: Em.Object.create({
          configTypes: Em.Object.create({
            site3: true,
            site2: true,
            site1: true
          })
        })
      });
      var wizardController = Em.Object.create({
          allHosts: [
            {hostName: 'h1'},
            {hostName: 'h2'},
            {hostName: 'h3'}
          ]
      });
      installerStep7Controller.set('wizardController', wizardController);
      installerStep7Controller.set('stepConfigs', Em.A([Em.Object.create({serviceName: 'OOZIE', configs: Em.A([]) })]));
      var desired_configs = {
        site1: {
          tag: "tag1"
        },
        site2: {
          tag: "tag2"
        },
        site3: {
          tag: "tag3"
        }
      };
      var data = {
        config_groups: Em.A([Em.Object.create({
          ConfigGroup: Em.Object.create({
            tag: 'OOZIE',
            hosts: Em.A([Em.Object.create({host_name: 'h1'})]),
            id: 1,
            group_name: "",
            description: "",
            desired_configs: Em.A([Em.Object.create({
              type: '1',
              tag: 'h1'
            })])
          })
        })]),
        Clusters: {
          desired_configs: desired_configs
        }
      };
      installerStep7Controller.loadServiceTagsSuccess(data, {}, params);
      var result = installerStep7Controller.get("loadedClusterSiteToTagMap");
      expect(JSON.parse(JSON.stringify(result))).to.eql(JSON.parse(JSON.stringify({"site1":"tag1","site2":"tag2","site3":"tag3"})));
    })
  });

  describe('#issuesFilterLinkText', function () {

    issuesFilterCases.forEach(function (item) {
      it(item.title, function () {
        issuesFilterTestSetup(installerStep7Controller, item);
        expect(installerStep7Controller.get('issuesFilterLinkText')).to.equal(item.issuesFilterLinkText);
      })
    });

  });

  describe('#toggleIssuesFilter', function () {
    beforeEach(function () {
      sinon.stub(installerStep7Controller, 'propertyDidChange', Em.K);
    });
    afterEach(function () {
      installerStep7Controller.propertyDidChange.restore();
    });
    it('should toggle issues filter', function () {
      var issuesFilter = installerStep7Controller.get('filterColumns').findProperty('attributeName', 'hasIssues');
      issuesFilter.set('selected', false);
      installerStep7Controller.toggleIssuesFilter();
      expect(issuesFilter.get('selected')).to.be.true;
      installerStep7Controller.toggleIssuesFilter();
      expect(issuesFilter.get('selected')).to.be.false;
    });
    it('selected service should be changed', function () {
      installerStep7Controller.setProperties({
        selectedService: {
          errorCount: 0,
          configGroups: []
        },
        stepConfigs: [
          {
            errorCount: 1,
            configGroups: []
          },
          {
            errorCount: 2,
            configGroups: []
          }
        ]
      });
      installerStep7Controller.toggleIssuesFilter();
      expect(installerStep7Controller.get('selectedService')).to.eql({
        errorCount: 1,
        configGroups: []
      });
      expect(installerStep7Controller.propertyDidChange.calledOnce).to.be.true;
      expect(installerStep7Controller.propertyDidChange.calledWith('selectedServiceNameTrigger')).to.be.true;
    });
  });

  describe('#addKerberosDescriptorConfigs', function() {
    var configs = [
      { name: 'prop1', displayName: 'Prop1' },
      { name: 'prop2', displayName: 'Prop2' },
      { name: 'prop3', displayName: 'Prop3' }
    ];
    var descriptor = [
      Em.Object.create({ name: 'prop4', filename: 'file-1'}),
      Em.Object.create({ name: 'prop1', filename: 'file-1'})
    ];
    var propertiesAttrTests = [
      {
        attr: 'isUserProperty', val: false,
        m: 'descriptor properties should not be marked as custom'
      },
      {
        attr: 'category', val: 'Advanced file-1',
        m: 'descriptor properties should be added to Advanced category'
      },
      {
        attr: 'isOverridable', val: false,
        m: 'descriptor properties should not be overriden'
      }
    ];

    propertiesAttrTests.forEach(function(test) {
      it(test.m, function() {
        installerStep7Controller.addKerberosDescriptorConfigs(configs, descriptor);
        expect(configs.findProperty('name', 'prop1')[test.attr]).to.be.eql(test.val);
      });
    });
  });

  describe('#addHawqConfigsOnNnHa', function () {
    var configs = [
      {
        filename: 'hdfs-site.xml',
        description: 'dfs.nameservices__hdfs-site',
        displayName: 'dfs.nameservices',
        displayType: 'string',
        name: 'dfs.nameservices',
        value: 'haservice',
        recommendedValue: 'haservice'
      },
      {
        filename: 'hdfs-site.xml',
        description: 'dfs.ha.namenodes.haservice__hdfs-site',
        displayName: 'dfs.ha.namenodes.haservice',
        displayType: 'string',
        name: 'dfs.ha.namenodes.haservice',
        value: 'nn1,nn2',
        recommendedValue: 'nn1,nn2'
      },
      {
        filename: 'hdfs-site.xml',
        description: 'dfs.namenode.rpc-address.haservice.nn1__hdfs-site',
        displayName: 'dfs.namenode.rpc-address.haservice.nn1',
        displayType: 'string',
        name: 'dfs.namenode.rpc-address.haservice.nn1',
        value: 'c6401.ambari.apache.org:8020',
        recommendedValue: 'c6401.ambari.apache.org:8020'
      },
      {
        filename: 'hdfs-site.xml',
        description: 'dfs.namenode.rpc-address.haservice.nn2__hdfs-site',
        displayName: 'dfs.namenode.rpc-address.haservice.nn2',
        displayType: 'string',
        name: 'dfs.namenode.rpc-address.haservice.nn2',
        value: 'c6402.ambari.apache.org:8020',
        recommendedValue: 'c6402.ambari.apache.org:8020'
      },
      {
        filename: 'hdfs-site.xml',
        description: 'dfs.namenode.http-address.haservice.nn1__hdfs-site',
        displayName: 'dfs.namenode.http-address.haservice.nn1',
        displayType: 'string',
        name: 'dfs.namenode.http-address.haservice.nn1',
        value: 'c6401.ambari.apache.org:50070',
        recommendedValue: 'c6401.ambari.apache.org:50070'
      },
      {
        filename: 'hdfs-site.xml',
        description: 'dfs.namenode.http-address.haservice.nn2__hdfs-site',
        displayName: 'dfs.namenode.http-address.haservice.nn2',
        displayType: 'string',
        name: 'dfs.namenode.http-address.haservice.nn2',
        value: 'c6402.ambari.apache.org:50070',
        recommendedValue: 'c6402.ambari.apache.org:50070'
      }
    ];

    it('should copy properties from hdfs-site to hdfs-client for HAWQ', function() {
      var oldConfigs = configs.slice();
      installerStep7Controller.addHawqConfigsOnNnHa(configs);
      // ensure 6 new configs were added
      expect(configs.length - oldConfigs.length).to.be.eql(6);
      var hdfsClientConfigs = configs.filterProperty('filename', 'hdfs-client.xml');
      oldConfigs.forEach(function(property){
        // find the same property in hdfs-client for HAWQ and see if attribute value matches with the corresponding property's attribute value in hdfs-site
        expect(hdfsClientConfigs.findProperty('name', property.name).description).to.be.eql(property.description);
        expect(hdfsClientConfigs.findProperty('name', property.name).displayName).to.be.eql(property.displayName);
        expect(hdfsClientConfigs.findProperty('name', property.name).value).to.be.eql(property.value);
        expect(hdfsClientConfigs.findProperty('name', property.name).recommendedValue).to.be.eql(property.recommendedValue);
      });
    });
  });

  describe('#addHawqConfigsOnRMHa', function () {
    var configs = [
      {
        id: 'yarn.resourcemanager.hostname.rm1',
        name: 'yarn.resourcemanager.hostname.rm1',
        value: 'c6401.ambari.apache.org',
        recommendedValue: 'c6401.ambari.apache.org',
        filename: 'yarn-site.xml'
      },
      {
        id: 'yarn.resourcemanager.hostname.rm2',
        name: 'yarn.resourcemanager.hostname.rm2',
        value: 'c6402.ambari.apache.org',
        recommendedValue: 'c6402.ambari.apache.org',
        filename: 'yarn-site.xml'
      }
    ];

    it('should update properties in yarn-client for HAWQ if yarn ha is enabled', function() {
      var inputConfigsCount = configs.length;
      installerStep7Controller.addHawqConfigsOnRMHa(configs);
      var yarnClientConfig = configs.filterProperty('filename', 'yarn-client.xml');
      var yarnRmDetails = yarnClientConfig.findProperty('name', 'yarn.resourcemanager.ha');
      var yarnRmSchedulerDetails = yarnClientConfig.findProperty('name', 'yarn.resourcemanager.scheduler.ha');

      var expectedYarnRmHaValue = 'c6401.ambari.apache.org:8032,c6402.ambari.apache.org:8032';
      expect(yarnRmDetails.value).to.be.eql(expectedYarnRmHaValue);
      expect(yarnRmDetails.recommendedValue).to.be.eql(expectedYarnRmHaValue);
      expect(yarnRmDetails.displayName).to.be.eql('yarn.resourcemanager.ha');
      expect(yarnRmDetails.description).to.be.eql('Comma separated yarn resourcemanager host addresses with port');

      var expectedYarnRmSchedulerValue = 'c6401.ambari.apache.org:8030,c6402.ambari.apache.org:8030';
      expect(yarnRmSchedulerDetails.value).to.be.eql(expectedYarnRmSchedulerValue);
      expect(yarnRmSchedulerDetails.recommendedValue).to.be.eql(expectedYarnRmSchedulerValue);
      expect(yarnRmSchedulerDetails.displayName).to.be.eql('yarn.resourcemanager.scheduler.ha');
      expect(yarnRmSchedulerDetails.description).to.be.eql('Comma separated yarn resourcemanager scheduler addresses with port');

      var noOfConfigsAdded = 2;
      expect(configs.length).to.be.eql(inputConfigsCount + noOfConfigsAdded) ;
    });
  });

  describe('#removeHawqStandbyAddressHostConfig', function() {
    var testHawqSiteConfigs = [
      {
        name: 'hawq_standby_address_host',
        value: 'h2'
      },
      {
        name: 'hawq_master_address_host',
        value: 'h1'
      }
    ];
    var oldHawqSiteLength = testHawqSiteConfigs.length;
    it('hawq_standby_address_host should be removed', function() {
      var hawqSiteConfigs = testHawqSiteConfigs.slice();
      var updatedHawqSiteConfigs = installerStep7Controller.removeHawqStandbyHostAddressConfig(hawqSiteConfigs);
      expect(updatedHawqSiteConfigs.length).to.be.eql(oldHawqSiteLength-1);
      expect(updatedHawqSiteConfigs.findProperty('name', 'hawq_standby_address_host')).to.be.eql(undefined);
      expect(updatedHawqSiteConfigs.findProperty('name', 'hawq_master_address_host').value).to.be.eql('h1');
    });

  });

  describe('#errorsCount', function () {

    it('should ignore configs with widgets (enhanced configs)', function () {

      installerStep7Controller.reopen({selectedService: {
        configs: [
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: false}),
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: true}),
          Em.Object.create({isVisible: true, isValid: true}),
          Em.Object.create({isVisible: true, isValid: false})
        ]
      }});

      expect(installerStep7Controller.get('errorsCount')).to.equal(1);

    });

    it('should ignore configs with widgets (enhanced configs) and hidden configs', function () {

      installerStep7Controller.reopen({selectedService: {
        configs: [
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: false}),
          Em.Object.create({isVisible: true, widgetType: 'type', isValid: true}),
          Em.Object.create({isVisible: false, isValid: false}),
          Em.Object.create({isVisible: true, isValid: true}),
          Em.Object.create({isVisible: true, isValid: false})
        ]
      }});

      expect(installerStep7Controller.get('errorsCount')).to.equal(1);

    });

  });

  describe('#_reconfigureServicesOnNnHa', function () {

    var dfsNameservices = 'some_cluster';

    Em.A([
      {
        serviceName: 'HBASE',
        configToUpdate: 'hbase.rootdir',
        oldValue: 'hdfs://nameserv:8020/apps/hbase/data',
        expectedNewValue: 'hdfs://' + dfsNameservices + '/apps/hbase/data'
      },
      {
        serviceName: 'ACCUMULO',
        configToUpdate: 'instance.volumes',
        oldValue: 'hdfs://localhost:8020/apps/accumulo/data',
        expectedNewValue: 'hdfs://' + dfsNameservices + '/apps/accumulo/data'
      },
      {
        serviceName: 'HAWQ',
        configToUpdate: 'hawq_dfs_url',
        oldValue: 'localhost:8020/hawq_data',
        expectedNewValue: dfsNameservices + '/hawq_data'
      }
    ]).forEach(function (test) {
      it(test.serviceName + ' ' + test.configToUpdate, function () {
        var serviceConfigs = [App.ServiceConfig.create({
          serviceName: test.serviceName,
          configs: [
            Em.Object.create({
              name: test.configToUpdate,
              value: test.oldValue
            })
          ]
        }),
          App.ServiceConfig.create({
            serviceName: 'HDFS',
            configs: [
              Em.Object.create({
                name: 'dfs.nameservices',
                value: dfsNameservices
              })
            ]
          })];
        installerStep7Controller.reopen({
          selectedServiceNames: [test.serviceName, 'HDFS']
        });
        serviceConfigs = installerStep7Controller._reconfigureServicesOnNnHa(serviceConfigs);
        expect(serviceConfigs.findProperty('serviceName', test.serviceName).configs.findProperty('name', test.configToUpdate).get('value')).to.equal(test.expectedNewValue);
      });
    });

  });

  describe('#showOozieDerbyWarning', function() {
    var controller;
    beforeEach(function() {
      controller = App.WizardStep7Controller.create({});
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });
    afterEach(function() {
      App.ModalPopup.show.restore();
    });

    Em.A([
      {
        selectedServiceNames: ['HDFS', 'OOZIE'],
        databaseType: Em.I18n.t('installer.step7.oozie.database.new'),
        e: true,
        m: 'Oozie selected with derby database, warning popup should be shown'
      },
      {
        selectedServiceNames: ['HDFS'],
        databaseType: Em.I18n.t('installer.step7.oozie.database.new'),
        e: false,
        m: 'Oozie not selected warning popup should be skipped'
      },
      {
        selectedServiceNames: ['HDFS', 'OOZIE'],
        databaseType: 'New Mysql Database',
        e: false,
        m: 'Oozie selected, mysql database used, warning popup should be sk'
      }
    ]).forEach(function(test) {
      it(test.m, function() {
        var callback = sinon.spy();
        sinon.stub(controller, 'findConfigProperty').returns(Em.Object.create({ value: test.databaseType}));
        controller.reopen({
          selectedServiceNames: test.selectedServiceNames
        });
        controller.showOozieDerbyWarningPopup(callback);
        controller.findConfigProperty.restore();
        expect(App.ModalPopup.show.calledOnce).to.equal(test.e);
      });
    });
  });

  describe('#addHostNamesToConfigs', function() {

    beforeEach(function () {
      sinon.stub(App.StackServiceComponent, 'find', function () {
        return Em.Object.create({
          id: 'NAMENODE',
          displayName: 'NameNode'
        });
      });
    });

    afterEach(function () {
      App.StackServiceComponent.find.restore();
    });

    it('should not create duplicate configs', function () {
      var serviceConfig = Em.Object.create({
        configs: [],
        serviceName: 'HDFS',
        configCategories: [
          {
            showHost: true,
            name: 'NAMENODE'
          }
        ]
      });
      var masterComponents = [
        {component: 'NAMENODE', hostName: 'h1'}
      ];
      var slaveComponents = [];
      installerStep7Controller.addHostNamesToConfigs(serviceConfig, masterComponents, slaveComponents);
      expect(serviceConfig.get('configs').filterProperty('name', 'namenode_host').length).to.equal(1);
      installerStep7Controller.addHostNamesToConfigs(serviceConfig, masterComponents, slaveComponents);
      expect(serviceConfig.get('configs').filterProperty('name', 'namenode_host').length).to.equal(1);
    });

  });

  describe('#resolveHiveMysqlDatabase', function () {

    beforeEach(function () {
      installerStep7Controller.get('content').setProperties({
        services: Em.A([
          Em.Object.create({serviceName: 'HIVE', isSelected: true, isInstalled: false})
        ])
      });
      installerStep7Controller.setProperties({
        stepConfigs: Em.A([
          Em.Object.create({serviceName: 'HIVE', configs: [{name: 'hive_database', value: 'New MySQL Database'}]})
        ]),
        mySQLServerConflict: true
      });
      sinon.stub(installerStep7Controller, 'moveNext', Em.K);
      sinon.stub(installerStep7Controller, 'checkMySQLHost', function () {
        return $.Deferred().resolve();
      });
      sinon.spy(App.ModalPopup, 'show');
    });

    afterEach(function () {
      installerStep7Controller.moveNext.restore();
      installerStep7Controller.checkMySQLHost.restore();

      App.ModalPopup.show.restore();
    });

    it('no HIVE service', function () {
      installerStep7Controller.set('content.services', Em.A([]));
      installerStep7Controller.resolveHiveMysqlDatabase();
      expect(installerStep7Controller.moveNext.calledOnce).to.be.true;
      expect(App.ModalPopup.show.called).to.be.false;
    });

    it('if mySQLServerConflict, popup is shown', function () {
      installerStep7Controller.resolveHiveMysqlDatabase();
      expect(installerStep7Controller.moveNext.called).to.be.false;
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

  });

  describe('#mySQLWarningHandler', function () {

    beforeEach(function () {
      installerStep7Controller.set('mySQLServerConflict', true);
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(App.router, 'get').returns({gotoStep: Em.K});
      sinon.stub(App.router.get(), 'gotoStep', Em.K);
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
      App.router.get().gotoStep.restore();
      App.router.get.restore();
    });

    it('warning popup is shown', function () {
      installerStep7Controller.mySQLWarningHandler();
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

    it('submitButtonClicked is set to false on primary click', function () {
      installerStep7Controller.mySQLWarningHandler().onPrimary();
      expect(installerStep7Controller.get('submitButtonClicked')).to.be.false;
    });

    it('second popup is shown on secondary click', function () {
      installerStep7Controller.mySQLWarningHandler().onSecondary();
      expect(App.ModalPopup.show.calledTwice).to.be.true;
    });

    it('submitButtonClicked is set to false on secondary click on the second popup', function () {
      installerStep7Controller.mySQLWarningHandler().onSecondary().onSecondary();
      expect(installerStep7Controller.get('submitButtonClicked')).to.be.false;
    });

    it('user is moved to step5 on primary click on the second popup (installerController)', function () {
      installerStep7Controller.set('content.controllerName', 'installerController');
      installerStep7Controller.mySQLWarningHandler().onSecondary().onPrimary();
      expect(App.router.get('installerController').gotoStep.calledWith(5, true)).to.be.true;
    });

    it('user is moved to step2 on primary click on the second popup (addSeviceController)', function () {
      installerStep7Controller.set('content.controllerName', 'addServiceController');
      installerStep7Controller.mySQLWarningHandler().onSecondary().onPrimary();
      expect(App.router.get('addSeviceController').gotoStep.calledWith(2, true)).to.be.true;
    });

  });

});

});

;require.register("test/controllers/wizard/step8_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var modelSetup = require('test/init_model_test');
require('utils/ajax/ajax_queue');
require('controllers/main/admin/security');
require('controllers/main/service/info/configs');
require('controllers/wizard/step8_controller');
var installerStep8Controller, configurationController;

describe('App.WizardStep8Controller', function () {

  var configs = Em.A([
    Em.Object.create({filename: 'hdfs-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hdfs-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hue-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hue-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'mapred-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'mapred-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'yarn-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'yarn-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'capacity-scheduler.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'mapred-queue-acls.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hbase-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hbase-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'oozie-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'oozie-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'hive-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'hive-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'pig-properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'webhcat-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'webhcat-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'tez-site.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'tez-site.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'falcon-startup.properties.xml', name: 'p2', value: 'v2'}),
    Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p1', value: 'v1'}),
    Em.Object.create({filename: 'falcon-runtime.properties.xml', name: 'p2', value: 'v2'})
  ]);

  beforeEach(function () {
    installerStep8Controller = App.WizardStep8Controller.create({
      configs: configs
    });
    configurationController = App.MainServiceInfoConfigsController.create({});
  });

  var siteObjTests = Em.A([
    {name: 'createHdfsSiteObj', e: {type: 'hdfs-site', tag: 'version1', l: 2}},
    {name: 'createHueSiteObj', e: {type: 'hue-site', tag: 'version1', l: 2}},
    {name: 'createMrSiteObj', e: {type: 'mapred-site', tag: 'version1', l: 2}},
    {name: 'createYarnSiteObj', e: {type: 'yarn-site', tag: 'version1', l: 2}},
    {name: 'createCapacityScheduler', e: {type: 'capacity-scheduler', tag: 'version1', l: 2}},
    {name: 'createMapredQueueAcls', e: {type: 'mapred-queue-acls', tag: 'version1', l: 2}},
    {name: 'createHbaseSiteObj', e: {type: 'hbase-site', tag: 'version1', l: 2}},
    {name: 'createOozieSiteObj', e: {type: 'oozie-site', tag: 'version1', l: 2}},
    {name: 'createHiveSiteObj', e: {type: 'hive-site', tag: 'version1', l: 2}},
    {name: 'createWebHCatSiteObj', e: {type: 'webhcat-site', tag: 'version1', l: 2}},
    {name: 'createTezSiteObj', e: {type: 'tez-site', tag: 'version1', l: 2}},
    {name: 'createPigPropertiesSiteObj', e: {type: 'pig-properties', tag: 'version1', l: 1}},
    {name: 'createFalconStartupSiteObj', e: {type: 'falcon-startup.properties', tag: 'version1', l: 2}},
    {name: 'createFalconRuntimeSiteObj', e: {type: 'falcon-runtime.properties', tag: 'version1', l: 2}}
  ]);

  siteObjTests.forEach(function (test) {
    describe('#' + test.name, function () {

      it(test.name, function () {

        var siteObj = installerStep8Controller.createSiteObj(test.e.type, test.e.tag);
        expect(siteObj.tag).to.equal(test.e.tag);
        expect(Em.keys(siteObj.properties).length).to.equal(test.e.l);
      });

    });
  });

  describe('#createSelectedServicesData', function () {

    var tests = Em.A([
      {selectedServices: Em.A(['MAPREDUCE2']), e: 2},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN']), e: 5},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE']), e: 7},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE']), e: 9},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 12},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE']), e: 13},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE']), e: 14},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG']), e: 15},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON']), e: 17},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM']), e: 18},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ']), e: 19},
      {selectedServices: Em.A(['MAPREDUCE2', 'YARN', 'HBASE', 'OOZIE', 'HIVE', 'HUE', 'PIG', 'FALCON', 'STORM', 'TEZ', 'ZOOKEEPER']), e: 21}
    ]);

    tests.forEach(function (test) {
      it(test.selectedServices.join(','), function () {
        var services = test.selectedServices.map(function (serviceName) {
          return Em.Object.create({isSelected: true, isInstalled: false, serviceName: serviceName});
        });
        installerStep8Controller = App.WizardStep8Controller.create({
          content: {controllerName: 'addServiceController', services: services},
          configs: configs
        });
        var serviceData = installerStep8Controller.createSelectedServicesData();
        expect(serviceData.mapProperty('ServiceInfo.service_name')).to.eql(test.selectedServices.toArray());
        installerStep8Controller.clearStep();
      });
    });

  });

  describe('#getRegisteredHosts', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: ['h1'],
        m: 'Two hosts, one registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2'})
        },
        e: [],
        m: 'Two hosts, zero registered'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1'}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2'})
        },
        e: ['h1', 'h2'],
        m: 'Two hosts, two registered'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHosts = installerStep8Controller.getRegisteredHosts();
        expect(registeredHosts.mapProperty('hostName').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#createRegisterHostData', function () {

    var tests = Em.A([
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h1', 'h2'],
        m: 'two registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'one registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: false})
        },
        e: ['h2'],
        m: 'two registered, one isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'OTHER', name: 'h1', isInstalled: false}),
          h2: Em.Object.create({bootStatus: 'OTHER', name: 'h2', isInstalled: false})
        },
        e: [],
        m: 'zero registered, two isInstalled false'
      },
      {
        hosts: {
          h1: Em.Object.create({bootStatus: 'REGISTERED', name: 'h1', isInstalled: true}),
          h2: Em.Object.create({bootStatus: 'REGISTERED', name: 'h2', isInstalled: true})
        },
        e: [],
        m: 'two registered, zeto insInstalled false'
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        installerStep8Controller.set('content', Em.Object.create({hosts: test.hosts}));
        var registeredHostData = installerStep8Controller.createRegisterHostData();
        expect(registeredHostData.mapProperty('Hosts.host_name').toArray()).to.eql(test.e);
      });
    });

  });

  describe('#clusterName', function () {
    it('should be equal to content.cluster.name', function () {
      installerStep8Controller.set('content', {cluster: {name: 'new_name'}});
      expect(installerStep8Controller.get('clusterName')).to.equal('new_name');
    });
  });

  describe('#createCoreSiteObj', function () {
    it('should return config', function () {
      var content = Em.Object.create({
        services: Em.A([
          Em.Object.create({
            serviceName: 's1',
            isSelected: true,
            isInstalled: false
          }),
          Em.Object.create({
            serviceName: 's2',
            isSelected: true,
            isInstalled: false
          }),
          Em.Object.create({
            serviceName: 's3',
            isSelected: true,
            isInstalled: false
          }),
          Em.Object.create({
            serviceName: 'GLUSTERFS',
            isSelected: false,
            isInstalled: true,
            configTypesRendered: {hdfs:'tag1'}
          })
        ])
      });
      var installedServices = content.services.filterProperty('isInstalled', true);
      var selectedServices = content.services.filterProperty('isSelected', true);
      installerStep8Controller.set('content', content);
      installerStep8Controller.set('installedServices', installedServices);
      installerStep8Controller.set('selectedServices', selectedServices);
      installerStep8Controller.set('configs', Em.A([
        Em.Object.create({
          name: 'fs_glusterfs_default_name',
          filename: 'core-site.xml',
          value: 'value',
          overrides: Em.A([
            Em.Object.create({
              value: '4',
              hosts: Em.A(['h1','h2'])
            })
          ])
        }),
        Em.Object.create({
          name: 'fs.defaultFS',
          filename: 'core-site.xml',
          value: 'value',
          overrides: Em.A([
            Em.Object.create({
              value: '4',
              hosts: Em.A(['h1','h2'])
            })
          ])
        }),
        Em.Object.create({
          name: 'glusterfs_defaultFS_name',
          filename: 'core-site.xml',
          value: 'value',
          overrides: Em.A([
            Em.Object.create({
              value: '4',
              hosts: Em.A(['h1','h2'])
            })
          ])
        })
      ]));
      var expected = {
        "type": "core-site",
        "tag": "version1",
        "properties": {
          "fs_glusterfs_default_name": "value",
          "fs.defaultFS": "value",
          "glusterfs_defaultFS_name": "value"
        }
      };

      expect(installerStep8Controller.createCoreSiteObj()).to.eql(expected);
    });
  });

  describe('#createConfigurationGroups', function () {
    beforeEach(function() {
      sinon.stub(App.router,'get').returns(Em.Object.create({
        getDBProperty: function() {
          return Em.A([
            Em.Object.create({
              value: 1
            })
          ]);
        },
        getConfigAttributes: function() {
          return Em.A(['atr']);
        },
        createSiteObj: App.MainServiceInfoConfigsController.create({}).createSiteObj.bind(App.MainServiceInfoConfigsController.create({}))
      }));
    });
    afterEach(function() {
      App.router.get.restore();
    });
    it('should push group in properties', function () {
      var content = Em.Object.create({
        configGroups: Em.A([
          Em.Object.create({
            isDefault: true,
            service: Em.Object.create({
              id: 1
            }),
            name: 'n1',
            description: 'describe',
            hosts: ['h1', 'h2'],
            properties: Em.A([
              Em.Object.create({
                value: 'p1',
                filename: 'file.xml'
              }),
              Em.Object.create({
                value: 'p2',
                filename: 'file1.xml'
              })
            ])
          }),
          Em.Object.create({
            isDefault: false,
            service: Em.Object.create({
              id: 2
            }),
            name: 'n2',
            hosts: ['h3', 'h4'],
            description: 'describe1',
            properties: Em.A([
              Em.Object.create({
                value: 'p3',
                filename: 'file2.xml'
              }),
              Em.Object.create({
                value: 'p4',
                filename: 'file3.xml'
              })
            ])
          })
        ])
      });
      var defaultGroups = Em.A([
        Em.Object.create({
          group: 'n2',
          filename: 'file5.xml'
        }),
        Em.Object.create({
          group: 'n1',
          filename: 'file4.xml'
        })
      ]);
      installerStep8Controller.set('content', content);
      installerStep8Controller.set('clusterName', 'name');
      installerStep8Controller.set('customNonDefaultGroupConfigs', defaultGroups);
      installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
      installerStep8Controller.get('ajaxRequestsQueue').clear();
      installerStep8Controller.createConfigurationGroups();
      var expected = [
        {
          "value": "p3",
          "filename": "file2.xml"
        },
        {
          "value": "p4",
          "filename": "file3.xml"
        },
        {
          "group": "n2",
          "filename": "file5.xml"
        }
      ];
      var result = JSON.parse(JSON.stringify(content.configGroups[1].properties));
      expect(result).to.eql(expected);
    });
  });

  describe('#isConfigsChanged', function () {
    it('should return true if config changed', function () {
      var properties = Em.Object.create({
        property:true,
        property1: Em.Object.create({
          hasInitialValue: false,
          isNotDefaultValue: false
        })
      });
      var configs = Em.A([Em.Object.create({
        name: 'property'
      })]);
      expect(installerStep8Controller.isConfigsChanged(properties,configs)).to.be.true;
    });
  });

  describe('#loadServices', function () {
    it('should load services', function () {
      var services = Em.A([
        Em.Object.create({
          serviceName: 's1',
          isSelected: true,
          displayNameOnSelectServicePage: 's01',
          isClientOnlyService: false,
          serviceComponents: Em.A([
            Em.Object.create({
              isClient: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        }),
        Em.Object.create({
          serviceName: 's2',
          isSelected: true,
          displayNameOnSelectServicePage: 's02',
          serviceComponents: Em.A([
            Em.Object.create({
              isMaster: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        }),
        Em.Object.create({
          serviceName: 's3',
          isSelected: true,
          displayNameOnSelectServicePage: 's03',
          serviceComponents: Em.A([
            Em.Object.create({
              isHAComponentOnly: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        }),
        Em.Object.create({
          serviceName: 's4',
          isSelected: true,
          displayNameOnSelectServicePage: 's03',
          isClientOnlyService: true,
          serviceComponents: Em.A([
            Em.Object.create({
              isClient: true
            })
          ]),
          isHiddenOnSelectServicePage: false
        })
      ]);
      var selectedServices = services.filterProperty('isSelected');
      var slaveComponentHosts = Em.A([
        Em.Object.create({
          componentName: 'CLIENT',
          hostName: 'h1',
          hosts: Em.A([
            Em.Object.create({hostName: 'h1', isInstalled: true}),
            Em.Object.create({hostName: 'h2', isInstalled: false})
          ])
        })
      ]);
      var content = Em.Object.create({
        services: services,
        selectedServices: selectedServices,
        slaveComponentHosts: slaveComponentHosts,
        hosts: Em.A([
          Em.Object.create({hostName: 'h1', isInstalled: true}),
          Em.Object.create({hostName: 'h2', isInstalled: false})
        ])
      });
      installerStep8Controller.set('content', content);
      installerStep8Controller.set('services', Em.A([]));
      installerStep8Controller.reopen({selectedServices: selectedServices});
      installerStep8Controller.loadServices();
      var expected = [
        {
          "service_name": "s1",
          "display_name": "s01",
          "service_components": []
        },
        {
          "service_name": "s2",
          "display_name": "s02",
          "service_components": []
        },
        {
          "service_name": "s3",
          "display_name": "s03",
          "service_components": []
        },
        {
          "service_name": "s4",
          "display_name": "s03",
          "service_components": [
            {
              "component_name": "CLIENT",
              "display_name": "Clients",
              "component_value": "2 hosts"
            }
          ]
        }
      ];
      var result = JSON.parse(JSON.stringify(installerStep8Controller.get('services')));
      expect(result).to.be.eql(expected);
    });
  });

  describe('#removeClientsFromList', function () {
    it('should remove h1', function () {
      installerStep8Controller.set('content', Em.Object.create({
        hosts: Em.Object.create({
          h1: Em.Object.create({
            hostName: 'h1',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({HostRoles: Em.Object.create({component_name: "h1"})})])
          }),
          h2: Em.Object.create({
            hostName: 'h2',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({HostRoles: Em.Object.create({component_name: "h2"})})])
          })
        })
      }));
      var hostList = Em.A(['h1','h2']);
      installerStep8Controller.removeClientsFromList('h1', hostList);
      expect(JSON.parse(JSON.stringify(hostList))).to.eql(["h2"]);
    });
  });

  describe('#createSlaveAndClientsHostComponents', function () {
    it('should return non install object', function () {
      installerStep8Controller.set('content', Em.Object.create({
        masterComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            component: 'HBASE_MASTER',
            hostName: 'h1'
          })
        ]),
        slaveComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            hostName: 'h1',
            hosts: Em.A([
              Em.Object.create({hostName: 'h1', isInstalled: true}),
              Em.Object.create({hostName: 'h2', isInstalled: false})
            ])
          }),
          Em.Object.create({
            componentName: 'CLIENT1',
            hostName: 'h1',
            hosts: Em.A([
              Em.Object.create({hostName: 'h1', isInstalled: true}),
              Em.Object.create({hostName: 'h2', isInstalled: false})
            ])

          })
        ]),
        clients: Em.A([
          Em.Object.create({
            isInstalled: false
          })
        ]),
        services: Em.A([
          Em.Object.create({
            isInstalled: true,
            serviceName: "name",
            isClient: true
          })
        ]),
        hosts: Em.Object.create({
          h1: Em.Object.create({
            hostName: 'h1',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({})])
          }),
          h2: Em.Object.create({
            hostName: 'h2',
            isInstalled: false,
            hostComponents: Em.A([Em.Object.create({})])
          })
        }),
        additionalClients: Em.A([{hostNames: "name", componentName: "client"}])
      }));
      installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
      installerStep8Controller.get('ajaxRequestsQueue').clear();
      installerStep8Controller.createSlaveAndClientsHostComponents();
      expect(installerStep8Controller.get('content.clients')[0].isInstalled).to.be.false;
    });
  });

  describe('#createAdditionalClientComponents', function () {
    it('should bes equal to content.cluster.name', function () {
      installerStep8Controller.set('content', Em.Object.create({
        masterComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            component: 'HBASE_MASTER',
            hostName: 'h1'
          })
        ]),
        slaveComponentHosts: Em.A([
          Em.Object.create({
            componentName: 'CLIENT',
            hostName: 'h1',
            hosts: Em.A([
              Em.Object.create({hostName: 'h1', isInstalled: true}),
              Em.Object.create({hostName: 'h2', isInstalled: false})
            ])
          })
        ]),
        clients: Em.A([
          Em.Object.create({
            isInstalled: false
          })
        ]),
        services: Em.A([
          Em.Object.create({
            isInstalled: true,
            serviceName: "name",
            isClient: true
          })
        ]),
        hosts: Em.Object.create({
          h1: Em.Object.create({
            hostName: 'h1',
            isInstalled: true,
            hostComponents: Em.A([Em.Object.create({})])
          }),
          h2: Em.Object.create({
            hostName: 'h2',
            isInstalled: false,
            hostComponents: Em.A([Em.Object.create({})])
          })
        }),
        additionalClients: Em.A([{hostNames: "name", componentName: "client"}])
      }));
      installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
      installerStep8Controller.get('ajaxRequestsQueue').clear();
      installerStep8Controller.createAdditionalClientComponents();
      var result = [
        {
          "hostNames": "name",
          "componentName": "client"
        }
      ];
      var expected = installerStep8Controller.get('content.additionalClients');
      expect(JSON.parse(JSON.stringify(expected))).to.eql(result);
    });
  });

  describe('#assignComponentHosts', function () {
    it('should return host name', function () {
      var component = Em.Object.create({
        isMaster: true,
        componentName: 'HBASE_MASTER',
        hostName: 'h1'
      });
      installerStep8Controller.set('content', Em.Object.create({
        masterComponentHosts:Em.A([
          Em.Object.create({component: 'HBASE_MASTER', hostName: 'h1'})
      ])}));
      var res = installerStep8Controller.assignComponentHosts(component);
      expect(res).to.equal("h1");
    });
    it('should return number of hosts', function () {
      var component = Em.Object.create({
        componentName: 'HBASE_MASTER',
        isClient: false,
        hostName: 'h1'
      });
      installerStep8Controller.set('content', Em.Object.create({
        slaveComponentHosts:Em.A([
          Em.Object.create({
            componentName: 'HBASE_MASTER',
            hostName: 'h1',
            hosts: [
              {hostName: 'h1'},
              {hostName: 'h2'}
            ]
          })
      ])}));
      var res = installerStep8Controller.assignComponentHosts(component);
      expect(res).to.equal("2 hosts");
    });
  });

  describe('#loadClusterInfo', function () {
    beforeEach(function () {
      sinon.stub(App.Stack, 'find', function(){
        return Em.A([
          Em.Object.create({isSelected: false, hostName: 'h1'}),
          Em.Object.create({
            isSelected: true,
            hostName: 'h2',
            operatingSystems: Em.A([Em.Object.create({
              name:'windows',
              isSelected: true,
              repositories: Em.A([Em.Object.create({
                baseUrl: "url",
                osType: "2",
                repoId: "3"
              })])
            })])
          }),
          Em.Object.create({isSelected: false, hostName: 'h3'})
        ]);
      });
    });
    afterEach(function () {
      App.Stack.find.restore();
    });
    it('should return config with display_name', function () {
      installerStep8Controller.set('clusterInfo', Em.A([]));
      installerStep8Controller.loadClusterInfo();
      var res = [{
        "config_name":"cluster",
        "display_name":"Cluster Name"
      },{
        "config_name":"hosts",
        "display_name":"Total Hosts",
        "config_value":"0 (0 new)"
      }];
      var calcRes = JSON.parse(JSON.stringify(installerStep8Controller.get('clusterInfo')));
      expect(calcRes).to.eql(res);
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(installerStep8Controller, 'clearStep', Em.K);
      sinon.stub(installerStep8Controller, 'formatProperties', Em.K);
      sinon.stub(installerStep8Controller, 'loadConfigs', Em.K);
      sinon.stub(installerStep8Controller, 'loadClusterInfo', Em.K);
      sinon.stub(installerStep8Controller, 'loadServices', Em.K);
      installerStep8Controller.set('content', {controllerName: 'installerController'});
    });
    afterEach(function () {
      installerStep8Controller.clearStep.restore();
      installerStep8Controller.formatProperties.restore();
      installerStep8Controller.loadConfigs.restore();
      installerStep8Controller.loadClusterInfo.restore();
      installerStep8Controller.loadServices.restore();
    });
    it('should call clearStep', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadClusterInfo', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadClusterInfo.calledOnce).to.equal(true);
    });
    it('should call loadServices', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call formatProperties if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadServices.calledOnce).to.equal(true);
    });
    it('should call loadConfigs if content.serviceConfigProperties is true', function () {
      installerStep8Controller.set('content.serviceConfigProperties', true);
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.loadConfigs.calledOnce).to.equal(true);
    });
    it('should set isSubmitDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled to false', function () {
      installerStep8Controller.loadStep();
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
  });

  describe('#getRegisteredHosts', function() {
    Em.A([
        {
          hosts: {},
          m: 'no content.hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: ''},
            h2:{bootStatus: ''}
          },
          m: 'no registered hosts',
          e: []
        },
        {
          hosts: {
            h1:{bootStatus: 'REGISTERED', hostName: '', name: 'n1'},
            h2:{bootStatus: 'REGISTERED', hostName: '', name: 'n2'}
          },
          m: 'registered hosts available',
          e: ['n1', 'n2']
        }
      ]).forEach(function(test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {hosts: test.hosts});
          var hosts = installerStep8Controller.getRegisteredHosts();
          expect(hosts.mapProperty('hostName')).to.eql(test.e);
        });
      });
  });

  describe('#loadRepoInfo', function() {

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('currentStackName').returns('HDP');
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.stub(App.StackVersion, 'find', function() {
        return [
          Em.Object.create({state: 'CURRENT', repositoryVersion: {repositoryVersion: '2.3.0.0-2208'}})
        ];
      });
    });

    afterEach(function () {
      App.ajax.send.restore();
      App.get.restore();
      App.StackVersion.find.restore();
    });
    it('should use current StackVersion', function() {
      installerStep8Controller.loadRepoInfo();
      var data = App.ajax.send.args[0][0].data;
      expect(data).to.eql({stackName: 'HDP', repositoryVersion: '2.3.0.0-2208'});
    });
  });

  describe('#loadRepoInfoSuccessCallback', function () {
    beforeEach(function () {
      installerStep8Controller.set('clusterInfo', Em.Object.create({}));
    });

    it('should assert error if no data returned from server', function () {
      expect(function () {
        installerStep8Controller.loadRepoInfoSuccessCallback({items: []});
      }).to.throw(Error);
    });

    Em.A([
      {
        m: 'Normal JSON',
        e: {
          base_url: ['baseurl1', 'baseurl2'],
          os_type: ['redhat6', 'suse11'],
          repo_id: ['HDP-2.3', 'HDP-UTILS-1.1.0.20']
        },
        items: [
          {
            repository_versions: [
              {
                operating_systems: [
                  {
                    repositories: [
                      {
                        Repositories: {
                          base_url: 'baseurl1',
                          os_type: 'redhat6',
                          repo_id: 'HDP-2.3'
                        }
                      }
                    ]
                  },
                  {
                    repositories: [
                      {
                        Repositories: {
                          base_url: 'baseurl2',
                          os_type: 'suse11',
                          repo_id: 'HDP-UTILS-1.1.0.20'
                        }
                      }
                    ]
                  }
                ]
              }
            ]
          }
        ]
      }
    ]).forEach(function (test) {

      it(test.m, function () {
        installerStep8Controller.loadRepoInfoSuccessCallback({items: test.items});
        expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('base_url')).to.eql(test.e.base_url);
        expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('os_type')).to.eql(test.e.os_type);
        expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('repo_id')).to.eql(test.e.repo_id);
      });

    });

    /*Em.A([
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'only redhat5',
          e: {
            base_url: ['url1'],
            os_type: ['redhat5']
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'redhat5, redhat6',
          e: {
            base_url: ['url1', 'url2'],
            os_type: ['redhat5', 'redhat6']
          }
        },
        {
          items: [
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat5',
                    base_url: 'url1'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'redhat6',
                    base_url: 'url2'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            },
            {
              repositories: [
                {
                  Repositories: {
                    os_type: 'sles11',
                    base_url: 'url3'
                  }
                }
              ],
              OperatingSystems: {
                is_type: ''
              }
            }
          ],
          m: 'redhat5, redhat6, sles11',
          e: {
            base_url: ['url1', 'url2', 'url3'],
            os_type: ['redhat5', 'redhat6', 'sles11']
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.loadRepoInfoSuccessCallback({items: test.items});
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('base_url')).to.eql(test.e.base_url);
          expect(installerStep8Controller.get('clusterInfo.repoInfo').mapProperty('os_type')).to.eql(test.e.os_type);
        });
      });*/
  });

  describe('#loadRepoInfoErrorCallback', function() {
    it('should set [] to repoInfo', function() {
      installerStep8Controller.set('clusterInfo', Em.Object.create({repoInfo: [{}, {}]}));
      installerStep8Controller.loadRepoInfoErrorCallback({});
      expect(installerStep8Controller.get('clusterInfo.repoInfo.length')).to.eql(0);
    });
  });

  describe('#loadHbaseMasterValue', function () {
    Em.A([
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'one host',
          e: 'h1'
        },
        {
          masterComponentHosts: [{component: 'HBASE_MASTER', hostName: 'h1'}, {component: 'HBASE_MASTER', hostName: 'h2'}, {component: 'HBASE_MASTER', hostName: 'h3'}],
          component: Em.Object.create({component_name: 'HBASE_MASTER'}),
          m: 'many hosts',
          e: 'h1 ' + Em.I18n.t('installer.step8.other').format(2)
        }
      ]).forEach(function (test) {
        it(test.m, function() {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadHbaseMasterValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#loadZkServerValue', function() {
    Em.A([
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: '1 host',
          e: '1 host'
        },
        {
          masterComponentHosts: [{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'},{component: 'ZOOKEEPER_SERVER'}],
          component: Em.Object.create({component_name: 'ZOOKEEPER_SERVER'}),
          m: 'many hosts',
          e: '3 hosts'
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          installerStep8Controller.set('content', {masterComponentHosts: test.masterComponentHosts});
          installerStep8Controller.loadZkServerValue(test.component);
          expect(test.component.component_value).to.equal(test.e);
        });
      });
  });

  describe('#submit', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'submitProceed', Em.K);
      sinon.stub(installerStep8Controller, 'showRestartWarnings').returns($.Deferred().resolve().promise());
      sinon.stub(App.get('router.mainAdminKerberosController'), 'getKDCSessionState', Em.K);
    });
    afterEach(function() {
      installerStep8Controller.submitProceed.restore();
      installerStep8Controller.showRestartWarnings.restore();
      App.set('isKerberosEnabled', false);
      App.get('router.mainAdminKerberosController').getKDCSessionState.restore();
    });
    it('AddServiceController Kerberos enabled', function () {
      installerStep8Controller.reopen({
        isSubmitDisabled: false,
        content: {controllerName: 'addServiceController'}
      });
      installerStep8Controller.submit();
      expect(App.get('router.mainAdminKerberosController').getKDCSessionState.called).to.equal(true);
    });
    it('shouldn\'t do nothing if isSubmitDisabled is true', function() {
      installerStep8Controller.reopen({isSubmitDisabled: true});
      installerStep8Controller.submit();
      expect(App.get('router.mainAdminKerberosController').getKDCSessionState.called).to.equal(false);
      expect(installerStep8Controller.submitProceed.called).to.equal(false);
    });
  });

  describe('#getExistingClusterNamesSuccessCallBack', function() {
    it('should set clusterNames received from server', function() {
      var data = {
          items:[
            {Clusters: {cluster_name: 'c1'}},
            {Clusters: {cluster_name: 'c2'}},
            {Clusters: {cluster_name: 'c3'}}
          ]
        },
        clasterNames = ['c1','c2','c3'];
      installerStep8Controller.getExistingClusterNamesSuccessCallBack(data);
      expect(installerStep8Controller.get('clusterNames')).to.eql(clasterNames);
    });
  });

  describe('#getExistingClusterNamesErrorCallback', function() {
    it('should set [] to clusterNames', function() {
      installerStep8Controller.set('clusterNames', ['c1', 'c2']);
      installerStep8Controller.getExistingClusterNamesErrorCallback();
      expect(installerStep8Controller.get('clusterNames')).to.eql([]);
    });
  });

  describe('#deleteClusters', function() {

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    it('should call App.ajax.send for each provided clusterName', function() {
      var clusterNames = ['h1', 'h2', 'h3'];
      installerStep8Controller.deleteClusters(clusterNames);
      expect(App.ajax.send.callCount).to.equal(clusterNames.length);
      clusterNames.forEach(function(n, i) {
        expect(App.ajax.send.getCall(i).args[0].data).to.eql({name: n, isLast: i == clusterNames.length - 1});
      });
    });

    it('should clear cluster delete error popup body views', function () {
      installerStep8Controller.deleteClusters([]);
      expect(installerStep8Controller.get('clusterDeleteErrorViews')).to.eql([]);
    });

  });

  describe('#createSelectedServicesData', function() {
    it('should reformat provided data', function() {
      var selectedServices = [
        Em.Object.create({serviceName: 's1'}),
        Em.Object.create({serviceName: 's2'}),
        Em.Object.create({serviceName: 's3'})
      ];
      var expected = [
        {"ServiceInfo": { "service_name": 's1' }},
        {"ServiceInfo": { "service_name": 's2' }},
        {"ServiceInfo": { "service_name": 's3' }}
      ];
      installerStep8Controller.reopen({selectedServices: selectedServices});
      var createdData = installerStep8Controller.createSelectedServicesData();
      expect(createdData).to.eql(expected);
    });
  });

  describe('#createRegisterHostData', function() {
    it('should return empty data if no hosts', function() {
      sinon.stub(installerStep8Controller, 'getRegisteredHosts', function() {return [];});
      expect(installerStep8Controller.createRegisterHostData()).to.eql([]);
      installerStep8Controller.getRegisteredHosts.restore();
    });
    it('should return computed data', function() {
      var data = [
        {isInstalled: false, hostName: 'h1'},
        {isInstalled: true, hostName: 'h2'},
        {isInstalled: false, hostName: 'h3'}
      ];
      var expected = [
        {"Hosts": { "host_name": 'h1'}},
        {"Hosts": { "host_name": 'h3'}}
      ];
      sinon.stub(installerStep8Controller, 'getRegisteredHosts', function() {return data;});
      expect(installerStep8Controller.createRegisterHostData()).to.eql(expected);
      installerStep8Controller.getRegisteredHosts.restore();
    });
  });

  describe('#createStormSiteObj', function() {
    it('should replace quote \'"\' to "\'" for some properties', function() {
      var configs = [
          {filename: 'storm-site.xml', value: ["a", "b"], name: 'storm.zookeeper.servers'}
        ],
        expected = {
          type: 'storm-site',
          tag: 'version1',
          properties: {
            'storm.zookeeper.servers': '[\'a\',\'b\']'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createStormSiteObj('version1')).to.eql(expected);
    });

    it('should not escape special characters', function() {
      var configs = [
          {filename: 'storm-site.xml', value: "abc\n\t", name: 'nimbus.childopts'},
          {filename: 'storm-site.xml', value: "a\nb", name: 'supervisor.childopts'},
          {filename: 'storm-site.xml', value: "a\t\tb", name: 'worker.childopts'}
        ],
        expected = {
          type: 'storm-site',
          tag: 'version1',
          properties: {
            'nimbus.childopts': 'abc\n\t',
            'supervisor.childopts': 'a\nb',
            'worker.childopts': 'a\t\tb'
          }
        };
      installerStep8Controller.reopen({configs: configs});
      expect(installerStep8Controller.createStormSiteObj('version1')).to.eql(expected);
    });
  });

  describe('#ajaxQueueFinished', function() {
    it('should call App.router.next', function() {
      sinon.stub(App.router, 'send', Em.K);
      installerStep8Controller.ajaxQueueFinished();
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });
  });

  describe('#addRequestToAjaxQueue', function() {
    describe('testMode = true', function() {
      before(function() {
        App.set('testMode', true);
      });
      after(function() {
        App.set('testMode', false);
      });
      it('shouldn\'t do nothing', function() {
        installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        installerStep8Controller.addRequestToAjaxQueue({});
        expect(installerStep8Controller.get('ajaxRequestsQueue.queue.length')).to.equal(0);
      });
    });
    describe('testMode = true', function() {
      before(function() {
        App.set('testMode', false);
      });
      it('should add request', function() {
        var clusterName = 'c1';
        installerStep8Controller.reopen({clusterName: clusterName});
        installerStep8Controller.set('ajaxRequestsQueue', App.ajaxQueue.create());
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        installerStep8Controller.addRequestToAjaxQueue({name:'name', data:{}});
        var request = installerStep8Controller.get('ajaxRequestsQueue.queue.firstObject');
        expect(request.error).to.equal('ajaxQueueRequestErrorCallback');
        expect(request.data.cluster).to.equal(clusterName);
      });
    });
  });

  describe('#ajaxQueueRequestErrorCallback', function() {
    var obj = Em.Object.create({
      registerErrPopup: Em.K,
      setStepsEnable: Em.K
    });
    beforeEach(function() {
      sinon.stub(App.router, 'get', function() {
        return obj;
      });
      sinon.spy(obj, 'registerErrPopup');
      sinon.spy(obj, 'setStepsEnable');
    });
    afterEach(function() {
      App.router.get.restore();
      obj.registerErrPopup.restore();
      obj.setStepsEnable.restore();
    });
    it('should set hasErrorOccurred true', function () {
      installerStep8Controller.set('hasErrorOccurred', false);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('hasErrorOccurred')).to.equal(true);
    });
    it('should set isSubmitDisabled false', function () {
      installerStep8Controller.set('isSubmitDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isSubmitDisabled')).to.equal(false);
    });
    it('should set isBackBtnDisabled false', function () {
      installerStep8Controller.set('isBackBtnDisabled', true);
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.equal(false);
    });
    it('should call setStepsEnable', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.setStepsEnable.calledOnce).to.equal(true);
    });
    it('should call registerErrPopup', function () {
      installerStep8Controller.ajaxQueueRequestErrorCallback({responseText: '{"message": ""}'});
      expect(obj.registerErrPopup.calledOnce).to.equal(true);
    });
  });

  describe('#removeInstalledServicesConfigurationGroups', function() {
    beforeEach(function() {
      sinon.stub(installerStep8Controller, 'deleteConfigurationGroup', Em.K);
    });
    afterEach(function() {
      installerStep8Controller.deleteConfigurationGroup.restore();
    });
    it('should call App.config.deleteConfigGroup for each received group', function() {
      var groups = [{}, {}, {}];
      installerStep8Controller.removeInstalledServicesConfigurationGroups(groups);
      expect(installerStep8Controller.deleteConfigurationGroup.callCount).to.equal(groups.length);
    });
  });

  describe('#applyInstalledServicesConfigurationGroup', function() {
    beforeEach(function() {
      sinon.stub($, 'ajax', function () {
        return {
          retry: function () {
            return {then: Em.K}
          }
        }
      });
      sinon.stub(App.router, 'get', function() {
        return configurationController;
      });
    });
    afterEach(function() {
      $.ajax.restore();
      App.router.get.restore();
    });
    it('should do ajax request for each config group', function() {
      var configGroups = [{ConfigGroup: {id:''}}, {ConfigGroup: {id:''}}];
      installerStep8Controller.applyInstalledServicesConfigurationGroup(configGroups);
      expect($.ajax.callCount).to.equal(configGroups.length);
    });
  });

  describe('#getExistingClusterNames', function() {
    beforeEach(function() {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function() {
      App.ajax.send.restore();
    });
    it('should do ajax request', function() {
      installerStep8Controller.getExistingClusterNames();
      expect(App.ajax.send.calledOnce).to.be.true;
    });
  });

  describe('Queued requests', function() {

    beforeEach(function() {
      installerStep8Controller.clearStep();
      sinon.spy(installerStep8Controller, 'addRequestToAjaxQueue');
    });

    afterEach(function() {
      installerStep8Controller.addRequestToAjaxQueue.restore();
    });

    describe('#createCluster', function() {

      it('shouldn\'t add request to queue if not installerController used', function() {
        installerStep8Controller.reopen({content: {controllerName: 'addServiceController'}});
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });

      it('App.currentStackVersion should be changed if localRepo selected', function() {
        App.set('currentStackVersion', 'HDP-1.1.1');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: true}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDPLocal-1.1.1' }})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(data.data);
      });

      it('App.currentStackVersion shouldn\'t be changed if localRepo ins\'t selected', function() {
        App.set('currentStackVersion', 'HDP-1.1.1');
        installerStep8Controller.reopen({content: {controllerName: 'installerController', installOptions: {localRepo: false}}});
        var data = {
          data: JSON.stringify({ "Clusters": {"version": 'HDP-1.1.1' }})
        };
        installerStep8Controller.createCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.eql(data.data);
      });

    });

    describe('#createSelectedServices', function() {

      it('shouldn\'t do nothing if no data', function() {
        sinon.stub(installerStep8Controller, 'createSelectedServicesData', function() {return [];});
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
        installerStep8Controller.createSelectedServicesData.restore();
      });

      it('should call addRequestToAjaxQueue with computed data', function() {
        var data = [
          {"ServiceInfo": { "service_name": 's1' }},
          {"ServiceInfo": { "service_name": 's2' }},
          {"ServiceInfo": { "service_name": 's3' }}
        ];
        sinon.stub(installerStep8Controller, 'createSelectedServicesData', function() {return data;});
        installerStep8Controller.createSelectedServices();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(JSON.stringify(data));
        installerStep8Controller.createSelectedServicesData.restore();
      });

    });

    describe('#registerHostsToCluster', function() {
      it('shouldn\'t do nothing if no data', function() {
        sinon.stub(installerStep8Controller, 'createRegisterHostData', function() {return [];});
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
        installerStep8Controller.createRegisterHostData.restore();
      });
      it('should call addRequestToAjaxQueue with computed data', function() {
        var data = [
          {"Hosts": { "host_name": 'h1'}},
          {"Hosts": { "host_name": 'h3'}}
        ];
        sinon.stub(installerStep8Controller, 'createRegisterHostData', function() {return data;});
        installerStep8Controller.registerHostsToCluster();
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(JSON.stringify(data));
        installerStep8Controller.createRegisterHostData.restore();
      });
    });

    describe('#registerHostsToComponent', function() {

      it('shouldn\'t do request if no hosts provided', function() {
        installerStep8Controller.registerHostsToComponent([]);
        expect(installerStep8Controller.addRequestToAjaxQueue.called).to.equal(false);
      });

      it('should do request if hostNames are provided', function() {
        var hostNames = ['h1', 'h2'],
          componentName = 'c1';
        installerStep8Controller.registerHostsToComponent(hostNames, componentName);
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(data.RequestInfo.query).to.equal('Hosts/host_name=h1|Hosts/host_name=h2');
        expect(data.Body.host_components[0].HostRoles.component_name).to.equal('c1');
      });

    });

    describe('#applyConfigurationsToCluster', function() {
      it('should call addRequestToAjaxQueue', function() {
        var serviceConfigTags = [
            {
              type: 'hdfs',
              tag: 'tag1',
              properties: [
                {},
                {}
              ]
            }
          ],
          data = '['+JSON.stringify({
            Clusters: {
              desired_config: [serviceConfigTags[0]]
            }
          })+']';
        installerStep8Controller.reopen({
          installedServices: [
              Em.Object.create({
                isSelected: true,
                isInstalled: false,
                configTypesRendered: {hdfs:'tag1'}
              })
            ], selectedServices: []
        });
        installerStep8Controller.applyConfigurationsToCluster(serviceConfigTags);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(data);
      });
    });

    describe('#applyConfigurationGroups', function() {
      it('should call addRequestToAjaxQueue', function() {
        var data = [{}, {}];
        installerStep8Controller.applyConfigurationGroups(data);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data).to.equal(JSON.stringify(data));
      });
    });

    describe('#newServiceComponentErrorCallback', function() {

      it('should add request for new component', function() {
        var serviceName = 's1',
          componentName = 'c1';
        installerStep8Controller.newServiceComponentErrorCallback({}, {}, '', {}, {serviceName: serviceName, componentName: componentName});
        var data = JSON.parse(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.data);
        expect(installerStep8Controller.addRequestToAjaxQueue.args[0][0].data.serviceName).to.equal(serviceName);
        expect(data.components[0].ServiceComponentInfo.component_name).to.equal(componentName);
      });

    });

    describe('#createAdditionalHostComponents', function() {

      beforeEach(function() {
        sinon.stub(installerStep8Controller, 'registerHostsToComponent', Em.K);
      });

      afterEach(function() {
        installerStep8Controller.registerHostsToComponent.restore();
      });

      it('should add components with isRequiredOnAllHosts == true (1)', function() {
        installerStep8Controller.reopen({
          getRegisteredHosts: function() {
            return [{hostName: 'h1'}, {hostName: 'h2'}];
          },
          content: {
            services: [
              Em.Object.create({
                serviceName: 'GANGLIA', isSelected: true, isInstalled: false, serviceComponents: [
                  Em.Object.create({
                    componentName: 'GANGLIA_MONITOR',
                    isRequiredOnAllHosts: true
                  }),
                  Em.Object.create({
                    componentName: 'GANGLIA_SERVER',
                    isRequiredOnAllHosts: false
                  })
                ]
              })
            ]
          }
        });
        installerStep8Controller.createAdditionalHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
      });

      it('should add components with isRequiredOnAllHosts == true (2)', function() {
        installerStep8Controller.reopen({
          getRegisteredHosts: function() {
            return [{hostName: 'h1', isInstalled: true}, {hostName: 'h2', isInstalled: false}];
          },
          content: {
            services: [
              Em.Object.create({
                serviceName: 'GANGLIA', isSelected: true, isInstalled: true, serviceComponents: [
                  Em.Object.create({
                    componentName: 'GANGLIA_MONITOR',
                    isRequiredOnAllHosts: true
                  }),
                  Em.Object.create({
                    componentName: 'GANGLIA_SERVER',
                    isRequiredOnAllHosts: false
                  })
                ]
              })
            ]
          }
        });
        installerStep8Controller.createAdditionalHostComponents();
        expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
        expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h2']);
        expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal('GANGLIA_MONITOR');
      });

      var newDatabases = [
        {name: 'New MySQL Database',
         component: 'MYSQL_SERVER'
        },
        {name: 'New PostgreSQL Database',
          component: 'POSTGRESQL_SERVER'
        }
      ];

      newDatabases.forEach(function (db) {
        it('should add {0}'.format(db.component), function() {
          installerStep8Controller.reopen({
            getRegisteredHosts: function() {
              return [{hostName: 'h1'}, {hostName: 'h2'}];
            },
            content: {
              masterComponentHosts: [
                {component: 'HIVE_SERVER', hostName: 'h1'},
                {component: 'HIVE_SERVER', hostName: 'h2'}
              ],
              services: [
                Em.Object.create({serviceName: 'HIVE', isSelected: true, isInstalled: false, serviceComponents: []})
              ],
              serviceConfigProperties: [
                {name: 'hive_database', value: db.name}
              ]
            }
          });
          installerStep8Controller.createAdditionalHostComponents();
          expect(installerStep8Controller.registerHostsToComponent.calledOnce).to.equal(true);
          expect(installerStep8Controller.registerHostsToComponent.args[0][0]).to.eql(['h1', 'h2']);
          expect(installerStep8Controller.registerHostsToComponent.args[0][1]).to.equal(db.component);
        });

      });

    });

    describe('#createNotification', function () {

      beforeEach(function () {
        var stub = sinon.stub(App, 'get');
        stub.withArgs('testMode').returns(false);
        installerStep8Controller.clearStep();
        installerStep8Controller.set('content', {controllerName: 'installerController'});
        installerStep8Controller.set('configs', [
          {name: 'create_notification', value: 'yes', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'ambari.dispatch.recipients', value: 'to@f.c', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.host', value: 'h', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.port', value: '25', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.from', value: 'from@f.c', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.starttls.enable', value: true, serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'mail.smtp.startssl.enable', value: false, serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'smtp_use_auth', value: 'true', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'ambari.dispatch.credential.username', value: 'usr', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'ambari.dispatch.credential.password', value: 'pwd', serviceName: 'MISC', filename: 'alert_notification'},
          {name: 'some_p', value: 'some_v', serviceName: 'MISC', filename: 'alert_notification'}
        ]);
        installerStep8Controller.get('ajaxRequestsQueue').clear();
        sinon.stub($, 'ajax', function () {return {complete: Em.K}});
      });

      afterEach(function () {
        App.get.restore();
        $.ajax.restore();
      });

      it('should add request to queue', function () {
        installerStep8Controller.createNotification();
        expect(installerStep8Controller.get('ajaxRequestsQueue.queue.length')).to.equal(1);
        installerStep8Controller.get('ajaxRequestsQueue').runNextRequest();
        expect($.ajax.calledOnce).to.be.true;
        expect($.ajax.args[0][0].url.contains('overwrite_existing=true')).to.be.true;
      });

      it('sent data should be valid', function () {

        installerStep8Controller.createNotification();
        var data = installerStep8Controller.get('ajaxRequestsQueue.queue')[0].data.data.AlertTarget;
        expect(data.global).to.be.true;
        expect(data.notification_type).to.equal('EMAIL');
        expect(data.alert_states).to.eql(['OK', 'WARNING', 'CRITICAL', 'UNKNOWN']);
        expect(data.properties['ambari.dispatch.recipients']).to.eql(['to@f.c']);
        expect(data.properties['mail.smtp.host']).to.equal('h');
        expect(data.properties['mail.smtp.port']).to.equal('25');
        expect(data.properties['mail.smtp.from']).to.equal('from@f.c');
        expect(data.properties['mail.smtp.starttls.enable']).to.equal(true);
        expect(data.properties['mail.smtp.startssl.enable']).to.equal(false);
        expect(data.properties['ambari.dispatch.credential.username']).to.equal('usr');
        expect(data.properties['ambari.dispatch.credential.password']).to.equal('pwd');
        expect(data.properties['some_p']).to.equal('some_v');

      });

    });

  });

  describe('#isAllClusterDeleteRequestsCompleted', function () {
    it('should depend on completed cluster delete requests number', function () {
      installerStep8Controller.setProperties({
        clusterDeleteRequestsCompleted: 0,
        clusterNames: ['c0']
      });
      expect(installerStep8Controller.get('isAllClusterDeleteRequestsCompleted')).to.be.false;
      installerStep8Controller.incrementProperty('clusterDeleteRequestsCompleted');
      expect(installerStep8Controller.get('isAllClusterDeleteRequestsCompleted')).to.be.true;
    });
  });

  describe('#deleteClusterSuccessCallback', function () {

    beforeEach(function () {
      sinon.stub(installerStep8Controller, 'showDeleteClustersErrorPopup', Em.K);
      sinon.stub(installerStep8Controller, 'startDeploy', Em.K);
      installerStep8Controller.setProperties({
        clusterDeleteRequestsCompleted: 0,
        clusterNames: ['c0', 'c1'],
        clusterDeleteErrorViews: []
      });
      installerStep8Controller.deleteClusterSuccessCallback();
    });

    afterEach(function () {
      installerStep8Controller.showDeleteClustersErrorPopup.restore();
      installerStep8Controller.startDeploy.restore();
    });

    it('no failed requests', function () {
      expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(1);
      expect(installerStep8Controller.showDeleteClustersErrorPopup.called).to.be.false;
      expect(installerStep8Controller.startDeploy.called).to.be.false;
      installerStep8Controller.deleteClusterSuccessCallback();
      expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(2);
      expect(installerStep8Controller.showDeleteClustersErrorPopup.called).to.be.false;
      expect(installerStep8Controller.startDeploy.calledOnce).to.be.true;
    });

    it('one request failed', function () {
      installerStep8Controller.deleteClusterErrorCallback({}, null, null, {});
      expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(2);
      expect(installerStep8Controller.showDeleteClustersErrorPopup.calledOnce).to.be.true;
      expect(installerStep8Controller.startDeploy.called).to.be.false;
    });

  });

  describe('#deleteClusterErrorCallback', function () {

    var request = {
        status: 500,
        responseText: '{"message":"Internal Server Error"}'
      },
      ajaxOptions = 'error',
      error = 'Internal Server Error',
      opt = {
        url: 'api/v1/clusters/c0',
        type: 'DELETE'
      };

    beforeEach(function () {
      installerStep8Controller.setProperties({
        clusterDeleteRequestsCompleted: 0,
        clusterNames: ['c0', 'c1'],
        clusterDeleteErrorViews: []
      });
      sinon.stub(installerStep8Controller, 'showDeleteClustersErrorPopup', Em.K);
      installerStep8Controller.deleteClusterErrorCallback(request, ajaxOptions, error, opt);
    });

    afterEach(function () {
      installerStep8Controller.showDeleteClustersErrorPopup.restore();
    });

    it('should show error popup only if all requests are completed', function () {
      expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(1);
      expect(installerStep8Controller.showDeleteClustersErrorPopup.called).to.be.false;
      installerStep8Controller.deleteClusterErrorCallback(request, ajaxOptions, error, opt);
      expect(installerStep8Controller.get('clusterDeleteRequestsCompleted')).to.equal(2);
      expect(installerStep8Controller.showDeleteClustersErrorPopup.calledOnce).to.be.true;
    });

    it('should create error popup body view', function () {
      expect(installerStep8Controller.get('clusterDeleteErrorViews')).to.have.length(1);
      expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.url')).to.equal('api/v1/clusters/c0');
      expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.type')).to.equal('DELETE');
      expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.status')).to.equal(500);
      expect(installerStep8Controller.get('clusterDeleteErrorViews.firstObject.message')).to.equal('Internal Server Error');
    });

  });

  describe('#showDeleteClustersErrorPopup', function () {

    beforeEach(function () {
      installerStep8Controller.setProperties({
        isSubmitDisabled: true,
        isBackBtnDisabled: true
      });
      sinon.stub(App.ModalPopup, 'show', Em.K);
      installerStep8Controller.showDeleteClustersErrorPopup();
    });

    afterEach(function () {
      App.ModalPopup.show.restore();
    });

    it('should show error popup and unlock navigation', function () {
      expect(installerStep8Controller.get('isSubmitDisabled')).to.be.false;
      expect(installerStep8Controller.get('isBackBtnDisabled')).to.be.false;
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });

  });

  describe('#startDeploy', function () {

    var stubbedNames = ['createCluster', 'createSelectedServices', 'updateConfigurations', 'createConfigurations',
        'applyConfigurationsToCluster', 'createComponents', 'registerHostsToCluster', 'createConfigurationGroups',
        'createMasterHostComponents', 'createSlaveAndClientsHostComponents', 'createAdditionalClientComponents',
        'createAdditionalHostComponents'],
      cases = [
        {
          controllerName: 'installerController',
          notExecuted: ['createAdditionalClientComponents', 'updateConfigurations'],
          fileNamesToUpdate: [],
          title: 'Installer, no configs to update'
        },
        {
          controllerName: 'addHostController',
          notExecuted: ['updateConfigurations', 'createConfigurations', 'applyConfigurationsToCluster', 'createAdditionalClientComponents'],
          title: 'Add Host Wizard'
        },
        {
          controllerName: 'addServiceController',
          notExecuted: ['updateConfigurations'],
          fileNamesToUpdate: [],
          title: 'Add Service Wizard, no configs to update'
        },
        {
          controllerName: 'addServiceController',
          notExecuted: [],
          fileNamesToUpdate: [''],
          title: 'Add Service Wizard, some configs to be updated'
        }
      ];

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('isKerberosEnabled').returns(false);
      stubbedNames.forEach(function (name) {
        sinon.stub(installerStep8Controller, name, Em.K);
      });
      installerStep8Controller.setProperties({
        serviceConfigTags: [],
        content: {
          controllerName: null
        }
      });
    });

    afterEach(function () {
      App.get.restore();
      stubbedNames.forEach(function (name) {
        installerStep8Controller[name].restore();
      });
      installerStep8Controller.get.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(installerStep8Controller, 'get')
          .withArgs('ajaxRequestsQueue').returns({
            start: Em.K
          })
          .withArgs('ajaxRequestsQueue.queue.length').returns(1)
          .withArgs('wizardController').returns({
            getDBProperty: function () {
              return item.fileNamesToUpdate;
            }
          })
          .withArgs('content.controllerName').returns(item.controllerName);
        installerStep8Controller.startDeploy();
        stubbedNames.forEach(function (name) {
          expect(installerStep8Controller[name].called).to.equal(!item.notExecuted.contains(name));
        });
      });
    });

  });

  describe('#getClientsMap', function () {

    var cases = [
      {
        flag: 'isMaster',
        result: {
          c8: ['c1', 'c2'],
          c9: ['c1', 'c2']
        },
        title: 'dependencies for masters'
      },
      {
        flag: 'isSlave',
        result: {
          c8: ['c5', 'c6'],
          c9: ['c5', 'c6']
        },
        title: 'dependencies for slaves'
      },
      {
        flag: 'isClient',
        result: {
          c8: ['c9', 'c10'],
          c9: ['c9', 'c10']
        },
        title: 'dependencies for clients'
      },
      {
        flag: null,
        result: {
          c8: ['c1', 'c2', 'c5', 'c6', 'c9', 'c10'],
          c9: ['c1', 'c2', 'c5', 'c6', 'c9', 'c10']
        },
        title: 'dependencies for all components'
      }
    ];

    before(function () {
      sinon.stub(App.StackServiceComponent, 'find').returns([
        Em.Object.create({
          componentName: 'c0',
          isMaster: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c1',
          isMaster: true,
          dependencies: [
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c2',
          isMaster: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c3',
          isMaster: true,
          dependencies: []
        }),
        Em.Object.create({
          componentName: 'c4',
          isSlave: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c5',
          isSlave: true,
          dependencies: [
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c6',
          isSlave: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c7',
          isSlave: true,
          dependencies: []
        }),
        Em.Object.create({
          componentName: 'c8',
          isClient: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c9',
          isClient: true,
          dependencies: [
            {
              componentName: 'c4'
            },
            {
              componentName: 'c5'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c10',
          isClient: true,
          dependencies: [
            {
              componentName: 'c1'
            },
            {
              componentName: 'c2'
            },
            {
              componentName: 'c8'
            },
            {
              componentName: 'c9'
            }
          ]
        }),
        Em.Object.create({
          componentName: 'c11',
          isClient: true,
          dependencies: []
        })
      ]);
    });

    after(function () {
      App.StackServiceComponent.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(installerStep8Controller.getClientsMap(item.flag)).to.eql(item.result);
      });
    });

  });

  describe('#showLoadingIndicator', function() {
    it('if popup doesn\'t exist should create another', function() {
      installerStep8Controller.set('isSubmitDisabled', true);
      sinon.spy(App.ModalPopup, 'show');
      installerStep8Controller.showLoadingIndicator();
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });

  });

});

});

;require.register("test/controllers/wizard/step9_test", function(exports, require, module) {
  /**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var Ember = require('ember');
var App = require('app');
require('models/stack_service_component');
require('models/hosts');
require('controllers/wizard');
require('controllers/installer');
require('controllers/wizard/step9_controller');
require('utils/helper');
require('utils/ajax/ajax');

var modelSetup = require('test/init_model_test');
var c, obj;
describe('App.InstallerStep9Controller', function () {

  beforeEach(function () {
    App.set('supports.skipComponentStartAfterInstall', false);
    modelSetup.setupStackServiceComponent();
    c = App.WizardStep9Controller.create({
      content: {controllerName: ''},
      saveClusterStatus: Em.K,
      saveInstalledHosts: Em.K,
      togglePreviousSteps: Em.K,
      setFinishState: Em.K,
      changeParseHostInfo: Em.K,
      parseHostInfoPolling: Em.K,
      wizardController: Em.Object.create({
        requestsId: [],
        cluster: {oldRequestsId: []},
        getDBProperty: function(name) {
          return this.get(name);
        }
      })
    });
    obj = App.InstallerController.create();
    sinon.stub(App.ajax, 'send', function() {
      return {
        then: function() { 
          return true;
        },
        retry: function() {
          return {
            then: Em.K,
            complete: Em.K
          };
        },
        complete: Em.K
      };
    });
  });

  afterEach(function () {
    modelSetup.cleanStackServiceComponent();
    App.ajax.send.restore();
  });

  describe('#isSubmitDisabled', function () {
    var tests = Em.A([
      {controllerName: 'addHostController', state: 'STARTED', e: false},
      {controllerName: 'addHostController', state: 'START_SKIPPED', e: false},
      {controllerName: 'addHostController', state: 'START FAILED', e: false},
      {controllerName: 'addHostController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addHostController', state: 'PENDING', e: true},
      {controllerName: 'addHostController', state: 'INSTALLED', e: true},
      {controllerName: 'addServiceController', state: 'STARTED', e: false},
      {controllerName: 'addServiceController', state: 'START_SKIPPED', e: false},
      {controllerName: 'addServiceController', state: 'START FAILED', e: false},
      {controllerName: 'addServiceController', state: 'INSTALL FAILED', e: false},
      {controllerName: 'addServiceController', state: 'PENDING', e: true},
      {controllerName: 'addServiceController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'STARTED', e: false},
      {controllerName: 'installerController', state: 'START_SKIPPED', e: false},
      {controllerName: 'installerController', state: 'START FAILED', e: false},
      {controllerName: 'installerController', state: 'INSTALL FAILED', e: true},
      {controllerName: 'installerController', state: 'INSTALLED', e: true},
      {controllerName: 'installerController', state: 'PENDING', e: true}
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({
        saveClusterStatus: Em.K,
        saveInstalledHosts: Em.K,
        content: {
          controllerName: test.controllerName,
          cluster: {
            status: test.state
          }
        }
      });
      it('controllerName is ' + test.controllerName + '; cluster status is ' + test.state + '; isSubmitDisabled should be ' + test.e, function () {
        expect(controller.get('isSubmitDisabled')).to.equal(test.e);
      });
    });

  });

  describe('#status', function () {
    var tests = Em.A([
      {
        hosts: [
          {status: 'failed'},
          {status: 'success'}
        ],
        isStepFailed: false,
        progress: '100',
        m: 'One host is failed',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is not failed',
        isStepFailed: false,
        progress: '100',
        e: 'warning'
      },
      {
        hosts: [
          {status: 'warning'},
          {status: 'success'}
        ],
        m: 'One host is failed and step is failed',
        isStepFailed: true,
        progress: '100',
        e: 'failed'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 100',
        isStepFailed: false,
        progress: '100',
        e: 'success'
      },
      {
        hosts: [
          {status: 'success'},
          {status: 'success'}
        ],
        m: 'All hosts are success and progress is 50',
        isStepFailed: false,
        progress: '50',
        e: 'info'
      }
    ]);
    tests.forEach(function (test) {
      var controller = App.WizardStep9Controller.create({
        saveClusterStatus: Em.K,
        saveInstalledHosts: Em.K,
        hosts: test.hosts,
        isStepFailed: function () {
          return test.isStepFailed
        },
        progress: test.progress
      });
      controller.updateStatus();
      it(test.m, function () {
        expect(controller.get('status')).to.equal(test.e);
      });
    });
  });

  describe('#showRetry', function () {
    it('cluster status is not INSTALL FAILED', function () {
      c.reopen({content: {cluster: {status: 'INSTALLED'}}});
      expect(c.get('showRetry')).to.equal(false);
    });
    it('cluster status is INSTALL FAILED', function () {
      c.reopen({content: {cluster: {status: 'INSTALL FAILED'}}});
      expect(c.get('showRetry')).to.equal(true);
    });
  });

  describe('#resetHostsForRetry', function () {
    it('All should have status "pending" and message "Waiting"', function () {
      var hosts = {'host1': Em.Object.create({status: 'failed', message: 'Failed'}), 'host2': Em.Object.create({status: 'success', message: 'Success'})};
      c.reopen({content: {hosts: hosts}});
      c.resetHostsForRetry();
      for (var name in hosts) {
        if (hosts.hasOwnProperty(name)) {
          expect(c.get('content.hosts')[name].get('status', 'pending')).to.equal('pending');
          expect(c.get('content.hosts')[name].get('message', 'Waiting')).to.equal('Waiting');
        }
      }
    });
  });

  describe('#setParseHostInfo', function () {
    var tasks = Em.A([
      Em.Object.create({
        Tasks: Em.Object.create({
          host_name: 'host1',
          status: 'PENDING'
        })
      }),
      Em.Object.create({
        Tasks: Em.Object.create({
          host_name: 'host1',
          status: 'PENDING'
        })
      })
    ]);
    var content = Em.Object.create({
      cluster: Em.Object.create({
        requestId: '11',
        status: 'PENDING'
      })
    });
    beforeEach(function(){
      c.set('content', content)
    });
    it('Should make parseHostInfo false"', function () {
      var polledData = Em.Object.create({
        tasks: tasks,
        Requests: Em.Object.create({
          id: '222'
        })
      });
      c.setParseHostInfo(polledData);
      expect(c.get('parseHostInfo')).to.be.false;
    });
    it('Should set polledData"', function () {
      var polledData = Em.Object.create({
        tasks: tasks,
        Requests: Em.Object.create({
          id: '11'
        })
      });
      c.setParseHostInfo(polledData);
      var expected = [
        {
          "Tasks": {
            "status": "PENDING",
            "host_name": "host1",
            "request_id": "11"
          }
        },
        {
          "Tasks": {
            "status": "PENDING",
            "host_name": "host1",
            "request_id": "11"
          }
        }
      ];
      var result = JSON.parse(JSON.stringify(c.get('polledData')));
      expect(result).to.eql(expected);
    });
    it('Should set progress for hosts"', function () {
      var polledData = Em.Object.create({
        tasks: tasks,
        Requests: Em.Object.create({
          id: '11'
        })
      });
      var hosts = Em.A([
        Em.Object.create({
          name: 'host1',
          logTasks: [
            {Tasks: {role: 'HDFS_CLIENT'}},
            {Tasks: {role: 'DATANODE'}}
          ],
          status: 'old_status',
          progress: '10',
          isNoTasksForInstall: true,
          e: {status: 'old_status', progress: '10'}
        }),
        Em.Object.create({
          name: 'host2',
          logTasks: [
            {Tasks: {role: 'HDFS_CLIENT'}}
          ],
          status: 'old_status',
          progress: '10',
          e: {status: 'success', progress: '100'}
        })
      ]);
      c.set('hosts', hosts);
      c.setParseHostInfo(polledData);
      var expected = [
        {
          "name": "host1",
          "logTasks": [
            {
              "Tasks": {
                "role": "HDFS_CLIENT",
                "status": "PENDING"
              }
            },
            {
              "Tasks": {
                "role": "DATANODE"
              }
            }
          ],
          "progress": "0",
          "isNoTasksForInstall": false,
          "e": {
            "status": "old_status",
            "progress": "10"
          },
          "status": "in_progress",
          "message": ""
        },
        {
          "name": "host2",
          "logTasks": [
            {
              "Tasks": {
                "role": "HDFS_CLIENT"
              }
            }
          ],
          "progress": "33",
          "e": {
            "status": "success",
            "progress": "100"
          },
          "status": "pending",
          "isNoTasksForInstall": true,
          "message": "Install complete (Waiting to start)"
        }
      ];

      var result = JSON.parse(JSON.stringify(c.get('hosts')));
      expect(result).to.eql(expected);
    });
  });

  var hosts_for_load_and_render = {
    'host1': {
      message: 'message1',
      status: 'unknown',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: 'REGISTERED'
    },
    'host2': {
      message: '',
      status: 'failed',
      progress: '1',
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host3': {
      message: '',
      status: 'waiting',
      progress: null,
      logTasks: [
        {},
        {}
      ],
      bootStatus: ''
    },
    'host4': {
      message: 'message4',
      status: null,
      progress: '10',
      logTasks: [
        {}
      ],
      bootStatus: 'REGISTERED'
    }
  };

  describe('#loadHosts', function () {

    beforeEach(function() {
      c.reopen({content: {hosts: hosts_for_load_and_render}});
      c.loadHosts();
    });

    it('Only REGISTERED hosts', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.length).to.equal(2);
    });
    it('All hosts have progress 0', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.everyProperty('progress', 0)).to.equal(true);
    });
    it('All hosts have progress 0', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.everyProperty('progress', 0)).to.equal(true);
    });
    it('All host don\'t have logTasks', function () {
      var loaded_hosts = c.get('hosts');
      expect(loaded_hosts.everyProperty('logTasks.length', 0)).to.equal(true);
    });
  });

  describe('#isServicesStarted', function () {
    it('Should return false when server not started', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'PENDING'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'PENDING'
          })
        })
      ]);
      expect(c.isServicesStarted(polledData)).to.be.false;
    });
    it('Should return true when server started', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        })
      ]);
      expect(c.isServicesStarted(polledData)).to.be.true;
    });
    it('Should return true when tasks completed', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'COMPLETED'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'COMPLETED'
          })
        })
      ]);
      expect(c.isServicesStarted(polledData)).to.be.true;
    });
  });

  describe('#setIsServicesInstalled', function () {
    it('Should return 100% completed', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        })
      ]);
      c.setProperties({
        status: 'failed',
        isPolling: true,
        hosts: Em.A([
          Em.Object.create({
            progress: 0
          })
        ])
      });
      c.setIsServicesInstalled(polledData);
      expect(c.get('progress')).to.equal('100');
      expect(c.get('isPolling')).to.be.false;
    });
    it('Should return 34% completed', function () {
      var polledData = Em.A([
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        }),
        Em.Object.create({
          Tasks: Em.Object.create({
            status: 'NONE'
          })
        })
      ]);
      c.setProperties({
        status: '',
        isPolling: true,
        hosts: Em.A([
          Em.Object.create({
            progress: 0
          })
        ]),
        content: Em.Object.create({
          controllerName: 'installerController'
        })
      });
      c.setIsServicesInstalled(polledData);
      expect(c.get('progress')).to.equal('34');
      expect(c.get('isPolling')).to.be.true;
    });
  });

  describe('#launchStartServices', function () {
    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves')
          return ["TASKTRACKER", "DATANODE", 
                  "JOURNALNODE", "ZKFC", 
                  "APP_TIMELINE_SERVER", 
                  "NODEMANAGER", 
                  "GANGLIA_MONITOR", 
                  "HBASE_REGIONSERVER", 
                  "SUPERVISOR", 
                  "FLUME_HANDLER"];
        return true;
      });
    });
    afterEach(function() {
      App.get.restore();
    });
    var tests = [
      {
        expected: [],
        message: 'should return query',
        controllerName: 'addHostController',
        hosts: Em.A([
          Em.Object.create({
            name: 'h1'
          }),
          Em.Object.create({
            name: 'h2'
          })
        ])
      },
      {
        expected: [],
        text: 'should return server info',
        controllerName: 'addServiceController',
        services: Em.A([
          Em.Object.create({
            serviceName: 'OOZIE',
            isSelected: true,
            isInstalled: false
          }),
          Em.Object.create({
            serviceName: 'h2',
            isSelected: false,
            isInstalled: true
          })
        ])
      },
      {
        expected: [],
        text: 'should return default data',
        controllerName: 'addHostContro',
        hosts: Em.A([
          Em.Object.create({
            name: 'h1'
          }),
          Em.Object.create({
            name: 'h2'
          })
        ])
      }
    ];
    tests.forEach(function(test) {
      it(test.message, function () {
        var content = Em.Object.create({
          controllerName: test.controllerName,
          services: test.services
        });
        var wizardController = Em.Object.create({
          getDBProperty: function() {
            return test.hosts
          }
        });
        c.set('content', content);
        c.set('wizardController', wizardController);
        expect(c.launchStartServices(function(){})).to.be.true;
      });
    })
  });

  describe('#hostHasClientsOnly', function () {
    var tests = Em.A([
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'old_status', progress: '10'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: false
      },
      {
        hosts: [
          Em.Object.create({
            hostName: 'host1',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}},
              {Tasks: {role: 'DATANODE'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          }),
          Em.Object.create({
            hostName: 'host2',
            logTasks: [
              {Tasks: {role: 'HDFS_CLIENT'}}
            ],
            status: 'old_status',
            progress: '10',
            e: {status: 'success', progress: '100'}
          })
        ],
        jsonError: true
      }
    ]);
    tests.forEach(function (test) {
      it('', function () {
        c.reopen({hosts: test.hosts});
        c.hostHasClientsOnly(test.jsonError);
        test.hosts.forEach(function (host) {
          expect(c.get('hosts').findProperty('hostName', host.hostName).get('status')).to.equal(host.e.status);
          expect(c.get('hosts').findProperty('hostName', host.hostName).get('progress')).to.equal(host.e.progress);
        });
      });
    });
  });

  describe('#onSuccessPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'success'},
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'success'},
        m: 'All Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'All Tasks COMPLETED and cluster status FAILED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        m: 'Not all Tasks COMPLETED and cluster status FAILED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({content: {cluster: {status: test.cluster.status}}});
        c.onSuccessPerHost(test.actions, test.host);
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#onErrorPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'pending'}),
        actions: [],
        e: {status: 'pending'},
        isMasterFailed: false,
        m: 'No tasks for host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'ABORTED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task ABORTED and cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'TIMEDOUT'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'warning'},
        isMasterFailed: false,
        m: 'One Task TIMEDOUT and cluster status INSTALLED'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'FAILED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'failed'},
        isMasterFailed: true,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed true'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({status: 'info'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {status: 'info'},
        isMasterFailed: false,
        m: 'One Task FAILED and cluster status PENDING isMasterFailed false'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({content: {cluster: {status: test.cluster.status}}, isMasterFailed: function () {
          return test.isMasterFailed;
        }});
        c.onErrorPerHost(test.actions, test.host);
        expect(test.host.status).to.equal(test.e.status);
      });
    });
  });

  describe('#isMasterFailed', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves')
          return ["TASKTRACKER", "DATANODE", "JOURNALNODE", "ZKFC", "APP_TIMELINE_SERVER", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    var tests = Em.A([
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'DATANODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'No one Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: true,
        m: 'One Master is failed'
      },
      {
        actions: [
          {Tasks: {command: 'PENDING', status: 'FAILED', role: 'NAMENODE'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'TASKTRACKER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'HBASE_REGIONSERVER'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'GANGLIA_MONITOR'}},
          {Tasks: {command: 'INSTALL', status: 'FAILED', role: 'SUPERVISOR'}}
        ],
        e: false,
        m: 'one Master is failed but command is not install'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        expect(c.isMasterFailed(test.actions)).to.equal(test.e);
      });
    });
  });

  describe('#onInProgressPerHost', function () {
    var tests = Em.A([
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: true},
        m: 'All Tasks COMPLETED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'IN_PROGRESS'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task IN_PROGRESS'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'QUEUED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task QUEUED'
      },
      {
        host: Em.Object.create({message: 'default_message'}),
        actions: [
          {Tasks: {status: 'PENDING'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: {message: 'default_message', b: false},
        m: 'One Task PENDING'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.onInProgressPerHost(test.actions, test.host);
        expect(test.host.message == test.e.message).to.equal(test.e.b);
      });
    });
  });

  describe('#progressPerHost', function () {
    var tests = Em.A([
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 2,
          'QUEUED': 2,
          'IN_PROGRESS': 1
        },
        e: {progress: 17},
        s: false,
        m: 'All types of status available. cluster status PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 33},
        s: false,
        m: 'No tasks available. cluster status PENDING'
      },
      {
        cluster: {status: 'PENDING'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 100},
        s: true,
        m: 'No tasks available. cluster status PENDING. skipComponentStartAfterInstall is true.'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 100},
        m: 'No tasks available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 2,
          'QUEUED': 2,
          'IN_PROGRESS': 1
        },
        e: {progress: 66},
        s: false,
        m: 'All types of status available. cluster status INSTALLED'
      },
      {
        cluster: {status: 'FAILED'},
        host: Em.Object.create({progress: 0}),
        actions: {},
        e: {progress: 100},
        s: false,
        m: 'Cluster status is not PENDING or INSTALLED'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 150,
          'QUEUED': 0,
          'IN_PROGRESS': 1
        },
        e: {progress: 99},
        s: false,
        m: '150 tasks on host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 498,
          'QUEUED': 1,
          'IN_PROGRESS': 1
        },
        e: {progress: 99},
        s: false,
        m: '500 tasks on host'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 150,
          'QUEUED': 0,
          'IN_PROGRESS': 0
        },
        e: {progress: 100},
        s: false,
        m: '100 tasks, 100 completed'
      },
      {
        cluster: {status: 'INSTALLED'},
        host: Em.Object.create({progress: 0}),
        actions: {
          'COMPLETED': 1,
          'QUEUED': 0,
          'IN_PROGRESS': 0
        },
        e: {progress: 100},
        s: false,
        m: '1 task, 1 completed'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        var actions = [];
        for (var prop in test.actions) {
          if (test.actions.hasOwnProperty(prop) && test.actions[prop]) {
            for (var i = 0; i < test.actions[prop]; i++) {
              actions.push({Tasks: {status: prop}});
            }
          }
        }
        c.reopen({content: {cluster: {status: test.cluster.status}}});
        App.set('supports.skipComponentStartAfterInstall', test.s);
        var progress = c.progressPerHost(actions, test.host);
        expect(progress).to.equal(test.e.progress);
        expect(test.host.progress).to.equal(test.e.progress.toString());
      });
    });
  });

  describe('#clearStep', function () {
    it('All to default values', function () {
      c.reopen({hosts: [{},{},{}]});
      c.clearStep();
      expect(c.get('hosts.length')).to.equal(0);
      expect(c.get('status')).to.equal('info');
      expect(c.get('progress')).to.equal('0');
      expect(c.get('numPolls')).to.equal(1);
    });
  });

  describe('#replacePolledData', function () {
    it('replacing polled data', function () {
      c.reopen({polledData: [{},{},{}]});
      var newPolledData = [{}];
      c.replacePolledData(newPolledData);
      expect(c.get('polledData.length')).to.equal(newPolledData.length);
    });
  });

  describe('#isSuccess', function () {
    var tests = Em.A([
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'COMPLETED'}}
        ],
        e: true,
        m: 'All tasks are COMPLETED'
      },
      {
        polledData: [
          {Tasks: {status: 'COMPLETED'}},
          {Tasks: {status: 'FAILED'}}
        ],
        e: false,
        m: 'Not all tasks are COMPLETED'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        expect(c.isSuccess(test.polledData)).to.equal(test.e);
      });
    });
  });

  describe('#isStepFailed', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if (k === 'components.slaves')
          return ["TASKTRACKER", "DATANODE", "JOURNALNODE", "ZKFC", "APP_TIMELINE_SERVER", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    var tests = Em.A([
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: true,
        m: 'GANGLIA_MONITOR 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'GANGLIA_MONITOR', status: 'PENDING'}}
        ],
        e: false,
        m: 'GANGLIA_MONITOR 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: true,
        m: 'HBASE_REGIONSERVER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'HBASE_REGIONSERVER', status: 'PENDING'}}
        ],
        e: false,
        m: 'HBASE_REGIONSERVER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: true,
        m: 'TASKTRACKER 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'TASKTRACKER', status: 'PENDING'}}
        ],
        e: false,
        m: 'TASKTRACKER 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'FAILED'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'DATANODE 2/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'DATANODE 1/3 failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'TIMEDOUT'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: true,
        m: 'NAMENODE failed'
      },
      {
        polledData: [
          {Tasks: {command: 'INSTALL', role: 'NAMENODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}},
          {Tasks: {command: 'INSTALL', role: 'DATANODE', status: 'PENDING'}}
        ],
        e: false,
        m: 'Nothing failed failed'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({polledData: test.polledData});
        expect(c.isStepFailed()).to.equal(test.e);
      });
    });
  });

  describe('#setLogTasksStatePerHost', function () {
    var tests = Em.A([
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [],
        e: {m: 'COMPLETED', l: 2},
        m: 'host didn\'t have tasks and got 2 new'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 2},
        m: 'host had 2 tasks and got both updated'
      },
      {
        tasksPerHost: [],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'IN_PROGRESS', l: 2},
        m: 'host had 2 tasks and didn\'t get updates'
      },
      {
        tasksPerHost: [
          {Tasks: {id: 1, status: 'COMPLETED'}},
          {Tasks: {id: 2, status: 'COMPLETED'}},
          {Tasks: {id: 3, status: 'COMPLETED'}}
        ],
        tasks: [
          {Tasks: {id: 1, status: 'IN_PROGRESS'}},
          {Tasks: {id: 2, status: 'IN_PROGRESS'}}
        ],
        e: {m: 'COMPLETED', l: 3},
        m: 'host had 2 tasks and got both updated and 1 new'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        c.reopen({hosts: [Em.Object.create({logTasks: test.tasks})]});
        c.setLogTasksStatePerHost(test.tasksPerHost, c.get('hosts')[0]);
        expect(c.get('hosts')[0].get('logTasks').everyProperty('Tasks.status', test.e.m)).to.equal(true);
        expect(c.get('hosts')[0].get('logTasks.length')).to.equal(test.e.l);
      });
    });
  });

 // On completion of Start all services error callback function,
  // Cluster Status should be INSTALL FAILED
  // All progress bar on the screen should be finished (100%) with blue color.
  // Retry button should be enabled, next button should be disabled

  describe('#launchStartServicesErrorCallback', function () {

    beforeEach(function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      App.get.restore();
    });

    it('Main progress bar on the screen should be finished (100%) with red color', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      expect(c.get('progress')).to.equal('100');
      expect(c.get('status')).to.equal('failed');
    });

    it('All Host progress bars on the screen should be finished (100%) with blue color', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      c.get('hosts').forEach(function (host) {
        expect(host.get('progress')).to.equal('100');
        expect(host.get('status')).to.equal('info');
      });
    });

    it('Next button should be disabled', function () {
      var hosts = Em.A([Em.Object.create({name: 'host1', progress: '33', status: 'info'}), Em.Object.create({name: 'host2', progress: '33', status: 'info'})]);
      c.reopen({hosts: hosts, content: {controllerName: 'installerController', cluster: {status: 'PENDING', name: 'c1'}}});
      c.launchStartServicesErrorCallback({status: 500, statusTesxt: 'Server Error'}, {}, '', {});
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });

  });

  describe('#submit', function () {
    it('should call App.router.send', function () {
      sinon.stub(App.router, 'send', Em.K);
      c.submit();
      expect(App.router.send.calledWith('next')).to.equal(true);
      App.router.send.restore();
    });
  });

  describe('#back', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'send', Em.K);
    });
    afterEach(function () {
      App.router.send.restore();
    });
    it('should call App.router.send', function () {
      c.reopen({isSubmitDisabled: false});
      c.back();
      expect(App.router.send.calledWith('back')).to.equal(true);
    });
    it('shouldn\'t call App.router.send', function () {
      c.reopen({isSubmitDisabled: true});
      c.back();
      expect(App.router.send.called).to.equal(false);
    });
  });

  describe('#loadStep', function () {
    beforeEach(function () {
      sinon.stub(c, 'clearStep', Em.K);
      sinon.stub(c, 'loadHosts', Em.K);
    });
    afterEach(function () {
      c.clearStep.restore();
      c.loadHosts.restore();
    });
    it('should call clearStep', function () {
      c.loadStep();
      expect(c.clearStep.calledOnce).to.equal(true);
    });
    it('should call loadHosts', function () {
      c.loadStep();
      expect(c.loadHosts.calledOnce).to.equal(true);
    });
  });

  describe('#startPolling', function () {
    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequestErrorCallback', Em.K);
    });
    afterEach(function () {
      c.getLogsByRequestErrorCallback.restore();
    });
    it('should set isSubmitDisabled to true', function () {
      c.set('isSubmitDisabled', false);
      c.startPolling();
      expect(c.get('isSubmitDisabled')).to.equal(true);
    });
    it('should call doPolling', function () {
      sinon.stub(c, 'doPolling', Em.K);
      c.startPolling();
      expect(c.doPolling.calledOnce).to.equal(true);
      c.doPolling.restore();
    });
  });

  describe('#loadLogData', function () {

    beforeEach(function () {
      obj.reopen({
        cluster: {oldRequestsId: [1,2,3]},
        getDBProperty: function (name) {
          return this.get(name);
        }
      });
      c.reopen({wizardController: obj});
      sinon.stub(c, 'getLogsByRequest', Em.K);
    });

    afterEach(function () {
      c.getLogsByRequest.restore();
    });

    it('should call getLogsByRequest 1 time with 3', function () {
      c.loadLogData(true);
      expect(c.getLogsByRequest.calledWith(true, 3)).to.equal(true);
    });

    it('should set POLL_INTERVAL to 1 if testMode enabled', function () {
      sinon.stub(App, 'get', function(k) { if ('testMode' === k) return true; return Em.get(App, k);});
      c.loadLogData();
      expect(c.get('POLL_INTERVAL')).to.equal(1);
      App.get.restore();
    });

  });

  describe('#loadCurrentTaskLog', function () {
    beforeEach(function () {
      sinon.stub(c, 'loadLogData', Em.K);
      c.set('wizardController', Em.Object.create({
        getDBProperty: Em.K
      }));
    });
    afterEach(function () {
      c.loadLogData.restore();
    });
    it('shouldn\'t call App.ajax.send if no currentOpenTaskId', function () {
      c.set('currentOpenTaskId', null);
      c.loadCurrentTaskLog();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('should call App.ajax.send with provided data', function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      c.set('currentOpenTaskId', 1);
      c.set('currentOpenTaskRequestId', 2);
      c.set('content', {cluster: {name: 3}});
      c.loadCurrentTaskLog();
      expect(App.ajax.send.args[0][0].data).to.eql({taskId: 1, requestId: 2, clusterName: 3});
      c.togglePreviousSteps.restore();
    });
  });

  describe('#loadCurrentTaskLogSuccessCallback', function () {

    beforeEach(function() {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
    });

    afterEach(function() {
      c.getLogsByRequest.restore();
      c.loadLogData.restore();
    });

    it('should increment logTasksChangesCounter', function () {
      c.set('logTasksChangesCounter', 0);
      c.loadCurrentTaskLogSuccessCallback();
      expect(c.get('logTasksChangesCounter')).to.equal(1);
    });
    it('should update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('stdout');
      expect(t.stderr).to.equal('stderr');
    });
    it('shouldn\'t update stdout, stderr', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h1',
            logTasks: [
              {Tasks: {id: 2, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
    it('shouldn\'t update stdout, stderr (2)', function () {
      c.set('currentOpenTaskId', 1);
      c.reopen({
        hosts: [
          Em.Object.create({
            name: 'h2',
            logTasks: [
              {Tasks: {id: 1, stdout: '', stderr: ''}}
            ]
          })
        ]
      });
      var data = {Tasks: {host_name: 'h1', id: 1, stderr: 'stderr', stdout: 'stdout'}};
      c.loadCurrentTaskLogSuccessCallback(data);
      var t = c.get('hosts')[0].logTasks[0].Tasks;
      expect(t.stdout).to.equal('');
      expect(t.stderr).to.equal('');
    });
  });

  describe('#loadCurrentTaskLogErrorCallback', function () {
    it('should set currentOpenTaskId to 0', function () {
      c.set('currentOpenTaskId', 123);
      c.loadCurrentTaskLogErrorCallback();
      expect(c.get('currentOpenTaskId')).to.equal(0);
    });
  });

  describe('#doPolling', function () {

    beforeEach(function () {
      sinon.stub(c, 'getLogsByRequest', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });

    afterEach(function () {
      c.getLogsByRequest.restore();
      c.togglePreviousSteps.restore();
    });

    it('should increment numPolls if testMode', function () {
      App.set('testMode', true);
      c.set('numPolls', 0);
      c.doPolling();
      expect(c.get('numPolls')).to.equal(1);
      App.set('testMode', false);
    });

    it('should call getLogsByRequest', function () {
      c.set('content', {cluster: {requestId: 1}});
      c.doPolling();
      expect(c.getLogsByRequest.calledWith(true, 1)).to.equal(true);
    });

  });

  describe('#isAllComponentsInstalledErrorCallback', function () {
    beforeEach(function () {
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'togglePreviousSteps', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.togglePreviousSteps.restore();
    });
    it('should call saveClusterStatus', function () {
      c.isAllComponentsInstalledErrorCallback({});
      expect(c.saveClusterStatus.calledOnce).to.equal(true);
    });
  });

  describe('#navigateStep', function () {
    beforeEach(function () {
      sinon.stub(c, 'togglePreviousSteps', Em.K);
      sinon.stub(c, 'loadStep', Em.K);
      sinon.stub(c, 'loadLogData', Em.K);
      sinon.stub(c, 'startPolling', Em.K);
    });
    afterEach(function () {
      c.togglePreviousSteps.restore();
      c.loadStep.restore();
      c.loadLogData.restore();
      c.startPolling.restore();
      App.get.restore();
    });
    it('should set custom data in testMode', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return true; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'st', isCompleted: true, requestId: 0}}});
      c.navigateStep();
      expect(c.get('content.cluster.status')).to.equal('PENDING');
      expect(c.get('content.cluster.isCompleted')).to.equal(false);
      expect(c.get('content.cluster.requestId')).to.equal(1);
    });
    it('isCompleted = true, requestId = 1', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {isCompleted: true, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
      expect(c.get('progress')).to.equal('100');
    });
    it('isCompleted = false, requestId = 1, status = INSTALL FAILED', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'INSTALL FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = START FAILED', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'START FAILED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(false)).to.equal(true);
    });
    it('isCompleted = false, requestId = 1, status = OTHER', function () {
      sinon.stub(App, 'get', function(k) {if('testMode' === k) return false; return Em.get(App, k);});
      c.reopen({content: {cluster: {status: 'STARTED', isCompleted: false, requestId: 1}}});
      c.navigateStep();
      expect(c.loadStep.calledOnce).to.equal(true);
      expect(c.loadLogData.calledWith(true)).to.equal(true);
    });
  });

  describe('#launchStartServicesSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(App.clusterStatus, 'setClusterStatus', function() {
        return $.ajax();
      });
      sinon.stub(c, 'saveClusterStatus', Em.K);
      sinon.stub(c, 'doPolling', Em.K);
      sinon.stub(c, 'hostHasClientsOnly', Em.K);
    });
    afterEach(function () {
      c.saveClusterStatus.restore();
      c.doPolling.restore();
      c.hostHasClientsOnly.restore();
      App.clusterStatus.setClusterStatus.restore();
    });
    it('should call doPolling if some data were received', function () {
      c.launchStartServicesSuccessCallback({Requests: {id: 2}});
      expect(c.doPolling.calledOnce).to.equal(true);
    });
    Em.A([
        {
          jsonData: {Requests: {id: 2}},
          e: {
            hostHasClientsOnly: false,
            clusterStatus: {
              status: 'INSTALLED',
              requestId: 2,
              isStartError: false,
              isCompleted: false
            }
          }
        },
        {
          jsonData: null,
          e: {
            hostHasClientsOnly: true,
            clusterStatus: {
              status: 'STARTED',
              isStartError: false,
              isCompleted: true
            },
            status: 'success',
            progress: '100'
          }
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          c.launchStartServicesSuccessCallback(test.jsonData);
          expect(c.hostHasClientsOnly.calledWith(test.e.hostHasClientsOnly)).to.equal(true);
          expect(c.saveClusterStatus.calledWith(test.e.clusterStatus)).to.equal(true);
          if (test.e.status) {
            expect(c.get('status')).to.equal(test.e.status);
          }
          if (test.e.progress) {
            expect(c.get('progress')).to.equal(test.e.progress);
          }
        });
      });
  });

});

});

;require.register("test/controllers/wizard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/cluster');
require('controllers/wizard');

var c;

describe('App.WizardController', function () {

  var wizardController = App.WizardController.create({});

  var totalSteps = 11;
  var ruller = [];
  for(var i = 0; i < totalSteps; i++) {
    ruller.push(i);
  }

  beforeEach(function () {
    c = App.WizardController.create({});
  });

  describe('#setLowerStepsDisable', function() {
    for(var i = 1; i < totalSteps; i++) {
      var indx = i;
      var steps = [];
      for(var j = 1; j <= indx; j++) {
        steps.push(Em.Object.create({step:j,value:false}));
      }
      wizardController.set('isStepDisabled', steps);
      for(j = 1; j <= indx; j++) {
        it('Steps: ' + i + ' | Disabled: ' + (j-1), function() {
          wizardController.setLowerStepsDisable(j);
          expect(wizardController.get('isStepDisabled').filterProperty('value', true).length).to.equal(j-1);
        });
      }
    }
  });

  // isStep0 ... isStep10 tests
  App.WizardController1 = App.WizardController.extend({currentStep:''});
  var tests = [];
  for(var i = 0; i < totalSteps; i++) {
    var n = ruller.slice(0);
    n.splice(i,1);
    tests.push({i:i,n:n});
  }
  tests.forEach(function(test) {
    describe('isStep'+test.i, function() {
      var w = App.WizardController1.create();
      w.set('currentStep', test.i);
      it('Current Step is ' + test.i + ', so isStep' + test.i + ' is TRUE', function() {
        expect(w.get('isStep'+ test.i)).to.equal(true);
      });
      test.n.forEach(function(indx) {
        it('Current Step is ' + test.i + ', so isStep' + indx + ' is FALSE', function() {
          expect(w.get('isStep'+ indx)).to.equal(false);
        });
      });
    });
  });
  // isStep0 ... isStep10 tests end

  describe('#gotoStep', function() {
    var w = App.WizardController1.create();
    var steps = [];
    for(var j = 0; j < totalSteps; j++) {
      steps.push(Em.Object.create({step:j,value:false}));
    }
    steps.forEach(function(step, index) {
      step.set('value', true);
      w.set('isStepDisabled', steps);
      it('step ' + index + ' is disabled, so gotoStep('+index+') is not possible', function() {
        expect(w.gotoStep(index)).to.equal(false);
      });
    });
  });

  describe('#launchBootstrapSuccessCallback', function() {
    it('Save bootstrapRequestId', function() {
      var data = {requestId: 123};
      var params = {popup: {finishLoading: function(){}}};
      sinon.spy(params.popup, "finishLoading");
      wizardController.launchBootstrapSuccessCallback(data, {}, params);
      expect(params.popup.finishLoading.calledWith(123)).to.be.true;
      params.popup.finishLoading.restore();
    });
  });

  describe('#getInstallOptions', function () {

    var cases = [
        {
          isHadoopWindowsStack: true,
          expected: {
            useSsh: false
          }
        },
        {
          isHadoopWindowsStack: false,
          expected: {
            useSsh: true
          }
        }
      ],
      title = 'should return {0}';

    beforeEach(function () {
      sinon.stub(wizardController, 'get')
        .withArgs('installOptionsTemplate').returns({useSsh: true})
        .withArgs('installWindowsOptionsTemplate').returns({useSsh: false});
    });

    afterEach(function () {
      App.get.restore();
      wizardController.get.restore();
    });

    cases.forEach(function (item) {
      it(title.format(item.expected), function () {
        sinon.stub(App, 'get').withArgs('isHadoopWindowsStack').returns(item.isHadoopWindowsStack);
        expect(wizardController.getInstallOptions()).to.eql(item.expected);
      });
    });

  });

  describe('#clearInstallOptions', function () {

    wizardController.setProperties({
      content: {},
      name: 'wizard'
    });

    beforeEach(function () {
      sinon.stub(App, 'get').withArgs('isHadoopWindowsStack').returns(false);
    });

    afterEach(function () {
      App.get.restore();
    });

    it('should clear install options', function () {
      wizardController.clearInstallOptions();
      expect(wizardController.get('content.installOptions')).to.eql(wizardController.get('installOptionsTemplate'));
      expect(wizardController.get('content.hosts')).to.eql({});
      expect(wizardController.getDBProperty('installOptions')).to.eql(wizardController.get('installOptionsTemplate'));
      expect(wizardController.getDBProperty('hosts')).to.eql({});
    });
  });

  describe('#loadServiceConfigGroups', function () {
     beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperties', function() {
        return {
          serviceConfigGroups: [
            {
              hosts: ['h1']
            }
          ],
          hosts: Em.Object.create({
            h1: Em.Object.create({
              id: 'h1'
            })
          })
        };
      });
    });
    afterEach(function () {
      wizardController.getDBProperties.restore();
    });
    it('should load service confgig group', function () {
      wizardController.loadServiceConfigGroups();
      expect(wizardController.get('content.configGroups')).to.eql([
        {
          "hosts": [
            "h1"
          ]
        }
      ]);
    });
  });

  describe('#saveTasksStatuses', function () {
    it('should set status', function () {
      wizardController.saveTasksStatuses('st');
      expect(wizardController.get('content.tasksStatuses')).to.equal('st');
    });
  });

  describe('#saveSlaveComponentHosts', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'getDBProperty').returns(Em.A({
        'h1': {
          id: 1
        }
      }));
    });
    afterEach(function(){
      wizardController.getDBProperty.restore();
    });
    it('should save slave components', function () {
      var stepController = Em.Object.create({
        hosts: Em.A([
          Em.Object.create({
            hostName: 'h1',
            checkboxes: Em.A([
              Em.Object.create({title: 'hl1', checked: true})
            ])
          })
        ]),
        headers: Em.A([
          Em.Object.create({name: 'header1', label: 'hl1'})
        ])
      });
      wizardController.saveSlaveComponentHosts(stepController);
      var res = JSON.parse(JSON.stringify(wizardController.get('content.slaveComponentHosts')));
      expect(res).to.eql([
        {
          "componentName": "header1",
          "displayName": "hl1",
          "hosts": [
            {
              "group": "Default",
              "host_id": 1
            }
          ]
        }
      ]);
    });
  });

  describe('#showLaunchBootstrapPopup', function () {
    beforeEach(function(){
      sinon.stub(App.ModalPopup,'show', function(data){
        data.finishLoading.call(wizardController);
      });
    });
    afterEach(function(){
      App.ModalPopup.show.restore();
    });
    it('should set error', function () {
      wizardController.showLaunchBootstrapPopup(Em.K);
      expect(wizardController.get('isError')).to.be.true;
    });
  });

  describe('#gotoStep0', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 0 step', function () {
      wizardController.gotoStep0(Em.K);
      expect(res).to.be.equal(0);
    });
  });

  describe('#gotoStep1', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 1 step', function () {
      wizardController.gotoStep1(Em.K);
      expect(res).to.be.equal(1);
    });
  });

  describe('#gotoStep2', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 2 step', function () {
      wizardController.gotoStep2(Em.K);
      expect(res).to.be.equal(2);
    });
  });

  describe('#gotoSte3', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 3 step', function () {
      wizardController.gotoStep3(Em.K);
      expect(res).to.be.equal(3);
    });
  });

  describe('#gotoStep4', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 4 step', function () {
      wizardController.gotoStep4(Em.K);
      expect(res).to.be.equal(4);
    });
  });

  describe('#gotoStep5', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 5 step', function () {
      wizardController.gotoStep5(Em.K);
      expect(res).to.be.equal(5);
    });
  });

  describe('#gotoStep6', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 6 step', function () {
      wizardController.gotoStep6(Em.K);
      expect(res).to.be.equal(6);
    });
  });

  describe('#gotoStep7', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 7 step', function () {
      wizardController.gotoStep7(Em.K);
      expect(res).to.be.equal(7);
    });
  });

  describe('#gotoStep8', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 8 step', function () {
      wizardController.gotoStep8(Em.K);
      expect(res).to.be.equal(8);
    });
  });

  describe('#gotoStep9', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 9 step', function () {
      wizardController.gotoStep9(Em.K);
      expect(res).to.be.equal(9);
    });
  });

  describe('#gotoStep10', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'gotoStep', function(step){
        res = step;
      });
    });
    afterEach(function(){
      wizardController.gotoStep.restore();
    });
    it('should go to 10 step', function () {
      wizardController.gotoStep10(Em.K);
      expect(res).to.be.equal(10);
    });
  });

  describe('#gotoStep', function () {
    beforeEach(function(){
      sinon.stub(App.ModalPopup,'show', Em.K);
      sinon.stub(App.clusterStatus,'setClusterStatus', Em.K);  
      sinon.stub(App.router,'send', Em.K);  
    });
    afterEach(function(){
      App.ModalPopup.show.restore();
      App.clusterStatus.setClusterStatus.restore();
      App.router.send.restore();
    });
    it('should go to step', function () {
      wizardController.set('isStepDisabled', Em.A([
        Em.Object.create({
          step: '8',
          value: false
        })
      ]));
      wizardController.hide = Em.K;
      wizardController.set('content.controllerName','installerController');
      wizardController.set('currentStep','9');

      expect(wizardController.gotoStep('8')).to.be.true;
    });
  });

  describe('#launchBootstrap', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'showLaunchBootstrapPopup').returns({
        name: 'popup'
      });
      sinon.stub(App.ajax,'send', Em.K);
    });
    afterEach(function(){
      wizardController.showLaunchBootstrapPopup.restore();
      App.ajax.send.restore();
    });
    it('should return popup', function () {
      expect(wizardController.launchBootstrap()).to.be.eql({
        name: 'popup'
      });
    });
  });

  describe('#save', function () {
    it('should save data', function () {
      var res;
      sinon.stub(wizardController,'setDBProperty', function(data){
        res = data;
      });
      sinon.stub(wizardController,'toJSInstance').returns('val');
      wizardController.save('name');
      wizardController.setDBProperty.restore();
      wizardController.toJSInstance.restore();
      expect(res).to.be.equal('name');
    });
  });

  describe('#installServicesSuccessCallback', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'saveClusterStatus', function(data){
        res = JSON.parse(JSON.stringify(data));
      });
      sinon.stub(App,'dateTime').returns('22');
    });
    afterEach(function(){
      wizardController.saveClusterStatus.restore();
      App.dateTime.restore();
    });
    it('should call callbeck with data', function () {
      var jsonData = {
        Requests: {
          id: 1
        }
      };
      wizardController.installServicesSuccessCallback(jsonData);
      expect(res).to.be.eql({
        "status": "PENDING",
        "requestId": 1,
        "isInstallError": false,
        "isCompleted": false,
        "installStartTime": "22"
      });
    });
  });

  describe('#installServices', function () {
    var res;
    beforeEach(function(){
      sinon.stub(wizardController,'saveClusterStatus', function(data){
        res = JSON.parse(JSON.stringify(data));
      });
      sinon.stub(App.ajax,'send').returns({
        then: function() {}
      });
    });
    afterEach(function(){
      wizardController.saveClusterStatus.restore();
      App.ajax.send.restore();
    });
    it('should call callbeck with data', function () {
      var jsonData = {
        Requests: {
          id: 1
        }
      };
      wizardController.set('content', Em.Object.create({
        cluster: {
          oldRequestsId: '1'
        }
      }));
      wizardController.installServices(true);
      expect(res).to.be.eql({
        "status": "PENDING"
      });
    });
  });

  describe('#saveInstalledHosts', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'getDBProperty').returns({
        'h1': {
          id: 1,
          status: '',
          name: 'h1'
        }
      });
    });
    afterEach(function(){
      wizardController.getDBProperty.restore();
    });
    it('should save installed hosts', function () {
      var stepController = Em.Object.create({
        hosts: Em.A([
          Em.Object.create({
            hostName: 'h1',
            name: 'h1',
            status: 'st',
            message: 'ms',
            checkboxes: Em.A([
              Em.Object.create({title: 'hl1', checked: true})
            ])
          })
        ])
      });
      wizardController.saveInstalledHosts(stepController);
      var res = JSON.parse(JSON.stringify(wizardController.get('content.hosts')));
      expect(res).to.eql({
        "h1": {
          "id": 1,
          "status": "st",
          "name": "h1",
          "message": "ms"
        }
      });
    });
  });

  describe('#saveConfirmedHosts', function () {
    beforeEach(function(){
      sinon.stub(wizardController,'getDBProperty').returns({
        'h1': {
          id: 1,
          status: '',
          name: 'h1'
        }
      });
    });
    afterEach(function(){
      wizardController.getDBProperty.restore();
    });
    it('should save confirmed hosts', function () {
      var stepController = Em.Object.create({
        confirmedHosts: Em.A([
          {
            name: 'h2',
            cpu: '1',
            isInstalled: true
          }
        ])
      });
      wizardController.set('content.hosts', {
        'h1': {
          isInstalled: false,
          bootStatus: 'REGISTERED'
        },
        'h2': {
          isInstalled: true,
          bootStatus: 'REGISTERED'
        }
      });
      wizardController.saveConfirmedHosts(stepController);
      var res = JSON.parse(JSON.stringify(wizardController.get('content.hosts')));
      expect(res).to.eql({
        "h2": {
          "isInstalled": true,
          "bootStatus": "REGISTERED"
        }
      });
    });
  });

  describe('#loadTasksStatuses', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns('st');
    });
    afterEach(function () {
      wizardController.getDBProperty.restore();
    });
    it('should load status', function () {
      wizardController.loadTasksStatuses();
      expect(wizardController.get('content.tasksStatuses')).to.equal('st');
    });
  });

  describe('#saveTasksRequestIds', function () {
    it('should save id', function () {
      wizardController.saveTasksRequestIds('st');
      expect(wizardController.get('content.tasksRequestIds')).to.equal('st');
    });
  });

  describe('#loadTasksRequestIds', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns('st');
    });
    afterEach(function () {
      wizardController.getDBProperty.restore();
    });
    it('should load status', function () {
      wizardController.loadTasksRequestIds();
      expect(wizardController.get('content.tasksRequestIds')).to.equal('st');
    });
  });

  describe('#saveRequestIds', function () {
    it('should save id', function () {
      wizardController.saveRequestIds('st');
      expect(wizardController.get('content.requestIds')).to.equal('st');
    });
  });

  describe('#load', function () {
    it('should clear install options', function () {
      var name = 'Name';
      wizardController.set('get'+name.capitalize(), function() {return 'res';});
      wizardController.load(name, true);
      expect(wizardController.get('content.' + name)).to.equal('res');
    });
  });

  describe('#usersLoading', function () {
    beforeEach(function(){
      sinon.stub(App.MainAdminServiceAccountsController,'create').returns({
        loadUsers: function() {},
        get: function(type) {
          if (type == 'dataIsLoaded') {
            return true;
          }
          return Em.Object.create({
            hdfsUser: {
              name: 'user'
            }
          });
        }
      });
    });
    afterEach(function(){
      App.MainAdminServiceAccountsController.create.restore();
    });
    it('should load users', function () {
      wizardController.set('content.hdfsUser', true);
      wizardController.usersLoading().then(function(data){
        expect(data).to.be.undefined;
      });
    });
  });

  describe('#loadConfirmedHosts', function () {
    beforeEach(function(){
      sinon.stub(App.db, 'getHosts').returns(Em.A([
        Em.Object.create({
          name: 'h1'
        })
      ]));
    });
    afterEach(function(){
      App.db.getHosts.restore();
    });
    it('should load hosts from db', function () {
      wizardController.loadConfirmedHosts();
      var res = JSON.parse(JSON.stringify(wizardController.get('content.hosts')));
      expect(res).to.eql([
        {
          "name": "h1"
        }
      ]);
    });
  });

  describe('#loadServicesFromServer', function () {//TODO
    var res;
    beforeEach(function(){
      sinon.stub(App.StackService, 'find').returns(Em.A([
        Em.Object.create({
          isSelected: false,
          isInstalled: false,
          serviceName: 's1'
        })
      ]));
      sinon.stub(App.Service, 'find').returns(Em.A([
        Em.Object.create({
          isSelected: false,
          isInstalled: false,
          serviceName: 's1'
        })
      ]));
      sinon.stub(wizardController, 'setDBProperty', function(data) {
        res = data;
      });
    });
    
    afterEach(function () {
      App.StackService.find.restore();
      App.Service.find.restore();
      wizardController.setDBProperty.restore();
    });
    it('should load services from server', function () {
      wizardController.loadServicesFromServer();
      expect(res).to.eql('services');
    });
  });

  describe('#loadRequestIds', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns('st');
    });
    afterEach(function () {
      wizardController.getDBProperty.restore();
    });
    it('should load status', function () {
      wizardController.loadRequestIds();
      expect(wizardController.get('content.requestIds')).to.equal('st');
    });
  });

  describe('#loadServiceComponentsSuccessCallback', function () {
    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperties', function() {
        return {
          selectedServiceNames: ['a','b'],
          installedServiceNames: ['c','d']
        };
      });
      sinon.stub(App.stackServiceMapper, 'mapStackServices', Em.K); 
    });
    afterEach(function () {
      wizardController.getDBProperties.restore();
      App.stackServiceMapper.mapStackServices.restore();
    });
    it('should load json data', function () {
      var jsonData = {
        items: [
          {
            StackServices: {
              isSelected: false,
              service_name: 'a'
            }
          },
          {
            StackServices: {
              isSelected: false,
              service_name: 'none'
            }
          }
        ]
      };
      wizardController.loadServiceComponentsSuccessCallback(jsonData);
      var exp = {
        "items": [
          {
            "StackServices": {
              "isSelected": false,
              "service_name": "a",
              "is_selected": true,
              "is_installed": false
            }
          },
          {
            "StackServices": {
              "isSelected": false,
              "service_name": "none",
              "is_selected": false,
              "is_installed": false
            }
          }
        ]
      };

      expect(jsonData).to.eql(exp);
    });
  });

  describe('#setInfoForStep9', function () {

    var res;

    beforeEach(function () {
      sinon.stub(wizardController, 'getDBProperty').returns(Em.Object.create({
        status: {},
        message: {},
        logTasks: {},
        tasks: {},
        progress: {}
      }));
      sinon.stub(wizardController, 'setDBProperty', function(title,data) {
        res = data;
      });
    });

    afterEach(function () {
      wizardController.getDBProperty.restore();
      wizardController.setDBProperty.restore();
    });

    it('should return info for step 9', function () {
      wizardController.setInfoForStep9();
      var exp = {
        "status": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "message": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "logTasks": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "tasks": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        },
        "progress": {
          "status": "pending",
          "message": "Waiting",
          "logTasks": [],
          "tasks": [],
          "progress": "0"
        }
      };

      res = JSON.parse(JSON.stringify(res));

      expect(res).to.eql(exp);
    });
  });

  describe('#saveServiceConfigProperties', function () {

    beforeEach(function () {
      c.set('content', {});
      sinon.stub(c, 'setDBProperties', Em.K);
      sinon.stub(c, 'getDBProperty').withArgs('fileNamesToUpdate').returns([]);
      sinon.stub(App.config, 'shouldSupportFinal').returns(true);
    });

    afterEach(function () {
      c.setDBProperties.restore();
      c.getDBProperty.restore();
      App.config.shouldSupportFinal.restore();
    });

    var kerberosStepController = Em.Object.create({
      installedServiceNames: ['KERBEROS'],
      stepConfigs: [
        Em.Object.create({
          serviceName: 'KERBEROS',
          configs: [
            Em.Object.create({
              id: 'id',
              name: 'admin_password',
              value: 'value',
              defaultValue: 'defaultValue',
              description: 'description',
              serviceName: 'serviceName',
              domain: 'domain',
              isVisible: true,
              isNotDefaultValue: true,
              isFinal: true,
              defaultIsFinal: true,
              supportsFinal: true,
              filename: 'krb5-conf.xml',
              displayType: 'string',
              isRequiredByAgent: true,
              hasInitialValue: true,
              isRequired: true,
              group: {name: 'group'},
              showLabel: true,
              category: 'some_category'
            }),

            Em.Object.create({
              id: 'id',
              name: 'admin_principal',
              value: 'value',
              defaultValue: 'defaultValue',
              description: 'description',
              serviceName: 'serviceName',
              domain: 'domain',
              isVisible: true,
              isNotDefaultValue: true,
              isFinal: true,
              defaultIsFinal: true,
              supportsFinal: true,
              filename: 'krb5-conf.xml',
              displayType: 'string',
              isRequiredByAgent: true,
              hasInitialValue: true,
              isRequired: true,
              group: {name: 'group'},
              showLabel: true,
              category: 'some_category'
            })
          ]
        })
      ]
    });

    var stepController = Em.Object.create({
      installedServiceNames: ['HDFS'],
      stepConfigs: [
      Em.Object.create({
        serviceName: 'HDFS',
        configs: [
          Em.Object.create({
            id: 'id',
            name: 'name',
            value: 'value',
            defaultValue: 'defaultValue',
            description: 'description',
            serviceName: 'serviceName',
            domain: 'domain',
            isVisible: true,
            isNotDefaultValue: true,
            isFinal: true,
            defaultIsFinal: true,
            supportsFinal: true,
            filename: 'filename',
            displayType: 'string',
            isRequiredByAgent: true,
            hasInitialValue: true,
            isRequired: true,
            showLabel: true,
            category: 'some_category'
          })
        ]
      }),
      Em.Object.create({
        serviceName: 'YARN',
        configs: [
          Em.Object.create({
            id: 'id',
            name: 'name',
            value: 'value',
            defaultValue: 'defaultValue',
            description: 'description',
            serviceName: 'serviceName',
            domain: 'domain',
            isVisible: true,
            isFinal: true,
            defaultIsFinal: true,
            supportsFinal: true,
            filename: 'filename',
            displayType: 'string',
            isRequiredByAgent: true,
            hasInitialValue: true,
            isRequired: true,
            group: {name: 'group'},
            showLabel: true,
            category: 'some_category'
          })
        ]
      })
    ]});

    it('should save configs from default config group to content.serviceConfigProperties', function () {
      c.saveServiceConfigProperties(stepController);
      var saved = c.get('content.serviceConfigProperties');
      expect(saved.length).to.equal(1);
      expect(saved[0].category).to.equal('some_category');
    });

    it('should not save admin_principal or admin_password to the localStorage', function () {
      c.saveServiceConfigProperties(kerberosStepController);
      var saved = c.get('content.serviceConfigProperties');
      saved.forEach(function(config) {
        expect(config.value).to.equal('');
      });
    });
  });

  describe('#enableStep', function () {

    it('should update appropriate value in isStepDisabled', function () {

      c.set('isStepDisabled', [
        Em.Object.create({step: 1, value: true}),
        Em.Object.create({step: 2, value: true}),
        Em.Object.create({step: 3, value: true}),
        Em.Object.create({step: 4, value: true}),
        Em.Object.create({step: 5, value: true}),
        Em.Object.create({step: 6, value: true}),
        Em.Object.create({step: 7, value: true})
      ]);

      c.enableStep(1);
      expect(c.get('isStepDisabled')[0].get('value')).to.be.false;

      c.enableStep(7);
      expect(c.get('isStepDisabled')[6].get('value')).to.be.false;
    });

  });

  describe('#allHosts', function () {

    it('should return all hosts', function () {
      var hosts = {
        'h1': {hostComponents: ['c1', 'c2'], disk_info: [{size: 2, available: 1}]},
        'h2': {hostComponents: ['c3', 'c4'], disk_info: [{size: 2, available: 1}]}
      };

      var content = Em.Object.create({
        hosts: hosts
      });

      c.set('content', content);

      var exp = [
        {
          "id": "h1",
          "hostName": "h1",
          "publicHostName": "h1",
          "diskInfo": [
            {
              "size": 2,
              "available": 1
            }
          ],
          "diskTotal": 0.0000019073486328125,
          "diskFree": 9.5367431640625e-7,
          "disksMounted": 1,
          "osType": 0,
          "osArch": 0,
          "ip": 0,
          "hostComponents": [
            {
              "componentName": "c1",
              "displayName": "C1"
            },
            {
              "componentName": "c2",
              "displayName": "C2"
            }
          ]
        },
        {
          "id": "h2",
          "hostName": "h2",
          "publicHostName": "h2",
          "diskInfo": [
            {
              "size": 2,
              "available": 1
            }
          ],
          "diskTotal": 0.0000019073486328125,
          "diskFree": 9.5367431640625e-7,
          "disksMounted": 1,
          "osType": 0,
          "osArch": 0,
          "ip": 0,
          "hostComponents": [
            {
              "componentName": "c3",
              "displayName": "C3"
            },
            {
              "componentName": "c4",
              "displayName": "C4"
            }
          ]
        }
      ];

      var res = JSON.parse(JSON.stringify(c.get('allHosts')));

      expect(res).to.be.eql(exp);
    });
  });

  describe('#getSlaveComponentHosts', function () {
    beforeEach(function () {
      sinon.stub(App.Service, 'find').returns(Em.A([
        Em.Object.create({
          serviceName: 's1'
        })
      ]));
      sinon.stub(App.StackService, 'find').returns(Em.A([
        Em.Object.create({
          serviceName: 's2',
          isSelected: true
        })
      ]));
      sinon.stub(App.StackServiceComponent, 'find').returns(Em.A([
        Em.Object.create({componentName: 'DATANODE', serviceName: 's1', isSlave: true}),
        Em.Object.create({componentName: 'c2', serviceName: 's2', isSlave: true})
      ]));
      sinon.stub(App.HostComponent, 'find').returns(Em.A([
        Em.Object.create({
          componentName: 'DATANODE',
          hostName: 'h1'
        })
      ]));
    });

    afterEach(function () {
      App.Service.find.restore();
      App.HostComponent.find.restore();
      App.StackService.find.restore();
      App.StackServiceComponent.find.restore();
    });

    it('should return slave components', function () {
      var res = JSON.parse(JSON.stringify(c.getSlaveComponentHosts()));
      var exp = [
        {
          "componentName": "DATANODE",
          "displayName": "DataNode",
          "hosts": [
            {
              "group": "Default",
              "hostName": "h1",
              "isInstalled": true
            }
          ],
          "isInstalled": true
        },
        {
          "componentName": "CLIENT",
          "displayName": "Client",
          "hosts": [],
          "isInstalled": true
        },
        {
          "componentName": "c2",
          "displayName": "C2",
          "hosts": [
            {
              "group": "Default",
              "hostName": "h1",
              "isInstalled": false
            }
          ],
          "isInstalled": false
        }
      ];

      expect(res).to.be.eql(exp);
    });

  });

  describe('#setSkipSlavesStep', function () {

    var step = 6,
      cases = [
        {
          services: [
            {
              hasSlave: true,
              hasNonMastersWithCustomAssignment: true
            }
          ],
          skipSlavesStep: false,
          title: 'service with customizable slave selected'
        },
        {
          services: [
            {
              hasClient: true,
              hasNonMastersWithCustomAssignment: true
            }
          ],
          skipSlavesStep: false,
          title: 'service with customizable client selected'
        },
        {
          services: [
            {
              hasSlave: true,
              hasNonMastersWithCustomAssignment: false
            },
            {
              hasClient: true,
              hasNonMastersWithCustomAssignment: false
            }
          ],
          skipSlavesStep: true,
          title: 'no service with customizable slaves or clients selected'
        },
        {
          services: [
            {
              hasSlave: false,
              hasClient: false
            }
          ],
          skipSlavesStep: true,
          title: 'no service with slaves or clients selected'
        }
      ];

    beforeEach(function () {
      c.reopen({
        isStepDisabled: [
          Em.Object.create({
            step: 6
          })
        ],
        content: {}
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        c.setSkipSlavesStep(item.services, step);
        expect(Boolean(c.get('isStepDisabled').findProperty('step', step).get('value'))).to.equal(item.skipSlavesStep);
      });
    });

  });

  describe('#toJSInstance', function () {

    var testCases = [
      {
        o: {'test': 'test'},
        e: {'test': 'test'}
      },
      {
        o: {'test': Em.Object.create()},
        e: {'test': {}}
      },
      {
        o: {'test': Em.Object.create({'test': {}})},
        e: {'test': {'test': {}}}
      },
      {
        o: [],
        e: []
      },
      {
        o: Em.A([[]]),
        e: [[]]
      },
      {
        o: 11,
        e: 11
      },
      {
        o: '11',
        e: '11'
      },
      {
        o: null,
        e: null
      }
    ];

    it('should convert objects and arrays to pure JS objects and arrays', function () {
      testCases.forEach(function (testCase) {
        expect(c.toJSInstance(testCase.o)).to.eql(testCase.e);
      });
    });
  });

  describe('#loadConfigThemes', function() {
    beforeEach(function () {
      sinon.stub(wizardController, 'loadConfigThemeForServices').returns({
        always: function(callback) {callback();}
      });
      sinon.stub(App.themesMapper, 'generateAdvancedTabs').returns(true);
      sinon.stub(App.config, 'loadConfigsFromStack').returns({
        done: function(callback) {
          callback();
        }
      });
      sinon.stub(App.StackService, 'find').returns(Em.A([
        Em.Object.create({
          isSelected: true,
          serviceName: 's1'
        })
      ]));
    });
    afterEach(function () {
      App.get.restore();
      App.StackService.find.restore();
      App.config.loadConfigsFromStack.restore();
      App.themesMapper.generateAdvancedTabs.restore();
      wizardController.loadConfigThemeForServices.restore();
    });
    it('Should load config themes', function() { 
      sinon.stub(App, 'get').returns(true);
      wizardController.loadConfigThemes().then(function(data) {
        expect().to.be.undefined;
      });
    });
    it('Should load config themes', function() {
      sinon.stub(App, 'get').returns(false); 
      wizardController.loadConfigThemes().then(function(data) {
        expect().to.be.undefined;
      });
    });
  });

  describe('#dataLoading', function () {
    var clusterController = Em.Object.create({
      isLoaded: false
    });
    beforeEach(function(){
      sinon.stub(App.router,'get').returns(clusterController);
      sinon.stub(wizardController, 'connectOutlet', Em.K);
      clusterController.set('isLoaded', false);
    });
    afterEach(function(){
      App.router.get.restore();
      wizardController.connectOutlet.restore();
    });
    it('should load data', function () {
      clusterController.set('isLoaded', true);
      wizardController.dataLoading().then(function(data){
        expect(data).to.be.undefined;
      });
    });
    it('should load data after 25ms', function () {
      clusterController.set('isLoaded', false);
      setTimeout(function(){
        clusterController.set('isLoaded', true);
      },25);
      wizardController.dataLoading().then(function(data){
        expect(data).to.be.undefined;
      });
    });
  });

  describe('#loadRecommendations', function () {

    beforeEach(function () {
      sinon.stub(c, 'getDBProperty').returns({});
    });

    afterEach(function () {
      c.getDBProperty.restore();
    });

    it('should set recommendations', function () {
      c.set('content', {});
      c.loadRecommendations();
      expect(c.get('content.recommendations')).to.eql({});
    });

  });

});

});

;require.register("test/data/HDP2.2/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
require('data/HDP2/gluster_fs_properties');
var siteProperties = require('data/HDP2.2/site_properties').configProperties;

describe('hdp2SiteProperties', function () {
  /**
   * @stackProperties: All the properties that are derived from stack definition
   */
  var stackProperties = siteProperties.filter(function(item){
    return  (!(item.isRequiredByAgent === false || item.filename === 'alert_notification' || item.category === 'Ambari Principals' || item.name === 'oozie_hostname'))
  });

  stackProperties.forEach(function(siteProperty){
    /**
     * Following config attributes are stack driven and should be defined in the stack metainfo instead of ambari-web site-properties file
     * isVisible
     * isOverridable
     * value
     * recommendedValue
     * isReconfigurable
     * isRequired
     * displayName
     * description
     * showLabel
     * unit
     */
    it('Check attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Stack driven attributes should be undefined ', function () {
      expect(siteProperty.isVisible).to.equal(undefined);
      expect(siteProperty.value).to.equal(undefined);
      expect(siteProperty.recommendedValue).to.equal(undefined);
      expect(siteProperty.description).to.equal(undefined);
      expect(siteProperty.isReconfigurable).to.equal(undefined);
      expect(siteProperty.isRequired).to.equal(undefined);
      expect(siteProperty.displayName).to.equal(undefined);
      expect(siteProperty.showLabel).to.equal(undefined);
      expect(siteProperty.unit).to.equal(undefined);
    });

    /**
     * displayTypes <code>supportTextConnection<code> and <code>radio button<code>
     * can be used as exception. Other displayTypes values should be used in stack definition
     */
    it('Check attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Display type value ' + siteProperty.displayType + ' should be described in stack ', function () {
      expect(siteProperty.displayType).to.match(/undefined|supportTextConnection|radio button/);
    });

    /**
     * Following config attributes uniquely represent a config property
     * name
     * filename
     */
    it('Check primary attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Attributes that uniquely represent a property should be defined ', function () {
      expect(siteProperty.name).to.not.equal(undefined);
      expect(siteProperty.filename).to.not.equal(undefined);
    });
  });

});
});

;require.register("test/data/HDP2.3/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
require('data/HDP2/gluster_fs_properties');
var siteProperties = require('data/HDP2.3/site_properties').configProperties;

describe('hdp2SiteProperties', function () {
  /**
   * @stackProperties: All the properties that are derived from stack definition
   */
  var stackProperties = siteProperties.filter(function(item){
    return  (!(item.isRequiredByAgent === false || item.filename === 'alert_notification' || item.category === 'Ambari Principals' || item.name === 'oozie_hostname'))
  });

  stackProperties.forEach(function(siteProperty){
    /**
     * Following config attributes are stack driven and should be defined in the stack metainfo instead of ambari-web site-properties file
     * isVisible
     * isOverridable
     * value
     * recommendedValue
     * isReconfigurable
     * isRequired
     * displayName
     * description
     * showLabel
     * unit
     */
    it('Check attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Stack driven attributes should be undefined ', function () {
      expect(siteProperty.isVisible).to.equal(undefined);
      expect(siteProperty.value).to.equal(undefined);
      expect(siteProperty.recommendedValue).to.equal(undefined);
      expect(siteProperty.description).to.equal(undefined);
      expect(siteProperty.isReconfigurable).to.equal(undefined);
      expect(siteProperty.isRequired).to.equal(undefined);
      expect(siteProperty.displayName).to.equal(undefined);
      expect(siteProperty.showLabel).to.equal(undefined);
      expect(siteProperty.unit).to.equal(undefined);
    });


    /**
     * displayTypes <code>supportTextConnection<code> and <code>radio button<code>
     * can be used as exception. Other displayTypes values should be used in stack definition
     */
    it('Check attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Display type value ' + siteProperty.displayType + ' should be described in stack ', function () {
      expect(siteProperty.displayType).to.match(/undefined|supportTextConnection|radio button/);
    });

    /**
     * Following config attributes uniquely represent a config property
     * name
     * filename
     */
    it('Check primary attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Attributes that uniquely represent a property should be defined ', function () {
      expect(siteProperty.name).to.not.equal(undefined);
      expect(siteProperty.filename).to.not.equal(undefined);
    });
  });

});

});

;require.register("test/data/HDP2/secure_mapping_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
var mappedHdp2Properties = require('data/HDP2/secure_mapping');

describe('hdp2SiteMapping', function () {

  // All mapped properties should have value of string type
  mappedHdp2Properties.forEach(function(mappedProperty){
    it('Value of "' + mappedProperty.name  + '"' + ' should be string', function () {
      expect(mappedProperty.value).to.be.a('string');
    });
  });
  mappedHdp2Properties.forEach(function(mappedProperty){
    it('Value of "' + mappedProperty.name  + '"' + ' should have serviceName and filename attribute', function () {
      expect(mappedProperty).to.have.property('serviceName');
      expect(mappedProperty).to.have.property('filename');
    });
  });
});
});

;require.register("test/data/HDP2/site_properties_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/helper');
require('data/HDP2/gluster_fs_properties');
var siteProperties = require('data/HDP2/site_properties').configProperties;

describe('hdp2SiteProperties', function () {
  /**
   * @stackProperties: All the properties that are derived from stack definition
   */
  var stackProperties = siteProperties.filter(function(item){
    return  (!(item.isRequiredByAgent === false || item.filename === 'alert_notification' || item.category === 'Ambari Principals' || item.name === 'oozie_hostname'))
  });

  stackProperties.forEach(function(siteProperty){
    /**
     * Following config attributes are stack driven and should be defined in the stack metainfo instead of ambari-web site-properties file
     * isVisible
     * isOverridable
     * value
     * recommendedValue
     * isReconfigurable
     * isRequired
     * displayName
     * description
     * showLabel
     * unit
     */
    it('Check attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Stack driven attributes should be undefined ', function () {
      expect(siteProperty.isVisible).to.equal(undefined);
      expect(siteProperty.value).to.equal(undefined);
      expect(siteProperty.recommendedValue).to.equal(undefined);
      expect(siteProperty.description).to.equal(undefined);
      expect(siteProperty.isReconfigurable).to.equal(undefined);
      expect(siteProperty.isRequired).to.equal(undefined);
      expect(siteProperty.displayName).to.equal(undefined);
      expect(siteProperty.showLabel).to.equal(undefined);
      expect(siteProperty.unit).to.equal(undefined);
    });

    /**
     * displayTypes <code>supportTextConnection<code> and <code>radio button<code>
     * can be used as exception. Other displayTypes values should be used in stack definition
     */
    it('Check attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Display type value ' + siteProperty.displayType + ' should be described in stack ', function () {
      expect(siteProperty.displayType).to.match(/undefined|supportTextConnection|radio button/);
    });

    /**
     * Following config attributes uniquely represent a config property
     * name
     * filename
     */
    it('Check primary attributes of "' + siteProperty.filename + '/' + siteProperty.name  + '"' + '. Attributes that uniquely represent a property should be defined ', function () {
      expect(siteProperty.name).to.not.equal(undefined);
      expect(siteProperty.filename).to.not.equal(undefined);
    });
  });

});
});

;require.register("test/helpers", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

module.exports = {

  /**
   * Examples:
   * <code>
   *   var actual = [{a:1, b: [1, 2], c: 3}],
   *    expected = [{a: 1, b: [1, 2]}];
   *  nestedExpect(expected, actual); // valid
   * </code>
   *
   * <code>
   *   var actual = [{a:1, b: [1, 2]}],
   *    expected = [{a: 1, b: [1, 2], c: 3}];
   *  nestedExpect(expected, actual); // invalid valid (actual[0] doesn't contains key 'c)
   * </code>
   * @param {object[]} expected
   * @param {object[]} actual
   * @method nestedExpect
   */
  nestedExpect: function (expected, actual) {
    expected.forEach(function (group, i) {
      Em.keys(group).forEach(function (key) {
        if ('array' === Em.typeOf(actual[i][key])) {
          expect(group[key]).to.eql(actual[i][key].toArray());
        }
        else {
          expect(group[key]).to.equal(actual[i][key]);
        }
      });
    });
  }

};
});

;require.register("test/init_model_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/stack_service_component');
require('mappers/server_data_mapper');
require('mappers/stack_service_mapper');

module.exports = {
  setupStackServiceComponent: function() {
    /**
     * initialization of App.StackServiceComponent and App.StackService models
     * @type {*}
     */
    App.stackServiceMapper.map(require('test/service_components'));
  },
  cleanStackServiceComponent: function() {
    App.StackServiceComponent.find().set('content',[]);
    App.StackService.find().set('content',[]);
  },
  setupStackVersion: function(context, version) {
    context.prevStackVersion = App.get('currentStackVersion');
    App.set('currentStackVersion', version);
  },
  restoreStackVersion: function(context) {
    App.set('currentStackVersion', context.prevStackVersion);
  },
  configs: require('test/mock_data_setup/configs_mock_data'),
  /**
   * Delete record from DS.Store and set its stateManager to proper state
   * @param {DS.Model} record
   * @method deleteRecord
   */
  deleteRecord: function (record) {
    record.deleteRecord();
    record.get('stateManager').transitionTo('loading');
  }
};
});

;require.register("test/init_router_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

//mock App.router object
App.router = Em.Object.create({
  transitionTo: Em.K,
  configurationController: Em.Object.create({
    getConfigsByTags: Em.K
  }),
  backgroundOperationsController: Em.Object.create({
    services: []
  })
});

});

;require.register("test/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('controllers/login_controller');

describe('App.LoginController', function () {

  var loginController = App.LoginController.create();

  describe('#validateCredentials()', function () {
    /*
    it('should return undefined if no username is present', function () {
      loginController.set('loginName', '');
      expect(loginController.validateCredentials()).to.equal(undefined);
    })
    it('should return undefined if no password is present', function () {
      loginController.set('password', '');
      expect(loginController.validateCredentials()).to.equal(undefined);
    })
    it('should return the user object with the specified username and password (dummy until actual integration)', function () {
      loginController.set('loginName', 'admin');
      loginController.set('password', 'admin');
      expect(loginController.validateCredentials().get('loginName'), 'admin');
    })
    */
  })
});

});

;require.register("test/mappers/alert_definition_summary_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_definition_summary_mapper');

describe('App.alertDefinitionSummaryMapper', function () {

  describe('#map', function() {

    var testModels = [
        App.AlertDefinition.createRecord({id: 1, enabled: true, type: 'PORT'}),
        App.AlertDefinition.createRecord({id: 2, enabled: true, type: 'METRICS'}),
        App.AlertDefinition.createRecord({id: 3, enabled: true, type: 'WEB'}),
        App.AlertDefinition.createRecord({id: 4, enabled: true, type: 'AGGREGATE'}),
        App.AlertDefinition.createRecord({id: 5, enabled: true, type: 'SCRIPT'}),
        App.AlertDefinition.createRecord({id: 6, enabled: false, type: 'SCRIPT', summary: {OK: 1}})
      ],
      dataToMap = {
        alerts_summary_grouped: [
          {
            definition_id: 1,
            summary: {
              OK: {count: 1, original_timestamp: 1, maintenance_count: 0, latest_text : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"},
              WARNING: {count: 1, original_timestamp: 2, maintenance_count: 0, latest_text : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"},
              CRITICAL: {count: 0, original_timestamp: 0, maintenance_count: 1},
              UNKNOWN: {count: 0, original_timestamp: 0, maintenance_count: 0}
            }
          },
          {
            definition_id: 2,
            summary: {
              OK: {count: 1, original_timestamp: 1, maintenance_count: 0, latest_text : "HTTP 200 response in 0.000 seconds"},
              WARNING: {count: 5, original_timestamp: 2, maintenance_count: 0, latest_text : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"},
              CRITICAL: {count: 1, original_timestamp: 1, maintenance_count: 0},
              UNKNOWN: {count: 1, original_timestamp: 3, maintenance_count: 0}
            }
          },
          {
            definition_id: 3,
            summary: {
              OK: {count: 1, original_timestamp: 1, maintenance_count: 0, latest_text : "HTTP 200 response in 0.000 seconds"},
              WARNING: {count: 2, original_timestamp: 2, maintenance_count: 2},
              CRITICAL: {count: 3, original_timestamp: 4, maintenance_count: 0, latest_text : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"},
              UNKNOWN: {count: 4, original_timestamp: 3, maintenance_count: 0}
            }
          },
          {
            definition_id: 4,
            summary: {
              OK: {count: 4, original_timestamp: 1, maintenance_count: 0, latest_text : "HTTP 200 response in 0.000 seconds"},
              WARNING: {count: 3, original_timestamp: 2, maintenance_count: 0},
              CRITICAL: {count: 2, original_timestamp: 1, maintenance_count: 0},
              UNKNOWN: {count: 1, original_timestamp: 2, maintenance_count: 0, latest_text : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"}
            }
          },
          {
            definition_id: 5,
            summary: {
              OK: {count: 1, original_timestamp: 1, maintenance_count: 0, latest_text : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"},
              WARNING: {count: 1, original_timestamp: 2, maintenance_count: 0},
              CRITICAL: {count: 1, original_timestamp: 3, maintenance_count: 0},
              UNKNOWN: {count: 1, original_timestamp: 4, maintenance_count: 0}
            }
          }
        ]
      };

    beforeEach(function() {

      sinon.stub(App.AlertDefinition, 'find', function() {return testModels;});

    });

    afterEach(function() {

      App.AlertDefinition.find.restore();

    });

    it('should map summary info for each alert', function() {

      App.alertDefinitionSummaryMapper.map(dataToMap);
      expect(App.AlertDefinition.find().findProperty('id', 1).get('lastTriggered')).to.equal(2);
      expect(App.AlertDefinition.find().findProperty('id', 1).get('summary')).to.eql({OK: {count: 1, maintenanceCount: 0, latestText : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"}, WARNING: {count: 1, maintenanceCount: 0, latestText : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"}, CRITICAL: {count: 0, maintenanceCount: 1}, UNKNOWN: {count: 0, maintenanceCount: 0}});

      expect(App.AlertDefinition.find().findProperty('id', 2).get('lastTriggered')).to.equal(3);
      expect(App.AlertDefinition.find().findProperty('id', 2).get('summary')).to.eql({OK: {count: 1, maintenanceCount: 0, latestText : "HTTP 200 response in 0.000 seconds"}, WARNING: {count: 5, maintenanceCount: 0, latestText : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"}, CRITICAL: {count: 1, maintenanceCount: 0}, UNKNOWN: {count: 1, maintenanceCount: 0}});

      expect(App.AlertDefinition.find().findProperty('id', 3).get('lastTriggered')).to.equal(4);
      expect(App.AlertDefinition.find().findProperty('id', 3).get('summary')).to.eql({OK: {count: 1, maintenanceCount: 0, latestText : "HTTP 200 response in 0.000 seconds"}, WARNING: {count: 2, maintenanceCount: 2}, CRITICAL: {count: 3, maintenanceCount: 0, latestText : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"}, UNKNOWN: {count: 4, maintenanceCount: 0}});

      expect(App.AlertDefinition.find().findProperty('id', 4).get('lastTriggered')).to.equal(2);
      expect(App.AlertDefinition.find().findProperty('id', 4).get('summary')).to.eql({OK: {count: 4, maintenanceCount: 0, latestText : "HTTP 200 response in 0.000 seconds"}, WARNING: {count: 3, maintenanceCount: 0}, CRITICAL: {count: 2, maintenanceCount: 0}, UNKNOWN: {count: 1, maintenanceCount: 0, latestText : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"}});

      expect(App.AlertDefinition.find().findProperty('id', 5).get('lastTriggered')).to.equal(4);
      expect(App.AlertDefinition.find().findProperty('id', 5).get('summary')).to.eql({OK: {count: 1, maintenanceCount: 0, latestText : "Connection failed: [Errno 111] Connection refused to c6407.ambari.apache.org:60000"}, WARNING: {count: 1, maintenanceCount: 0}, CRITICAL: {count: 1, maintenanceCount: 0}, UNKNOWN: {count: 1, maintenanceCount: 0}});

    });

    it('should clear summary for disabled definitions', function () {

      App.alertDefinitionSummaryMapper.map(dataToMap);
      expect(App.AlertDefinition.find().findProperty('id', 6).get('summary')).to.eql({});

    });

  });

});

});

;require.register("test/mappers/alert_definitions_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_definitions_mapper');
var testHelpers = require('test/helpers');

describe('App.alertDefinitionsMapper', function () {
  describe.skip('#map', function () {

    var json = {
      items: [
        {
          "AlertDefinition" : {
            "component_name" : "RESOURCEMANAGER",
            "enabled" : true,
            "id" : 1,
            "ignore_host" : false,
            "interval" : 5,
            "label" : "ResourceManager RPC Latency",
            "name" : "yarn_resourcemanager_rpc_latency",
            "description" : "some description",
            "scope" : "ANY",
            "service_name" : "YARN",
            "source" : {
              "jmx" : {
                "property_list" : [
                  "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcQueueTimeAvgTime",
                  "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcProcessingTimeAvgTime"
                ],
                "value" : "{0}"
              },
              "reporting" : {
                "ok" : {
                  "text" : "Average Queue Time:[{0}], Average Processing Time:[{1}]"
                },
                "warning" : {
                  "text" : "Average Queue Time:[{0}], Average Processing Time:[{1}]",
                  "value" : 3000.0
                },
                "critical" : {
                  "text" : "Average Queue Time:[{0}], Average Processing Time:[{1}]",
                  "value" : 5000.0
                }
              },
              "type" : "METRIC",
              "uri" : {
                "http" : "{{yarn-site/yarn.resourcemanager.webapp.address}}",
                "https" : "{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
                "https_property" : "{{yarn-site/yarn.http.policy}}",
                "https_property_value" : "HTTPS_ONLY",
                "default_port" : 0.0
              }
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : "RESOURCEMANAGER",
            "enabled" : true,
            "id" : 2,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "ResourceManager Web UI",
            "name" : "yarn_resourcemanager_webui",
            "description" : "",
            "scope" : "ANY",
            "service_name" : "YARN",
            "source" : {
              "reporting" : {
                "ok" : {
                  "text" : "HTTP {0} response in {2:.4f} seconds"
                },
                "warning" : {
                  "text" : "HTTP {0} response in {2:.4f} seconds"
                },
                "critical" : {
                  "text" : "Connection failed to {1}"
                }
              },
              "type" : "WEB",
              "uri" : {
                "http" : "{{yarn-site/yarn.resourcemanager.webapp.address}}",
                "https" : "{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
                "https_property" : "{{yarn-site/yarn.http.policy}}",
                "https_property_value" : "HTTPS_ONLY",
                "default_port" : 0.0
              }
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : null,
            "enabled" : true,
            "id" : 3,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "Percent NodeManagers Available",
            "name" : "yarn_nodemanager_webui_percent",
            "description" : null,
            "scope" : "SERVICE",
            "service_name" : "YARN",
            "source" : {
              "alert_name" : "yarn_nodemanager_webui",
              "reporting" : {
                "ok" : {
                  "text" : "affected: [{1}], total: [{0}]"
                },
                "warning" : {
                  "text" : "affected: [{1}], total: [{0}]",
                  "value" : 0.1
                },
                "critical" : {
                  "text" : "affected: [{1}], total: [{0}]",
                  "value" : 0.3
                }
              },
              "type" : "AGGREGATE"
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : "NODEMANAGER",
            "enabled" : true,
            "id" : 4,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "NodeManager Health",
            "name" : "yarn_nodemanager_health",
            "description" : "some description",
            "scope" : "HOST",
            "service_name" : "YARN",
            "source" : {
              "path" : "HDP/2.0.6/services/YARN/package/files/alert_nodemanager_health.py",
              "type" : "SCRIPT"
            }
          }
        },
        {
          "AlertDefinition" : {
            "component_name" : "ZOOKEEPER_SERVER",
            "enabled" : true,
            "id" : 5,
            "ignore_host" : false,
            "interval" : 1,
            "label" : "ZooKeeper Server Process",
            "name" : "zookeeper_server_process",
            "description" : "some description",
            "scope" : "ANY",
            "service_name" : "ZOOKEEPER",
            "source" : {
              "default_port" : 2181.0,
              "reporting" : {
                "ok" : {
                  "text" : "TCP OK - {0:.4f} response on port {1}"
                },
                "critical" : {
                  "text" : "Connection failed: {0} to {1}:{2}"
                }
              },
              "type" : "PORT",
              "uri" : "{{zookeeper-env/clientPort}}"
            }
          }
        }
      ]
    };

    beforeEach(function () {

      App.alertDefinitionsMapper.setProperties({
        'model': {},

        'reportModel': {},
        'metricsSourceModel': {},
        'metricsUriModel': {}
      });

      sinon.stub(App.alertDefinitionsMapper, 'deleteRecord', Em.K);

      sinon.stub(App.store, 'commit', Em.K);
      sinon.stub(App.store, 'loadMany', function (type, content) {
        type.content = content;
      });

      sinon.stub(App.router, 'get', function() {return false;});
      App.cache['previousAlertGroupsMap'] = {};

      sinon.stub(App.alertDefinitionsMapper, 'setMetricsSourcePropertyLists', Em.K);
      sinon.stub(App.alertDefinitionsMapper, 'setAlertDefinitionsRawSourceData', Em.K);

    });

    afterEach(function () {

      App.store.commit.restore();
      App.store.loadMany.restore();

      App.alertDefinitionsMapper.setProperties({
        'model': App.AlertDefinition,

        'reportModel': App.AlertReportDefinition,
        'metricsSourceModel': App.AlertMetricsSourceDefinition,
        'metricsUriModel': App.AlertMetricsUriDefinition
      });

      App.alertDefinitionsMapper.deleteRecord.restore();

      App.router.get.restore();
      App.cache['previousAlertGroupsMap'] = {};

      App.alertDefinitionsMapper.setMetricsSourcePropertyLists.restore();
      App.alertDefinitionsMapper.setAlertDefinitionsRawSourceData.restore();

    });

    describe('should parse METRIC alertDefinitions', function () {

      var data = {items: [json.items[0]]},
        expected = [{
          id: 1,
          "name": "yarn_resourcemanager_rpc_latency",
          "label": "ResourceManager RPC Latency",
          "description" : "some description",
          "service_id": "YARN",
          "component_name": "RESOURCEMANAGER",
          "enabled": true,
          "scope": "ANY",
          "interval": 5,
          "type": "METRIC",
          "jmx_id": "1jmx",
          "uri_id": "1uri"
        }],
        expectedMetricsSource = [{
          "id":"1jmx",
          "value":"{0}",
          "property_list":[
            "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcQueueTimeAvgTime",
            "Hadoop:service=ResourceManager,name=RpcActivityForPort*/RpcProcessingTimeAvgTime"
          ]
        }],
        expectedMetricsUri = [{
          "id":"1uri",
          "http":"{{yarn-site/yarn.resourcemanager.webapp.address}}",
          "https":"{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
          "https_property":"{{yarn-site/yarn.http.policy}}",
          "https_property_value":"HTTPS_ONLY"
        }];


      beforeEach(function () {

        App.alertDefinitionsMapper.map(data);

      });

      it('parsing metrics model', function() {
        testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));
      });

      it('parse metrics source', function() {
        testHelpers.nestedExpect(expectedMetricsSource, App.alertDefinitionsMapper.get('metricsSourceModel.content'));
      });

      it('parse metrics uri', function() {
        testHelpers.nestedExpect(expectedMetricsUri, App.alertDefinitionsMapper.get('metricsUriModel.content'));
      });

    });

    describe('should parse WEB alertDefinitions', function () {

      var data = {items: [json.items[1]]},
        expected = [
          {
            "id": 2,
            "name": "yarn_resourcemanager_webui",
            "label": "ResourceManager Web UI",
            "description" : "",
            "service_id": "YARN",
            "component_name": "RESOURCEMANAGER",
            "enabled": true,
            "scope": "ANY",
            "interval": 1,
            "type": "WEB",
            "uri_id": "2uri"
          }
        ],
        expectedMetricsUri = [{
          "id":"2uri",
          "http":"{{yarn-site/yarn.resourcemanager.webapp.address}}",
          "https":"{{yarn-site/yarn.resourcemanager.webapp.https.address}}",
          "https_property":"{{yarn-site/yarn.http.policy}}",
          "https_property_value":"HTTPS_ONLY"
        }];

      beforeEach(function () {

        App.alertDefinitionsMapper.map(data);

      });

      it('parsing web model', function() {
        testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));
      });


      it('parse metrics uri', function() {
        testHelpers.nestedExpect(expectedMetricsUri, App.alertDefinitionsMapper.get('metricsUriModel.content'));
      });

    });

    it('should parse AGGREGATE alertDefinitions', function () {

      var data = {items: [json.items[2]]},
        expected = [
          {
            "id":3,
            "name":"yarn_nodemanager_webui_percent",
            "label":"Percent NodeManagers Available",
            "description" : "",
            "service_id":"YARN",
            "component_name":null,
            "enabled":true,
            "scope":"SERVICE",
            "interval":1,
            "type":"AGGREGATE",
            "alert_name":"yarn_nodemanager_webui"
          }
        ];
      App.alertDefinitionsMapper.map(data);

      testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));

    });

    it('should parse SCRIPT alertDefinitions', function () {

      var data = {items: [json.items[3]]},
        expected = [
          {
            "id":4,
            "name":"yarn_nodemanager_health",
            "label":"NodeManager Health",
            "description" : "some description",
            "service_id":"YARN",
            "component_name":"NODEMANAGER",
            "enabled":true,
            "scope":"HOST",
            "interval":1,
            "type":"SCRIPT",
            "location":"HDP/2.0.6/services/YARN/package/files/alert_nodemanager_health.py"
          }
        ];
      App.alertDefinitionsMapper.map(data);

      testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));

    });

    it('should parse PORT alertDefinitions', function () {

      var data = {items: [json.items[4]]},
        expected = [
          {
            "id":5,
            "name":"zookeeper_server_process",
            "label":"ZooKeeper Server Process",
            "description" : "some description",
            "service_id":"ZOOKEEPER",
            "component_name":"ZOOKEEPER_SERVER",
            "enabled":true,
            "scope":"ANY",
            "interval":1,
            "type":"PORT",
            "default_port":2181,
            "port_uri":"{{zookeeper-env/clientPort}}"
          }
        ];
      App.alertDefinitionsMapper.map(data);

      testHelpers.nestedExpect(expected, App.alertDefinitionsMapper.get('model.content'));

    });

    it('should set groups from App.cache.previousAlertGroupsMap', function () {

      App.cache['previousAlertGroupsMap'] = {
        1: [5,1],
        2: [4,3],
        3: [3,2],
        4: [2,5],
        5: [1,4]
      };

      App.alertDefinitionsMapper.map(json);

      expect(App.alertDefinitionsMapper.get('model.content')[0].groups).to.eql([5, 1]);
      expect(App.alertDefinitionsMapper.get('model.content')[1].groups).to.eql([4, 3]);
      expect(App.alertDefinitionsMapper.get('model.content')[2].groups).to.eql([3, 2]);
      expect(App.alertDefinitionsMapper.get('model.content')[3].groups).to.eql([2, 5]);
      expect(App.alertDefinitionsMapper.get('model.content')[4].groups).to.eql([1, 4]);


    });

    describe('should delete not existing definitions', function () {

      var definitions = [
        Em.Object.create({id: 100500, type: 'PORT'})
      ];

      beforeEach(function () {

        sinon.stub(App.AlertDefinition, 'find', function () {
          return definitions;
        });

      });

      afterEach(function() {
        App.AlertDefinition.find.restore();
      });

      it('should delete PORT alert definition with id 100500', function () {

        App.alertDefinitionsMapper.map(json);
        expect(App.alertDefinitionsMapper.deleteRecord.calledOnce).to.be.true;
        expect(App.alertDefinitionsMapper.deleteRecord.args[0][0].id).to.equal(100500);
      });

    });

  });

});
});

;require.register("test/mappers/alert_groups_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_groups_mapper');
var testHelpers = require('test/helpers');

describe('App.alertGroupsMapper', function () {

  describe('#map', function () {

    var json = {
      items: [
        {
          "AlertGroup" : {
            "default" : true,
            "definitions" : [
              {
                "id" : 8,
                "source_type" : "PORT"
              },
              {
                "id" : 9,
                "source_type" : "AGGREGATE"
              }
            ],
            "id" : 3,
            "name" : "ZOOKEEPER",
            "targets": [{id: 1}, {id: 2}]
          }
        },
        {
          "AlertGroup" : {
            "default" : true,
            "definitions" : [
              {
                "id" : 1,
                "source_type" : "METRIC"
              },
              {
                "id" : 2,
                "source_type" : "WEB"
              },
              {
                "id" : 3,
                "source_type" : "WEB"
              },
              {
                "id" : 4,
                "source_type" : "AGGREGATE"
              },
              {
                "id" : 5,
                "source_type" : "METRIC"
              },
              {
                "id" : 6,
                "source_type" : "SCRIPT"
              },
              {
                "id" : 7,
                "source_type" : "WEB"
              }
            ],
            "id" : 2,
            "name" : "YARN",
            "targets": [{id: 2}, {id: 3}]
          }
        }
      ]
    };

    beforeEach(function () {

      sinon.stub(App.store, 'commit', Em.K);
      sinon.stub(App.store, 'loadMany', function (type, content) {
        type.content = content;
      });

      App.alertGroupsMapper.set('model', {});
      App.cache['previousAlertGroupsMap'] = {};

    });

    afterEach(function () {

      App.store.commit.restore();
      App.store.loadMany.restore();
      App.alertGroupsMapper.set('model', App.AlertGroup);
      App.cache['previousAlertGroupsMap'] = {};

    });

    it('should parse alert groups', function() {

      var expected = [
        {
          id: 3,
          name: 'ZOOKEEPER',
          default: true,
          definitions: [8,9],
          targets: [1, 2]
        },
        {
          id: 2,
          name: 'YARN',
          default: true,
          definitions: [1, 2, 3, 4, 5, 6, 7],
          targets: [2, 3]
        }
      ];

      App.alertGroupsMapper.map(json);

      var mapped = App.alertGroupsMapper.get('model.content');

      testHelpers.nestedExpect(expected, mapped);

    });

    it('should set App.cache.previousAlertGroupsMap', function () {

      var expected = {
        8: [3],
        9: [3],
        1: [2],
        2: [2],
        3: [2],
        4: [2],
        5: [2],
        6: [2],
        7: [2]
      };

      App.alertGroupsMapper.map(json);

      expect(App.cache['previousAlertGroupsMap']).to.eql(expected);

    });

    describe('should delete not existing groups', function () {

      var groups = [
        {id: 1},
        {id: 2},
        {id: 3},
        {id: 4}
      ];

      beforeEach(function () {

        sinon.stub(App.AlertGroup, 'find', function() {
          if (arguments.length) {
            return groups.findProperty('id', arguments[0]);
          }
          return groups;
        });

        sinon.stub(App.alertGroupsMapper, 'deleteRecord', Em.K);

      });

      afterEach(function () {
        App.AlertGroup.find.restore();
        App.alertGroupsMapper.deleteRecord.restore();
      });

      it('should call deleteRecord with not existing groups', function () {

        App.alertGroupsMapper.map(json);
        expect(App.alertGroupsMapper.deleteRecord.calledTwice).to.be.true;
        // first call
        expect(App.alertGroupsMapper.deleteRecord.args[0][0].id).to.equal(1);
        // second call
        expect(App.alertGroupsMapper.deleteRecord.args[1][0].id).to.equal(4);

      });

    });

  });

});
});

;require.register("test/mappers/alert_instances_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/alert_instances_mapper');

describe('App.alertInstanceMapper', function () {

  var alertInstances = [
      {id: 1},
      {id: 2},
      {id: 3},
      {id: 4}
    ],
    json = {
      "items": [
        {
          "Alert": {
            "component_name": "AMBARI_AGENT",
            "host_name": "c6401.ambari.apache.org",
            "id": 2,
            "instance": null,
            "label": "Host Disk Usage",
            "latest_timestamp": 1415224354954,
            "maintenance_state": "OFF",
            "name": "ambari_agent_disk_usage",
            "original_timestamp": 1414695835400,
            "scope": "HOST",
            "service_name": "AMBARI",
            "state": "OK",
            "text": "Capacity Used: [1.26%, 6.6 GB], Capacity Total: [525.3 GB]"
          }
        },
        {
          "Alert": {
            "component_name": null,
            "host_name": null,
            "id": 3,
            "instance": null,
            "label": "Percent DataNodes Available",
            "latest_timestamp": 1415224362617,
            "maintenance_state": "OFF",
            "name": "datanode_process_percent",
            "original_timestamp": 1414695787466,
            "scope": "SERVICE",
            "service_name": "HDFS",
            "state": "CRITICAL",
            "text": "affected: [1], total: [1]"
          }
        }
      ]
    };

  it('load new records', function () {
    App.alertInstanceMapper.map(json);

    expect(App.AlertInstance.find().content.length).to.equal(2);
  });

  it('delete inexistent record', function () {
    App.alertInstanceMapper.map({
      items: [
        json.items[0]
      ]
    });

    expect(App.AlertInstance.find().content.length).to.equal(1);
  });

  it('model should be empty', function () {
    App.alertInstanceMapper.map({items: []});

    expect(App.AlertInstance.find().content).to.be.empty;
  });
});

});

;require.register("test/mappers/configs/config_groups_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/config_groups_mapper');

/**
 * not using this mapper
 */
describe.skip('App.configGroupsMapper', function () {

  var allHosts = App.get('allHostNames');
  var defaultAllHosts = ['host1', 'host2', 'host3'];
  beforeEach(function () {
    App.set('allHostNames', defaultAllHosts);
  });
  afterEach(function(){
    App.set('allHostNames', allHosts);
  });

  describe("#map", function() {

    var json = {
      "items" : [
        {
          "ConfigGroup" : {
            "cluster_name" : "1",
            "description" : "1",
            "desired_configs" : [
              {
                "tag" : "version1426088081862",
                "type" : "hadoop-env"
              }
            ],
            "group_name" : "1",
            "hosts" : [
              {
                "host_name" : "host1"
              }
            ],
            "id" : 2,
            "tag" : "Service1"
          }
        },
        {
          "ConfigGroup" : {
            "cluster_name" : "1",
            "description" : "hdfs2",
            "desired_configs" : [ ],
            "group_name" : "hdfs2",
            "hosts" : [
              {
                "host_name" : "host2"
              }
            ],
            "id" : 3,
            "tag" : "Service1"
          }
        },
        {
          "ConfigGroup" : {
            "cluster_name" : "1",
            "description" : "yarn1",
            "desired_configs" : [ ],
            "group_name" : "yarn1",
            "hosts" : [
              {
                "host_name" : "host1"
              },
              {
                "host_name" : "host2"
              }
            ],
            "id" : 4,
            "tag" : "Service2"
          }
        }
      ]
    };

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.ServiceConfigGroup);
      App.resetDsStoreTypeMap(App.Service);
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function(){
      App.store.commit.restore();
    });

    it('should not do anything as there is no serviceName', function() {
      App.configGroupsMapper.map(json);
      expect(App.ServiceConfigGroup.find().get('length')).to.equal(0);
    });

    it('should generate default groups for services', function() {
      App.Service.createRecord({'id': 'Service1'});
      App.configGroupsMapper.map(null, ["Service1"]);
      expect(App.ServiceConfigGroup.find().get('length')).to.equal(1);
      expect(App.ServiceConfigGroup.find('Service10').get('id')).to.eql('Service10');
      expect(App.ServiceConfigGroup.find('Service10').get('configGroupId')).to.eql(-1);
      expect(App.ServiceConfigGroup.find('Service10').get('name')).to.eql('Service1 Default');
      expect(App.ServiceConfigGroup.find('Service10').get('description')).to.eql('Default cluster level Service1 configuration');
      expect(App.ServiceConfigGroup.find('Service10').get('hostNames')).to.eql(defaultAllHosts);
      expect(App.ServiceConfigGroup.find('Service10').get('serviceName')).to.eql('Service1');
      expect(App.ServiceConfigGroup.find('Service10').get('service.id')).to.eql('Service1');
    });

    it('should generate groups form json and default config groups', function() {
      App.Service.createRecord({'id': 'Service1'});
      App.Service.createRecord({'id': 'Service2'});
      App.configGroupsMapper.map(json, ["Service1", "Service2"]);
      expect(App.ServiceConfigGroup.find().get('length')).to.equal(5);
      expect(App.ServiceConfigGroup.find().mapProperty('id')).to.eql(["Service12", "Service13", "Service24", "Service10", "Service20"]);
    });

    it('should generate groups form json and default config groups and check data', function() {
      App.Service.createRecord({'id': 'Service1'});
      App.Service.createRecord({'id': 'Service2'});
      App.configGroupsMapper.map(json, ["Service1", "Service2"]);

      expect(App.ServiceConfigGroup.find('Service12').get('id')).to.eql('Service12');
      expect(App.ServiceConfigGroup.find('Service12').get('configGroupId')).to.eql(2);
      expect(App.ServiceConfigGroup.find('Service12').get('name')).to.eql('1');
      expect(App.ServiceConfigGroup.find('Service12').get('description')).to.eql('1');
      expect(App.ServiceConfigGroup.find('Service12').get('hostNames')).to.eql(["host1"]);
      expect(App.ServiceConfigGroup.find('Service12').get('serviceName')).to.eql('Service1');
      expect(App.ServiceConfigGroup.find('Service12').get('service.id')).to.eql('Service1');
    });
  });

  describe("generateDefaultGroup", function() {
    var tests = [
      {
        service: 's1',
        hosts: ['h1'],
        res: {
          id: 's10',
          config_group_id: '-1',
          name: 's1 Default',
          service_name: 's1',
          description: 'Default cluster level s1 configuration',
          host_names: ['h1'],
          service_id: 's1'
        },
        m: 'with hosts'
      },
      {
        service: 's1',
        res: {
          id: 's10',
          config_group_id: '-1',
          name: 's1 Default',
          service_name: 's1',
          description: 'Default cluster level s1 configuration',
          host_names: defaultAllHosts,
          service_id: 's1'
        },
        m: 'without hosts'
      }
    ];


    tests.forEach(function(t) {
      it('generates default config group mock object ' + t.m, function() {
        expect(App.configGroupsMapper.generateDefaultGroup(t.service, t.hosts)).to.be.eql(t.res);
      });
    });

  });
});

});

;require.register("test/mappers/configs/config_versions_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/config_versions_mapper');

describe('App.configVersionsMapper', function () {

  var allHosts = App.get('allHostNames');
  var defaultAllHosts = ['host1', 'host2', 'host3'];
  beforeEach(function () {
    App.set('allHostNames', defaultAllHosts);
  });
  afterEach(function(){
    App.set('allHostNames', allHosts);
  });

  describe("#map", function() {

    var json = { items: [
      {
        "cluster_name" : "1",
        "createtime" : 1425979244738,
        "group_id" : -1,
        "group_name" : "default",
        "hosts" : [ ],
        "is_current" : true,
        "service_config_version" : 1,
        "service_config_version_note" : "Initial configurations for SERVICE1",
        "service_name" : "SERVICE1",
        "user" : "admin"
      },
      {
        "cluster_name" : "1",
        "configurations" : [
          {
            "Config" : {
              "cluster_name" : "1"
            },
            "type" : "hadoop-env",
            "tag" : "version1426088081862",
            "version" : 2,
            "properties" : {
              "dtnode_heapsize" : "1026m"
            },
            "properties_attributes" : { }
          }
        ],
        "createtime" : 1426088137115,
        "group_id" : 2,
        "group_name" : "1",
        "hosts" : [
          "host1"
        ],
        "is_current" : false,
        "service_config_version" : 4,
        "service_config_version_note" : "",
        "service_name" : "SERVICE2",
        "user" : "admin"
      },
    ]};

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.ConfigVersion);
      App.resetDsStoreTypeMap(App.ConfigProperty);
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function(){
      App.store.commit.restore();
    });

    it('should not do anything as there is no json', function() {
      App.configVersionsMapper.map(null);
      expect(App.ConfigVersion.find().get('length')).to.equal(0);
    });

    it('should load data to model', function() {
      App.configVersionsMapper.map(json);
      expect(App.ConfigVersion.find().get('length')).to.equal(2);
      expect(App.ConfigVersion.find().mapProperty('id')).to.eql(['SERVICE1_1','SERVICE2_4']);

      //SERVICE1_1
      expect(App.ConfigVersion.find('SERVICE1_1').get('configProperties.length')).to.eql(0);
      expect(App.ConfigVersion.find('SERVICE1_1').get('createTime')).to.eql(1425979244738);
      expect(App.ConfigVersion.find('SERVICE1_1').get('groupId')).to.eql(-1);
      expect(App.ConfigVersion.find('SERVICE1_1').get('hosts')).to.eql(defaultAllHosts);
      expect(App.ConfigVersion.find('SERVICE1_1').get('isCurrent')).to.be.true;
      expect(App.ConfigVersion.find('SERVICE1_1').get('version')).to.eql(1);
      expect(App.ConfigVersion.find('SERVICE1_1').get('notes')).to.eql("Initial configurations for SERVICE1");
      expect(App.ConfigVersion.find('SERVICE1_1').get('serviceName')).to.eql("SERVICE1");
      expect(App.ConfigVersion.find('SERVICE1_1').get('author')).to.eql("admin");

      //SERVICE1_2
      expect(App.ConfigVersion.find('SERVICE2_4').get('configProperties.length')).to.eql(1);
      expect(App.ConfigVersion.find('SERVICE2_4').get('createTime')).to.eql(1426088137115);
      expect(App.ConfigVersion.find('SERVICE2_4').get('groupId')).to.eql(2);
      expect(App.ConfigVersion.find('SERVICE2_4').get('hosts')).to.eql(["host1"]);
      expect(App.ConfigVersion.find('SERVICE2_4').get('isCurrent')).to.be.false;
      expect(App.ConfigVersion.find('SERVICE2_4').get('version')).to.eql(4);
      expect(App.ConfigVersion.find('SERVICE2_4').get('notes')).to.eql("");
      expect(App.ConfigVersion.find('SERVICE2_4').get('serviceName')).to.eql("SERVICE2");
      expect(App.ConfigVersion.find('SERVICE2_4').get('author')).to.eql("admin");

      //CONFIG_PROPERTY
      expect(App.ConfigProperty.find('dtnode_heapsize_hadoop-env_4').get('value')).to.eql('1026m');
      expect(App.ConfigProperty.find('dtnode_heapsize_hadoop-env_4').get('recommendedValue')).to.equal('1026m');
      expect(App.ConfigProperty.find('dtnode_heapsize_hadoop-env_4').get('isFinal')).to.be.false;
      expect(App.ConfigProperty.find('dtnode_heapsize_hadoop-env_4').get('recommendedIsFinal')).to.be.false;
    });
  });

});


});

;require.register("test/mappers/configs/stack_config_properties_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/stack_config_properties_mapper');

describe('App.stackConfigPropertiesMapper', function () {

  describe("#map", function() {

    var json = { items: [
      {
        "StackServices" : {
          "service_name" : "HBASE",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "config_types" : {
            "site1" : {
              "supports" : {
                "adding_forbidden" : "false",
                "do_not_extend" : "false",
                "final" : "true"
              }
            }
          }
        },
        "configurations" : [
          {
            "StackConfigurations" : {
              "final" : "false",
              "property_description" : "desc1",
              "property_name" : "p1",
              "property_display_name" : "P1",
              "property_type" : [ ],
              "property_value" : "v1",
              "service_name" : "s1",
              "stack_name" : "HDP",
              "stack_version" : "2.2",
              "type" : "site1.xml",
              "property_depends_on": [
                {
                  "name": "p5",
                  "type": "site5"
                }
              ],
              "property_value_attributes": {
                "type": "int",
                "minimum": "512",
                "maximum": "10240",
                "unit": "MB"
              }
            },
            "dependencies": [
              {
                "StackConfigurationDependency" : {
                  "dependency_name" : "p4",
                  "dependency_type" : "site4"
                }
              }
            ]
          }
        ]
      },
      {
        "StackServices" : {
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "config_types" : {
            "site2" : {
              "supports" : {
                "adding_forbidden" : "false",
                "do_not_extend" : "false",
                "final" : "true"
              }
            },
            "site3" : {
              "supports" : {
                "adding_forbidden" : "false",
                "do_not_extend" : "false",
                "final" : "true"
              }
            }
          }
        },
        "configurations" : [
          {
            "StackConfigurations" : {
              "final" : "false",
              "property_description" : "desc3",
              "property_name" : "p2",
              "property_display_name" : "P2",
              "property_type" : [ ],
              "property_value" : "v2",
              "service_name" : "s2",
              "stack_name" : "HDP",
              "stack_version" : "2.2",
              "type" : "site2.xml"
            }
          },
          {
            "StackConfigurations" : {
              "final" : "false",
              "property_description" : "desc3",
              "property_name" : "p3",
              "property_display_name" : "P3",
              "property_type" : [ ],
              "property_value" : "v3",
              "service_name" : "s2",
              "stack_name" : "HDP",
              "stack_version" : "2.2",
              "type" : "site3.xml"
            }
          },
          {
            "StackConfigurations" : {
              "final" : "false",
              "property_description" : "desc4",
              "property_name" : "p4",
              "property_display_name" : "P4",
              "property_type" : [ "PASSWORD" ],
              "property_value" : "v4",
              "service_name" : "s2",
              "stack_name" : "HDP",
              "stack_version" : "2.2",
              "type" : "site3.xml"
            }
          },
          {
            "StackConfigurations" : {
              "final" : "false",
              "property_description" : "desc5",
              "property_name" : "p5",
              "property_display_name" : "P5",
              "property_type" : [ "USER" ],
              "property_value" : "v4",
              "service_name" : "s2",
              "stack_name" : "HDP",
              "stack_version" : "2.2",
              "type" : "site3.xml"
            }
          }
        ]
      }
    ]};

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.StackConfigProperty);
      sinon.stub(App.store, 'commit', Em.K);
      sinon.stub(App.StackService, 'find', function() { return Em.A()});
    });
    afterEach(function(){
      App.store.commit.restore();
      App.StackService.find.restore();
    });

    it('should not do anything as there is no json', function() {
      App.stackConfigPropertiesMapper.map(null);
      expect(App.StackConfigProperty.find().get('length')).to.equal(0);
    });

    it('should load data to model', function() {
      App.stackConfigPropertiesMapper.map(json);
      expect(App.StackConfigProperty.find().get('length')).to.equal(5);
      expect(App.StackConfigProperty.find().mapProperty('id')).to.eql(['p1_site1','p2_site2','p3_site3', 'p4_site3', 'p5_site3']);

      expect(App.StackConfigProperty.find('p1_site1').get('name')).to.eql('p1');
      expect(App.StackConfigProperty.find('p1_site1').get('displayName')).to.eql('P1');
      expect(App.StackConfigProperty.find('p1_site1').get('description')).to.eql('desc1');
      expect(App.StackConfigProperty.find('p1_site1').get('recommendedValue')).to.eql('v1');
      expect(App.StackConfigProperty.find('p1_site1').get('recommendedIsFinal')).to.be.false;
      expect(App.StackConfigProperty.find('p1_site1').get('serviceName')).to.eql('s1');
      expect(App.StackConfigProperty.find('p1_site1').get('stackName')).to.eql('HDP');
      expect(App.StackConfigProperty.find('p1_site1').get('stackVersion')).to.eql('2.2');
      expect(App.StackConfigProperty.find('p1_site1').get('type').toArray()).to.eql([]);
      expect(App.StackConfigProperty.find('p1_site1').get('fileName')).to.eql('site1.xml');
      expect(App.StackConfigProperty.find('p1_site1').get('propertyDependedBy')).to.eql([
        {
          "type": "site4",
          "name": "p4"
        }
      ]);
      expect(App.StackConfigProperty.find('p1_site1').get('propertyDependsOn')).to.eql([
        {
          "type": "site5",
          "name": "p5"
        }
      ]);
      expect(App.StackConfigProperty.find('p1_site1').get('valueAttributes')).to.eql({
        "type": "int",
        "minimum": "512",
        "maximum": "10240",
        "unit": "MB"
      });
      expect(App.StackConfigProperty.find('p1_site1').get('supportsFinal')).to.be.true;
    });

    it('should set "displayType" by "property_type" attribute', function() {
      App.stackConfigPropertiesMapper.map(json);
      var prop = App.StackConfigProperty.find().findProperty('name', 'p4');
      var prop2 = App.StackConfigProperty.find().findProperty('name', 'p5');
      expect(prop).to.be.ok;
      expect(prop.get('displayType')).to.be.eql('password');
      expect(prop2.get('displayType')).to.be.eql('user');
    });
  });

});

});

;require.register("test/mappers/configs/themes_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mappers/configs/themes_mapper');
require('models/configs/theme/tab');
require('models/configs/theme/section');
require('models/configs/theme/sub_section');
require('models/configs/stack_config_property');

describe('App.themeMapper', function () {

  beforeEach(function () {
    App.resetDsStoreTypeMap(App.Tab);
    App.resetDsStoreTypeMap(App.Section);
    App.resetDsStoreTypeMap(App.SubSection);
    App.resetDsStoreTypeMap(App.StackConfigProperty);
    sinon.stub(App.store, 'commit', Em.K);
  });

  afterEach(function () {
    App.store.commit.restore();
  });

  describe("#map", function () {

    var json = {
      items: [
        {
          ThemeInfo: {
            service_name: "HDFS",
            theme_data: {
              "Theme": {
                "name": "default",
                "description": "Default theme for HDFS service",
                "configuration": {
                  "layouts": [
                    {
                      "name": "default",
                      "tabs": [
                        {
                          "name": "settings",
                          "display-name": "Settings",
                          "layout": {
                            "tab-columns": "2",
                            "tab-rows": "1",
                            "sections": [
                              {
                                "name": "Section-1",
                                "display-name": "Section One",
                                "row-index": "0",
                                "column-index": "0",
                                "row-span": "1",
                                "column-span": "1",
                                "section-columns": "2",
                                "section-rows": "3",
                                "subsections": [
                                  {
                                    "name": "subsection1",
                                    "display-name": "Storage",
                                    "border": "false",
                                    "row-index": "0",
                                    "column-index": "0",
                                    "column-span": "1",
                                    "row-span": "1"
                                  }
                                ]
                              },
                              {
                                "name": "Section-2",
                                "display-name": "Section Two",
                                "row-index": "0",
                                "column-index": "1"
                              }
                            ]
                          }
                        }
                      ]
                    }
                  ],
                  "widgets": [
                              {
                                "config": "c1/p1",
                                "widget": {
                                  "type": "slider",
                                  "units": [
                                            {
                                              "unit-name": "MB"
                                            },
                                            {
                                              "unit-name": "GB"
                                            }
                                            ]
                                }
                              },
                              {
                                "config": "c1/p2",
                                "widget": {
                                  "type": "slider",
                                  "units": [
                                            {
                                              "unit-name": "percent"
                                            }
                                            ]
                                }
                              }
                              ],
                              "placement": {
                                "configuration-layout": "default",
                                "configs": [
                                            {
                                              "config": "c1/p1",
                                              "subsection-name": "subsection1"
                                            },
                                            {
                                              "config": "c1/p2",
                                              "subsection-name": "subsection1"
                                            }
                                            ]
                              }
                }
              }
            }
          }
        }
      ]
    };

    it('should map theme data', function () {

      App.StackConfigProperty.createRecord({id: 'p1_c1'});
      App.StackConfigProperty.createRecord({id: 'p2_c1'});

      App.themesMapper.map(json);

      expect(App.Tab.find().get('length')).to.equal(1);
      expect(App.Section.find().get('length')).to.equal(2);
      expect(App.SubSection.find().get('length')).to.equal(1);

      //checking tab
      expect(App.Tab.find('HDFS_settings').toJSON()).to.eql({
        id: 'HDFS_settings',
        name: 'settings',
        display_name: 'Settings',
        columns: "2",
        rows: "1",
        is_advanced: false,
        service_name: 'HDFS',
        is_advanced_hidden: false,
        is_rendered: false,
        is_configs_prepared: false
      });

      //checking section
      expect(App.Tab.find('HDFS_settings').get('sections').objectAt(0).toJSON()).to.eql({
        "id": "Section-1",
        "name": "Section-1",
        "display_name": "Section One",
        "row_index": "0",
        "row_span": "1",
        "column_index": "0",
        "column_span": "1",
        "section_columns": "2",
        "section_rows": "3",
        "tab_id": "HDFS_settings"
      });

      //checking subsection
      expect(App.Tab.find('HDFS_settings').get('sections').objectAt(0).get('subSections').objectAt(0).toJSON()).to.eql({
        "id": "subsection1",
        "name": "subsection1",
        "display_name": "Storage",
        "border": "false",
        "row_index": "0",
        "row_span": "1",
        "column_index": "0",
        "depends_on": [],
        "left_vertical_splitter": true,
        "column_span": "1",
        "section_id": "Section-1"
      });

      //checking stack config object
      var config = App.Tab.find('HDFS_settings').get('sections').objectAt(0).get('subSections').objectAt(0).get('configProperties').objectAt(0);
      expect(config.get('id')).to.eql("p1_c1");
      expect(config.get('subSection.id')).to.eql("subsection1");
      expect(config.get('widget')).to.eql({
        "type": "slider",
        "units": [
          {
            "unit-name": "MB"
          },
          {
            "unit-name": "GB"
          }
        ]
      });
    });
  });

  describe('#generateAdvancedTabs', function () {
    it('generates advanced tabs', function () {
      App.themesMapper.generateAdvancedTabs(['HDFS']);
      expect(App.Tab.find('HDFS_advanced').toJSON()).to.eql({
        "id": "HDFS_advanced",
        "name": "advanced",
        "display_name": "Advanced",
        "columns": 1,
        "rows": 1,
        "is_advanced": true,
        "service_name": "HDFS",
        "is_advanced_hidden": false,
        is_rendered: false,
        is_configs_prepared: false
      });
    });
  });

  describe('#getConfigId', function () {
    it('gets configs id from json', function () {
      expect(App.themesMapper.getConfigId({config: "c1/p1"})).to.equal("p1_c1");
    });
    it('returns null as data is invalid', function () {
      expect(App.themesMapper.getConfigId({configs: "c1/p1"})).to.equal(null);
    });
  });
});

});

;require.register("test/mappers/hosts_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('models/host');
require('models/host_component');
require('mappers/server_data_mapper');
require('mappers/hosts_mapper');

describe('App.hostsMapper', function () {
  var mapper = App.hostsMapper;

  describe("#setMetrics()", function() {
    var data = {
      items: [
        {
          Hosts: {
            host_name: 'host1'
          },
          metrics: {
            load: {
              load_one: 1
            }
          }
        }
      ]
    };
    beforeEach(function(){
      this.mock = sinon.stub(App.Host, 'find')
    });
    afterEach(function(){
      this.mock.restore();
    });
    it("Host not in the model", function() {
      var host = Em.Object.create({
        hostName: 'host2',
        isRequested: true
      });
      this.mock.returns([host]);
      mapper.setMetrics(data);
      expect(host.get('loadOne')).to.be.undefined;
    });
    it("Host not in the filter", function() {
      var host = Em.Object.create({
        hostName: 'host1',
        isRequested: false
      });
      this.mock.returns([host]);
      mapper.setMetrics(data);
      expect(host.get('loadOne')).to.be.undefined;
    });
    it("Host should have updated metrics", function() {
      var host = Em.Object.create({
        hostName: 'host1',
        isRequested: true
      });
      this.mock.returns([host]);
      mapper.setMetrics(data);
      expect(host.get('loadOne')).to.equal(1);
    });
  });
});

});

;require.register("test/mappers/server_data_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
var mapper;

require('mappers/server_data_mapper');

describe('App.QuickDataMapper', function () {

  var test_json = {
    a1: {
      b1: {
        c1: 'val1'
      },
      b2: 'val2',
      b3: [
        {
          c2: 'val4'
        },
        {
          c2: 'val5'
        },
        {
          c2: 'val1'
        }
      ]
    },
    a2: 'val3',
    item: {
      'key.dotted': 'val6'
    }
  };

  beforeEach(function () {
    mapper = App.QuickDataMapper.create();
  });

  describe('#getJsonProperty', function() {
    var tests = [
      {i:'a1.b1.c1',e:'val1'},
      {i:'a1.b2',e:'val2'},
      {i:'a2',e:'val3'},
      {i:'a1.b3[0].c2',e:'val4'},
      {i:'a1.b3[1].c2',e:'val5'}
    ];
    tests.forEach(function(test) {
      it(test.i, function() {
        expect(mapper.getJsonProperty(test_json, test.i)).to.equal(test.e);
      });
    });
  });

  describe('#parseIt', function() {
    var config = {
      $a2: 'a2',
      f1: 'a1.b1.c1',
      f2: 'a1.b3[0].c2',
      f3: 'a1.b3',
      f4_key: 'a1.b3',
      f4_type: 'array',
      f4: {
        item: 'c2'
      }
    };
    var result;

    beforeEach(function () {
      result = mapper.parseIt(test_json, config);
    });

    it('Property starts with $', function() {
      expect(result.a2).to.equal('a2');
    });
    it('Multi-components path', function() {
      expect(result.f1).to.equal('val1');
    });
    it('Path with array index', function() {
      expect(result.f2).to.equal('val4');
    });
    it('Path returns array', function() {
      expect(result.f3.length).to.equal(3);
    });
    it('Generate array of json fields', function() {
      expect(result.f4).to.eql(['val1','val4','val5']);
    });
  });

  describe('#binaryIndexOf', function () {

    var array1 = [1,2,3,4,5,6,7,8,9];
    var array2 = ['b','c','d','e','f','g'];

    array1.forEach(function(item, index) {
      it('numeric array. test ' + (index + 1), function () {
        expect(mapper.binaryIndexOf(array1, item)).to.equal(index);
      });
    });

    it('numeric array. element doesn\'t exists', function () {
      expect(mapper.binaryIndexOf(array1, 0) < 0).to.be.true;
    });

    it('numeric array. element doesn\'t exists 2', function () {
      expect(mapper.binaryIndexOf(array1, 10) < 0).to.be.true;
    });

    array2.forEach(function(item, index) {
      it('string array. test ' + (index + 1), function () {
        expect(mapper.binaryIndexOf(array2, item)).to.equal(index);
      });
    });

    it('string array. element doesn\'t exists', function () {
      expect(mapper.binaryIndexOf(array2, 'a') < 0).to.be.true;
    });

    it('string array. element doesn\'t exists 2', function () {
      expect(mapper.binaryIndexOf(array2, 'q') < 0).to.be.true;
    });

  });

});

});

;require.register("test/mappers/service_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('utils/helper');
require('mappers/server_data_mapper');
require('mappers/service_metrics_mapper');

describe('App.serviceMetricsMapper', function () {

  describe('#hbaseMapper', function() {

    it ('Round Average Load', function() {
      var tests = [
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1.23456789
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.23'
        },
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1.00
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.00'
        },
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.00'
        },
        {
          components: [
            {
              ServiceComponentInfo: {
                component_name: "HBASE_MASTER",
                RegionsInTransition : [ ]
              },
              host_components: [
                {
                  metrics:{
                    hbase: {
                      master: {
                        IsActiveMaster: 'true',
                        AverageLoad: 1.2
                      }
                    },
                    master: {
                      AssignmentManger: {
                        ritCount: 0
                      }
                    }
                  },
                  HostRoles: {
                    host_name: 'host1'
                  }
                }
              ]
            }
          ],
          e: '1.20'
        }
      ];
      tests.forEach(function(test) {
        var result = App.serviceMetricsMapper.hbaseMapper(test);
        expect(result.average_load).to.equal(test.e);
      });
    });
  });

  describe('#stormMapper', function() {
    var tests = [
      {
        stackVersionNumber: '2.2',
        message: 'Storm mapper, stack version 2.2',
        expectedValues: {
          total_executors: 28,
          nimbus_uptime: "15m 1s",
          free_slots: 0,
          used_slots: 2,
          total_slots: 2,
          total_tasks: 28,
          topologies: 1
        },
        components: [
          {
            "ServiceComponentInfo" : {
              "component_name" : "STORM_UI_SERVER",
              "service_name" : "STORM"
            },
            "metrics" : {
              "api" : {
                "v1": {
                  "cluster": {
                    "summary": {
                      "executorsTotal": 28.0,
                      "nimbusUptime": "15m 1s",
                      "slotsFree": 0.0,
                      "slotsTotal": 2.0,
                      "slotsUsed": 2.0,
                      "supervisors": 1.0,
                      "tasksTotal": 28.0
                    }
                  },
                  "topology": {
                    "summary": [
                      {
                        "executorsTotal": 21.0,
                        "uptime": "5m 59s",
                        "schedulerInfo": null,
                        "name": "WordCountida8c06640_date2901141",
                        "workersTotal": 2.0,
                        "status": "ACTIVE",
                        "owner": "",
                        "tasksTotal": 21.0,
                        "id": "WordCountida8c06640_date2901141-2-1412195707"
                      }
                    ]
                  }
                }
              }
            }
          }
        ]
      },
      {
        stackVersionNumber: '2.1',
        message: 'Storm mapper, stack version 2.1',
        expectedValues: {
          total_executors: 2,
          nimbus_uptime: "3.96 hours",
          free_slots: 2,
          used_slots: 0,
          total_slots: 2,
          total_tasks: 21,
          topologies: 0
        },
        components: [
          {
            "ServiceComponentInfo" : {
              "component_name" : "STORM_REST_API",
              "service_name" : "STORM"
            },
            "metrics" : {
              "api" : {
                "cluster" : {
                  "summary" : {
                    "executors.total" : 2.0,
                    "nimbus.uptime" : 14250.0,
                    "slots.free" : 2.0,
                    "slots.total" : 2.0,
                    "slots.used" : 0.0,
                    "supervisors" : 1.0,
                    "tasks.total" : 21.0,
                    "topologies" : 0.0
                  }
                }
              }
            }
          }
        ]
      }
    ];

    tests.forEach(function(test) {
      it(test.message, function() {
        sinon.stub(App, 'get', function(key) {
          if (key == 'currentStackVersionNumber') {
            return test.stackVersionNumber;
          }
        });
        var result = App.serviceMetricsMapper.stormMapper(test);
        expect(result).to.include(test.expectedValues);
        App.get.restore();
      });
    });

  });
});

});

;require.register("test/mappers/service_metrics_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */


var App = require('app');

describe('App.serviceMetricsMapper', function () {

  describe('#computeAdditionalRelations', function () {

    var tests = [
      {
        message: 'if both namenodes are standby then `display_name_advanced` for both should be `Standby NameNode`',
        haStateForNn1: 'standby',
        haStateForNn2: 'standby',
        expectedNameForNn1: 'Standby NameNode',
        expectedNameForNn2: 'Standby NameNode'
      },
      {
        message: 'if one namenode is active and another is standby then they should be shown as  `Active NameNode` and `Standby NameNode` respectively',
        haStateForNn1: 'active',
        haStateForNn2: 'standby',
        expectedNameForNn1: 'Active NameNode',
        expectedNameForNn2: 'Standby NameNode'
      },
      {
        message: 'if one namenode is active and another is unknown then they should be shown as  `Active NameNode` and `Standby NameNode` respectively',
        haStateForNn1: 'active',
        haStateForNn2: undefined,
        expectedNameForNn1: 'Active NameNode',
        expectedNameForNn2: 'Standby NameNode'
      },
      {
        message: 'if both namenodes state are unknown then `display_name_advanced` for both should be null (NN will be shown with display name as `NameNode`)',
        haStateForNn1: undefined,
        haStateForNn2: undefined,
        expectedNameForNn1: null,
        expectedNameForNn2: null
      }
    ];

    var services = [
      {
        ServiceInfo: {
          service_name: "HDFS"
        },
        components: [
          {
            ServiceComponentInfo: {
              component_name: "NAMENODE",
              service_name: "HDFS"
            },
            host_components: [
              {
                HostRoles: {
                  component_name: "NAMENODE",
                  host_name: "h1"
                },
                metrics: {
                  dfs: {
                    FSNamesystem: {
                      HAState: ""
                    }
                  }
                }
              },
              {
                HostRoles: {
                  component_name: "NAMENODE",
                  host_name: "h2"
                },
                metrics: {
                  dfs: {
                    FSNamesystem: {
                      HAState: ""
                    }
                  }
                }
              }
            ]
          }
        ]
      }
    ];

    var hostComponents = [
      {
        component_name: "NAMENODE",
        host_id: "h1",
        service_id: "HDFS"
      },
      {
        component_name: "NAMENODE",
        host_id: "h2",
        service_id: "HDFS"
      }
    ];

    tests.forEach(function (test) {
      it(test.message, function () {
        services[0].components[0].host_components[0].metrics.dfs.FSNamesystem['HAState'] = test.haStateForNn1;
        services[0].components[0].host_components[1].metrics.dfs.FSNamesystem['HAState'] = test.haStateForNn2;
        App.serviceMetricsMapper.computeAdditionalRelations(hostComponents, services);
        expect(hostComponents[0].display_name_advanced).to.equal(test.expectedNameForNn1);
        expect(hostComponents[1].display_name_advanced).to.equal(test.expectedNameForNn2);
      });
    });
  });

  describe('#yarnMapper', function () {

    it('should set ACTIVE RM first in any cases (if RM HA enabled)', function() {
      var item = {
          components: [
            {
              ServiceComponentInfo: {
                component_name: 'RESOURCEMANAGER'
              },
              host_components: [
                {
                  HostRoles: {
                    ha_state: null,
                    host_name : 'h1'
                  }
                },
                {
                  HostRoles: {
                    ha_state: 'ACTIVE',
                    host_name : 'h2'
                  },
                  metrics: {
                    yarn: {
                      Queue: {
                        root: {
                          default: {}
                        }
                      }
                    }
                  }
                }
              ]
            }
          ]
        },
        result = App.serviceMetricsMapper.yarnMapper(item);
      expect(result.queue).to.equal("{\"root\":{\"default\":{}}}");
    });
  });

  describe("#isHostComponentPresent()", function () {
    var testCases = [
      {
        title: 'component is empty',
        data: {
          component: {},
          name: 'C1'
        },
        result: false
      },
      {
        title: 'component name does not match',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: ''
            }
          },
          name: 'C1'
        },
        result: false
      },
      {
        title: 'host_components is undefined',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: 'C1'
            }
          },
          name: 'C1'
        },
        result: false
      },
      {
        title: 'host_components is empty',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: 'C1'
            },
            host_components: []
          },
          name: 'C1'
        },
        result: false
      },
      {
        title: 'host_components has component',
        data: {
          component: {
            ServiceComponentInfo: {
              component_name: 'C1'
            },
            host_components: [{}]
          },
          name: 'C1'
        },
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        expect(App.serviceMetricsMapper.isHostComponentPresent(test.data.component, test.data.name)).to.equal(test.result);
      });
    });
  });
});

});

;require.register("test/mappers/stack_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');
require('mappers/server_data_mapper');
require('mappers/stack_mapper');
require('models/stack');
require('models/operating_system');
require('models/repository');

describe('App.stackMapper', function () {
	describe("#map", function() {
    
    var test_data = {
        items: [{
          "Versions" : {
            "active" : true,
            "min_upgrade_version" : null,
            "parent_stack_version" : "1.3.3",
            "stack_name" : "HDP",
            "stack_version" : "1.3"
          },
          "operating_systems" : [
            {
              "OperatingSystems" : {
                "os_type" : "redhat5",
                "stack_name" : "HDP",
                "stack_version" : "1.3"
              },
              "repositories" : [
                {
                   "Repositories" : {
                    "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                    "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                    "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.8.0",
                    "mirrors_list" : null,
                    "os_type" : "redhat5",
                    "repo_id" : "HDP-1.3",
                    "repo_name" : "HDP",
                    "stack_name" : "HDP",
                    "stack_version" : "1.3"
                  }
                },{
                  "Repositories" : {
                    "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                    "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                    "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                    "mirrors_list" : null,
                    "os_type" : "redhat5",
                    "repo_id" : "HDP-UTILS-1.1.0.16",
                    "repo_name" : "HDP-UTILS",
                    "stack_name" : "HDP",
                    "stack_version" : "1.3"
                  }
                }]
            },{
              "OperatingSystems" : {
                "os_type" : "redhat6",
                "stack_name" : "HDP",
                "stack_version" : "1.3"
              }, "repositories" : [
                  {
                    "Repositories" : {
                      "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
                      "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
                      "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.8.0",
                      "mirrors_list" : null,
                      "os_type" : "redhat6",
                      "repo_id" : "HDP-1.3",
                      "repo_name" : "HDP",
                      "stack_name" : "HDP",
                      "stack_version" : "1.3"
                    }
                  },
                  {
                    "Repositories" : {
                      "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
                      "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
                      "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
                      "mirrors_list" : null,
                      "os_type" : "redhat6",
                      "repo_id" : "HDP-UTILS-1.1.0.16",
                      "repo_name" : "HDP-UTILS",
                      "stack_name" : "HDP",
                      "stack_version" : "1.3"
                    }
                  }
                ]
            }]
      },{
        "Versions" : {
          "active" : false,
          "min_upgrade_version" : null,
          "parent_stack_version" : null,
          "stack_name" : "HDP",
          "stack_version" : "2.0.6"
        },
        "operating_systems" : [
          {
            "OperatingSystems" : {
              "os_type" : "redhat5",
              "stack_name" : "HDP",
              "stack_version" : "2.0.6"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-2.0.6",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              },
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              }]
          }, {
            "OperatingSystems" : {
              "os_type" : "redhat6",
              "stack_name" : "HDP",
              "stack_version" : "2.0.6"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-2.0.6",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              }, {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.0.6"
                }
              }]
          }]
      },{
        "Versions" : {
          "active" : true,
          "min_upgrade_version" : null,
          "parent_stack_version" : null,
          "stack_name" : "HDP",
          "stack_version" : "2.1"
        },
        "operating_systems" : [
          {
            "OperatingSystems" : {
              "os_type" : "redhat5",
              "stack_name" : "HDP",
              "stack_version" : "2.1"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-2.1",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              },
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                  "mirrors_list" : null,
                  "os_type" : "redhat5",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              }]
          }, {
            "OperatingSystems" : {
              "os_type" : "redhat6",
              "stack_name" : "HDP",
              "stack_version" : "2.1"
            },
            "repositories" : [
              {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-2.1",
                  "repo_name" : "HDP",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              }, {
                "Repositories" : {
                  "base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "default_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "latest_base_url" : "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                  "mirrors_list" : null,
                  "os_type" : "redhat6",
                  "repo_id" : "HDP-UTILS-1.1.0.17",
                  "repo_name" : "HDP-UTILS",
                  "stack_name" : "HDP",
                  "stack_version" : "2.1"
                }
              }]
          }]
      }] 
    };

    beforeEach(function () {
      App.resetDsStoreTypeMap(App.Repository);
      App.resetDsStoreTypeMap(App.OperatingSystem);
      App.resetDsStoreTypeMap(App.Stack);
      sinon.stub(App.store, 'commit', Em.K);
    });
    afterEach(function(){
      App.store.commit.restore();
    });

		
    it ('should map active Stack data', function() {
      App.stackMapper.map(test_data);
      expect(App.Stack.find().get('length')).to.equal(2);
      expect(App.Stack.find().everyProperty('active')).to.equal(true);
      expect(App.Stack.find().everyProperty('isSelected')).to.equal(false);
      expect(App.Stack.find().mapProperty('id')).to.eql(['HDP-2.1','HDP-1.3']);
    });

    it ('should map Operating System data', function() {
      App.stackMapper.map(test_data);
      expect(App.OperatingSystem.find().get('length')).to.equal(4);
      expect(App.OperatingSystem.find().mapProperty('id')).to.eql(['HDP-2.1-redhat5', 'HDP-2.1-redhat6', 'HDP-1.3-redhat5', 'HDP-1.3-redhat6']);
    });
    
    it ('should map Repository data', function() {
      App.stackMapper.map(test_data);
      expect(App.Repository.find().get('length')).to.equal(8);
      expect(App.Repository.find().mapProperty('id')).to.eql(["HDP-2.1-redhat5-HDP-2.1", "HDP-2.1-redhat5-HDP-UTILS-1.1.0.17", "HDP-2.1-redhat6-HDP-2.1", "HDP-2.1-redhat6-HDP-UTILS-1.1.0.17", "HDP-1.3-redhat5-HDP-1.3", "HDP-1.3-redhat5-HDP-UTILS-1.1.0.16", "HDP-1.3-redhat6-HDP-1.3", "HDP-1.3-redhat6-HDP-UTILS-1.1.0.16"]);
    });
  });
});

});

;require.register("test/mappers/stack_service_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');

require('mappers/stack_service_mapper');

describe('App.stackServiceMapper', function () {

  describe('#map', function () {

    var data = {
        "items": [
          {
            "StackServices" : {
              "comments" : "A high-throughput distributed messaging system",
              "custom_commands" : [ ],
              "display_name" : "Kafka",
              "required_services" : [
                "ZOOKEEPER"
              ],
              "service_check_supported" : true,
              "service_name" : "KAFKA",
              "service_version" : "0.8.1.2.2",
              "stack_name" : "HDP",
              "stack_version" : "2.2",
              "config_types" : {
                "kafka-broker" : {
                  "supports" : {
                    "adding_forbidden" : "false",
                    "do_not_extend" : "false",
                    "final" : "false"
                  }
                },
                "kafka-env" : {
                  "supports" : {
                    "adding_forbidden" : "false",
                    "do_not_extend" : "false",
                    "final" : "false"
                  }
                },
                "kafka-log4j" : {
                  "supports" : {
                    "adding_forbidden" : "false",
                    "do_not_extend" : "false",
                    "final" : "false"
                  }
                }
              }
            },
            "components" : [
              {
                "StackServiceComponents" : {
                  "cardinality" : "1+",
                  "component_category" : "MASTER",
                  "component_name" : "KAFKA_BROKER",
                  "custom_commands" : [ ],
                  "display_name" : "Kafka Broker",
                  "is_client" : false,
                  "is_master" : true,
                  "service_name" : "KAFKA",
                  "stack_name" : "HDP",
                  "stack_version" : "2.2"
                },
                "dependencies" : [
                  {
                    "Dependencies" : {
                      "component_name" : "ZOOKEEPER_SERVER",
                      "dependent_component_name" : "KAFKA_BROKER",
                      "dependent_service_name" : "KAFKA",
                      "scope" : "cluster",
                      "stack_name" : "HDP",
                      "stack_version" : "2.2"
                    }
                  }
                ]
              }
            ],
            "artifacts" : [
              {
                "Artifacts" : {
                  "artifact_name": "widget_descriptor"
                }
              }
            ]
          },
          {
            "StackServices" : {
              "service_name" : "ZOOKEEPER"
            },
            "components" : [ ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "KERBEROS"
            },
            "components" : [ ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "HDFS"
            },
            "components" : [ ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "ACCUMULO"
            },
            "components" : [ ],
            "artifacts" : [ ]
          },
          {
            "StackServices" : {
              "service_name" : "HIVE"
            },
            "components" : [
              {
                "StackServiceComponents" : {
                  "component_name" : "MYSQL_SERVER",
                  "custom_commands" : [
                    "CLEAN"
                  ]
                },
                "dependencies" : [ ]
              }
            ],
            "artifacts" : [ ]
          }
        ]
      },
      sortedServiceNames = ["HDFS", "HIVE", "ZOOKEEPER", "KAFKA", "KERBEROS", "ACCUMULO"],
      serviceResult = {
        id: "KAFKA",
        serviceName: "KAFKA",
        displayName: "Kafka",
        configTypes: {
          "kafka-broker" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kafka-env" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kafka-log4j" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          }
        },
        comments: "A high-throughput distributed messaging system",
        serviceVersion: "0.8.1.2.2",
        stackName: "HDP",
        isInstalled: false,
        isInstallable: true,
        isServiceWithWidgets: false,
        serviceCheckSupported: true,
        requiredServices: ["ZOOKEEPER"]
      },
      componentResult = {
        id: "KAFKA_BROKER",
        componentName: "KAFKA_BROKER",
        displayName: "Kafka Broker",
        cardinality: "1+",
        customCommands: [],
        serviceName: "KAFKA",
        componentCategory: "MASTER",
        isMaster: true,
        isClient: false,
        stackName: "HDP",
        stackVersion: "2.2",
        dependencies: [
          {
            componentName: "ZOOKEEPER_SERVER",
            scope : "cluster"
          }
        ]
      };

    beforeEach(function () {
      App.stackServiceMapper.clearStackModels();
    });

    it('should sort and map data about services with their components', function () {
      App.stackServiceMapper.map(data);
      var services = App.StackService.find(),
        components = App.StackServiceComponent.find(),
        kafkaService = services.findProperty('serviceName', 'KAFKA');
      expect(services.mapProperty('serviceName')).to.eql(sortedServiceNames);
      expect(kafkaService.get('serviceComponents.length')).to.equal(1);
      Em.keys(serviceResult).forEach(function (key) {
        expect(kafkaService.get(key)).to.eql(serviceResult[key]);
      });
      Em.keys(componentResult).forEach(function (key) {
        expect(kafkaService.get('serviceComponents').toArray()[0].get(key)).to.eql(componentResult[key]);
      });
      Em.keys(componentResult).forEach(function (key) {
        expect(components.findProperty('componentName', 'KAFKA_BROKER').get(key)).to.eql(componentResult[key]);
      });
      expect(services.findProperty('serviceName', 'KERBEROS').get('isInstallable')).to.be.false;
      expect(services.findProperty('serviceName', 'KERBEROS').get('isSelected')).to.be.false;
      expect(components.findProperty('componentName', 'MYSQL_SERVER').get('customCommands')).to.be.empty;
    });

  });

});

});

;require.register("test/mappers/status_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');

describe('App.statusMapper', function () {


});

});

;require.register("test/mappers/users_mapper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('mappers/server_data_mapper');
require('mappers/users_mapper');

describe('App.usersMapper', function () {

  describe('#isAdmin', function() {
    var tests = [
      {i:["AMBARI.ADMIN"],e:true,m:'has admin role'},
      {i:["CLUSTER.READ", "AMBARI.ADMIN"],e:true,m:'has admin role'},
      {i:["VIEW.USE"],e:false,m:'doesn\'t have admin role'},
      {i:["CLUSTER.OPERATE"],e:true,m:'has admin role'}
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.usersMapper.isAdmin(test.i)).to.equal(test.e);
      });
    });
  });

});

});

;require.register("test/mixins/common/configs/configs_saver_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ConfigsSaverMixin', function() {
  var mixinObject =  Em.Controller.extend(App.ConfigsSaverMixin, {});
  var instanceObject = mixinObject.create({});

  describe('#allowSaveSite()', function() {
    var stackServices = [
      Em.Object.create({
        serviceName: 'HDFS',
        serviceType: 'NONHCFS'
      }),
      Em.Object.create({
        serviceName: 'S1',
        serviceType: 'HCFS'
      }),
      Em.Object.create({
        serviceName: 'S2',
        serviceType: 'NONHCFS'
      }),
      Em.Object.create({
        serviceName: 'S3'
      })
    ];
    beforeEach(function() {
      instanceObject.set('content', {});
      sinon.stub(App.StackService, 'find', function () {
        return stackServices;
      });
    });

    afterEach(function() {
      App.StackService.find.restore();
    });

    it('returns true by default', function() {
      expect(instanceObject.allowSaveSite('some-site')).to.be.true
    });

    it('returns true for core-site and proper service', function() {
      instanceObject.set('content.serviceName', 'HDFS');
      expect(instanceObject.allowSaveSite('core-site.xml')).to.be.true
    });

    it('returns true for core-site and serviceType HCFS', function() {
      instanceObject.set('content.serviceName', 'S1');
      expect(instanceObject.allowSaveSite('core-site.xml')).to.be.true
    });

    it('returns false for core-site and serviceType not HCFS', function() {
      instanceObject.set('content.serviceName', 'S2');
      expect(instanceObject.allowSaveSite('core-site.xml')).to.be.false
    });

    it('returns false for core-site but serviceType undefined', function() {
      instanceObject.set('content.serviceName', 'S3');
      expect(instanceObject.allowSaveSite('core-site.xml')).to.be.false
    });

    it('returns false for mapred-queue-acls.xml', function() {
      expect(instanceObject.allowSaveSite('mapred-queue-acls.xml')).to.be.false
    });
  });

  describe('#createDesiredConfig()', function() {
    beforeEach(function() {
      sinon.stub(instanceObject, 'formatValueBeforeSave', function(property) {
        return property.get('value');
      })
    });
    afterEach(function() {
      instanceObject.formatValueBeforeSave.restore();
    });

    it('generates config wil throw error', function() {
      expect(instanceObject.createDesiredConfig.bind(instanceObject)).to.throw(Error, 'assertion failed');
    });

    it('generates config without properties', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1')).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {},
        "service_config_version_note": ""
      })
    });

    it('generates config with properties', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [Em.Object.create({name: 'p1', value: 'v1', isRequiredByAgent: true}), Em.Object.create({name: 'p2', value: 'v2', isRequiredByAgent: true})], "note")).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          "p1": 'v1',
          "p2": 'v2'
        },
        "service_config_version_note": 'note'
      })
    });

    it('generates config with properties and skip isRequiredByAgent', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [Em.Object.create({name: 'p1', value: 'v1', isRequiredByAgent: true}), Em.Object.create({name: 'p2', value: 'v2', isRequiredByAgent: false})], "note")).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          p1: 'v1'
        },
        "service_config_version_note": 'note'
      })
    });

    it('generates config with properties and skip service_config_version_note', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [Em.Object.create({name: 'p1', value: 'v1', isRequiredByAgent: true})], "note", true)).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          p1: 'v1'
        }
      })
    });

    it('generates config with final', function() {
      expect(instanceObject.createDesiredConfig('type1', 'version1', [Em.Object.create({name: 'p1', value: 'v1', isFinal: true, isRequiredByAgent: true}), Em.Object.create({name: 'p2', value: 'v2', isRequiredByAgent: true})], "note")).to.eql({
        "type": 'type1',
        "tag": 'version1',
        "properties": {
          p1: 'v1',
          p2: 'v2'
        },
        "properties_attributes": {
          final: {
            'p1': "true"
          }
        },
        "service_config_version_note": 'note'
      })
    })
  });

  describe('#generateDesiredConfigsJSON()', function() {
    beforeEach(function() {
      sinon.stub(instanceObject, 'createDesiredConfig', function(type) {
        return 'desiredConfig_' + type;
      });
      sinon.stub(instanceObject, 'allowSaveSite', function() {
        return true;
      });

    });
    afterEach(function() {
      instanceObject.createDesiredConfig.restore();
      instanceObject.allowSaveSite.restore();
    });

    it('generates empty array as data is missing', function() {
      expect(instanceObject.generateDesiredConfigsJSON()).to.eql([]);
      expect(instanceObject.generateDesiredConfigsJSON(1,1)).to.eql([]);
      expect(instanceObject.generateDesiredConfigsJSON([],[])).to.eql([]);
    });

    it('generates array with desired configs', function() {
      expect(instanceObject.generateDesiredConfigsJSON([Em.Object.create({'name': 'p1', 'fileName': 'f1.xml'})], ['f1'])).to.eql(['desiredConfig_f1']);
      expect(instanceObject.createDesiredConfig).to.be.calledOnce
    })
  });

  describe('#getModifiedConfigs', function () {
    var configs = [
      Em.Object.create({
        name: 'p1',
        filename: 'f1',
        isNotDefaultValue: true,
        value: 'v1'
      }),
      Em.Object.create({
        name: 'p2',
        filename: 'f1',
        isNotDefaultValue: false,
        value: 'v2'
      }),
      Em.Object.create({
        name: 'p3',
        filename: 'f2',
        isNotSaved: true,
        value: 'v4'
      }),
      Em.Object.create({
        name: 'p4',
        filename: 'f3',
        isNotDefaultValue: false,
        isNotSaved: false,
        value: 'v4'
      })
    ];
    it('filter out changed configs', function () {
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('name')).to.eql(['p1','p2','p3']);
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('filename').uniq()).to.eql(['f1','f2']);
    });

    it('filter out changed configs and modifiedFileNames', function () {
      instanceObject.set('modifiedFileNames', ['f3']);
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('name')).to.eql(['p1','p2','p3','p4']);
      expect(instanceObject.getModifiedConfigs(configs).mapProperty('filename').uniq()).to.eql(['f1','f2','f3']);
    });
  });
});


});

;require.register("test/mixins/common/configs/enhanced_configs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.EnhancedConfigsMixin', function() {

  var mixinObject = Em.Controller.extend(App.EnhancedConfigsMixin, {});
  var instanceObject = mixinObject.create({});
  describe('#removeCurrentFromDependentList()', function() {
    it('update some fields', function() {
      instanceObject.get('_dependentConfigValues').pushObject({
          saveRecommended: true,
          saveRecommendedDefault: true,
          propertyName: 'p1',
          fileName: 'f1',
          value: 'v1'
        });
      instanceObject.removeCurrentFromDependentList(Em.Object.create({name: 'p1', filename: 'f1.xml', value: 'v2'}));
      expect(instanceObject.get('_dependentConfigValues')[0]).to.eql({
        saveRecommended: false,
        saveRecommendedDefault: false,
        propertyName: 'p1',
        fileName: 'f1',
        value: 'v1'
      });
    });
  });

  describe('#buildConfigGroupJSON()', function() {
    it('generates JSON based on config group info', function() {
      var configGroup = App.ConfigGroup.create({
        name: 'group1',
        isDefault: false,
        hosts: ['host1', 'host2']
      });
      var configs = [
        App.ServiceConfigProperty.create({
          name: 'p1',
          filename: 'f1',
          overrides: [
            App.ServiceConfigProperty.create({
              group: configGroup,
              value: 'v1'
            })
          ]
        }),
        App.ServiceConfigProperty.create({
          name: 'p2',
          filename: 'f1',
          overrides: [
            App.ServiceConfigProperty.create({
              group: configGroup,
              value: 'v2'
            })
          ]
        }),
        App.ServiceConfigProperty.create({
          name: 'p3',
          filename: 'f2'
        })
      ];
      expect(instanceObject.buildConfigGroupJSON(configs, configGroup)).to.eql({
        "configurations": [
          {
            "f1": {
              "properties": {
                "p1": "v1",
                "p2": "v2"
              }
            }
          }
        ],
        "hosts": ['host1', 'host2']
      })
    });

    it('throws error as group is null', function() {
      expect(instanceObject.buildConfigGroupJSON.bind(instanceObject)).to.throw(Error, 'configGroup can\'t be null');
    });
  });
});


});

;require.register("test/mixins/common/configs/toggle_isrequired_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('#_overrideConfigIsRequired', function () {
  var controller,
    instanceObject,
    configs,
    serviceConfig;

  beforeEach(function() {
    var mixinObject = Em.Controller.extend(App.ToggleIsRequiredMixin, {});

    instanceObject = mixinObject.create({});

    configs = Em.A([
      App.ServiceConfigProperty.create({ name: 'kdc_host', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true}),
      App.ServiceConfigProperty.create({ name: 'admin_server_host', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true}),
      App.ServiceConfigProperty.create({ name: 'admin_principal', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true}),
      App.ServiceConfigProperty.create({ name: 'admin_password', value: '', category: 'KDC', serviceName: 'KERBEROS', isRequired: true})
    ]);

    configs.forEach(function(config) {
      config.validate(); // make isRequired to trigger validation and to set every property's error flag to true
    });
    serviceConfig = App.ServiceConfig.create({
      'serviceName': 'KERBEROS',
      'configs': configs
    });

  });

  it('should make isRequired = false for kerberos properties', function () {
    instanceObject.overrideConfigIsRequired(serviceConfig);
    // toggle isRequired to false
    configs.forEach(function(p) {
      expect(p.isRequired).to.be.false;
      expect(p.error).to.be.false;
    });
  });

  it('should make isRequired = true for kerberos properties', function () {
    // toggle to false
    instanceObject.overrideConfigIsRequired(serviceConfig);
    // toggle to true
    instanceObject.overrideConfigIsRequired(serviceConfig);

    configs.forEach(function(p) {
      expect(p.isRequired).to.be.true;
    });
  });
});
});

;require.register("test/mixins/common/kdc_credentials_controller_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('mixins/common/kdc_credentials_controller_mixin');

var App = require('app');
var credentialsUtils = require('utils/credentials');

var mixedObject;

describe('App.KDCCredentialsControllerMixin', function() {

  beforeEach(function() {
    mixedObject = Em.Object.create(App.KDCCredentialsControllerMixin);
  });

  afterEach(function() {
    mixedObject.destroy();
  });

  describe('#initilizeKDCStoreProperties', function() {
    [
      {
        isStorePersisted: true,
        e: {
          isEditable: true,
          hintMessage: Em.I18n.t('admin.kerberos.credentials.store.hint.supported')
        },
        message: 'Persistent store available, config should be editable, and appropriate hint shown'
      },
      {
        isStorePersisted: false,
        e: {
          isEditable: false,
          hintMessage: Em.I18n.t('admin.kerberos.credentials.store.hint.not.supported')
        },
        message: 'Only temporary store available, config should be disabled, and appropriate hint shown'
      }
    ].forEach(function(test) {
      it(test.message, function() {
        var configs = [],
            config;
        mixedObject.reopen({
          isStorePersisted: function() {
            return test.isStorePersisted;
          }.property()
        });
        mixedObject.initilizeKDCStoreProperties(configs);
        config = configs.findProperty('name', 'persist_credentials');
        Em.keys(test.e).forEach(function(key) {
          assert.equal(Em.get(config, key), test.e[key], 'validate attribute: ' + key);
        });
      });
    });
  });

  describe('#createKDCCredentials', function() {
    var createConfig = function(name, value) {
      return App.ServiceConfigProperty.create({
        name: name,
        value: value
      });
    };
    var resolveWith = function(data) {
      return $.Deferred().resolve(data).promise();
    };
    var rejectWith = function(data) {
      return $.Deferred().reject(data).promise();
    };
    [
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'true')
        ],
        credentialsExists: false,
        createCredentialFnCalled: true,
        updateCredentialFnCalled: false,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'persisted',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox checked, credentials already stored and should be updated as `persisted`'
      },
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'true')
        ],
        credentialsExists: true,
        createCredentialFnCalled: false,
        updateCredentialFnCalled: true,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'persisted',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox checked, no stored credentials, should be created as `persisted`'
      },
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'false')
        ],
        credentialsExists: true,
        createCredentialFnCalled: false,
        updateCredentialFnCalled: true,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'temporary',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox unchecked, credentials already stored and should be updated as `temporary`'
      },
      {
        configs: [
          createConfig('admin_password', 'admin'),
          createConfig('admin_principal', 'admin/admin'),
          createConfig('persist_credentials', 'false')
        ],
        credentialsExists: false,
        createCredentialFnCalled: true,
        updateCredentialFnCalled: false,
        e: [
          'testName',
          'kdc.admin.credential',
          {
            type: 'temporary',
            key: 'admin',
            principal: 'admin/admin'
          }
        ],
        message: 'Save Admin credentials checkbox unchecked, credentials already stored and should be updated as `temporary`'
      }
    ].forEach(function(test) {
      it(test.message, function() {
        sinon.stub(App, 'get').withArgs('clusterName').returns('testName');
        sinon.stub(credentialsUtils, 'getCredential', function(clusterName, alias) {
          return test.credentialsExists ? resolveWith() : rejectWith();
        });
        sinon.stub(credentialsUtils, 'createCredentials', function() {
          return resolveWith();
        });
        sinon.stub(credentialsUtils, 'updateCredentials', function() {
          return resolveWith();
        });

        mixedObject.reopen({
          isStorePersisted: function() {
            return true;
          }.property()
        });
        mixedObject.createKDCCredentials(test.configs);
        assert.equal(credentialsUtils.createCredentials.calledOnce, test.createCredentialFnCalled,  'credentialsUtils#createCredentials called');
        if (test.createCredentialFnCalled) {
          assert.deepEqual(credentialsUtils.createCredentials.args[0], test.e, 'credentialsUtils#createCredentials called with correct arguments');
        }
        credentialsUtils.createCredentials.restore();
        assert.equal(credentialsUtils.updateCredentials.calledOnce, test.updateCredentialFnCalled, 'credentialUtils#updateCredentials called');
        if (test.updateCredentialFnCalled) {
          assert.deepEqual(credentialsUtils.updateCredentials.args[0], test.e, 'credentialUtils#updateCredentials called with correct arguments');
        }
        credentialsUtils.updateCredentials.restore();
        credentialsUtils.getCredential.restore();
        App.get.restore();
      });
    });
  });

});

});

;require.register("test/mixins/common/localStorage_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/localStorage');

var localStorage,
  nameCases = [
    {
      toSet: {
        name: 'name'
      },
      toExpect: 'Name'
    },
    {
      toSet: {
        name: null,
        controller: {
          name: 'samplecontroller'
        }
      },
      toExpect: 'Samplecontroller'
    },
    {
      toSet: {
        controller: {
          name: 'sampleController'
        }
      },
      toExpect: 'Sample'
    }
  ];

describe('App.LocalStorage', function () {

  beforeEach(function () {
    localStorage = Em.Object.create(App.LocalStorage);
  });

  after(function () {
    App.db.cleanUp();
  });

  describe('#dbNamespace', function () {
    nameCases.forEach(function (item) {
      it('should be ' + item.toExpect, function () {
        localStorage.setProperties(item.toSet);
        expect(localStorage.get('dbNamespace')).to.equal(item.toExpect)
      });
    });
  });

  describe('#getDBProperty', function () {
    it('should take value from DB', function () {
      localStorage.set('name', 'name');
      localStorage.setDBProperty('key', 'value');
      expect(localStorage.getDBProperty('key')).to.equal('value');
    });
  });

});

});

;require.register("test/mixins/common/reload_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/reload_popup');

describe('App.ReloadPopupMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.ReloadPopupMixin);
  });

  describe('#popupText', function () {
    var cases = [
      {
        result: Em.I18n.t('app.reloadPopup.text'),
        title: 'should show modal popup with default message'
      },
      {
        text: 'text',
        result: 'text',
        title: 'should show modal popup with custom message'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(obj.popupText(item.text)).to.equal(item.result);
      });
    });

  });

  describe('#closeReloadPopup', function () {

    it('should hide modal popup', function () {
      obj.showReloadPopup();
      obj.closeReloadPopup();
      expect(obj.get('reloadPopup')).to.be.null;
    });

  });

});

});

;require.register("test/mixins/common/serverValidator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ServerValidatorMixin', function() {
  var mixinObject = Em.Object.extend(App.ServerValidatorMixin, {});
  describe('#validationSuccess', function() {
    var instanceObject;
    var genRespItem = function(name, filename, level, message) {
      return {
        type: 'configuration',
        'config-name': name,
        'config-type': filename,
        level: level,
        message: message
      };
    };
    var genResponse = function(items) {
      return {
        items: (items.map(function(item) { return genRespItem.apply(undefined, item); }))
      };
    };
    var genConfigs = function(configs) {
      return Em.Object.create({
        configs: (configs.map(function(item) {
            return Em.Object.create({ name: item[0], filename: item[1] });
          }))
      });
    };
    var tests = [
      {
        stepConfigs: Em.A([
          genConfigs([
            ['prop1', 'some-site.xml']
          ])
        ]),
        resources: [
          genResponse([
            ['prop1', 'some-site', 'WARN', 'Some warn'],
            ['prop2', 'some-site', 'ERROR', 'Value should be set']
          ])
        ],
        expected: [
          { prop: 'configValidationError', value: true },
          { prop: 'configValidationWarning', value: true },
          { prop: 'configValidationGlobalMessage.length', value: 1 },
          { prop: 'configValidationGlobalMessage[0].serviceName', value: 'Some Service' },
          { prop: 'configValidationGlobalMessage[0].propertyName', value: 'prop2' }
        ],
        message: 'validation failed on absent property from step configs. global message should be showed.'
      },
      {
        stepConfigs: Em.A([
          genConfigs([
            ['prop1', 'some-site.xml'],
            ['prop2', 'some-site.xml']
          ])
        ]),
        resources: [
          genResponse([
            ['prop1', 'some-site', 'WARN', 'Some warn']
          ])
        ],
        expected: [
          { prop: 'configValidationError', value: false },
          { prop: 'configValidationWarning', value: true },
          { prop: 'configValidationGlobalMessage.length', value: 0}
        ],
        message: 'all properties present in step configs. validation failed. Present WARN and ERROR level messages.'
      },
            {
        stepConfigs: Em.A([
          genConfigs([
            ['prop1', 'some-site.xml'],
            ['prop2', 'some-site.xml']
          ])
        ]),
        resources: [
          {
            items: []
          }
        ],
        expected: [
          { prop: 'configValidationFailed', value: false },
          { prop: 'configValidationError', value: false },
          { prop: 'configValidationWarning', value: false },
          { prop: 'configValidationGlobalMessage.length', value: 0}
        ],
        message: 'validation success. no errors flags should be set.'
      }
    ];
    
    beforeEach(function() {
      instanceObject = mixinObject.create({});
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({
          displayName: 'Some Service',
          configTypes: { 'some-site': {} }
        })
      ]);
    });

    afterEach(function() {
      App.StackService.find.restore();
    });
    
    tests.forEach(function(test) {
      it(test.message, function() {
        instanceObject.set('stepConfigs', test.stepConfigs);
        instanceObject.validationSuccess({resources: test.resources});
        test.expected.forEach(function(e) {
          expect(instanceObject).to.have.deep.property(e.prop, e.value);
        });
      });
    });
  });

  describe('#loadServerSideConfigsRecommendations', function() {
    describe('Request on recommendations for only specified controllers', function() {
      beforeEach(function() {
        sinon.stub(App.ajax, 'send', function(args) { return args; });
      });

      afterEach(function() {
        App.ajax.send.restore();
      });

      [
        {
          controllerName: '',
          injectEnhancedConfigsMixin: false,
          e: false
        },
        {
          controllerName: 'wizardStep7Controller',
          injectEnhancedConfigsMixin: true,
          e: true
        },
        {
          controllerName: 'kerberosWizardStep2Controller',
          injectEnhancedConfigsMixin: true,
          e: false
        }
      ].forEach(function(test) {
        it('controller "name": {0} using "EnhancedConfigsMixin": {1} recommendations called: {2}'.format(test.controllerName, test.injectEnhancedConfigsMixin, test.e), function() {
          var mixed;
          if (test.injectEnhancedConfigsMixin) {
            mixed = Em.Object.extend(App.EnhancedConfigsMixin, App.ServerValidatorMixin);
          } else {
            mixed = Em.Object.extend(App.ServerValidatorMixin);
          }
          // mock controller name in mixed object directly
          mixed.create({name: test.controllerName}).loadServerSideConfigsRecommendations();
          expect(App.ajax.send.calledOnce).to.be.eql(test.e);
          if (test.e) {
            expect(App.ajax.send.args[0][0].name).to.be.eql('config.recommendations');
          }
        });
      });
    });
  });
});


});

;require.register("test/mixins/common/table_server_view_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mixins/common/table_server_view_mixin');

describe('App.MainConfigHistoryView', function() {
  var view = Em.View.create(App.TableServerViewMixin, {
    filteredCount: 0,
    totalCount: 0,
    content: [],
    filteredContent: [],
    refresh: Em.K,
    saveFilterConditions: Em.K,
    controller: Em.Object.create({
      name: 'mainConfigHistoryController',
      paginationProps: [
        {
          name: 'displayLength',
          value: '25'
        },
        {
          name: 'startIndex',
          value: 0
        }
      ]
    })
  });

  describe('#pageContent', function() {
    beforeEach(function(){
      view.propertyDidChange('pageContent');
    });
    it('filtered content is empty', function() {
      view.set('filteredContent', []);
      expect(view.get('pageContent')).to.be.empty;
    });
    it('filtered content contain one item', function() {
      view.set('filteredCount', 1);
      view.set('filteredContent', [Em.Object.create()]);

      expect(view.get('pageContent')).to.eql([Em.Object.create()]);
    });
    it('filtered content contain two unsorted items', function() {
      view.set('filteredCount', 2);
      view.set('filteredContent', [
        Em.Object.create({index:2}),
        Em.Object.create({index:1})
      ]);

      expect(view.get('pageContent')).to.eql([
        Em.Object.create({index:1}),
        Em.Object.create({index:2})
      ]);
    });
  });

  describe('#updatePagination', function() {
    beforeEach(function () {
      sinon.spy(view, 'refresh');
      sinon.stub(App.db, 'setDisplayLength', Em.K);
      sinon.stub(App.db, 'setStartIndex', Em.K);
    });
    afterEach(function () {
      view.refresh.restore();
      App.db.setStartIndex.restore();
      App.db.setDisplayLength.restore();
    });

    it('displayLength is correct', function() {
      view.set('displayLength', '50');
      view.set('startIndex', null);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.called).to.be.false;
      expect(App.db.setDisplayLength.calledWith('mainConfigHistoryController', '50')).to.be.true;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(0);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('50');
    });
    it('startIndex is correct', function() {
      view.set('displayLength', null);
      view.set('startIndex', 10);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.calledWith('mainConfigHistoryController', 10)).to.be.true;
      expect(App.db.setDisplayLength.called).to.be.false;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(10);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('50');
    });
    it('displayLength and startIndex are correct', function() {
      view.set('displayLength', '100');
      view.set('startIndex', 20);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.calledWith('mainConfigHistoryController', 20)).to.be.true;
      expect(App.db.setDisplayLength.calledWith('mainConfigHistoryController', '100')).to.be.true;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(20);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('100');
    });
    it('displayLength and startIndex are null', function() {
      view.set('displayLength', null);
      view.set('startIndex', null);

      view.updatePagination();

      expect(view.refresh.calledOnce).to.be.true;
      expect(App.db.setStartIndex.called).to.be.false;
      expect(App.db.setDisplayLength.called).to.be.false;
      expect(view.get('controller.paginationProps').findProperty('name', 'startIndex').value).to.equal(20);
      expect(view.get('controller.paginationProps').findProperty('name', 'displayLength').value).to.equal('100');
    });
  });

  describe('#updateFilter()', function() {
    beforeEach(function () {
      sinon.stub(view, 'saveFilterConditions', Em.K);
      sinon.stub(view, 'refresh', Em.K);
      sinon.spy(view, 'updateFilter');
    });
    afterEach(function () {
      view.saveFilterConditions.restore();
      view.updateFilter.restore();
      view.refresh.restore();
    });
    it('filteringComplete is false', function() {
      this.clock = sinon.useFakeTimers();

      view.set('filteringComplete', false);
      view.updateFilter(1, '1', 'string');
      expect(view.get('controller.resetStartIndex')).to.be.false;
      expect(view.saveFilterConditions.called).to.be.false;
      view.set('filteringComplete', true);
      this.clock.tick(view.get('filterWaitingTime'));
      expect(view.updateFilter.calledWith(1, '1', 'string')).to.be.true;
      this.clock.restore();
    });
    it('filteringComplete is true', function() {
      view.set('filteringComplete', true);

      view.updateFilter(1, '1', 'string');
      expect(view.get('controller.resetStartIndex')).to.be.true;
      expect(view.saveFilterConditions.calledWith(1, '1', 'string', false)).to.be.true;
      expect(view.refresh.calledOnce).to.be.true;
    });

    it('clear filters - refresh() clears timer', function () {
      this.clock = sinon.useFakeTimers();

      //clear filters simulation
      view.set('filteringComplete', false);
      view.updateFilter(0, '', 'string');

      //filters cleared success
      view.updaterSuccessCb();

      //timeout in updateFilter() runs out
      this.clock.tick(view.get('filterWaitingTime'));

      //should not call update filter again
      expect(view.updateFilter.calledOnce).to.be.true;
      this.clock.restore();
    })
  });

  describe('#resetStartIndex()', function() {
    it('resetStartIndex is false and filteredCount is 0', function() {
      view.set('filteredCount', 0);
      view.set('controller.resetStartIndex', false);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
    });
    it('resetStartIndex is true and filteredCount is 0', function() {
      view.set('filteredCount', 0);
      view.set('controller.resetStartIndex', true);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
    });
    it('resetStartIndex is false and filteredCount is 5', function() {
      view.set('filteredCount', 5);
      view.set('controller.resetStartIndex', false);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(0);
    });
    it('resetStartIndex is true and filteredCount is 5', function() {
      view.set('controller.resetStartIndex', true);
      view.set('filteredCount', 5);
      view.set('startIndex', 0);
      view.resetStartIndex();
      expect(view.get('startIndex')).to.equal(1);
    });
  });

  describe("#updaterSuccessCb()", function () {
    beforeEach(function () {
      sinon.stub(view, 'propertyDidChange');
    });
    afterEach(function () {
      view.propertyDidChange.restore();
    });
    it("", function () {
      view.set('filteringComplete', false);
      view.updaterSuccessCb();
      expect(view.propertyDidChange.calledWith('pageContent')).to.be.true;
      expect(view.get('filteringComplete')).to.be.true;
    });
  });
});

});

;require.register("test/mixins/common/widget_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.WidgetMixin', function () {
  var mixinClass = Em.Object.extend(App.WidgetMixin, {metrics: [], content: {}});

  describe('#loadMetrics()', function () {
    var mixinObject = mixinClass.create();
    beforeEach(function () {
      this.mock = sinon.stub(mixinObject, 'getRequestData');
      sinon.stub(App.WidgetLoadAggregator, 'add');
    });
    afterEach(function () {
      this.mock.restore();
      App.WidgetLoadAggregator.add.restore();
    });
    it('has host_component_criteria', function () {
      this.mock.returns({'key1': {host_component_criteria: 'criteria'}});
      mixinObject.set('isLoaded', false);
      mixinObject.loadMetrics();

      expect(App.WidgetLoadAggregator.add.calledOnce).to.be.true;
    });
    it('host_component_criteria is absent', function () {
      this.mock.returns({'key1': {}});
      mixinObject.set('isLoaded', false);
      mixinObject.loadMetrics();

      expect(App.WidgetLoadAggregator.add.calledOnce).to.be.true;
    });
  });

  describe("#extractExpressions()", function () {
    var mixinObject = mixinClass.create();
    var testCases = [
      {
        data: '',
        result: []
      },
      {
        data: 'text',
        result: []
      },
      {
        data: 'text${a}',
        result: ['a']
      },
      {
        data: 'text${a} - ${a.b}',
        result: ['a', 'a.b']
      },
      {
        data: '${o.a-(b+4)/cc*tt}',
        result: ['o.a-(b+4)/cc*tt']
      }
    ];
    testCases.forEach(function (test) {
      it('input: ' + test.data, function () {
        var input = {value: test.data};
        expect(mixinObject.extractExpressions(input)).to.eql(test.result);
      });
    });
    it('input is null', function () {
      var input = null;
      expect(mixinObject.extractExpressions(input)).to.be.empty;
    });
  });

  describe("#getRequestData()", function () {
    var mixinObject = mixinClass.create();
    it("", function () {
      var data = [
        {
          "name": "regionserver.Server.percentFilesLocal",
          "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
          "service_name": "HBASE",
          "component_name": "HBASE_REGIONSERVER"
        },
        {
          "name": "regionserver.Server.percentFilesLocal2",
          "metric_path": "w2",
          "service_name": "HBASE",
          "component_name": "HBASE_REGIONSERVER"
        },
        {
          "name": "regionserver.Server.percentFilesLocal",
          "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
          "service_name": "HBASE",
          "component_name": "HBASE_REGIONSERVER",
          "host_component_criteria": 'c1'
        },
        {
          "name": "regionserver.Server.percentFilesLocal",
          "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
          "service_name": "HDFS",
          "component_name": "DATANODE",
          "host_component_criteria": 'c1'
        }
      ];

      expect(JSON.stringify(mixinObject.getRequestData(data))).to.eql(JSON.stringify({
        "HBASE_HBASE_REGIONSERVER": {
          "name": "regionserver.Server.percentFilesLocal",
          "service_name": "HBASE",
          "component_name": "HBASE_REGIONSERVER",
          "metric_paths": [
            {
              "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
              "metric_type": "POINT_IN_TIME",
              "id": "metrics/hbase/regionserver/percentFilesLocal_POINT_IN_TIME",
              "context": {}
            },
            {
              "metric_path": "w2",
              "metric_type": "POINT_IN_TIME",
              "id": "w2_POINT_IN_TIME",
              "context": {}
            }
          ]
        },
        "HBASE_HBASE_REGIONSERVER_c1": {
          "name": "regionserver.Server.percentFilesLocal",
          "service_name": "HBASE",
          "component_name": "HBASE_REGIONSERVER",
          "host_component_criteria": "c1",
          "metric_paths": [
            {
              "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
              "metric_type": "POINT_IN_TIME",
              "id": "metrics/hbase/regionserver/percentFilesLocal_POINT_IN_TIME",
              "context": {}
            }
          ]
        },
        "HDFS_DATANODE_c1": {
          "name": "regionserver.Server.percentFilesLocal",
          "service_name": "HDFS",
          "component_name": "DATANODE",
          "host_component_criteria": "c1",
          "metric_paths": [
            {
              "metric_path": "metrics/hbase/regionserver/percentFilesLocal",
              "metric_type": "POINT_IN_TIME",
              "id": "metrics/hbase/regionserver/percentFilesLocal_POINT_IN_TIME",
              "context": {}
            }
          ]
        }
      }));
    });
  });

  describe("#getServiceComponentMetrics()", function () {
    var mixinObject = mixinClass.create();
    before(function () {
      sinon.stub(App.ajax, 'send');
    });
    after(function () {
      App.ajax.send.restore();
    });
    it("", function () {
      var request = {
        service_name: 'S1',
        component_name: 'C1',
        metric_paths: [
          {
            "metric_path": "w1",
            "metric_type": "POINT_IN_TIME",
            "id": "w1_POINT_IN_TIME",
            "context": {}
          },
          {
            "metric_path": "w2",
            "metric_type": "POINT_IN_TIME",
            "id": "w2_POINT_IN_TIME",
            "context": {}
          }
        ]
      };
      mixinObject.getServiceComponentMetrics(request);
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'widgets.serviceComponent.metrics.get',
        sender: mixinObject,
        data: {
          serviceName: 'S1',
          componentName: 'C1',
          metricPaths: 'w1,w2'
        }
      })
    });
  });

  describe("#getMetricsSuccessCallback()", function () {
    var mixinObject = mixinClass.create();
    it("should push metrics", function () {
      var data = {
        metrics: {
          "hbase": {
            "ipc": {
              "IPC": {
                "numOpenConnections": 11.5
              }
            }
          }
        }
      };
      mixinObject.set('content.metrics', [
        {
          metric_path: 'metrics/hbase/ipc/IPC/numOpenConnections'
        }
      ]);
      mixinObject.getMetricsSuccessCallback(data);
      expect(mixinObject.get('metrics').findProperty('metric_path', 'metrics/hbase/ipc/IPC/numOpenConnections').data).to.equal(11.5);
    });
  });

  describe("#disableGraph", function () {
    var mixinObject,
      graph = Em.Object.create({
        _showMessage: Em.K
      });

    beforeEach(function() {
      mixinObject = mixinClass.create({
        childViews: [
          graph
        ],
        graphView: {},
        metrics: [{name: 'm1'}, {name: 'm2'}],
        content: {
          metrics: [{name: 'm2'}]
        }
      });
      sinon.stub(graph, '_showMessage');
      mixinObject.disableGraph();
    });

    afterEach(function() {
      graph._showMessage.restore();
    });

    it("hasData should be false", function() {
      expect(graph.get('hasData')).to.be.false;
    });

    it("isExportButtonHidden should be true", function() {
      expect(mixinObject.get('isExportButtonHidden')).to.be.true;
    });

    it("_showMessage should be called", function() {
      expect(graph._showMessage.calledWith('info', mixinObject.t('graphs.noData.title'), mixinObject.t('graphs.noDataAtTime.message'))).to.be.true;
    });

    it("metrics should be filtered", function() {
      expect(mixinObject.get('metrics').mapProperty('name')).to.be.eql(['m1']);
    });
  });

  describe("#getHostComponentMetrics()", function () {
    var mixinObject = mixinClass.create();
    before(function () {
      sinon.stub(App.ajax, 'send');
      sinon.stub(mixinObject, 'computeHostComponentCriteria').returns('criteria')
    });
    after(function () {
      App.ajax.send.restore();
      mixinObject.computeHostComponentCriteria.restore();
    });
    it("", function () {
      var request = {
        component_name: 'C1',
        metric_paths: [
          {
            "metric_path": "w1",
            "metric_type": "POINT_IN_TIME",
            "id": "w1_POINT_IN_TIME",
            "context": {}
          },
          {
            "metric_path": "w2",
            "metric_type": "POINT_IN_TIME",
            "id": "w2_POINT_IN_TIME",
            "context": {}
          }
        ],
        host_component_criteria: 'c1'
      };
      mixinObject.getHostComponentMetrics(request);
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'widgets.hostComponent.metrics.get',
        sender: mixinObject,
        data: {
          componentName: 'C1',
          metricPaths: 'w1,w2',
          hostComponentCriteria: 'criteria'
        }
      })
    });
  });

  describe("#calculateValues()", function () {
    var mixinObject = mixinClass.create();

    beforeEach(function () {
      sinon.stub(mixinObject, 'extractExpressions');
      this.mock = sinon.stub(mixinObject, 'computeExpression');
    });
    afterEach(function () {
      mixinObject.extractExpressions.restore();
      this.mock.restore();
    });
    it("value compute correctly", function () {
      this.mock.returns({'${a}': 1});
      mixinObject.set('content.values', [{
        value: '${a}'
      }]);
      mixinObject.calculateValues();
      expect(mixinObject.get('content.values')[0].computedValue).to.equal('1');
    });
    it("value not available", function () {
      this.mock.returns({});
      mixinObject.set('content.values', [{
        value: '${a}'
      }]);
      mixinObject.calculateValues();
      expect(mixinObject.get('content.values')[0].computedValue).to.equal('<span class="grey">n/a</span>');
    });
    it("value is null", function () {
      this.mock.returns({'${a}': null});
      mixinObject.set('content.values', [{
        value: '${a}'
      }]);
      mixinObject.calculateValues();
      expect(mixinObject.get('content.values')[0].computedValue).to.equal('<span class="grey">n/a</span>');
    });
  });

  describe("#computeExpression()", function () {
    var mixinObject = mixinClass.create();

    it("expression missing metrics", function () {
      var expressions = ['e.m1'];
      var metrics = [];
      expect(mixinObject.computeExpression(expressions, metrics)).to.eql({
        "${e.m1}": ""
      });
    });
    it("Value is not correct mathematical expression", function () {
      var expressions = ['e.m1'];
      var metrics = [{
        name: 'e.m1',
        data: 'a+1'
      }];
      expect(mixinObject.computeExpression(expressions, metrics)).to.eql({
        "${e.m1}": ""
      });
    });
    it("correct expression", function () {
      var expressions = ['e.m1+e.m1'];
      var metrics = [{
        name: 'e.m1',
        data: 1
      }];
      expect(mixinObject.computeExpression(expressions, metrics)).to.eql({
        "${e.m1+e.m1}": "2"
      });
    });
  });

  describe("#cloneWidget()", function () {
    var mixinObject = mixinClass.create();

    before(function () {
      sinon.spy(App, 'showConfirmationPopup');
      sinon.stub(mixinObject, 'postWidgetDefinition', Em.K);
    });
    after(function () {
      App.showConfirmationPopup.restore();
      mixinObject.postWidgetDefinition.restore();
    });
    it("", function () {
      var popup = mixinObject.cloneWidget();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(mixinObject.postWidgetDefinition.calledOnce).to.be.true;
    });
  });

  describe("#postWidgetDefinition()", function () {
    var mixinObject = mixinClass.create();

    before(function () {
      sinon.spy(App.ajax, 'send');
      sinon.stub(mixinObject, 'collectWidgetData').returns({});
    });
    after(function () {
      App.ajax.send.restore();
      mixinObject.collectWidgetData.restore();
    });
    it("", function () {
      mixinObject.postWidgetDefinition();
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'widgets.wizard.add',
        sender: mixinObject,
        data: {
          data: {}
        },
        success: 'postWidgetDefinitionSuccessCallback'
      });
    });
  });

  describe('#getMetricsErrorCallback()', function () {

    var obj,
      view = Em.Object.create({
        _showMessage: Em.K
      }),
      metrics = [
        {
          name: 'n0'
        },
        {
          name: 'n1'
        }
      ],
      cases = [
        {
          graphView: null,
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no graph view'
        },
        {
          graphView: {},
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no childViews property'
        },
        {
          graphView: {},
          childViews: [],
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no child views'
        },
        {
          graphView: {},
          childViews: [Em.Object.create({})],
          isForcedAbort: false,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'no view with _showMessage method'
        },
        {
          graphView: {},
          childViews: [Em.Object.create({}), view],
          isForcedAbort: false,
          metrics: [
            {
              name: 'n1'
            }
          ],
          showMessageCallCount: 1,
          isExportButtonHidden: true,
          title: 'graph view is available'
        },
        {
          graphView: {},
          childViews: [Em.Object.create({}), view],
          isForcedAbort: true,
          metrics: metrics,
          showMessageCallCount: 0,
          isExportButtonHidden: false,
          title: 'request is aborted'
        }
      ],
      messageCases = [
        {
          readyState: 2,
          status: 0,
          textStatus: 'error',
          title: 'incomplete request'
        },
        {
          readyState: 4,
          status: 0,
          textStatus: 'error',
          title: 'no status code'
        },
        {
          readyState: 4,
          status: 404,
          textStatus: '404 error',
          title: 'status code available'
        }
      ];

    beforeEach(function () {
      sinon.spy(view, '_showMessage');
    });

    afterEach(function () {
      view._showMessage.restore();
    });

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          obj = Em.Object.create(App.WidgetMixin, {
            metrics: metrics,
            content: {
              metrics: [
                {
                  name: 'n0'
                }
              ]
            },
            isExportButtonHidden: false,
            graphView: item.graphView,
            childViews: item.childViews
          });
          obj.getMetricsErrorCallback({
            isForcedAbort: item.isForcedAbort
          });
        });

        it('metrics array', function () {
          expect(obj.get('metrics')).to.eql(item.metrics);
        });

        it('error message', function () {
          expect(view._showMessage.callCount).to.equal(item.showMessageCallCount);
        });

        it('export button display', function () {
          expect(obj.get('isExportButtonHidden')).to.equal(item.isExportButtonHidden);
        });

      });

    });

    messageCases.forEach(function (item) {

      it(item.title, function () {
        obj = Em.Object.create(App.WidgetMixin, {
          graphView: Em.Object.create({}),
          childViews: [view]
        });
        obj.getMetricsErrorCallback({
          readyState: item.readyState,
          status: item.status
        }, 'error', 'Not Found');
        expect(view._showMessage.firstCall.args).to.eql(['warn', Em.I18n.t('graphs.error.title'), Em.I18n.t('graphs.error.message').format(item.textStatus, 'Not Found')]);
      });

    });

  });
});


describe('App.WidgetLoadAggregator', function () {
  var aggregator = App.WidgetLoadAggregator;

  describe("#add()", function () {
    beforeEach(function () {
      sinon.stub(window, 'setTimeout').returns('timeId');
    });
    afterEach(function () {
      window.setTimeout.restore();
    });
    it("timeout started", function () {
      aggregator.set('timeoutId', 'timeId');
      aggregator.get('requests').clear();
      aggregator.add({});
      expect(aggregator.get('requests')).to.not.be.empty;
      expect(window.setTimeout.called).to.be.false;
    });
    it("timeout started", function () {
      aggregator.set('timeoutId', null);
      aggregator.get('requests').clear();
      aggregator.add({});
      expect(aggregator.get('requests')).to.not.be.empty;
      expect(window.setTimeout.calledOnce).to.be.true;
      expect(aggregator.get('timeoutId')).to.equal('timeId');
    });
  });

  describe("#groupRequests()", function () {
    it("", function () {
      var requests = [
        {
          startCallName: 'n1',
          data: {
            component_name: 'C1',
            metric_paths: ['m1']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'GRAPH'
            }
          })
        },
        {
          startCallName: 'n1',
          data: {
            component_name: 'C1',
            metric_paths: ['m2']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'NUMBER'
            }
          })
        },
        {
          startCallName: 'n2',
          data: {
            component_name: 'C1',
            metric_paths: ['m3']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'TEMPLATE'
            }
          })
        },
        {
          startCallName: 'n1',
          data: {
            component_name: 'C2',
            metric_paths: ['m4']
          },
          context: Em.Object.create({
            content: {
              widgetType: 'GAUGE'
            }
          })
        }
      ];
      var result = aggregator.groupRequests(requests);

      expect(result['n1_C1'].subRequests.length).to.equal(1);
      expect(result['n1_C1'].data.metric_paths.length).to.equal(1);
      expect(result['n1_C1_graph'].subRequests.length).to.equal(1);
      expect(result['n1_C1_graph'].data.metric_paths.length).to.equal(1);
      expect(result['n2_C1'].subRequests.length).to.equal(1);
      expect(result['n2_C1'].data.metric_paths.length).to.equal(1);
      expect(result['n1_C2'].subRequests.length).to.equal(1);
      expect(result['n1_C2'].data.metric_paths.length).to.equal(1);
    });
  });

  describe("#runRequests()", function () {
    var mock = {
      f1: function () {
        return {
          done: Em.K,
          fail: Em.K,
          always: Em.K
        }
      }
    };
    beforeEach(function () {
      sinon.stub(aggregator, 'groupRequests', function (requests) {
        return requests;
      });
      sinon.spy(mock, 'f1');
    });
    afterEach(function () {
      aggregator.groupRequests.restore();
      mock.f1.restore();
    });
    it("", function () {
      var requests = {
        'r1': {
          data: {
            metric_paths: ['m1', 'm1', 'm2']
          },
          context: mock,
          startCallName: 'f1'
        }
      };
      aggregator.runRequests(requests);
      expect(mock.f1.calledWith(requests['r1'].data)).to.be.true;
    });
  });
});

});

;require.register("test/mixins/common/widgets/export_metrics_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/widgets/export_metrics_mixin');
var fileUtils = require('utils/file_utils');

describe('App.ExportMetricsMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.ExportMetricsMixin);
  });

  describe('#toggleFormatsList', function () {

    var cases = [
      {
        isExportMenuHidden: true,
        title: 'menu should be visible'
      },
      {
        isExportMenuHidden: false,
        title: 'menu should be hidden'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.set('isExportMenuHidden', !item.isExportMenuHidden);
        obj.toggleFormatsList();
        expect(obj.get('isExportMenuHidden')).to.equal(item.isExportMenuHidden);
      });
    });

  });

  describe('#exportGraphData', function () {

    var cases = [
      {
        isExportMenuHidden: true,
        event: {
          context: true
        },
        isCSV: true,
        title: 'CSV, menu should remain hidden'
      },
      {
        isExportMenuHidden: false,
        event: {},
        isCSV: false,
        title: 'JSON, menu should become hidden'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      obj.reopen({
        targetView: {
          ajaxIndex: 'index',
          getDataForAjaxRequest: function () {
            return {
              p: 'v'
            };
          }
        }
      });
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.set('isExportMenuHidden', item.isExportMenuHidden);
        obj.exportGraphData(item.event);
        var ajaxParams = App.ajax.send.firstCall.args[0];
        expect(obj.get('isExportMenuHidden')).to.be.true;
        expect(App.ajax.send.calledOnce).to.be.true;
        expect(ajaxParams.name).to.equal('index');
        expect(ajaxParams.data).to.eql({
          p: 'v',
          isCSV: item.isCSV
        });
      });
    });

  });

  describe('#exportGraphDataSuccessCallback', function () {

    var cases = [
      {
        response: null,
        showAlertPopupCallCount: 1,
        downloadTextFileCallCount: 0,
        title: 'no response'
      },
      {
        response: {
          metrics: null
        },
        showAlertPopupCallCount: 1,
        downloadTextFileCallCount: 0,
        title: 'no metrics object in response'
      },
      {
        response: {
          metrics: {}
        },
        showAlertPopupCallCount: 1,
        downloadTextFileCallCount: 0,
        title: 'empty metrics object'
      },
      {
        response: {
          metrics: {
            m0: [0, 1]
          }
        },
        params: {
          isCSV: true
        },
        showAlertPopupCallCount: 0,
        downloadTextFileCallCount: 1,
        data: '0,1',
        fileType: 'csv',
        fileName: 'data.csv',
        title: 'export to CSV'
      },
      {
        response: {
          metrics: {
            m0: [0, 1]
          }
        },
        params: {
          isCSV: false
        },
        showAlertPopupCallCount: 0,
        downloadTextFileCallCount: 1,
        data: '[{"name":"m0","data":[0,1]}]',
        fileType: 'json',
        fileName: 'data.json',
        title: 'export to JSON'
      }
    ];

    beforeEach(function () {
      sinon.stub(App, 'showAlertPopup', Em.K);
      sinon.stub(fileUtils, 'downloadTextFile', Em.K);
      sinon.stub(obj, 'prepareCSV').returns('0,1');
      obj.reopen({
        targetView: {
          getData: function (response) {
            var data = [];
            if (response && response.metrics) {
              var name = Em.keys(response.metrics)[0];
              if (name && response.metrics[name]) {
                data = [
                  {
                    name: name,
                    data: response.metrics[name]
                  }
                ];
              }
            }
            return data;
          }
        }
      });
    });

    afterEach(function () {
      App.showAlertPopup.restore();
      fileUtils.downloadTextFile.restore();
      obj.prepareCSV.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.exportGraphDataSuccessCallback(item.response, null, item.params);
        expect(fileUtils.downloadTextFile.callCount).to.equal(item.downloadTextFileCallCount);
        if (item.downloadTextFileCallCount) {
          expect(fileUtils.downloadTextFile.firstCall.args[0].replace(/\s/g, '')).to.equal(item.data);
          expect(fileUtils.downloadTextFile.firstCall.args[1]).to.equal(item.fileType);
          expect(fileUtils.downloadTextFile.firstCall.args[2]).to.equal(item.fileName);
        }
      });
    });

  });

  describe('#exportGraphDataErrorCallback', function () {

    beforeEach(function () {
      sinon.stub(App.ajax, 'defaultErrorHandler', Em.K);
    });

    afterEach(function () {
      App.ajax.defaultErrorHandler.restore();
    });

    it('should display error popup', function () {
      obj.exportGraphDataErrorCallback({
          status: 404
        }, null, '', {
          url: 'url',
          method: 'GET'
        });
      expect(App.ajax.defaultErrorHandler.calledOnce).to.be.true;
      expect(App.ajax.defaultErrorHandler.calledWith({
          status: 404
        }, 'url', 'GET', 404)).to.be.true;
    });

  });

  describe('#prepareCSV', function () {

    var cases = [
        {
          displayUnit: 'B',
          result: 'Timestamp,n0 (B),n1 (B)\n1,0,4\n3,2,5\n',
          title: 'display unit set'
        },
        {
          result: 'Timestamp,n0,n1\n1,0,4\n3,2,5\n',
          title: 'display unit not set'
        }
      ],
      data = [
        {
          name: 'n0',
          data: [[0, 1], [2, 3]]
        },
        {
          name: 'n1',
          data: [[4, 1], [5, 3]]
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.reopen({
          targetView: {
            displayUnit: item.displayUnit
          }
        });
        expect(obj.prepareCSV(data)).to.equal(item.result);
      });
    });

  });

  describe('#hideMenuForNoData', function () {

    var cases = [
      {
        isExportButtonHidden: true,
        isExportMenuHidden: true,
        title: 'menu should be hidden'
      },
      {
        isExportButtonHidden: false,
        isExportMenuHidden: false,
        title: 'menu should be visible'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        obj.setProperties({
          isExportButtonHidden: item.isExportButtonHidden,
          isExportMenuHidden: false
        });
        expect(obj.get('isExportMenuHidden')).to.equal(item.isExportMenuHidden);
      });
    });

  });

  describe('#jsonReplacer', function () {

    var cases = [
      {
        json: [
          {
            name: 'n0',
            data: [
              [0, 1],
              [1, 2]
            ]
          }
        ],
        result: '[{"name":"n0","data":[[0,1],[1,2]]}]',
        title: 'valid object'
      },
      {
        json: [
          {
            name: 'n1',
            data: [
              [0, 1],
              [1, 2]
            ],
            p1: 'v1'
          }
        ],
        result: '[{"name":"n1","data":[[0,1],[1,2]]}]',
        title: 'object with redundant property'
      },
      {
        json: [
          {
            name: 'n1',
            data: {
              p2: 'v2'
            }
          }
        ],
        result: '[{"name":"n1","data":{}}]',
        title: 'object with malformed data'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(JSON.stringify(item.json, obj.jsonReplacer())).to.equal(item.result);
      });
    });

  });

});

});

;require.register("test/mixins/common/widgets/time_range_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/widgets/time_range_mixin');

var timeRangePopup = require('views/common/custom_date_popup');

describe('App.TimeRangeMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.TimeRangeMixin);
  });

  describe('#currentTimeRange', function () {

    var cases = Em.Object.create(App.TimeRangeMixin).get('timeRangeOptions'),
      title = 'should set "{0}" time range';

    cases.forEach(function (item) {
      it(title.format(item.name), function () {
        obj.set('currentTimeRangeIndex', item.index);
        expect(obj.get('currentTimeRange')).to.eql(item);
      });
    });

  });

  describe('#setTimeRange', function () {

    var indexCases = [
        {
          index: 1,
          showCustomDatePopupCallCount: 0,
          title: 'preset time range',
          popupTestTitle: 'popup should not be displayed'
        },
        {
          index: 8,
          showCustomDatePopupCallCount: 1,
          title: 'custom time range',
          popupTestTitle: 'popup should be displayed'
        }
      ],
      rangeCases = [
        {
          index: 1,
          customStartTime: null,
          customEndTime: null,
          customDurationFormatted: null,
          title: 'time range is preset',
          testTitle: 'should reset time range boundaries'
        },
        {
          index: 8,
          customStartTime: 1,
          customEndTime: 1,
          customDurationFormatted: '1 hour',
          title: 'time range is custom',
          testTitle: 'should not reset time range boundaries'
        }
      ];

    beforeEach(function () {
      sinon.stub(timeRangePopup, 'showCustomDatePopup', Em.K);
    });

    afterEach(function () {
      timeRangePopup.showCustomDatePopup.restore();
    });

    indexCases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          obj.setTimeRange({
            context: {
              index: item.index
            }
          });
        });

        it('should set time range', function () {
          expect(obj.get('currentTimeRangeIndex')).to.equal(item.index);
        });

        it(item.popupTestTitle, function () {
          expect(timeRangePopup.showCustomDatePopup.callCount).to.equal(item.showCustomDatePopupCallCount);
        });

      });

    });

    rangeCases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          obj.setProperties({
            customStartTime: 1,
            customEndTime: 1,
            customDurationFormatted: '1 hour'
          });
          obj.setTimeRange({
            context: {
              index: item.index
            }
          });
        });

        it(item.testTitle, function () {
          expect(obj.getProperties(['customStartTime', 'customEndTime', 'customDurationFormatted'])).to.eql({
            customStartTime: item.customStartTime,
            customEndTime: item.customEndTime,
            customDurationFormatted: item.customDurationFormatted
          });
        });

      });

    });

  });

});

});

;require.register("test/mixins/common/widgets/widget_section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/common/widgets/widget_section');

describe('App.WidgetSectionMixin', function () {

  var obj;

  beforeEach(function () {
    obj = Em.Object.create(App.WidgetSectionMixin);
  });

  describe('#isAmbariMetricsInstalled', function () {

    var cases = [
      {
        services: [],
        isAmbariMetricsInstalled: false,
        title: 'Ambari Metrics not installed'
      },
      {
        services: [
          {
            serviceName: 'AMBARI_METRICS'
          }
        ],
        isAmbariMetricsInstalled: true,
        title: 'Ambari Metrics installed'
      }
    ];

    afterEach(function () {
      App.Service.find.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App.Service, 'find').returns(item.services);
        expect(obj.get('isAmbariMetricsInstalled')).to.equal(item.isAmbariMetricsInstalled);
      });
    });

  });

});
});

;require.register("test/mixins/main/host/details/host_components/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('mixins/main/host/details/host_components/decommissionable');

var decommissionable,
  view,
  statusCases = [
    {
      status: App.HostComponentStatus.started,
      expected: false
    },
    {
      status: 'status',
      expected: true
    }
  ],
  responseCases = [
    {
      HostRoles: {
        desired_admin_state: 'state'
      },
      ServiceComponentInfo: {component_state: ''}
    },
    {
      HostRoles: {
        desired_admin_state: null
      },
      ServiceComponentInfo: {component_state: ''}
    }
  ],
  textCases = [
    {
      available: true,
      text: Em.I18n.t('common.decommission')
    },
    {
      available: false,
      text: Em.I18n.t('common.recommission')
    }
  ];

describe('App.Decommissionable', function () {

  beforeEach(function () {
    decommissionable = Em.Object.create(App.Decommissionable);
  });

  describe('#decommissionView.text', function () {

    beforeEach(function () {
      view = decommissionable.decommissionView.create();
      view.reopen({
        parentView: decommissionable
      });
    });

    textCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        view.set('parentView.isComponentDecommissionAvailable', item.available);
        expect(view.get('text')).to.equal(item.text);
      });
    });

  });

});

});

;require.register("test/mixins/main/service/configs/widget_popover_support_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.WidgetPopoverSupport', function () {

  beforeEach(function () {
    view = Em.View.create(App.WidgetPopoverSupport, {});
  });


});
});

;require.register("test/mixins/routers/redirections_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var router, installerController, currentClusterStatus;

describe('App.RouterRedirections', function () {

  beforeEach(function () {

    installerController = Em.Object.create({
      currentStep: '',
      totalSteps: 11,
      setCurrentStep: function (k) {
        this.set('currentStep', k);
      }
    });
    App.router.get('installerController').setIsStepDisabled.call(installerController);
    installerController.setLowerStepsDisable = App.router.get('installerController').setLowerStepsDisable.bind(installerController);
    installerController.get('isStepDisabled').pushObject(Ember.Object.create({
      step: 0,
      value: true
    }));

    router = Em.Object.create(App.RouterRedirections, {
      transitionTo: Em.K,
      setAuthenticated: Em.K,
      installerController: installerController
    });

    currentClusterStatus = {};

    sinon.spy(router, 'transitionTo');
    sinon.spy(router, 'setAuthenticated');
    sinon.stub(App, 'get').withArgs('router').returns(router);

  });

  afterEach(function () {
    router.transitionTo.restore();
    router.setAuthenticated.restore();
    App.get.restore();
    currentClusterStatus = {};
  });

  describe('#redirectToInstaller', function () {

    it('CLUSTER_NOT_CREATED_1. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_NOT_CREATED_1';
      installerController.set('currentStep', '4');
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step4')).to.be.true;
    });

    it('CLUSTER_NOT_CREATED_1. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_NOT_CREATED_1';
      installerController.set('currentStep', '4');
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step4')).to.be.true;
    });

    it('CLUSTER_DEPLOY_PREP_2. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_DEPLOY_PREP_2';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step8')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

    it('CLUSTER_DEPLOY_PREP_2. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_DEPLOY_PREP_2';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step8')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

    it('CLUSTER_INSTALLING_3. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLING_3';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step9')).to.be.true;
    });

    it('CLUSTER_INSTALLING_3. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLING_3';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step9')).to.be.true;
    });

    it('SERVICE_STARTING_3. user is on installer', function () {
      currentClusterStatus.clusterState = 'SERVICE_STARTING_3';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step9')).to.be.true;
    });

    it('SERVICE_STARTING_3. user is not on installer', function () {
      currentClusterStatus.clusterState = 'SERVICE_STARTING_3';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step9')).to.be.true;
    });

    it('CLUSTER_INSTALLED_4. user is on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLED_4';
      router.redirectToInstaller(router, currentClusterStatus, true);
      expect(router.transitionTo.calledWith('step10')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

    it('CLUSTER_INSTALLED_4. user is not on installer', function () {
      currentClusterStatus.clusterState = 'CLUSTER_INSTALLED_4';
      router.redirectToInstaller(router, currentClusterStatus, false);
      expect(router.transitionTo.calledWith('installer.step10')).to.be.true;
      expect(router.setAuthenticated.calledWith(true)).to.be.true;
    });

  });

});
});

;require.register("test/mixins/unit_convert/base_unit_convert_mixin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.BaseUnitConvertMixin', function() {
  beforeEach(function() {
    this.mixin = Em.Object.create(App.BaseUnitConvertMixin, {});
  });

  describe('#convertValue', function() {
    var tests = [
      {
        value: "10",
        fromUnit: "b",
        toUnit: "b",
        e: 10
      },
      {
        value: "2048",
        fromUnit: "b",
        toUnit: "kb",
        e: 2
      },
      {
        value: "2097152",
        fromUnit: "b",
        toUnit: "mb",
        e: 2
      },
      {
        value: "1",
        fromUnit: "mb",
        toUnit: "kb",
        e: 1024
      },
      {
        value: "107374182400",
        fromUnit: "b",
        toUnit: "gb",
        e: 100
      },
      {
        value: "100",
        fromUnit: "gb",
        toUnit: "b",
        e: 107374182400
      },
      {
        value: "1294336",
        fromUnit: "b",
        toUnit: ["mb", "kb"],
        e: [
          { type: "mb", value: 1},
          { type: "kb", value: 240}
        ]
      },
      {
        value: [
          { type: "mb", value: 1},
          { type: "kb", value: 240}
        ],
        fromUnit: ["mb", "kb"],
        toUnit: "b",
        e: 1294336
      },
      {
        value: [
          { type: "mb", value: 1},
          { type: "kb", value: 240}
        ],
        fromUnit: "mb,kb",
        toUnit: "b",
        e: 1294336
      },
      {
        value: 60000,
        fromUnit: 'milliseconds',
        toUnit: "days,hours,minutes",
        e: [
          { type: 'days', value: 0},
          { type: 'hours', value: 0},
          { type: 'minutes', value: 1}
        ]
      },
      {
        value: 80,
        fromUnit: 'percent',
        toUnit: 'int',
        currentDimensionType: 'percent.percent_int',
        e: 80
      },
      {
        value: 80,
        fromUnit: 'int',
        toUnit: 'percent',
        currentDimensionType: 'percent.percent_int',
        e: 80
      },
      {
        value: 0.89,
        fromUnit: 'float',
        toUnit: 'percent',
        currentDimensionType: 'percent.percent_float',
        e: 89
      },
      {
        value: 89,
        fromUnit: 'percent',
        toUnit: 'float',
        currentDimensionType: 'percent.percent_float',
        e: 0.89
      },
      {
        value: 100,
        fromUnit: 'percent',
        toUnit: 'float',
        currentDimensionType: 'percent.percent_float',
        e: 1
      },
      {
        value: 1,
        fromUnit: 'float',
        toUnit: 'percent',
        currentDimensionType: 'percent.percent_float',
        e: 100
      }
    ];

    tests.forEach(function(test) {
      it('should convert {0} {1} to {2} {3}'.format(JSON.stringify(test.value), test.fromUnit, JSON.stringify(test.e), test.toUnit), function() {
        if (test.currentDimensionType) {
          this.mixin.set('currentDimensionType', test.currentDimensionType);
        }

        var result = this.mixin.convertValue(test.value, test.fromUnit, test.toUnit);
        if (Em.isArray(result)) {
          result = result.map(function(item) {
            return App.permit(item, ['type', 'value']);
          });
        }
        expect(result).to.be.eql(test.e);
      });
    }, this);
  });
});

});

;require.register("test/mixins/wizard/addSeccurityConfigs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var stackDescriptorData = require('test/mock_data_setup/stack_descriptors');
var stackDescriptor = stackDescriptorData.artifact_data;
var controller;
require('mixins/wizard/addSecurityConfigs');

describe('App.AddSecurityConfigs', function () {

  beforeEach(function () {
    controller = Em.Object.create(App.AddSecurityConfigs, {
      content: {
        services: []
      },
      enableSubmit: function () {
        this._super();
      },
      configs: [],
      secureMapping: [],
      secureProperties: []
    });
  });

  describe('#secureServices', function() {
    it('content.services is correct', function() {
      controller.set('content.services', [{}]);
      expect(controller.get('secureServices')).to.eql([{}]);
    });
  });

  describe('#loadUiSideSecureConfigs()', function() {

    beforeEach(function(){
      sinon.stub(controller, 'checkServiceForConfigValue', function() {
        return 'value2';
      });
      sinon.stub(controller, 'setConfigValue', Em.K);
      sinon.stub(controller, 'formatConfigName', Em.K);
      sinon.stub(App.Service, 'find').returns([{serviceName: 'SOME_SERVICE'}]);
    });

    afterEach(function(){
      controller.checkServiceForConfigValue.restore();
      controller.setConfigValue.restore();
      controller.formatConfigName.restore();
      App.Service.find.restore();
    });

    it('secureMapping is empty', function() {
      controller.set('secureMapping', []);

      expect(controller.loadUiSideSecureConfigs()).to.be.empty;
    });

    it('Config does not have dependedServiceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        serviceName: 'SOME_SERVICE',
        foreignKey: null
      }]);

      expect(controller.loadUiSideSecureConfigs()).to.eql([{
        "name": 'config1',
        "value": 'value1',
        "filename": 'file1'
      }]);
    });

    it('Config has dependedServiceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: null,
        serviceName: 'SOME_SERVICE',
        dependedServiceName: 'SOME_SERVICE'
      }]);

      expect(controller.loadUiSideSecureConfigs()).to.eql([{
        "name": 'config1',
        "value": 'value2',
        "filename": 'file1'
      }]);
    });

    it('Config has non-existent serviceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: true,
        serviceName: 'NO_SERVICE'
      }]);

      expect(controller.loadUiSideSecureConfigs()).to.be.empty;
    });

    it('Config has correct serviceName', function() {
      controller.set('secureMapping', [{
        name: 'config1',
        value: 'value1',
        filename: 'file1',
        foreignKey: true,
        serviceName: 'SOME_SERVICE'
      }]);

      expect(controller.loadUiSideSecureConfigs()).to.eql([{
        "name": 'config1',
        "value": 'value1',
        "filename": 'file1'
      }]);
      expect(controller.setConfigValue.calledOnce).to.be.true;
      expect(controller.formatConfigName.calledOnce).to.be.true;
    });

  });

  describe('#checkServiceForConfigValue()', function() {

    it('services is empty', function() {
      var services = [];

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('value1');
    });

    it('Service is loaded', function() {
      var services = [{}];
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('value1');

      App.Service.find.restore();
    });

    it('Service is not loaded', function() {
      var services = [{
        replace: 'val'
      }];
      sinon.stub(App.Service, 'find', function () {
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.checkServiceForConfigValue('value1', services)).to.equal('ue1');

      App.Service.find.restore();
    });

  });

  describe('#formatConfigName()', function() {

    it('config.value is null', function() {
      var config = {
        value: null
      };

      expect(controller.formatConfigName([], config)).to.be.false;
    });

    it('config.name does not contain foreignKey', function() {
      var config = {
        value: 'value1',
        name: 'config1'
      };

      expect(controller.formatConfigName([], config)).to.be.false;
    });

    it('globalProperties is empty, use uiConfig', function() {
      var config = {
        value: 'value1',
        name: '<foreignKey[0]>',
        foreignKey: ['key1']
      };
      controller.set('globalProperties', []);
      var uiConfig = [{
        name: 'key1',
        value: 'globalValue1'
      }];

      expect(controller.formatConfigName(uiConfig, config)).to.be.true;
      expect(config._name).to.equal('globalValue1');
    });

  });

  describe('#setConfigValue()', function() {

    it('config.value is null', function() {
      var config = {
        value: null
      };

      expect(controller.setConfigValue(config)).to.be.false;
    });

    it('config.value does not match "templateName"', function() {
      var config = {
        value: ''
      };

      expect(controller.setConfigValue(config)).to.be.false;
    });

    it('No such property in global configs', function() {
      var config = {
        value: '<templateName[0]>',
        templateName: ['config1']
      };
      controller.set('globalProperties', []);
      controller.set('configs', []);

      expect(controller.setConfigValue(config)).to.be.true;
      expect(config.value).to.be.null;
    });

    it('Hive Metastore hostname array is converted to string', function () {
      var config = {
        value: '<templateName[0]>',
        templateName: ['hive_metastore']
      };
      controller.set('globalProperties', []);
      controller.set('configs', [
        {
          name: 'hive_metastore',
          value: ['h0', 'h1', 'h2']
        }
      ]);

      expect(controller.setConfigValue(config)).to.be.true;
      expect(config.value).to.equal('h0,h1,h2');
    });

  });

  describe('#addHostConfig()', function() {

    afterEach(function () {
      App.Service.find.restore();
    });

    it('No such service loaded', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({isLoaded: false});
      });

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });

    it('No such service in secureServices', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({isLoaded: true});
      });
      controller.set('secureServices', []);

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });

    it('Service does not have such host-component', function() {
      sinon.stub(App.Service, 'find', function(){
        return Em.Object.create({
          isLoaded: true,
          hostComponents: []
        });
      });
      controller.set('secureServices', [{
        serviceName: 'service1'
      }]);

      expect(controller.addHostConfig('service1', 'comp1', 'config1')).to.be.false;
    });
  });

  describe('#getPrincipalNames()', function() {

    beforeEach(function () {
      controller.setProperties({
        globalProperties: [],
        secureProperties: []
      });
    });

    it('globalProperties and secureProperties are empty', function() {
      expect(controller.getPrincipalNames()).to.be.empty;
    });

    it('global property name does not match "principal_name"', function() {
      controller.set('globalProperties', [{
        name: 'config1'
      }]);
      expect(controller.getPrincipalNames()).to.be.empty;
    });

    it('secure property name does not match "principal_name"', function() {
      controller.set('secureProperties', [{
        name: 'config1'
      }]);
      expect(controller.getPrincipalNames()).to.be.empty;
    });

    it('property with such name already exists', function() {
      controller.setProperties({
        globalProperties: [{
          name: 'principal_name'
        }],
        secureProperties: [{
          name: 'principal_name'
        }]
      });
      expect(controller.getPrincipalNames().mapProperty('name')).to.eql(['principal_name']);
    });

  });

  describe('#loadUsersFromServer()', function() {

    it('testMode = true', function() {
      controller.set('testModeUsers', [{
        name: 'user1',
        value: 'value1'
      }]);
      controller.set('serviceUsers', []);
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });

      controller.loadUsersFromServer();
      expect(controller.get('serviceUsers')).to.eql([{
        name: 'user1',
        value: 'value1'
      }]);
      App.get.restore();
    });

    it('testMode = false', function() {
      sinon.stub(App.router, 'set', Em.K);
      sinon.stub(App.db, 'getSecureUserInfo', function(){
        return [];
      });
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return false;
        return Em.get(App, k);
      });

      controller.loadUsersFromServer();
      expect(App.db.getSecureUserInfo.calledOnce).to.be.true;
      expect(App.router.set.calledWith('mainAdminSecurityController.serviceUsers', [])).to.be.true;

      App.router.set.restore();
      App.get.restore();
      App.db.getSecureUserInfo.restore();
    });

  });

  describe('#createServicesStackDescriptorConfigs', function() {

    var result;
    beforeEach(function() {
      result = controller.createServicesStackDescriptorConfigs(stackDescriptorData);
    });

    Em.A([
      {
        property: 'spnego_keytab',
        e: [
          { key: 'value', value: '${keytab_dir}/spnego.service.keytab' },
          { key: 'serviceName', value: 'Cluster' }
        ]
      },
      // principal name inherited from /spnego with predefined value
      {
        property: 'oozie.authentication.kerberos.principal',
        e: [
          { key: 'value', value: 'HTTP/${host}@${realm}' },
          { key: 'isEditable', value: true }
        ]
      },
      // keytab inherited from /spnego without predefined file value
      {
        property: 'oozie.authentication.kerberos.keytab',
        e: [
          { key: 'value', value: null },
          { key: 'isEditable', value: false },
          { key: 'referenceProperty', value: 'spnego:keytab' },
          { key: 'observesValueFrom', value: 'spnego_keytab' }
        ]
      }
    ]).forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(result.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          expect(result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
        });
      });
    });
  });

  describe('#expandKerberosStackDescriptorProps', function() {
    var serviceName = 'Cluster';
    var result;
    beforeEach(function() {
      result = controller.expandKerberosStackDescriptorProps(stackDescriptor.properties, serviceName);
    });
    Em.A([
      {
        property: 'realm',
        e: [
          { key: 'isEditable', value: false },
          { key: 'serviceName', value: 'Cluster' }
        ]
      },
      {
        property: 'keytab_dir',
        e: [
          { key: 'isEditable', value: true },
          { key: 'serviceName', value: 'Cluster' }
        ]
      }
    ]).forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(result.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          expect(result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
        });
      });
    });
  });

  describe('#createConfigsByIdentity', function() {
    var identitiesData = stackDescriptor.services[0].components[0].identities;
    var properties;

    beforeEach(function () {
      properties = controller.createConfigsByIdentities(identitiesData, 'HDFS');
    });

    Em.A([
      {
        property: 'dfs.namenode.kerberos.principal',
        e: [
          { key: 'value', value: 'nn/_HOST@${realm}' }
        ]
      },
      {
        property: 'dfs.web.authentication.kerberos.principal',
        e: [
          { key: 'referenceProperty', value: 'spnego:principal' },
          { key: 'isEditable', value: false }
        ]
      }
    ]).forEach(function(test) {
      it('property {0} should be created'.format(test.property), function() {
        expect(properties.findProperty('name', test.property)).to.be.ok;
      });
      test.e.forEach(function(expected) {
        it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
          expect(properties.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
        });
      });
    });
  });

  describe('#parseIdentityObject', function() {
    var testCases = [
      {
        identity: stackDescriptor.services[0].components[0].identities[0],
        tests: [
          {
            property: 'dfs.namenode.kerberos.principal',
            e: [
              { key: 'filename', value: 'hdfs-site' }
            ]
          },
          {
            property: 'dfs.namenode.keytab.file',
            e: [
              { key: 'value', value: '${keytab_dir}/nn.service.keytab' }
            ]
          }
        ]
      },
      {
        identity: stackDescriptor.services[0].components[0].identities[1],
        tests: [
          {
            property: 'dfs.namenode.kerberos.https.principal',
            e: [
              { key: 'filename', value: 'hdfs-site' }
            ]
          }
        ]
      },
      {
        identity: stackDescriptor.identities[0],
        tests: [
          {
            property: 'spnego_principal',
            e: [
              { key: 'displayName', value: 'Spnego Principal' },
              { key: 'filename', value: 'cluster-env' }
            ]
          }
        ]
      },
      {
        identity: stackDescriptor.identities[0],
        tests: [
          {
            property: 'spnego_keytab',
            e: [
              { key: 'displayName', value: 'Spnego Keytab' },
              { key: 'filename', value: 'cluster-env' }
            ]
          }
        ]
      }
    ];
    
    testCases.forEach(function(testCase) {
      testCase.tests.forEach(function(test) {
        it('property `{0}` should be present'.format(test.property), function() {
          var result = controller.parseIdentityObject(testCase.identity);
          expect(result.findProperty('name', test.property)).to.be.ok;
        });
        test.e.forEach(function(expected) {
          it('property `{0}` should have `{1}` with value `{2}`'.format(test.property, expected.key, expected.value), function() {
            var result = controller.parseIdentityObject(testCase.identity);
            expect(result.findProperty('name', test.property)).to.have.deep.property(expected.key, expected.value);
          });
        });
      });
    });
  });

  describe('#processConfigReferences', function() {

    var generateProperty = function(name, reference) {
      return Em.Object.create({ name: name, referenceProperty: reference});
    };
    var descriptor = {
      identities: [
        { name: 'spnego', principal: { value: 'spnego_value' }, keytab: { file: 'spnego_file'} },
        { name: 'hdfs',
          principal: { value: 'hdfs_value', configuration: "hadoop-env/hdfs_user_principal_name" },
          keytab: { file: 'hdfs_file', configuration: "hadoop-env/hdfs_user_keytab"} }
      ],
      services: [
        {
          name: 'SERVICE',
          identities: [
            { name: '/spnego' },
            { name: '/hdfs' }
          ]
        },
        {
          name: 'SERVICE2',
          components: [
            {
              name: 'COMPONENT',
              identities: [
                {
                  name: 'component_prop1',
                  keytab: { configuration: 'service2-site/component.keytab' },
                  principal: { configuration: null }
                },
                {
                  name: 'component_prop2',
                  keytab: { configuration: 'service2-site/component2.keytab' },
                  principal: { configuration: 'service2-site/component2.principal' }
                }
              ]
            }
          ]
        }
      ]
    };
    var configs = Em.A([
      generateProperty('spnego_inherited_keytab', 'spnego:keytab'),
      generateProperty('spnego_inherited_principal', 'spnego:principal'),
      generateProperty('hdfs_inherited_keytab', 'hdfs:keytab'),
      generateProperty('hdfs_inherited_principal', 'hdfs:principal'),
      generateProperty('component_prop1_inherited_principal', 'component_prop1:principal'),
      generateProperty('component_prop1_inherited_keytab', 'component_prop1:keytab'),
      generateProperty('component_prop2_inherited_keytab', 'component_prop2:keytab'),
      generateProperty('component_prop2_inherited_principal', 'component_prop2:principal')
    ]);
    var tests = [
      { name: 'spnego_inherited_keytab', e: 'spnego_keytab' },
      { name: 'spnego_inherited_principal', e: 'spnego_principal' },
      { name: 'hdfs_inherited_keytab', e: 'hdfs_user_keytab' },
      { name: 'hdfs_inherited_principal', e: 'hdfs_user_principal_name' },
      { name: 'component_prop1_inherited_keytab', e: 'component.keytab' },
      { name: 'component_prop1_inherited_principal', e: 'component_prop1_principal' },
      { name: 'component_prop2_inherited_keytab', e: 'component2.keytab' },
      { name: 'component_prop2_inherited_principal', e: 'component2.principal' }
    ];

    before(function() {
      controller.processConfigReferences(descriptor, configs);
    });
    
    tests.forEach(function(test) {
      it('`{0}` should observe value from `{1}` property'.format(test.name, test.e), function() {
        expect(configs.findProperty('name', test.name).get('observesValueFrom')).to.be.eql(test.e); 
      });
    });
  });

  describe('#_getDisplayNameForConfig', function () {

    beforeEach(function () {
      controller.set('secureProperties', require('data/HDP2/secure_properties').configProperties);
    });

    it('config from `cluster-env`', function() {
      var config = {
        fileName: 'cluster-env',
        name: 'someCoolName'
      };
      var displayName = controller._getDisplayNameForConfig(config.name, config.fileName);
      expect(displayName).to.equal(App.format.normalizeName(config.name));
    });

    it('config does not exist in the secure_properties', function() {
      var config = {
        fileName: '',
        name: 'someCoolFakeName'
      };
      var displayName = controller._getDisplayNameForConfig(config.name, config.fileName);
      expect(displayName).to.equal(config.name);
    });

    it('config exists in the secure_properties', function() {
      var config = {
        fileName: '',
        name: 'storm_ui_keytab'
      };
      var displayName = controller._getDisplayNameForConfig(config.name, config.fileName);
      expect(displayName).to.equal(controller.get('secureProperties').findProperty('name', config.name).displayName);
    });

  })

});

});

;require.register("test/mixins/wizard/assign_master_components_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('mixins/wizard/assign_master_components');
var c;

describe('App.AssignMasterComponents', function () {
  var baseObject = Em.Object.extend(App.AssignMasterComponents);
  var data;

  beforeEach(function () {
    c = baseObject.create();
    c.set('content', {});

    var hosts = [];
    for(var i = 1; i <= 4; ++i) {
      hosts.push(App.Host.createRecord({
        'host_name': 'h' + i
      }));
    }
    c.set('hosts', hosts);

    data = {
      "resources": [
        {
          "recommendations": {
            "blueprint": {
              "host_groups": [
                {
                  "name": "host-group-1",
                  "components": [{"name": "c1"}, {"name": "c3"}, {"name": "c2"}]
                },
                {
                  "name": "host-group-2",
                  "components": [{"name": "c1"}, {"name": "c2"}]
                },
                {
                  "name": "host-group-3",
                  "components": [{"name": "c1"}]
                }
              ]
            },
            "blueprint_cluster_binding": {
              "host_groups": [
                {
                  "name": "host-group-1",
                  "hosts": [{"fqdn": "h1"}]
                },
                {
                  "name": "host-group-3",
                  "hosts": [{"fqdn": "h3"}]
                },
                {
                  "name": "host-group-2",
                  "hosts": [{"fqdn": "h2"}, {"fqdn": "h4"}]
                }
              ]
            }
          }
        }
      ]
    };
  });

  describe('#loadRecommendationsSuccessCallback', function () {

    it('should set recommendations', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.get('content.recommendations')).to.eq(data.resources[0].recommendations);
    });

    it('should set recommendedHostsForComponents', function() {
      c.loadRecommendationsSuccessCallback(data);
      var expected = {
        "c1": ["h1", "h2", "h4", "h3"],
        "c3": ["h1"],
        "c2": ["h1", "h2", "h4"]
      };

      expect(JSON.stringify(c.get('content.recommendedHostsForComponents'))).to.equal(JSON.stringify(expected));
    });
  });

  describe('#getHostForMaster', function () {

    var allMasters;

    beforeEach(function () {
      allMasters = [
        {
          "component_name": "c1",
          "selectedHost": "h1"
        },
        {
          "component_name": "c1",
          "selectedHost": "h2"
        },
        {
          "component_name": "c1",
          "selectedHost": "h3"
        },
        {
          "component_name": "c1",
          "selectedHost": "h4"
        },
        {
          "component_name": "c2",
          "selectedHost": "h1"
        },
        {
          "component_name": "c5",
          "selectedHost": "h1"
        }
      ];
    });

    it('should return the recommended host', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c2', allMasters)).to.eq('h2');
    });

    it('should return the first available host from the list of existing hosts', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c6', allMasters)).to.eq('h1');
    });

    it('should return the next available host from the list of existing hosts', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c5', allMasters)).to.eq('h2');
    });

    it('should return false if the component is already on all hosts', function() {
      c.loadRecommendationsSuccessCallback(data);
      expect(c.getHostForMaster('c1', allMasters)).to.eq(false);
    });

  });

  describe('#sortComponentsByServiceName', function () {

    var components = [{
      "component_name": "METRICS_COLLECTOR",
      "serviceId": "AMBARI_METRICS"
    }, {
      "component_name": "ZOOKEEPER_SERVER",
      "serviceId": "ZOOKEEPER"
    }, {
      "component_name": "NAMENODE",
      "serviceId": "HDFS"
    }, {
      "component_name": "DRPC_SERVER",
      "serviceId": "STORM"
    }, {
      "component_name": "APP_TIMELINE_SERVER",
      "serviceId": "YARN"
    }, {
      "component_name": "RESOURCEMANAGER",
      "serviceId": "YARN"
    }, {
      "component_name": "SECONDARY_NAMENODE",
      "serviceId": "HDFS"
    }, {
      "component_name": "ZOOKEEPER_SERVER",
      "serviceId": "ZOOKEEPER"
    }, {
      "component_name": "HISTORYSERVER",
      "serviceId": "MAPREDUCE2"
    }, {
      "component_name": "HAWQSTANDBY",
      "serviceId": "HAWQ"
    }, {
      "component_name": "NIMBUS",
      "serviceId": "STORM"
    }, {
      "component_name": "HAWQMASTER",
      "serviceId": "HAWQ"
    }, {
      "component_name": "STORM_UI_SERVER",
      "serviceId": "STORM"
    }];

    it('should place ZOOKEEPER_SERVER one after another', function () {
      var sorted = c.sortComponentsByServiceName(components);
      expect(sorted.mapProperty('component_name').join('|').contains('ZOOKEEPER_SERVER|ZOOKEEPER_SERVER')).to.be.true;
    });

    it('should place HAWQMASTER just before HAWQSTANDBY', function () {
      var sorted = c.sortComponentsByServiceName(components);
      expect(sorted.mapProperty('component_name').join('|').contains('HAWQMASTER|HAWQSTANDBY')).to.be.true;
    });

  });
});
});

;require.register("test/mixins/wizard/wizardEnableDone_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.WizardEnableDone', function () {
  var baseObject = Em.Object.extend({
        statusChangeCallback: function (data) {
          isSubmitDisabled: true
        }
      }),
      mixedObject = baseObject.extend(App.WizardEnableDone);
  beforeEach(function () {
    mixedObjectInstance = mixedObject.create({
      tasks: [{status: 'COMPLETED'}, {status: 'FAILED'}],
      content: Em.Object.create({
        controllerName: 'wizardControllerName'
      })
    });
    sinon.stub(App.router, 'get', function () {
          return Em.Object.create({
            totalSteps: 6,
            currentStep: 6
          });
        }
    );
  });

  afterEach(function () {
    App.router.get.restore();
  });

  it('#statusChangeCallback should enable done/complete button', function () {
    mixedObjectInstance.statusChangeCallback();
    expect(mixedObjectInstance.isSubmitDisabled).to.be.false;
  });
});
});

;require.register("test/mixins/wizard/wizardProgressPageController_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.wizardProgressPageControllerMixin', function() {
  var mixedObject = Em.Object.extend(App.wizardProgressPageControllerMixin, {});

  describe('#createComponent', function() {
    var mixedObjectInstance;
    beforeEach(function() {
      mixedObjectInstance = mixedObject.create({});
      sinon.stub(App.ajax, 'send', function(params) {
        return $.extend(params,{complete: function(callback){
          callback();
        }});
      });
      sinon.stub(mixedObjectInstance, "updateAndCreateServiceComponent").returns({
        done: function(callback) {
          return callback();
        }
      });
      sinon.spy(mixedObjectInstance, 'onCreateComponent');
      sinon.spy(mixedObjectInstance, 'updateComponent');
      sinon.stub(mixedObjectInstance, 'checkInstalledComponents', function(componentName, hostNames) {
        var def = $.Deferred();
        var data = {
          'ZOOKEEPER_SERVER': {
            items: []
          },
          'ZOOKEEPER_CLIENT': {
            items: [
              { HostRoles: { host_name: 'host1' } }
            ]
          }
        };
        def.resolve(data[componentName]);
        return def.promise();
      });
      sinon.stub(App.StackServiceComponent, 'find', function(){
        return [
          Em.Object.create({
          componentName: 'ZOOKEEPER_CLIENT',
          serviceName: 'ZOOKEEPER'
        }),
          Em.Object.create({
          componentName: 'ZOOKEEPER_SERVER',
          serviceName: 'ZOOKEEPER'
        })
        ];
      });
      App.serviceComponents = ['ZOOKEEPER_SERVER', 'ZOOKEEPER_CLIENT'];
    });

    afterEach(function() {
      App.ajax.send.restore();
      App.StackServiceComponent.find.restore();
      mixedObjectInstance.updateAndCreateServiceComponent.restore();
      mixedObjectInstance.onCreateComponent.restore();
      mixedObjectInstance.updateComponent.restore();
      mixedObjectInstance.checkInstalledComponents.restore();
    });

    it('should call `checkInstalledComponents` method', function() {
      mixedObjectInstance.createComponent('ZOOKEEPER_SERVER', 'host1', 'ZOOKEEPER');
      expect(mixedObjectInstance.checkInstalledComponents.called).to.be.true;
    });

    it('should call `checkInstalledComponents` method with host name converted to Array', function() {
      mixedObjectInstance.createComponent('ZOOKEEPER_SERVER', 'host1', 'ZOOKEEPER');
      expect(mixedObjectInstance.checkInstalledComponents.calledWith('ZOOKEEPER_SERVER', ['host1'])).to.be.true;
    });

    it('no ZooKeeper Servers installed. install on host1, host2. ajax request should be called with appropriate params', function() {
      mixedObjectInstance.createComponent('ZOOKEEPER_SERVER', ['host1', 'host2'], 'ZOOKEEPER');
      var args = App.ajax.send.args[0][0];

      var queryObject = JSON.parse(args.data.data);
      expect(args.data.hostName).to.be.eql(['host1', 'host2']);
      expect(queryObject.RequestInfo.query).to.be.eql('Hosts/host_name=host1|Hosts/host_name=host2');
      expect(queryObject.Body.host_components[0].HostRoles.component_name).to.be.eql('ZOOKEEPER_SERVER');
      expect(args.data.taskNum).to.be.eql(1);
      // invoke callback
      args.sender[args.success].apply(args.sender, [null, null, args.data]);
      expect(mixedObjectInstance.updateComponent.called).to.be.true;
    });

    it('ZooKeeper Client installed on host1. install on host1, host2. ajax request should be called with appropriate params', function() {
      mixedObjectInstance.createComponent('ZOOKEEPER_CLIENT', ['host1', 'host2'], 'ZOOKEEPER');
      var args = App.ajax.send.args[0][0];
      var queryObject = JSON.parse(args.data.data);
      expect(args.data.hostName).to.be.eql(['host1', 'host2']);
      expect(queryObject.RequestInfo.query).to.be.eql('Hosts/host_name=host2');
      expect(queryObject.Body.host_components[0].HostRoles.component_name).to.be.eql('ZOOKEEPER_CLIENT');
      expect(mixedObjectInstance.onCreateComponent.called).to.be.false;
      // invoke callback
      args.sender[args.success].apply(args.sender, [null, null, args.data]);
      expect(mixedObjectInstance.updateComponent.called).to.be.true;
    });
  });

  describe('#updateComponent', function() {
    var testsAjax = [
      {
        callParams: ['ZOOKEEPER_SERVER', 'host1', 'ZOOKEEPER', 'Install', 1],
        e: [
          { key: 'data.HostRoles.state', value: 'INSTALLED'},
          { key: 'data.hostName[0]', value: 'host1'},
          { key: 'data.query', value: 'HostRoles/component_name=ZOOKEEPER_SERVER&HostRoles/host_name.in(host1)&HostRoles/maintenance_state=OFF'}
        ]
      },
      {
        callParams: ['ZOOKEEPER_SERVER', ['host1', 'host2'], 'ZOOKEEPER', 'start', 1],
        e: [
          { key: 'data.HostRoles.state', value: 'STARTED'},
          { key: 'data.hostName[0]', value: 'host1'},
          { key: 'data.hostName[1]', value: 'host2'},
          { key: 'data.query', value: 'HostRoles/component_name=ZOOKEEPER_SERVER&HostRoles/host_name.in(host1,host2)&HostRoles/maintenance_state=OFF'}
        ]
      }
    ];

    testsAjax.forEach(function(test) {
      describe('called with params: ' + JSON.stringify(test.callParams), function() {
        before(function() {
          sinon.stub(App.ajax, 'send', Em.K);
          var mixedObjectInstance = mixedObject.create({});
          mixedObjectInstance.updateComponent.apply(mixedObjectInstance, test.callParams);
        });

        after(function() {
          App.ajax.send.restore();
        });

        test.e.forEach(function(eKey) {
          it('key: {0} should have value: {1}'.format(eKey.key, eKey.value), function() {
            var args = App.ajax.send.args[0][0];
            expect(args).to.have.deep.property(eKey.key, eKey.value);
          });
        });
      });
    });
  });

  describe('#createInstallComponentTask', function() {
    var mixedObjectInstance;
    beforeEach(function() {
      mixedObjectInstance = mixedObject.create({});
      sinon.stub(mixedObjectInstance, 'createComponent', Em.K);
      sinon.stub(mixedObjectInstance, 'onTaskError', Em.K);
      this.KDCStub = sinon.stub(App, 'get').withArgs('router.mainAdminKerberosController');
    });

    afterEach(function() {
      mixedObjectInstance.createComponent.restore();
      mixedObjectInstance.onTaskError.restore();
      mixedObjectInstance.destroy();
      mixedObjectInstance = null;
      App.get.restore();
      this.KDCStub = null;
    });

    it('when credentials are ok, createComponent method called', function() {
      this.KDCStub.returns({
        getKDCSessionState: function(sCallback, eCallback) {
          sCallback();
        }
      });
      mixedObjectInstance.createInstallComponentTask('componentName', 'hostName', 'serviceName');
      assert.isTrue(mixedObjectInstance.createComponent.calledOnce, 'createComponent should be called');
      assert.equal(JSON.stringify(mixedObjectInstance.createComponent.args[0]), JSON.stringify(['componentName', 'hostName', 'serviceName']), 'passed argument order should be the same');
    });

    it('when credentials are expired and KDC dialog cancelled task status should be changed to failed', function() {
      this.KDCStub.returns({
        getKDCSessionState: function(sCallback, eCallback) {
          eCallback();
        }
      });
      mixedObjectInstance.createInstallComponentTask('componentName', 'hostName', 'serviceName');
      assert.isFalse(mixedObjectInstance.createComponent.calledOnce, 'createComponent should not be called');
      assert.isTrue(mixedObjectInstance.onTaskError.called, 'onTaskError handler called');
    });
  });
});

});

;require.register("test/mixins/wizard/wizard_menu_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

describe('App.WizardMenuMixin', function () {

  beforeEach(function () {
    view = Em.View.create(App.WizardMenuMixin, {
      controller: Em.Object.create({
        isStepDisabled: []
      })
    });
  });

  describe("#isStepDisabled()", function () {
    it("step 1 disabled", function () {
      view.set('controller.isStepDisabled', [Em.Object.create({
        step: 1,
        value: true
      })]);
      expect(view.isStepDisabled(1)).to.be.true;
    });
  });

  describe("#isStep#Disabled", function () {
    var testCases = [
      {
        property: 'isStep0Disabled',
        step: 0
      },
      {
        property: 'isStep1Disabled',
        step: 1
      },
      {
        property: 'isStep2Disabled',
        step: 2
      },
      {
        property: 'isStep3Disabled',
        step: 3
      },
      {
        property: 'isStep4Disabled',
        step: 4
      },
      {
        property: 'isStep5Disabled',
        step: 5
      },
      {
        property: 'isStep6Disabled',
        step: 6
      },
      {
        property: 'isStep7Disabled',
        step: 7
      },
      {
        property: 'isStep8Disabled',
        step: 8
      },
      {
        property: 'isStep9Disabled',
        step: 9
      },
      {
        property: 'isStep10Disabled',
        step: 10
      }
    ];

    testCases.forEach(function (test) {
      it("step" + test.step + " disabled", function () {
        view.set('controller.isStepDisabled', [Em.Object.create({
          step: test.step,
          value: true
        })]);
        view.propertyDidChange(test.property);
        expect(view.get(test.property)).to.be.true;
      });
    }, this);
  });

});
});

;require.register("test/mock_data_setup/configs_mock_data", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  setupConfigGroupsObject: function(serviceName) {
    var serviceGroups = this.setupServiceConfigTagsObject(serviceName).mapProperty('siteName');
    var configGroups = [
      {
        "tag":"version1",
        "type":"core-site",
        "properties": {
          "fs.defaultFS" : "hdfs://c6401.ambari.apache.org:8020",
          "fs.trash.interval" : "360"
        }
      },
      {
        "tag":"version1",
        "type":"hadoop-env",
        "properties":{
          "hadoop_heapsize":"1024",
          "hdfs_user": "hdfs"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-site",
        "properties": {
          "dfs.datanode.data.dir": "/b,/a",
          "dfs.namenode.name.dir": "/b,/a,/c",
          "dfs.namenode.checkpoint.dir": "/b,/d,/a,/c",
          "dfs.datanode.failed.volumes.tolerated": "2",
          "content": "custom mock property"
        }
      },
      {
        "tag":"version1",
        "type":"hdfs-log4j",
        "properties": {
          "content": "hdfs log4j content"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "zoo cfg content"
        }
      },
      {
        "tag":"version1",
        "type":"storm-site",
        "properties": {
          "storm.zookeeper.servers": "['c6401.ambari.apache.org','c6402.ambari.apache.org']",
          "single_line_property": "value",
          "multi_line_property": "value \n value"
        }
      },
      {
        "tag": "version1",
        "type": "storm-env",
        "properties": {
          "nonexistent_property": "some value",
          "storm_log_dir": "/var/log/storm",
          "stormuiserver_host": "c6401.ambari.apache.org"
        }
      },
      {
        "tag":"version1",
        "type":"zoo.cfg",
        "properties": {
          "custom.zoo.cfg": "value"
        }
      }
    ];
    return configGroups.filter(function(configGroup) {
      return serviceGroups.contains(configGroup.type);
    });
  },
  setupServiceConfigTagsObject: function(serviceName) {
    var configTags = {
      STORM: ['storm-env','storm-site'],
      HDFS: ['hadoop-env','hdfs-site','core-site','hdfs-log4j'],
      ZOOKEEPER: ['hadoop-env', 'zoo.cfg']
    };
    var configTagsObject = [];
    if (serviceName) {
      configTags[serviceName].forEach(function(tag) {
        configTagsObject.push({
          siteName: tag,
          tagName: "version1",
          newTagName: null
        });
      });
    } else {
      for (var serviceName in configTags) {
        configTags[serviceName].forEach(function(tag) {
          configTagsObject.push({
            siteName: tag,
            tagName: "version1",
            newTagName: null
          });
        });
      }
    }
    return configTagsObject.uniq();
  },
  setupAdvancedConfigsObject: function() {
    return [
      {
        "serviceName": "HDFS",
        "name": "fs.defaultFS",
        "value": "hdfs://c6401.ambari.apache.org:8020",
        "description": "fs.defaultFS",
        "filename": "core-site.xml"
      },
      {
        "serviceName": "STORM",
        "name": "storm.zookeeper.servers",
        "value": "['localhost']",
        "description": "desc",
        "filename": "storm-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.data.dir",
        "value": "/hadoop/hdfs/data",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.name.dir",
        "value": "/hadoop/hdfs/namenode",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.namenode.checkpoint.dir",
        "value": "/hadoop/hdfs/namesecondary",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "dfs.datanode.failed.volumes.tolerated",
        "value": "2",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom mock property",
        "description": "desc",
        "filename": "hdfs-site.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "hdfs log4j content",
        "description": "desc",
        "filename": "hdfs-log4j.xml"
      },
      {
        "serviceName": "HDFS",
        "name": "content",
        "value": "custom hdfs log4j content",
        "description": "desc",
        "filename": "custom-hdfs-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "content",
        "value": "zookeeper log4j.xml content",
        "description": "desc",
        "filename": "zookeeper-log4j.xml"
      },
      {
        "serviceName": "ZOOKEEPER",
        "name": "custom.zoo.cfg",
        "value": "zoo cfg content",
        "description": "zoo.cfg config",
        "filename": "zoo.cfg"
      },
      {
        "serviceName": "YARN",
        "name": "content",
        "value": " value \n value",
        "filename": "capacity-scheduler.xml"
      },
      {
        "name": "hbase_log_dir",
        "value": "/hadoop/hbase",
        "serviceName": "HBASE",
        "filename": "hbase-env.xml"
      },
      {
        "name": "hbase_log_dir",
        "value": "/hadoop/ams-hbase",
        "serviceName": "AMBARI_METRICS",
        "filename": "ams-hbase-env.xml"
      }
    ];
  },
  setupStoredConfigsObject: function() {
    return [
      {
        "name":"storm.zookeeper.servers",
        "value":[
          "c6401.ambari.apache.org",
          "c6402.ambari.apache.org"
        ],
        "recommendedValue":"['c6401.ambari.apache.org','c6402.ambari.apache.org']",
        "filename":"storm-site.xml",
        "isUserProperty":false,
        "isOverridable":false,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"componentHosts",
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"General",
        "displayName":"storm.zookeeper.servers"
      },
      {
        "name":"single_line_property",
        "value":"value",
        "recommendedValue":"value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"string",
        "displayName":"single_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"multi_line_property",
        "value":"value \n value",
        "recommendedValue":"value \n value",
        "filename":"storm-site.xml",
        "isUserProperty":true,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"multiLine",
        "displayName":"multi_line_property",
        "category":"AdvancedStormSite"
      },
      {
        "name":"nonexistent_property",
        "value":"some value",
        "recommendedValue":"some value",
        "filename":"storm-env.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "isVisible":false,
        "displayName":null,
        "options":null
      },
      {
        "name":"dfs.datanode.data.dir",
        "value":"/a,/b",
        "recommendedValue":"/a,/b",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"HDFS",
        "displayType":"directories",
        "isRequired":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "index":1,
        "isSecureConfig":false,
        "category":"DataNode",
        "displayName":"DataNode directories"
      },
      {
        "name":"content",
        "value":"custom mock property",
        "recommendedValue":"custom mock property",
        "filename":"hdfs-site.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "displayName":"content"
      },
      {
        "name":"content",
        "value":"hdfs log4j content",
        "recommendedValue":"hdfs log4j content",
        "filename":"hdfs-log4j.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":false,
        "serviceName":"HDFS",
        "displayType":"content",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"desc",
        "isSecureConfig":false,
        "category":"AdvancedHDFSLog4j",
        "displayName":"content"
      },
      {
        "name":"storm_log_dir",
        "value":"/var/log/storm",
        "recommendedValue":"/var/log/storm",
        "filename":"storm-env.xml",
        "isUserProperty":false,
        "isOverridable":true,
        "showLabel":true,
        "serviceName":"STORM",
        "displayType":"directory",
        "isRequired":true,
        "isRequiredByAgent":true,
        "isReconfigurable":true,
        "isVisible":true,
        "description":"Storm log directory",
        "isSecureConfig":false,
        "category":"General",
        "displayName":"storm_log_dir"
      }
    ];
  },

  advancedConfigs: {
    items: [
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "Proxy user group.",
          "property_name" : "proxyuser_group",
          "property_type" : [
            "GROUP"
          ],
          "property_value" : "users",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hadoop-env.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "true",
          "property_description" : "dfs.datanode.data.dir description",
          "property_name" : "dfs.datanode.data.dir",
          "property_type" : [ ],
          "property_value" : "/hadoop/hdfs/data",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hdfs-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "true",
          "property_description" : "to enable dfs append",
          "property_name" : "dfs.support.append",
          "property_type" : [ ],
          "property_value" : "true",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hdfs-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "User to run HDFS as",
          "property_name" : "hdfs_user",
          "property_type" : [
            "USER"
          ],
          "property_value" : "hdfs",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hadoop-env.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "The permissions that should be there on dfs.datanode.data.dir\n      directories. The datanode will not come up if the permissions are\n      different on existing dfs.datanode.data.dir directories. If the directories\n      don't exist, they will be created with this permission.",
          "property_name" : "dfs.datanode.data.dir.perm",
          "property_type" : [ ],
          "property_value" : "750",
          "service_name" : "HDFS",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "hdfs-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "\n      DB user password.\n\n      IMPORTANT: if password is emtpy leave a 1 space string, the service trims the value,\n      if empty Configuration assumes it is NULL.\n    ",
          "property_name" : "oozie.service.JPAService.jdbc.password",
          "property_type" : [
            "PASSWORD"
          ],
          "property_value" : " ",
          "service_name" : "OOZIE",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "oozie-site.xml"
        }
      },
      {
        "StackConfigurations" : {
          "final" : "false",
          "property_description" : "prop description",
          "property_name" : "storm_log_dir",
          "property_type" : [],
          "property_value" : " ",
          "service_name" : "STORM",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "storm-env.xml"
        }
      }

    ]
  },
  
  advancedClusterConfigs: {
    items: [
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "Whether to ignore failures on users and group creation",
          "property_name" : "ignore_groupsusers_create",
          "property_type" : [ ],
          "property_value" : "false",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "Hadoop user group.",
          "property_name" : "user_group",
          "property_type" : [
            "GROUP"
          ],
          "property_value" : "hadoop",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "",
          "property_name" : "smokeuser",
          "property_type" : [
            "USER"
          ],
          "property_value" : "ambari-qa",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "",
          "property_name" : "zk_user",
          "property_type" : [
            "USER"
          ],
          "property_value" : "zookeeper",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      },
      {
        "StackLevelConfigurations" : {
          "final" : "false",
          "property_description" : "",
          "property_name" : "mapred_user",
          "property_type" : [
            "USER"
          ],
          "property_value" : "mapreduce",
          "stack_name" : "HDP",
          "stack_version" : "2.2",
          "type" : "cluster-env.xml"
        }
      }
    ]
  }
  
}

});

;require.register("test/mock_data_setup/stack_descriptors", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  "Artifacts": {
    "artifact_name": "kerberos_descriptor",
    "stack_name": "HDP",
    "stack_version": "2.2"
  },
  "artifact_data": {
    "properties": {
      "realm": "${cluster-env/kerberos_domain}",
      "keytab_dir": "/etc/security/keytabs"
    },
    "identities": [
      {
        "principal": {
          "value": "HTTP/_HOST@${realm}",
          "configuration": null
        },
        "name": "spnego",
        "keytab": {
          "file": "${keytab_dir}/spnego.service.keytab",
          "owner": {
            "name": "root",
            "access": "r"
          },
          "configuration": null,
          "group": {
            "name": "${hadoop-env/user_group}",
            "access": "r"
          }
        }
      },
      {
        "principal": {
          "value": "hdfs@${realm}",
          "configuration": "cluster-env/hdfs_principal_name"
        },
        "name": "hdfs",
        "keytab": {
          "file": "${keytab_dir}/hdfs.headless.keytab",
          "owner": {
            "name": "root",
            "access": "r"
          },
          "configuration": "hadoop-env/hdfs_user_keytab",
          "group": {
            "name": "${cluster-env/user_group}",
            "access": "r"
          }
        }
      },
      {
        "principal": {
          "value": "hbase@${realm}",
          "configuration": "hbase-env/hbase_principal_name"
        },
        "name": "hbase",
        "keytab": {
          "file": "${keytab_dir}/hbase.headless.keytab",
          "owner": {
            "name": "root",
            "access": "r"
          },
          "configuration": "hbase-env/hbase_user_keytab",
          "group": {
            "name": "${cluster-env/user_group}",
            "access": "r"
          }
        }
      },
      {
        "principal": {
          "value": "ambari-qa@${realm}",
          "configuration": "cluster-env/smokeuser_principal_name"
        },
        "name": "smokeuser",
        "keytab": {
          "file": "${keytab_dir}/smokeuser.headless.keytab",
          "owner": {
            "name": "root",
            "access": "r"
          },
          "configuration": "cluster-env/smokeuser_keytab",
          "group": {
            "name": "${cluster-env/user_group}",
            "access": "r"
          }
        }
      }
    ],
    "configurations": [
      {
        "core-site": {
          "hadoop.security.authentication": "kerberos",
          "hadoop.rpc.protection": "authentication; integrity; privacy",
          "hadoop.security.authorization": "true"
        }
      }
    ],
    "services": [
      {
        "name": "HDFS",
        "components": [
          {
            "name": "NAMENODE",
            "identities": [
              {
                "name": "namenode_nn",
                "principal": {
                  "value": "nn/_HOST@${realm}",
                  "configuration": "hdfs-site/dfs.namenode.kerberos.principal"
                },
                "keytab": {
                  "file": "${keytab_dir}/nn.service.keytab",
                  "owner": {
                    "name": "${hadoop-env/hdfs_user}",
                    "access": "r"
                  },
                  "group": {
                    "name": "${cluster-env/user_group}",
                    "access": ""
                  },
                  "configuration": "hdfs-site/dfs.namenode.keytab.file"
                }
              },
              {
                "name": "namenode_host",
                "principal": {
                  "value": "host/_HOST@${realm}",
                  "configuration": "hdfs-site/dfs.namenode.kerberos.https.principal"
                },
                "keytab": {
                  "file": "${keytab_dir}/host.keytab",
                  "owner": {
                    "name": "${hadoop-env/hdfs_user}",
                    "access": "r"
                  },
                  "group": {
                    "name": "${cluster-env/user_group}",
                    "access": ""
                  },
                  "configuration": "hdfs-site/dfs.namenode.keytab.file"
                }
              },
              {
                "name": "/spnego",
                "principal": {
                  "configuration": "hdfs-site/dfs.web.authentication.kerberos.principal"
                },
                "keytab": {
                  "configuration": "hdfs/dfs.web.authentication.kerberos.keytab"
                }
              }
            ]
          },
          {
            "name": "DATANODE",
            "identities": [
              {
                "name": "datanode_dn",
                "principal": {
                  "value": "dn/_HOST@${realm}",
                  "configuration": "hdfs-site/dfs.namenode.kerberos.principal"
                },
                "keytab": {
                  "file": "${keytab_dir}/dn.service.keytab",
                  "owner": {
                    "name": "${hadoop-env/hdfs_user}",
                    "access": "r"
                  },
                  "group": {
                    "name": "${cluster-env/user_group}",
                    "access": ""
                  },
                  "configuration": "hdfs-site/dfs.namenode.keytab.file"
                }
              },
              {
                "name": "datanode_host",
                "principal": {
                  "value": "host/_HOST@${realm}",
                  "configuration": "hdfs-site/dfs.datanode.kerberos.https.principal"
                },
                "keytab": {
                  "file": "${keytab_dir}/host.keytab.file",
                  "owner": {
                    "name": "${hadoop-env/hdfs_user}",
                    "access": "r"
                  },
                  "group": {
                    "name": "${cluster-env/user_group}",
                    "access": ""
                  },
                  "configuration": "hdfs-site/dfs.namenode.secondary.keytab.file"
                }
              }
            ]
          },
          {
            "name": "SECONDARY_NAMENODE",
            "identities": [
              {
                "name": "secondary_namenode_nn",
                "principal": {
                  "value": "nn/_HOST@${realm}",
                  "configuration": "hdfs-site/dfs.namenode.secondary.kerberos.principal"
                },
                "keytab": {
                  "file": "${keytab_dir}/snn.service.keytab",
                  "owner": {
                    "name": "${hadoop-env/hdfs_user}",
                    "access": "r"
                  },
                  "group": {
                    "name": "${cluster-env/user_group}",
                    "access": ""
                  },
                  "configuration": "hdfs-site/dfs.namenode.secondary.keytab.file"
                }
              },
              {
                "name": "secondary_namenode_host",
                "principal": {
                  "value": "host/_HOST@${realm}",
                  "configuration": "hdfs-site/dfs.namenode.secondary.kerberos.https.principal"
                },
                "keytab": {
                  "file": "${keytab_dir}/host.keytab.file",
                  "owner": {
                    "name": "${hadoop-env/hdfs_user}",
                    "access": "r"
                  },
                  "group": {
                    "name": "${cluster-env/user_group}",
                    "access": ""
                  },
                  "configuration": "hdfs-site/dfs.namenode.secondary.keytab.file"
                }
              },
              {
                "name": "/spnego",
                "principal": {
                  "configuration": "hdfs-site/dfs.web.authentication.kerberos.principal"
                },
                "keytab": {
                  "configuration": "hdfs/dfs.web.authentication.kerberos.keytab"
                }
              }
            ]
          }
        ]
      },
      {
        "name": "FALCON",
        "identities": [
          {
            "name": "/spnego"
          },
          {
            "name": "/smokeuser"
          },
          {
            "name": "/hdfs"
          }
        ],
        "configurations": [
          {
            "falcon-startup.properties": {
              "*.falcon.http.authentication.type": "kerberos",
              "*.falcon.authentication.type": "kerberos",
              "*.dfs.namenode.kerberos.principal": "nn/_HOST@${realm}"
            }
          }
        ],
        "components": [
          {
            "name": "FALCON_SERVER",
            "identities": [
              {
                "principal": {
                  "value": "falcon/${host}@${realm}",
                  "configuration": "falcon-startup.properties/*.falcon.service.authentication.kerberos.principal"
                },
                "name": "falcon_server",
                "keytab": {
                  "file": "${keytab_dir}/falcon.service.keytab",
                  "owner": {
                    "name": "${falcon-env/falcon_user}",
                    "access": "r"
                  },
                  "configuration": "falcon-startup.properties/*.falcon.service.authentication.kerberos.keytab",
                  "group": {
                    "name": "${cluster-env/user_group}",
                    "access": ""
                  }
                }
              },
              {
                "principal": {
                  "value": "HTTP/${host}@${realm}",
                  "configuration": "falcon-startup.properties/oozie.authentication.kerberos.principal"
                },
                "name": "/spnego",
                "keytab": {
                  "file": null,
                  "owner": {
                    "name": null,
                    "access": null
                  },
                  "configuration": "falcon-startup.properties/oozie.authentication.kerberos.keytab",
                  "group": {
                    "name": null,
                    "access": null
                  }
                }
              }
            ]
          }
        ]
      }
    ]
  }
};

});

;require.register("test/models/alerts/alert_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alerts/alert_config');

var model;

describe('App.AlertConfigProperties', function () {

  describe('Threshold', function () {

    beforeEach(function () {
      model = App.AlertConfigProperties.Threshold.create({});
    });

    describe('#apiFormattedValue', function () {

      it('should be based on showInputForValue and showInputForText', function () {

        model.setProperties({
          value: 'value',
          text: 'text',
          showInputForValue: false,
          showInputForText: false
        });
        expect(model.get('apiFormattedValue')).to.eql([]);

        model.set('showInputForValue', true);
        expect(model.get('apiFormattedValue')).to.eql(['value']);

        model.set('showInputForText', true);
        expect(model.get('apiFormattedValue')).to.eql(['value', 'text']);

      });

    });

    describe('#valueWasChanged', function () {

      it('value change should effect displayValue for AGGREGATE type', function () {

        model = App.AlertConfigProperties.Threshold.create(App.AlertConfigProperties.Thresholds.PercentageMixin, {
          value: '0.4',
          valueMetric: '%',
          text: 'text',
          showInputForValue: false,
          showInputForText: false
        });

        expect(model.get('displayValue')).to.eql('40');
      });

      it('value change should not effect displayValue for not AGGREGATE type', function () {

        model = App.AlertConfigProperties.Threshold.create({
          value: '0.4',
          valueMetric: '%',
          text: 'text',
          showInputForValue: false,
          showInputForText: false
        });

        expect(model.get('displayValue')).to.eql('0.4');
      });

    });

    describe('#badgeCssClass', function () {

      it ('should be based on badge', function () {

        model.set('badge', 'OK');
        expect(model.get('badgeCssClass')).to.equal('alert-state-OK');

      });

    });

    describe('#wasChanged', function () {

      Em.A([
          {
            p: {
              previousValue: null,
              previousText: null,
              value: '',
              text: ''
            },
            e: false
          },
          {
            p: {
              previousValue: 'not null',
              previousText: null,
              value: '',
              text: ''
            },
            e: true
          },
          {
            p: {
              previousValue: null,
              previousText: 'not null',
              value: '',
              text: ''
            },
            e: true
          },
          {
            p: {
              previousValue: 'not null',
              previousText: 'not null',
              value: '',
              text: ''
            },
            e: true
          }
        ]).forEach(function (test, i) {
        it('test #' + (i + 1), function () {
          model.setProperties(test.p);
          expect(model.get('wasChanged')).to.equal(test.e);
        });
      });

    });

    describe('#isValid', function () {

      it('should be true if showInputForValue is false', function () {
        model.set('showInputForValue', false);
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false if displayValue is null', function () {
        model.set('displayValue', null);
        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', undefined);
        expect(model.get('isValid')).to.be.false;
      });

      it('should be false if METRIC displayValue is not valid float', function () {
        model.set('displayValue', '$1234.444');
        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', 'hello-world!');
        expect(model.get('isValid')).to.be.false;
      });

      it('should be true if METRIC displayValue is valid float with at most one decimal', function () {
        model.set('displayValue', '123.4');
        expect(model.get('isValid')).to.be.true;

        model.set('displayValue', '123.0');
        expect(model.get('isValid')).to.be.true;

        model.set('displayValue', '666');
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false if METRIC displayValue is valid float with more than one decimal', function () {
        model.set('displayValue', '123.48');
        expect(model.get('isValid')).to.be.false;
      });

      it('should be true for AGGREGATE percentage with precision of 1', function () {
        model = Em.Object.create(App.AlertConfigProperties.Thresholds.PercentageMixin, {
          displayValue: '1',
          showInputForValue: true
        });

        expect(model.get('isValid')).to.be.true;

        model.set('displayValue', '88');
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false for AGGREGATE percentage values with precision smaller than 1', function () {
        model = Em.Object.create(App.AlertConfigProperties.Thresholds.PercentageMixin, {
          displayValue: '70.01',
          showInputForValue: true
        });

        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', '70.0');
        expect(model.get('isValid')).to.be.false;

        model.set('displayValue', '80.000');
        expect(model.get('isValid')).to.be.false;
      });

      it('should be true for PORT percentage values with precision of 1/10th', function () {
        model = App.AlertConfigProperties.Threshold.create({
          value: '0.4',
          showInputForValue: true
        })

        expect(model.get('isValid')).to.be.true;

        model.set('value', '3');
        expect(model.get('isValid')).to.be.true;

        model.set('value', '33.0');
        expect(model.get('isValid')).to.be.true;
      });

      it('should be false for PORT percentage values with precision greater than 1/10th', function() {
        model = App.AlertConfigProperties.Threshold.create({
          value: '4.234',
          showInputForValue: true
        });

        expect(model.get('isValid')).to.be.false;

        model.set('value', '44.001');
        expect(model.get('isValid')).to.be.false;

        model.set('value', '112.01');
        expect(model.get('isValid')).to.be.false;
      });

    });

  });

  describe('App.AlertConfigProperties.Thresholds', function () {

    describe('OkThreshold', function () {

      beforeEach(function () {
        model = App.AlertConfigProperties.Thresholds.OkThreshold.create();
      });

      describe('#apiProperty', function () {

        it('should be based on showInputForValue and showInputForText', function () {

          model.setProperties({
            showInputForValue: false,
            showInputForText: false
          });
          expect(model.get('apiProperty')).to.eql([]);

          model.set('showInputForValue', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.ok.value']);

          model.set('showInputForText', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.ok.value', 'source.reporting.ok.text']);

        });

      });

    });

    describe('WarningThreshold', function () {

      beforeEach(function () {
        model = App.AlertConfigProperties.Thresholds.WarningThreshold.create();
      });

      describe('#apiProperty', function () {

        it('should be based on showInputForValue and showInputForText', function () {

          model.setProperties({
            showInputForValue: false,
            showInputForText: false
          });
          expect(model.get('apiProperty')).to.eql([]);

          model.set('showInputForValue', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.warning.value']);

          model.set('showInputForText', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.warning.value', 'source.reporting.warning.text']);

        });

      });

    });

    describe('CriticalThreshold', function () {

      beforeEach(function () {
        model = App.AlertConfigProperties.Thresholds.CriticalThreshold.create();
      });

      describe('#apiProperty', function () {

        it('should be based on showInputForValue and showInputForText', function () {

          model.setProperties({
            showInputForValue: false,
            showInputForText: false
          });
          expect(model.get('apiProperty')).to.eql([]);

          model.set('showInputForValue', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.critical.value']);

          model.set('showInputForText', true);
          expect(model.get('apiProperty')).to.eql(['source.reporting.critical.value', 'source.reporting.critical.text']);

        });

      });

    });

  });

});

});

;require.register("test/models/alerts/alert_definition_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alerts/alert_definition');

var model;

describe('App.AlertDefinition', function () {

  beforeEach(function () {

    model = App.AlertDefinition.createRecord();

  });

  describe('#status', function () {

    Em.A([
      {
        summary: {OK: {count: 1, maintenanceCount: 0}, UNKNOWN: {count: 1, maintenanceCount: 0}, WARNING: {count: 2, maintenanceCount: 0}, CRITICAL: {count: 0, maintenanceCount: 0}},
        m: 'No CRITICAL',
        e: '<span class="alert-state-single-host label alert-state-OK">OK (1)</span> ' +
        '<span class="alert-state-single-host label alert-state-WARNING">WARN (2)</span> ' +
        '<span class="alert-state-single-host label alert-state-UNKNOWN">UNKWN (1)</span>'
      },
      {
        summary: {WARNING: {count: 2, maintenanceCount: 0}, CRITICAL: {count: 3, maintenanceCount: 0}, UNKNOWN: {count: 1, maintenanceCount: 0}, OK: {count: 1, maintenanceCount: 0}},
        m: 'All states exists',
        e: '<span class="alert-state-single-host label alert-state-OK">OK (1)</span> ' +
        '<span class="alert-state-single-host label alert-state-WARNING">WARN (2)</span> ' +
        '<span class="alert-state-single-host label alert-state-CRITICAL">CRIT (3)</span> ' +
        '<span class="alert-state-single-host label alert-state-UNKNOWN">UNKWN (1)</span>'
      },
      {
        summary: {OK: {count: 1, maintenanceCount: 0}, UNKNOWN: {count: 0, maintenanceCount: 0}, WARNING: {count: 0, maintenanceCount: 0}, CRITICAL: {count: 0, maintenanceCount: 0}},
        m: 'Single host',
        e: '<span class="alert-state-single-host label alert-state-OK">OK</span>'
      },
      {
        summary: {OK: {count: 0, maintenanceCount: 1}, UNKNOWN: {count: 0, maintenanceCount: 0}, WARNING: {count: 0, maintenanceCount: 0}, CRITICAL: {count: 0, maintenanceCount: 0}},
        m: 'Maintenance OK alert',
        e: '<span class="alert-state-single-host label alert-state-PENDING"><span class="icon-medkit"></span> OK</span>'
      },
      {
        summary: {},
        m: 'Pending',
        e: '<span class="alert-state-single-host label alert-state-PENDING">NONE</span>'
      }
    ]).forEach(function (test) {
      it(test.m, function () {
        model.set('summary', test.summary);
        expect(model.get('status')).to.equal(test.e);
      });
    });

  });

  describe('#isCriticalOrWarning', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {CRITICAL: {count: 0, maintenanceCount: 1}}, e: false},
      {summary: {CRITICAL: {count: 1, maintenanceCount: 1}}, e: true},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isCriticalOrWarning')).to.equal(test.e);
      });
    });

  });

  describe('#isCritical', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isCritical')).to.equal(test.e);
      });
    });

  });

  describe('#isWarning', function () {

    Em.A([
      {summary: {CRITICAL: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {WARNING: {count: 1, maintenanceCount: 0}}, e: true},
      {summary: {OK: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {UNKNOWN: {count: 1, maintenanceCount: 0}}, e: false},
      {summary: {}, e: false}
    ]).forEach(function (test, i) {
      it('test ' + (i + 1), function () {
        model.set('summary', test.summary);
        expect(model.get('isWarning')).to.equal(test.e);
      });
    });

  });

  describe('#lastTriggeredAgoFormatted', function () {

    it('should be empty', function () {
      model.set('lastTriggeredRaw', 0);
      expect(model.get('lastTriggeredAgoFormatted')).to.equal('');
    });

    it('should not be empty', function () {
      model.set('lastTriggeredRaw', new Date().getTime() - 61000);
      expect(model.get('lastTriggeredAgoFormatted')).to.equal('about a minute ago');
    });

  });

  describe('#serviceDisplayName', function () {

    it('should get name for non-existing service', function () {
      model.set('serviceName', 'FOOBAR');
      expect(model.get('serviceDisplayName')).to.equal('Foobar');
    });

  });

  describe('#componentNameFormatted', function () {

    beforeEach(function () {
      sinon.stub(App.format, 'role', function (a) {
        return 'role ' + a;
      });
    });

    it('should wrap component name by App.format.role method', function () {
      model.set('componentName', 'test');
      var result = model.get('componentNameFormatted');
      expect(result).to.equal('role test');
    });

    afterEach(function () {
      App.format.role.restore();
    });


  });

  describe('REOPEN', function () {

    describe('#getSortDefinitionsByStatus', function () {

      Em.A([
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {WARNING: {count: 1, maintenanceCount: 0}}}),
            order: true,
            e: -1
          },
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 2, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            order: true,
            e: -1
          },
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {WARNING: {count: 1, maintenanceCount: 0}}}),
            order: false,
            e: 1
          },
          {
            a: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 2, maintenanceCount: 0}}}),
            b: App.AlertDefinition.createRecord({summary: {OK: {count: 1, maintenanceCount: 0}, WARNING: {count: 1, maintenanceCount: 0}}}),
            order: false,
            e: 1
          }
        ]).forEach(function(test, i) {
          it('test #' + (i + 1), function () {
            var func = App.AlertDefinition.getSortDefinitionsByStatus(test.order);
            expect(func(test.a, test.b)).to.equal(test.e);
          });
        });

    });

  });

});

});

;require.register("test/models/alerts/alert_instance_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/alerts/alert_instance');

var model;

describe('App.AlertInstance', function () {

  beforeEach(function () {

    model = App.AlertInstance.createRecord();

  });

  describe('#serviceDisplayName', function () {

    it('should get name for non-existing service', function () {
      model.set('serviceName', 'FOOBAR');
      expect(model.get('serviceDisplayName')).to.equal('Foobar');
    });

  });

  describe('#statusChangedAndLastCheckedFormatted', function () {

    it('should Status Changed before Last Checked', function () {

      var lastCheckedFormatted = '123',
        lastTriggeredFormatted = '321';

      model.reopen({
        lastCheckedFormatted: lastCheckedFormatted,
        lastTriggeredFormatted: lastTriggeredFormatted
      });
      var status = model.get('statusChangedAndLastCheckedFormatted');
      expect(status.indexOf(lastCheckedFormatted) > status.indexOf(lastTriggeredFormatted)).to.be.true;

    });

  });

  describe('#status', function () {

    it('should show maint mode icon', function () {

      model.set('maintenanceState', 'ON');
      model.set('state', 'OK');
      var status = model.get('status');

      expect(status).to.equal('<div class="label alert-state-single-host alert-state-PENDING"><span class="icon-medkit"></span> OK</div>');

    });

    it('should not show maint mode icon', function () {

      model.set('maintenanceState', 'OFF');
      model.set('state', 'OK');
      var status = model.get('status');

      expect(status).to.equal('<div class="label alert-state-single-host alert-state-OK">OK</div>');

    });

  });

  describe('#escapeSpecialCharactersFromTooltip', function () {
    it('it Should Display Alert Without special characters "<" and ">"', function () {

      model.set('text', '<urlopen error [Errno 111] Connection refused>');
      var resultedText = model.get('escapeSpecialCharactersFromTooltip');

      expect(resultedText).to.equal('urlopen error [Errno 111] Connection refused');
    });
  });

});

});

;require.register("test/models/authentication_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/authentication');

var form,
  methods = [
    {
      name: 'method',
      fields: ['primaryServer', 'searchBaseDn', 'usernameAttribute']
    },
    {
      name: 'bindMethod',
      fields: ['bindUser', 'password', 'passwordRetype']
    }
  ],
  classCases = [
    {
      result: 0,
      message: 'fail',
      className: 'error'
    },
    {
      result: 1,
      message: 'success',
      className: 'success'
    }
  ];

describe('App.AuthenticationForm', function () {

  beforeEach(function() {
    form = App.AuthenticationForm.create();
  });

  methods.forEach(function (method) {
    method.fields.forEach(function (field) {
      describe('#' + field + '.isRequired', function () {
        for (var i = 2; i--; ) {
          it('should be ' + i + ' dependent on ' + method.name + ' value', function () {
            form.getField(method.name).set('value', i);
            expect(form.getField(field).get('isRequired')).to.equal(i);
          });
        }
      });
    });
  });

  describe('#testResult', function () {
    it('should be 0 or 1', function () {
      form.testConfiguration();
      expect([0, 1]).to.include(Number(form.get('testResult')));
    });
  });

  describe('#testConfigurationMessage', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.message, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationMessage')).to.equal(Em.I18n.t('admin.authentication.form.test.' + item.message));
      });
    });
  });

  describe('#testConfigurationClass', function () {
    classCases.forEach(function (item) {
      it('should indicate ' + item.className, function () {
        form.set('testResult', item.result);
        expect(form.get('testConfigurationClass')).to.equal('text-' + item.className);
      });
    });
  });

});

});

;require.register("test/models/cluster_states_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var LZString = require('utils/lz-string');
require('models/cluster_states');

var status = App.clusterStatus,
  notInstalledStates = ['CLUSTER_NOT_CREATED_1', 'CLUSTER_DEPLOY_PREP_2', 'CLUSTER_INSTALLING_3', 'SERVICE_STARTING_3'],
  values = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller',
    localdb: {}
  },
  response = {
    clusterState: 'DEFAULT',
    clusterName: 'cluster'
  },
  response2 = {
    clusterState: 'DEFAULT2',
    clusterName: 'cluster2'
  },
  newValue = {
    clusterName: 'name',
    clusterState: 'STACK_UPGRADING',
    wizardControllerName: 'wizardStep0Controller'
  };
var compressedResponse = LZString.compressToBase64(JSON.stringify(response2));

describe('App.clusterStatus', function () {

  describe('#isInstalled', function () {
    notInstalledStates.forEach(function (item) {
      it('should be false', function () {
        status.set('clusterState', item);
        expect(status.get('isInstalled')).to.be.false;
      });
    });
    it('should be true', function () {
      status.set('clusterState', 'DEFAULT');
      expect(status.get('isInstalled')).to.be.true;
    });
  });

  describe('#value', function () {
    it('should be set from properties', function () {
      Em.keys(values).forEach(function (key) {
        status.set(key, values[key]);
      });
      expect(status.get('value')).to.eql(values);
    });
  });

  describe('#getUserPrefSuccessCallback', function () {
    it('should set the cluster parameters', function () {
      status.getUserPrefSuccessCallback(response);
      Em.keys(response).forEach(function (key) {
        expect(status.get(key)).to.equal(response[key]);
      });
      status.getUserPrefSuccessCallback(compressedResponse);
      Em.keys(response2).forEach(function (key) {
        expect(status.get(key)).to.equal(response2[key]);
      });
    });
  });

  describe('#setClusterStatus', function () {

    beforeEach(function() {
      sinon.stub(status, 'postUserPref', function() {
        return $.ajax();
      });
    });

    afterEach(function () {
      status.postUserPref.restore();
      App.get.restore();
    });

    it('should return false in test mode', function () {
      sinon.stub(App, 'get', function(k) {
        if (k === 'testMode') return true;
        return Em.get(App, k);
      });
      expect(status.setClusterStatus()).to.be.false;
    });

    it('should set cluster status in non-test mode', function () {
      sinon.stub(App, 'get', function(k) {
        if (k === 'testMode') return false;
        return Em.get(App, k);
      });
      var clusterStatus = status.setClusterStatus(newValue);
      expect(clusterStatus).to.eql(newValue);
    });

  });

});

});

;require.register("test/models/config_group_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/config_group');
require('models/host');

var configGroup,
  hostRecord,
  hosts = [
    Em.Object.create({
      id: 'host0',
      hostName: 'host0',
      hostComponents: []
    }),
    Em.Object.create({
      id: 'host1',
      hostName: 'host1',
      hostComponents: []
    })
  ],
  host = Em.Object.create({
    id: 'host0',
    hostName: 'host0',
    hostComponents: []
  }),
  properties = [
    {
      name: 'n0',
      value: 'v0'
    },
    {
      name: 'n1',
      value: 'v1'
    }
  ],
  setParentConfigGroup = function (configGroup, hosts) {
    configGroup.set('parentConfigGroup', App.ConfigGroup.create());
    configGroup.set('parentConfigGroup.hosts', hosts.mapProperty('hostName'));
  };

describe('App.ConfigGroup', function () {

  beforeEach(function () {
    configGroup = App.ConfigGroup.create();
  });

  describe('#displayName', function () {
    it('should equal name if maximum length is not exceeded', function () {
      configGroup.set('name', 'n');
      expect(configGroup.get('displayName')).to.equal(configGroup.get('name'));
    });
    it('should be shortened if maximum length is exceeded', function () {
      var maxLength = App.config.CONFIG_GROUP_NAME_MAX_LENGTH;
      for (var i = maxLength + 1, name = ''; i--; ) {
        name += 'n';
      }
      configGroup.set('name', name);
      expect(configGroup.get('displayName')).to.contain('...');
      expect(configGroup.get('displayName')).to.have.length(2 * Math.floor(maxLength / 2) + 3);
    });
  });

  describe('#displayNameHosts', function () {
    it('should indicate the number of hosts', function () {
      var displayName = configGroup.get('displayName');
      configGroup.set('hosts', []);
      expect(configGroup.get('displayNameHosts')).to.equal(displayName + ' (0)');
      configGroup.set('hosts', hosts);
      expect(configGroup.get('displayNameHosts')).to.equal(displayName + ' (2)');
    });
  });

  describe('#availableHosts', function () {

    beforeEach(function () {
      App.clusterStatus.set('clusterState', 'DEFAULT');
      sinon.stub(App.Host, 'find', function() {
        return [host];
      });
      setParentConfigGroup(configGroup, hosts);
    });

    afterEach(function () {
      App.Host.find.restore();
    });

    it('should return an empty array as default', function () {
      configGroup.set('isDefault', true);
      expect(configGroup.get('availableHosts')).to.eql([]);
    });

    it('should return an empty array if there are no unused hosts', function () {
      configGroup.set('parentConfigGroup', App.ConfigGroup.create());
      expect(configGroup.get('availableHosts')).to.eql([]);
    });

    it('should take hosts from parentConfigGroup', function () {
      setParentConfigGroup(configGroup, hosts);
      configGroup.set('clusterHosts', hosts);
      expect(configGroup.get('availableHosts')).to.have.length(2);
    });
  });

  describe('#isAddHostsDisabled', function () {

    beforeEach(function () {
      hostRecord = App.Host.createRecord(host);
      setParentConfigGroup(configGroup, hosts);
      configGroup.set('isDefault', false);
      configGroup.reopen({availableHosts: [{}]});
    });

    afterEach(function () {
      modelSetup.deleteRecord(hostRecord);
    });

    it('should be false', function () {
      expect(configGroup.get('isAddHostsDisabled')).to.be.false;
    });
    it('should be true', function () {
      App.clusterStatus.set('clusterState', 'DEFAULT');
      configGroup.set('isDefault', true);
      expect(configGroup.get('isAddHostsDisabled')).to.be.true;
      configGroup.set('availableHosts', hosts);
      expect(configGroup.get('isAddHostsDisabled')).to.be.true;
    });
  });

  describe('#propertiesList', function () {
    it('should be formed from properties', function () {
      configGroup.set('properties', properties);
      properties.forEach(function (item) {
        Em.keys(item).forEach(function (prop) {
          expect(configGroup.get('propertiesList')).to.contain(item[prop]);
        });
      });
      expect(configGroup.get('propertiesList')).to.have.length(24);
    });
  });

});

});

;require.register("test/models/configs/config_property_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/configs/config_property');

var model;

describe('App.ConfigProperty', function () {
  model = App.ConfigProperty.createRecord();

  describe('#hasErrors', function () {
    it('should set hasErrors to true', function () {
      expect(model.setProperties({'errorMessage': 'some error'}).get('hasErrors')).to.eql(true);
    });
    it('should set hasErrors to false', function () {
      expect(model.setProperties({'errorMessage': ''}).get('hasErrors')).to.eql(false);
    });
  });

  describe('#hasWarnings', function () {
    it('should set hasWarnings to true', function () {
      expect(model.setProperties({'warnMessage': 'some warning'}).get('hasWarnings')).to.eql(true);
    });
    it('should set hasWarnings to false', function () {
      expect(model.setProperties({'warnMessage': ''}).get('hasWarnings')).to.eql(false);
    });
  });

  describe.skip('#isNotDefaultValue', function () {
    var tests = [
      { isEditable: false, value: 1, defaultValue: 2, supportsFinal: true, isFinal: true, defaultIsFinal: false, isNotDefaultValue: false },
      { isEditable: true, value: 1, defaultValue: 1, supportsFinal: false, isFinal: true, defaultIsFinal: true, isNotDefaultValue: false },
      { isEditable: true, value: 1, defaultValue: null, supportsFinal: false, isFinal: true, defaultIsFinal: true, isNotDefaultValue: false },
      { isEditable: true, value: 1, defaultValue: 1, supportsFinal: true, isFinal: true, defaultIsFinal: true, isNotDefaultValue: false },

      { isEditable: true, value: 2, defaultValue: 1, supportsFinal: true, isFinal: true, defaultIsFinal: true, isNotDefaultValue: true },
      { isEditable: true, value: 2, defaultValue: 1, supportsFinal: false, isFinal: true, defaultIsFinal: false, isNotDefaultValue: true },
      { isEditable: true, value: 1, defaultValue: 1, supportsFinal: true, isFinal: false, defaultIsFinal: true, isNotDefaultValue: true },
    ];

    tests.forEach(function(t, i) {
      it('should set isNotDefaultValue to ' + t.isNotDefaultValue + ' situation ' + i, function () {
        expect(model.setProperties({'isEditable': t.isEditable, 'value': t.value, defaultValue: t.defaultValue,
          supportsFinal: t.supportsFinal, isFinal: t.isFinal, defaultIsFinal:t.defaultIsFinal}).get('isNotDefaultValue')).to.eql(t.isNotDefaultValue);
      });
    });
  });

});

});

;require.register("test/models/configs/objects/service_config_category_test", function(exports, require, module) {

/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var configPropertyHelper = require('utils/configs/config_property_helper');

require('models/configs/objects/service_config_category');
require('models/configs/objects/service_config_property');

var serviceConfigCategory,
  nameCases = [
    {
      name: 'DataNode',
      primary: 'DATANODE'
    },
    {
      name: 'TaskTracker',
      primary: 'TASKTRACKER'
    },
    {
      name: 'RegionServer',
      primary: 'HBASE_REGIONSERVER'
    },
    {
      name: 'name',
      primary: null
    }
  ],
  components = [
    {
      name: 'NameNode',
      master: true
    },
    {
      name: 'SNameNode',
      master: true
    },
    {
      name: 'JobTracker',
      master: true
    },
    {
      name: 'HBase Master',
      master: true
    },
    {
      name: 'Oozie Master',
      master: true
    },
    {
      name: 'Hive Metastore',
      master: true
    },
    {
      name: 'WebHCat Server',
      master: true
    },
    {
      name: 'ZooKeeper Server',
      master: true
    },
    {
      name: 'Ganglia',
      master: true
    },
    {
      name: 'DataNode',
      slave: true
    },
    {
      name: 'TaskTracker',
      slave: true
    },
    {
      name: 'RegionServer',
      slave: true
    }
  ],
  masters = components.filterProperty('master'),
  slaves = components.filterProperty('slave'),
  groupsData = {
    groups: [
      Em.Object.create({
        errorCount: 1
      }),
      Em.Object.create({
        errorCount: 2
      })
    ]
  };

describe('App.ServiceConfigCategory', function () {

  beforeEach(function () {
    serviceConfigCategory = App.ServiceConfigCategory.create();
  });

  describe('#primaryName', function () {
    nameCases.forEach(function (item) {
      it('should return ' + item.primary, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('primaryName')).to.equal(item.primary);
      })
    });
  });

  describe('#isForMasterComponent', function () {
    masters.forEach(function (item) {
      it('should be true for ' + item.name, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('isForMasterComponent')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isForMasterComponent')).to.be.false;
    });
  });

  describe('#isForSlaveComponent', function () {
    slaves.forEach(function (item) {
      it('should be true for ' + item.name, function () {
        serviceConfigCategory.set('name', item.name);
        expect(serviceConfigCategory.get('isForSlaveComponent')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isForSlaveComponent')).to.be.false;
    });
  });

  describe('#slaveErrorCount', function () {
    it('should be 0', function () {
      serviceConfigCategory.set('slaveConfigs', []);
      expect(serviceConfigCategory.get('slaveErrorCount')).to.equal(0);
    });
    it('should sum all errorCount values', function () {
      serviceConfigCategory.set('slaveConfigs', groupsData);
      expect(serviceConfigCategory.get('slaveErrorCount')).to.equal(3);
    });
  });

  describe('#errorCount', function () {
    it('should sum all errors for category', function () {
      serviceConfigCategory.reopen({
        slaveErrorCount: 1
      });
      expect(serviceConfigCategory.get('errorCount')).to.equal(1);
      serviceConfigCategory.set('nonSlaveErrorCount', 2);
      expect(serviceConfigCategory.get('errorCount')).to.equal(3);
      serviceConfigCategory.set('slaveErrorCount', 0);
      expect(serviceConfigCategory.get('errorCount')).to.equal(2);
    });
  });

  describe('#isAdvanced', function () {
    it('should be true', function () {
      serviceConfigCategory.set('name', 'Advanced');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigCategory.set('name', 'name');
      expect(serviceConfigCategory.get('isAdvanced')).to.be.false;
    });
  });

});
});

;require.register("test/models/configs/objects/service_config_property_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var configPropertyHelper = require('utils/configs/config_property_helper');

require('models/configs/objects/service_config_category');
require('models/configs/objects/service_config_property');

var serviceConfigProperty,
  serviceConfigPropertyInit,
  configsData = [
    Ember.Object.create({
      category: 'c0',
      overrides: [
        {
          error: true,
          errorMessage: 'error'
        },
        {
          error: true
        },
        {}
      ]
    }),
    Ember.Object.create({
      category: 'c1',
      isValid: false,
      isVisible: true
    }),
    Ember.Object.create({
      category: 'c0',
      isValid: true,
      isVisible: true
    }),
    Ember.Object.create({
      category: 'c1',
      isValid: false,
      isVisible: false
    })
  ],

  components = [
    {
      name: 'NameNode',
      master: true
    },
    {
      name: 'SNameNode',
      master: true
    },
    {
      name: 'JobTracker',
      master: true
    },
    {
      name: 'HBase Master',
      master: true
    },
    {
      name: 'Oozie Master',
      master: true
    },
    {
      name: 'Hive Metastore',
      master: true
    },
    {
      name: 'WebHCat Server',
      master: true
    },
    {
      name: 'ZooKeeper Server',
      master: true
    },
    {
      name: 'Ganglia',
      master: true
    },
    {
      name: 'DataNode',
      slave: true
    },
    {
      name: 'TaskTracker',
      slave: true
    },
    {
      name: 'RegionServer',
      slave: true
    }
  ],
  overridableFalseData = [
    {
      isOverridable: false
    },
    {
      isEditable: false,
      overrides: configsData[0].overrides
    },
    {
      displayType: 'componentHost'
    }
  ],
  overridableTrueData = [
    {
      isOverridable: true,
      isEditable: true
    },    {
      isOverridable: true,
      overrides: []
    },
    {
      isOverridable: true
    }
  ],
  overriddenFalseData = [
    {
      overrides: null,
      isOriginalSCP: true
    },
    {
      overrides: [],
      isOriginalSCP: true
    }
  ],
  overriddenTrueData = [
    {
      overrides: configsData[0].overrides
    },
    {
      isOriginalSCP: false
    }
  ],
  removableFalseData = [
    {
      isEditable: false
    },
    {
      hasOverrides: true
    },
    {
      isUserProperty: false,
      isOriginalSCP: true
    }
  ],
  removableTrueData = [
    {
      isEditable: true,
      hasOverrides: false,
      isUserProperty: true
    },
    {
      isEditable: true,
      hasOverrides: false,
      isOriginalSCP: false
    }
  ],
  initPropertyData = [
    {
      initial: {
        displayType: 'password',
        value: 'value',
        recommendedValue: 'recommended'
      },
      result: {
        retypedPassword: 'value',
        recommendedValue: ''
      }
    },
    {
      initial: {
        value: '',
        savedValue: 'default',
        recommendedValue: 'recommended'
      },
      result: {
        value: '',
        recommendedValue: 'recommended'
      }
    },
    {
      initial: {
        value: null,
        savedValue: 'default',
        recommendedValue: 'recommended'
      },
      result: {
        value: 'default',
        recommendedValue: 'recommended'
      }
    }
  ],
  notDefaultFalseData = [
    {
      isEditable: false
    },
    {
      savedValue: null
    },
    {
      value: 'value',
      savedValue: 'value'
    }
  ],
  notDefaultTrueData = {
    isEditable: true,
    value: 'value',
    savedValue: 'default'
  },
  types = ['componentHost', 'componentHosts', 'radio button'],
  classCases = [
    {
      initial: {
        displayType: 'checkbox'
      },
      viewClass: App.ServiceConfigCheckbox
    },
    {
      initial: {
        displayType: 'checkbox',
        dependentConfigPattern: 'somPattern'
      },
      viewClass: App.ServiceConfigCheckboxWithDependencies
    },
    {
      initial: {
        displayType: 'password'
      },
      viewClass: App.ServiceConfigPasswordField
    },
    {
      initial: {
        displayType: 'combobox'
      },
      viewClass: App.ServiceConfigComboBox
    },
    {
      initial: {
        displayType: 'radio button'
      },
      viewClass: App.ServiceConfigRadioButtons
    },
    {
      initial: {
        displayType: 'directories'
      },
      viewClass: App.ServiceConfigTextArea
    },
    {
      initial: {
        displayType: 'content'
      },
      viewClass: App.ServiceConfigTextAreaContent

    },
    {
      initial: {
        displayType: 'multiLine'
      },
      viewClass: App.ServiceConfigTextArea
    },
    {
      initial: {
        displayType: 'custom'
      },
      viewClass: App.ServiceConfigBigTextArea
    },
    {
      initial: {
        displayType: 'componentHost'
      },
      viewClass: App.ServiceConfigMasterHostView
    },
    {
      initial: {
        displayType: 'componentHosts'
      },
      viewClass: App.ServiceConfigComponentHostsView
    },
    {
      initial: {
        displayType: 'componentHosts'
      },
      viewClass: App.ServiceConfigComponentHostsView
    },
    {
      initial: {
        unit: true,
        displayType: 'type'
      },
      viewClass: App.ServiceConfigTextFieldWithUnit
    },
    {
      initial: {
        unit: false,
        displayType: 'type'
      },
      viewClass: App.ServiceConfigTextField
    },
    {
      initial: {
        unit: false,
        displayType: 'supportTextConnection'
      },
      viewClass: App.checkConnectionView
    }
  ];

describe('App.ServiceConfigProperty', function () {

  beforeEach(function () {
    serviceConfigProperty = App.ServiceConfigProperty.create();
  });

  describe('#overrideErrorTrigger', function () {
    it('should be an increment', function () {
      serviceConfigProperty.set('overrides', configsData[0].overrides);
      expect(serviceConfigProperty.get('overrideErrorTrigger')).to.equal(1);
      serviceConfigProperty.set('overrides', []);
      expect(serviceConfigProperty.get('overrideErrorTrigger')).to.equal(2);
    });
  });

  describe('#isPropertyOverridable', function () {
    overridableFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.false;
      });
    });
    overridableTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isPropertyOverridable')).to.be.true;
      });
    });
  });

  describe('#isOverridden', function () {
    overriddenFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isOverridden')).to.be.false;
      });
    });
    overriddenTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isOverridden')).to.be.true;
      });
    });
  });

  describe('#isRemovable', function () {
    removableFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isRemovable')).to.be.false;
      });
    });
    removableTrueData.forEach(function (item) {
      it('should be true', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isRemovable')).to.be.true;
      });
    });
  });

  describe('#init', function () {
    initPropertyData.forEach(function (item) {
      it('should set initial data', function () {
        serviceConfigPropertyInit = App.ServiceConfigProperty.create(item.initial);
        Em.keys(item.result).forEach(function (prop) {
          expect(serviceConfigPropertyInit.get(prop)).to.equal(item.result[prop]);
        });
      });
    });
  });

  describe('#isNotDefaultValue', function () {
    notDefaultFalseData.forEach(function (item) {
      it('should be false', function () {
        Em.keys(item).forEach(function (prop) {
          serviceConfigProperty.set(prop, item[prop]);
        });
        expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.false;
      });
    });
    it('should be true', function () {
      Em.keys(notDefaultTrueData).forEach(function (prop) {
        serviceConfigProperty.set(prop, notDefaultTrueData[prop]);
      });
      expect(serviceConfigProperty.get('isNotDefaultValue')).to.be.true;
    });
  });

  describe('#cantBeUndone', function () {
    types.forEach(function (item) {
      it('should be true', function () {
        serviceConfigProperty.set('displayType', item);
        expect(serviceConfigProperty.get('cantBeUndone')).to.be.true;
      });
    });
    it('should be false', function () {
      serviceConfigProperty.set('displayType', 'type');
      expect(serviceConfigProperty.get('cantBeUndone')).to.be.false;
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      serviceConfigProperty.set('errorMessage', '');
      expect(serviceConfigProperty.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      serviceConfigProperty.set('errorMessage', 'message');
      expect(serviceConfigProperty.get('isValid')).to.be.false;
    });
  });

  describe('#viewClass', function () {
    classCases.forEach(function (item) {
      it ('should be ' + item.viewClass, function () {
        Em.keys(item.initial).forEach(function (prop) {
          serviceConfigProperty.set(prop, item.initial[prop]);
        });
        expect(serviceConfigProperty.get('viewClass')).to.eql(item.viewClass);
      });
    });
  });

  describe('#validate', function () {
    it('not required', function () {
      serviceConfigProperty.setProperties({
        isRequired: false,
        value: ''
      });
      expect(serviceConfigProperty.get('errorMessage')).to.be.empty;
      expect(serviceConfigProperty.get('error')).to.be.false;
    });
    it('should validate', function () {
      serviceConfigProperty.setProperties({
        isRequired: true,
        value: 'value'
      });
      expect(serviceConfigProperty.get('errorMessage')).to.be.empty;
      expect(serviceConfigProperty.get('error')).to.be.false;
    });
    it('should fail', function () {
      serviceConfigProperty.setProperties({
        isRequired: true,
        value: 'value'
      });
      serviceConfigProperty.set('value', '');
      expect(serviceConfigProperty.get('errorMessage')).to.equal('This is required');
      expect(serviceConfigProperty.get('error')).to.be.true;
    });
  });

  describe('#undoAvailable', function () {

    Em.A([
      {
        cantBeUndone: true,
        isNotDefaultValue: true,
        e: false
      },
      {
        cantBeUndone: false,
        isNotDefaultValue: true,
        e: true
      },
      {
        cantBeUndone: true,
        isNotDefaultValue: false,
        e: false
      },
      {
        cantBeUndone: false,
        isNotDefaultValue: false,
        e: false
      }
    ]).forEach(function (test) {
      it('', function () {
        serviceConfigProperty.reopen({
          cantBeUndone: test.cantBeUndone,
          isNotDefaultValue: test.isNotDefaultValue
        });
        expect(serviceConfigProperty.get('undoAvailable')).to.equal(test.e);
      });
    });

  });

  describe('#overrideIsFinalValues', function () {
    it('should be defined as empty array', function () {
      expect(serviceConfigProperty.get('overrideIsFinalValues')).to.eql([]);
    });
  });

  describe('#updateDescription', function () {

    beforeEach(function () {
      serviceConfigProperty.setProperties({
        displayType: 'password',
        description: ''
      });
    });

    it('should add extra-message to the description for `password`-configs', function () {

      var extraMessage = Em.I18n.t('services.service.config.password.additionalDescription');
      serviceConfigProperty.updateDescription();
      expect(serviceConfigProperty.get('description')).to.contain(extraMessage);

    });

    it('should not add extra-message to the description if it already contains it', function () {

      var extraMessage = Em.I18n.t('services.service.config.password.additionalDescription');
      serviceConfigProperty.updateDescription();
      serviceConfigProperty.updateDescription();
      serviceConfigProperty.updateDescription();
      expect(serviceConfigProperty.get('description')).to.contain(extraMessage);
      var subd = serviceConfigProperty.get('description').replace(extraMessage, '');
      expect(subd).to.not.contain(extraMessage);
    });

    it('should add extra-message to the description if description is not defined', function () {

      serviceConfigProperty.set('description', undefined);
      var extraMessage = Em.I18n.t('services.service.config.password.additionalDescription');
      serviceConfigProperty.updateDescription();
      expect(serviceConfigProperty.get('description')).to.contain(extraMessage);
    });

  });

});

});

;require.register("test/models/configs/objects/service_config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var configPropertyHelper = require('utils/configs/config_property_helper');

require('models/configs/objects/service_config');

var serviceConfig,
  group,
  configsData = [
    Ember.Object.create({
      category: 'c0',
      overrides: [
        {
          error: true,
          errorMessage: 'error'
        },
        {
          error: true
        },
        {}
      ]
    }),
    Ember.Object.create({
      category: 'c1',
      isValid: false,
      isVisible: true
    }),
    Ember.Object.create({
      category: 'c0',
      isValid: true,
      isVisible: true
    }),
    Ember.Object.create({
      category: 'c1',
      isValid: false,
      isVisible: false
    })
  ],
  configCategoriesData = [
    Em.Object.create({
      name: 'c0',
      slaveErrorCount: 1
    }),
    Em.Object.create({
      name: 'c1',
      slaveErrorCount: 2
    })
  ],
  components = [
    {
      name: 'NameNode',
      master: true
    },
    {
      name: 'SNameNode',
      master: true
    },
    {
      name: 'JobTracker',
      master: true
    },
    {
      name: 'HBase Master',
      master: true
    },
    {
      name: 'Oozie Master',
      master: true
    },
    {
      name: 'Hive Metastore',
      master: true
    },
    {
      name: 'WebHCat Server',
      master: true
    },
    {
      name: 'ZooKeeper Server',
      master: true
    },
    {
      name: 'Ganglia',
      master: true
    },
    {
      name: 'DataNode',
      slave: true
    },
    {
      name: 'TaskTracker',
      slave: true
    },
    {
      name: 'RegionServer',
      slave: true
    }
  ],
  masters = components.filterProperty('master'),
  slaves = components.filterProperty('slave'),
  groupNoErrorsData = [].concat(configsData.slice(2)),
  groupErrorsData = [configsData[1]];

describe('App.ServiceConfig', function () {

  beforeEach(function () {
    serviceConfig = App.ServiceConfig.create();
  });

  describe('#errorCount', function () {
    it('should be 0', function () {
      serviceConfig.setProperties({
        configs: [],
        configCategories: []
      });
      expect(serviceConfig.get('errorCount')).to.equal(0);
    });
    it('should sum counts of all errors', function () {
      serviceConfig.setProperties({
        configs: configsData,
        configCategories: configCategoriesData
      });
      expect(serviceConfig.get('errorCount')).to.equal(6);
      expect(serviceConfig.get('configCategories').findProperty('name', 'c0').get('nonSlaveErrorCount')).to.equal(2);
      expect(serviceConfig.get('configCategories').findProperty('name', 'c1').get('nonSlaveErrorCount')).to.equal(1);
    });
    it('should include invalid properties with widgets', function() {
      serviceConfig.setProperties({
        configs: [
          Em.Object.create({
            isValid: false,
            widgetType: 'type',
            isVisible: true,
            category: 'some1'
          }),
          Em.Object.create({
            isValid: false,
            widgetType: 'type',
            isVisible: true,
            category: 'some2'
          }),
          Em.Object.create({
            isValid: false,
            widgetType: null,
            isVisible: true,
            category: 'some2'
          }),
          Em.Object.create({
            isValid: false,
            widgetType: 'type',
            isVisible: true
          })
        ],
        configCategories: [
          Em.Object.create({ name: 'some1', slaveErrorCount: 0}),
          Em.Object.create({ name: 'some2', slaveErrorCount: 0})
        ]
      });
      expect(serviceConfig.get('errorCount')).to.equal(4);
    });
  });

});

describe('App.Group', function () {

  beforeEach(function () {
    group = App.Group.create();
  });

  describe('#errorCount', function () {
    it('should be 0', function () {
      group.set('properties', groupNoErrorsData);
      expect(group.get('errorCount')).to.equal(0);
    });
    it('should be 1', function () {
      group.set('properties', groupErrorsData);
      expect(group.get('errorCount')).to.equal(1);
    });
  });

});

});

;require.register("test/models/configs/section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var model;

describe('App.Section', function () {

  beforeEach(function () {
    model = App.Section.createRecord();
  });

  describe('#errorsCount', function () {

    beforeEach(function () {
      model.reopen({subSections: [
        App.SubSection.createRecord({configs: [
          App.ServiceConfigProperty.create({isValid: true}),
          App.ServiceConfigProperty.create({isValid: false})
        ]}),
        App.SubSection.createRecord({configs: [
          App.ServiceConfigProperty.create({isValid: true}),
          App.ServiceConfigProperty.create({isValid: false})
        ]})
      ]});
    });

    it('should use subsections.@each.errorsCount', function () {
      expect(model.get('errorsCount')).to.equal(2);
    });

  });

  describe('#isHiddenByFilter', function () {

    Em.A([
        {
          subSections: [],
          m: 'no subsections',
          e: true
        },
        {
          subSections: [
            App.SubSection.createRecord({configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: false, isVisible: true})]}),
            App.SubSection.createRecord({configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: false, isVisible: true})]})
          ],
          m: 'no subsections are hidden',
          e: false
        },
        {
          subSections: [
            App.SubSection.createRecord({configs: [Em.Object.create({isHiddenByFilter: true, isVisible: false, hiddenBySection: false}), Em.Object.create({isHiddenByFilter: true, isVisible: true, hiddenBySection: true})]})
          ],
          m: 'no subsections are hidden (hiddenBySection)',
          e: false
        },
        {
          subSections: [
            App.SubSection.createRecord({configs: [Em.Object.create({isHiddenByFilter: true, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})]}),
            App.SubSection.createRecord({configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: false, isVisible: true})]})
          ],
          m: 'one subsection is hidden',
          e: false
        },
        {
          subSections: [
            App.SubSection.createRecord({configs: [Em.Object.create({isHiddenByFilter: true, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})]}),
            App.SubSection.createRecord({configs: [Em.Object.create({isHiddenByFilter: true, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})]})
          ],
          m: 'all subsections are hidden',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          model.reopen({
            subSections: test.subSections
          });
          expect(model.get('isHiddenByFilter')).to.equal(test.e);
        });
      });

  });

});

});

;require.register("test/models/configs/service_config_version_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/configs/service_config_version');

var model;

describe('App.ServiceConfigVersion', function () {

  beforeEach(function () {
    model = App.ServiceConfigVersion.createRecord({});
  });

  describe('#authorFormatted', function () {

    var cases = [
      {
        author: 'admin',
        authorFormatted: 'admin',
        title: 'should display username as is'
      },
      {
        author: 'userNameIsTooLongToDisplay',
        authorFormatted: 'userNameIsTooLongToD...',
        title: 'should trim username to 20 chars'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.set('author', item.author);
        expect(model.get('authorFormatted')).to.equal(item.authorFormatted);
      });
    });

  });

  describe('#canBeMadeCurrent', function () {

    var cases = [
      {
        isCompatible: true,
        isCurrent: true,
        canBeMadeCurrent: false,
        title: 'current version'
      },
      {
        isCompatible: true,
        isCurrent: false,
        canBeMadeCurrent: true,
        title: 'compatible version'
      },
      {
        isCompatible: false,
        isCurrent: false,
        canBeMadeCurrent: false,
        title: 'not compatible version'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.setProperties({
          isCompatible: item.isCompatible,
          isCurrent: item.isCurrent
        });
        expect(model.get('canBeMadeCurrent')).to.equal(item.canBeMadeCurrent);
      });
    });

  });

});

});

;require.register("test/models/configs/sub_section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var model;

describe('App.SubSection', function () {

  beforeEach(function () {
    model = App.SubSection.createRecord();
  });

  describe('#errorsCount', function () {

    beforeEach(function () {
      model.set('configs', [
        App.ServiceConfigProperty.create({isValid: true}),
        App.ServiceConfigProperty.create({isValid: false}),
        App.ServiceConfigProperty.create({isValid: false}),
        App.ServiceConfigProperty.create({isValid: false}),
      ]);
    });

    it('should use configs.@each.isValid', function () {
      expect(model.get('errorsCount')).to.equal(3);
    });

    it('should use configs.@each.overrideErrorTrigger', function() {
      // original value is valid
      var validOriginalSCP = model.get('configs').objectAt(0);
      // add override with not valid value
      validOriginalSCP.set('overrides', [
        App.ServiceConfigProperty.create({ isValid: false }),
        App.ServiceConfigProperty.create({ isValid: true })
      ]);
      expect(model.get('errorsCount')).to.equal(4);
    });

  });

  describe('#isHiddenByFilter', function () {

    Em.A([
        {
          configs: [],
          e: false,
          m: 'Can\'t be hidden if there is no configs'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: true, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
          e: true,
          m: 'All configs are hidden'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
          e: false,
          m: 'Some configs are hidden'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: true, isVisible: true})],
          e: false,
          m: 'Some configs are hidden'
        },
        {
          configs: [Em.Object.create({isHiddenByFilter: false, isVisible: true}), Em.Object.create({isHiddenByFilter: false, isVisible: true})],
          e: false,
          m: 'No configs are hidden'
        }
    ]).forEach(function (test) {
        it(test.m, function () {
          model.set('configs', test.configs);
          expect(model.get('isHiddenByFilter')).to.equal(test.e);
        })
      });

  });

});

});

;require.register("test/models/form_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/form');

var form,
  field,
  formField,
  resultCases = [
    {
      text: Em.I18n.t('form.saveError'),
      result: -1
    },
    {
      text: Em.I18n.t('form.saveSuccess'),
      result: 1
    },
    {
      text: '',
      result: 0
    }
  ],
  displayTypeCases = [
    {
      type: 'checkbox',
      classString: 'Checkbox'
    },
    {
      type: 'select',
      classString: 'Select'
    },
    {
      type: 'textarea',
      classString: 'TextArea'
    },
    {
      type: 'password',
      classString: 'TextField'
    },
    {
      type: 'hidden',
      classString: 'TextField'
    }
  ],
  hiddenCases = [
    {
      displayType: 'password',
      type: 'hidden',
      value: false
    },
    {
      displayType: 'hidden',
      type: 'hidden',
      value: true
    }
  ],
  expectError = function (message) {
    formField.validate();
    expect(formField.get('errorMessage')).to.equal(message);
  };

describe('App.Form', function () {

  beforeEach(function () {
    form = App.Form.create({
      fieldsOptions: [
        {
          name: 'field0',
          value: 'value0',
          isRequired: false
        }
      ]
    });
    field = form.get('fields').objectAt(0);
  });

  describe('#fields', function () {
    it('should get data from formFields', function () {
      var fields = form.get('fields');
      expect(fields).to.have.length(1);
      expect(field.get('name')).to.equal('field0');
    });
  });

  describe('#field', function () {
    it('should get data from formFields', function () {
      var field0 = form.get('field.field0');
      expect(form.get('field')).to.not.be.empty;
      expect(field0.get('name')).to.equal('field0');
      expect(field0.get('form')).to.eql(form);
    });
  });

  describe('#getField', function () {
    it('should get field0', function () {
      expect(form.getField('field0')).to.eql(form.get('field.field0'));
    });
    it('should be empty', function () {
      form.set('fields', []);
      expect(form.getField()).to.be.empty;
    });
  });

  describe('#isValid', function () {
    it('should be true', function () {
      field.set('isRequired', false);
      expect(form.isValid()).to.be.true;
    });
    it('should be false', function () {
      field.setProperties({
        isRequired: true,
        value: ''
      });
      expect(form.isValid()).to.be.false;
    });
  });

  describe('#updateValues', function () {
    it('should update field0 value', function () {
      form.set('object', Em.Object.create({field0: 'value0upd'}));
      expect(field.get('value')).to.equal('value0upd');
    });
    it('should empty password value', function () {
      field.set('displayType', 'password');
      form.set('object', Em.Object.create());
      expect(field.get('value')).to.be.empty;
    });
    it('should clear values', function () {
      form.set('object', []);
      expect(field.get('value')).to.be.empty;
    });
  });

  describe('#clearValues', function () {
    it('should clear values', function () {
      var field0 = form.get('fields').objectAt(0);
      field0.set('value', 'value0');
      form.clearValues();
      expect(field0.get('value')).to.be.empty;
    });
  });

  describe('#resultText', function () {
    resultCases.forEach(function (item) {
      it('should be ' + item.text, function () {
        form.set('result', item.result);
        expect(form.get('resultText')).to.equal(item.text);
      });
    });
  });

});

describe('App.FormField', function () {

  beforeEach(function () {
    formField = App.FormField.create();
  });

  describe('#isValid', function () {
    it('should be true', function () {
      expect(formField.get('isValid')).to.be.true;
    });
    it('should be false', function () {
      formField.set('errorMessage', 'error');
      expect(formField.get('isValid')).to.be.false;
    });
  });

  describe('#viewClass', function () {
    displayTypeCases.forEach(function (item) {
      it('should be ' + item.classString, function () {
        formField.set('displayType', item.type);
        expect(formField.get('viewClass').toString()).to.contain(item.classString);
      });
    });
  });

  describe('#validate', function () {
    it('should return error message', function () {
      formField.set('isRequired', true);
      expectError('This is required');
    });
    it('should return empty error message', function () {
      formField.set('isRequired', false);
      expectError('');
      formField.set('value', 'value');
      expectError('');
    });
  });

  describe('#isHiddenField', function () {
    hiddenCases.forEach(function (item) {
      it('should be ' + item.value, function () {
        formField.setProperties(item);
        expect(formField.get('isHiddenField')).to.equal(item.value);
      });
    });
  });

});

});

;require.register("test/models/host_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');

describe('App.HostComponent', function() {

  App.store.load(App.HostComponent, {
    id: 'COMP_host',
    component_name: 'COMP1'
  });
  var hc = App.HostComponent.find('COMP_host');


  describe('#getStatusesList', function() {
    it('allowed statuses', function() {
      var statuses = ["STARTED","STARTING","INSTALLED","STOPPING","INSTALL_FAILED","INSTALLING","UPGRADE_FAILED","UNKNOWN","DISABLED","INIT"];
      expect(App.HostComponentStatus.getStatusesList()).to.include.members(statuses);
      expect(statuses).to.include.members(App.HostComponentStatus.getStatusesList());
    });
  });

  describe('#getStatusesList', function() {
    it('allowed statuses', function() {
      var statuses = ["STARTED","STARTING","INSTALLED","STOPPING","INSTALL_FAILED","INSTALLING","UPGRADE_FAILED","UNKNOWN","DISABLED","INIT"];
      expect(App.HostComponentStatus.getStatusesList()).to.include.members(statuses);
      expect(statuses).to.include.members(App.HostComponentStatus.getStatusesList());
    });
  });

  describe('#isClient', function() {
    it('', function() {
      sinon.stub(App.get('components.clients'), 'contains', Em.K);
      hc.propertyDidChange('isClient');
      hc.get('isClient');
      expect(App.get('components.clients').contains.calledWith('COMP1')).to.be.true;
      App.get('components.clients').contains.restore();
    });
  });

  describe('#isMaster', function() {
    it('', function() {
      sinon.stub(App.get('components.masters'), 'contains', Em.K);
      hc.propertyDidChange('isMaster');
      hc.get('isMaster');
      expect(App.get('components.masters').contains.calledWith('COMP1')).to.be.true;
      App.get('components.masters').contains.restore();
    });
  });

  describe('#isSlave', function() {
    it('', function() {
      sinon.stub(App.get('components.slaves'), 'contains', Em.K);
      hc.propertyDidChange('isSlave');
      hc.get('isSlave');
      expect(App.get('components.slaves').contains.calledWith('COMP1')).to.be.true;
      App.get('components.slaves').contains.restore();
    });
  });

  describe('#isDeletable', function() {
    it('', function() {
      sinon.stub(App.get('components.deletable'), 'contains', Em.K);
      hc.propertyDidChange('isDeletable');
      hc.get('isDeletable');
      expect(App.get('components.deletable').contains.calledWith('COMP1')).to.be.true;
      App.get('components.deletable').contains.restore();
    });
  });

  describe('#isRunning', function() {
    var testCases = [
      {
        workStatus: 'INSTALLED',
        result: false
      },
      {
        workStatus: 'STARTING',
        result: true
      },
      {
        workStatus: 'STARTED',
        result: true
      }
    ];
    testCases.forEach(function(test){
      it('workStatus - ' + test.workStatus, function() {
        hc.set('workStatus', test.workStatus);
        hc.propertyDidChange('isRunning');
        expect(hc.get('isRunning')).to.equal(test.result);
      });
    });
  });

  describe('#isDecommissioning', function() {
    var mock = [];
    beforeEach(function () {
      sinon.stub(App.HDFSService, 'find', function () {
        return mock;
      })
    });
    afterEach(function () {
      App.HDFSService.find.restore();
    });
    it('component name is not DATANODE', function() {
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('component name is DATANODE but no HDFS service', function() {
      hc.set('componentName', 'DATANODE');
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('HDFS has no decommission DataNodes', function() {
      hc.set('componentName', 'DATANODE');
      mock.push(Em.Object.create({
        decommissionDataNodes: []
      }));
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.false;
    });
    it('HDFS has decommission DataNodes', function() {
      hc.set('componentName', 'DATANODE');
      hc.set('hostName', 'host1');
      mock.clear();
      mock.push(Em.Object.create({
        decommissionDataNodes: [{hostName: 'host1'}]
      }));
      hc.propertyDidChange('isDecommissioning');
      expect(hc.get('isDecommissioning')).to.be.true;
    });
  });

  describe('#isActive', function() {
    it('passiveState is ON', function() {
      hc.set('passiveState', "ON");
      hc.propertyDidChange('isActive');
      expect(hc.get('isActive')).to.be.false;
    });
    it('passiveState is OFF', function() {
      hc.set('passiveState', "OFF");
      hc.propertyDidChange('isActive');
      expect(hc.get('isActive')).to.be.true;
    });
  });

  describe('#statusClass', function() {
    it('isActive is false', function() {
      hc.reopen({
        isActive: false
      });
      hc.propertyDidChange('statusClass');
      expect(hc.get('statusClass')).to.equal('icon-medkit');
    });
    it('isActive is true', function() {
      var status = 'INSTALLED';
      hc.set('isActive', true);
      hc.set('workStatus', status);
      hc.propertyDidChange('statusClass');
      expect(hc.get('statusClass')).to.equal(status);
    });
  });

  describe('#statusIconClass', function () {
    var testCases = [
      {
        statusClass: 'STARTED',
        result: 'icon-ok-sign'
      },
      {
        statusClass: 'STARTING',
        result: 'icon-ok-sign'
      },
      {
        statusClass: 'INSTALLED',
        result: 'icon-warning-sign'
      },
      {
        statusClass: 'STOPPING',
        result: 'icon-warning-sign'
      },
      {
        statusClass: 'UNKNOWN',
        result: 'icon-question-sign'
      },
      {
        statusClass: '',
        result: ''
      }
    ];

    it('reset statusClass to plain property', function () {
      hc.reopen({
        statusClass: ''
      })
    });
    testCases.forEach(function (test) {
      it('statusClass - ' + test.statusClass, function () {
        hc.set('statusClass', test.statusClass);
        hc.propertyDidChange('statusIconClass');
        expect(hc.get('statusIconClass')).to.equal(test.result);
      });
    });
  });

  describe('#componentTextStatus', function () {
    before(function () {
      sinon.stub(App.HostComponentStatus, 'getTextStatus', Em.K);
    });
    after(function () {
      App.HostComponentStatus.getTextStatus.restore();
    });
    it('componentTextStatus should be changed', function () {
      var status = 'INSTALLED';
      hc.set('workStatus', status);
      hc.propertyDidChange('componentTextStatus');
      hc.get('componentTextStatus');
      expect(App.HostComponentStatus.getTextStatus.calledWith(status)).to.be.true;
    });
  });

  describe("#getCount", function () {
    var testCases = [
      {
        t: 'unknown component',
        data: {
          componentName: 'CC',
          type: 'totalCount',
          stackComponent: Em.Object.create()
        },
        result: 0
      },
      {
        t: 'master component',
        data: {
          componentName: 'C1',
          type: 'totalCount',
          stackComponent: Em.Object.create({componentCategory: 'MASTER'})
        },
        result: 3
      },
      {
        t: 'slave component',
        data: {
          componentName: 'C1',
          type: 'installedCount',
          stackComponent: Em.Object.create({componentCategory: 'SLAVE'})
        },
        result: 4
      },
      {
        t: 'client component',
        data: {
          componentName: 'C1',
          type: 'startedCount',
          stackComponent: Em.Object.create({componentCategory: 'CLIENT'})
        },
        result: 5
      },
      {
        t: 'client component, unknown type',
        data: {
          componentName: 'C1',
          type: 'unknownCount',
          stackComponent: Em.Object.create({componentCategory: 'CLIENT'})
        },
        result: 0
      }
    ];

    beforeEach(function () {
      this.mock = sinon.stub(App.StackServiceComponent, 'find');
      sinon.stub(App.MasterComponent, 'find').returns(Em.Object.create({totalCount: 3}));
      sinon.stub(App.SlaveComponent, 'find').returns(Em.Object.create({installedCount: 4}));
      sinon.stub(App.ClientComponent, 'find').returns(Em.Object.create({startedCount: 5, unknownCount: null}));
    });
    afterEach(function () {
      this.mock.restore();
      App.MasterComponent.find.restore();
      App.SlaveComponent.find.restore();
      App.ClientComponent.find.restore();
    });

    testCases.forEach(function (test) {
      it(test.t, function () {
        this.mock.returns(test.data.stackComponent);
        expect(App.HostComponent.getCount(test.data.componentName, test.data.type)).to.equal(test.result);
      });
    });
  });
});
});

;require.register("test/models/host_stack_version_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host_stack_version');

describe('App.HostStackVersion', function () {

  describe("#displayStatus", function () {
    var testCases = [
      {
        status: 'OUT_OF_SYNC',
        result: Em.I18n.t('hosts.host.stackVersions.status.out_of_sync')
      },
      {
        status: 'INSTALLED',
        result: Em.I18n.t('hosts.host.stackVersions.status.installed')
      },
      {
        status: 'INSTALLING',
        result: Em.I18n.t('hosts.host.stackVersions.status.installing')
      },
      {
        status: 'INSTALL_FAILED',
        result: Em.I18n.t('hosts.host.stackVersions.status.install_failed')
      },
      {
        status: 'UPGRADE_FAILED',
        result: Em.I18n.t('hosts.host.stackVersions.status.upgrade_failed')
      },
      {
        status: 'UPGRADING',
        result: Em.I18n.t('hosts.host.stackVersions.status.upgrading')
      },
      {
        status: 'CURRENT',
        result: Em.I18n.t('hosts.host.stackVersions.status.current')
      },
      {
        status: 'ANY',
        result: 'Any'
      }
    ];
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    testCases.forEach(function (test) {
      it('status is ' + test.status, function () {
        App.store.load(App.HostStackVersion, {
          id: 1,
          status: test.status
        });
        expect(App.HostStackVersion.find().objectAt(0).get('displayStatus')).to.equal(test.result);
      });
    }, this);
  });

  describe("#installEnabled", function () {
    var testCases = [
      {
        status: 'OUT_OF_SYNC',
        result: true
      },
      {
        status: 'INSTALLED',
        result: false
      },
      {
        status: 'INSTALLING',
        result: false
      },
      {
        status: 'INSTALL_FAILED',
        result: true
      },
      {
        status: '',
        result: false
      }
    ];
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    testCases.forEach(function (test) {
      it('status is ' + test.status, function () {
        App.store.load(App.HostStackVersion, {
          id: 1,
          status: test.status
        });
        expect(App.HostStackVersion.find().objectAt(0).get('installEnabled')).to.equal(test.result);
      });
    }, this);
  });

  describe("#isCurrent", function () {
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    it("status is CURRENT", function () {
      App.store.load(App.HostStackVersion, {
        id: 1,
        status: 'CURRENT'
      });
      expect(App.HostStackVersion.find(1).get('isCurrent')).to.be.true;
    });
    it("status is not CURRENT", function () {
      App.store.load(App.HostStackVersion, {
        id: 1,
        status: 'INSTALLED'
      });
      expect(App.HostStackVersion.find(1).get('isCurrent')).to.be.false;
    });
  });

  describe("#isInstalling", function () {
    afterEach(function () {
      App.HostStackVersion.find().clear();
    });
    it("status is INSTALLING", function () {
      App.store.load(App.HostStackVersion, {
        id: 1,
        status: 'INSTALLING'
      });
      expect(App.HostStackVersion.find(1).get('isInstalling')).to.be.true;
    });
    it("status is not INSTALLING", function () {
      App.store.load(App.HostStackVersion, {
        id: 1,
        status: 'INSTALLED'
      });
      expect(App.HostStackVersion.find(1).get('isInstalling')).to.be.false;
    });
  });
});

});

;require.register("test/models/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var misc = require('utils/misc');

require('models/host');

describe('App.Host', function () {

  var data = [
    {
      id: 'host1',
      host_name: 'host1',
      memory: 200000,
      disk_total: 100.555,
      disk_free: 90.555,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 18100000
    },
    {
      id: 'host2',
      host_name: 'host2',
      memory: 99999,
      disk_total: 90,
      disk_free: 90,
      health_status: 'HEALTHY',
      last_heart_beat_time: (new Date()).getTime() - 170000
    },
    {
      id: 'host3',
      host_name: 'host3',
      memory: 99999,
      disk_total: 99.999,
      disk_free: 0,
      health_status: 'UNKNOWN',
      last_heart_beat_time: (new Date()).getTime()
    }
  ];
  before(function() {
    App.set('testMode', false);
  });
  App.Host.reopen({
    hostComponents: []
  });
  App.store.loadMany(App.Host, data);

  var host1 = App.Host.find('host1');

  describe('#diskUsedFormatted', function () {

    it('host1 - 10GB ', function () {
      expect(host1.get('diskUsedFormatted')).to.equal('10GB');
    });
    it('host2 - 0GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsedFormatted')).to.equal('0GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsedFormatted')).to.equal('100GB');
    });
  });

  describe('#diskTotalFormatted', function () {

    it('host1 - 100.56GB ', function () {
      expect(host1.get('diskTotalFormatted')).to.equal('100.56GB');
    });
    it('host2 - 90GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskTotalFormatted')).to.equal('90GB');
    });
    it('host3 - 100GB', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskTotalFormatted')).to.equal('100GB');
    });
  });

  describe('#diskUsageFormatted', function () {

    it('host1 - 9.94% ', function () {
      expect(host1.get('diskUsageFormatted')).to.equal('9.94%');
    });
    it('host2 - 0%', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('diskUsageFormatted')).to.equal('0%');
    });
    it('host3 - 100%', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('diskUsageFormatted')).to.equal('100%');
    });
  });

  describe('#isNotHeartBeating', function () {
    it('host2 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host2');
      expect(host.get('isNotHeartBeating')).to.equal(false);
    });
    it('host3 - false', function () {
      var host = App.Host.find().findProperty('hostName', 'host3');
      expect(host.get('isNotHeartBeating')).to.equal(true);
    });
  });

  describe('#cpuUsage', function () {
    var testCases = [
      {
        params: {
          cpuSystem: undefined,
          cpuUser: undefined
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 0,
          cpuUser: 0
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 1,
          cpuUser: 0
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 0,
          cpuUser: 1
        },
        result: 0
      },
      {
        params: {
          cpuSystem: 1,
          cpuUser: 1
        },
        result: 2
      }
    ];
    testCases.forEach(function (test) {
      it('cpuSystem - ' + test.params.cpuSystem + ', cpuUser - ' + test.params.cpuUser, function () {
        host1.set('cpuSystem', test.params.cpuSystem);
        host1.set('cpuUser', test.params.cpuUser);
        host1.propertyDidChange('cpuUsage');

        expect(host1.get('cpuUsage')).to.equal(test.result);
      });
    });
  });

  describe('#memoryUsage', function () {
    var testCases = [
      {
        params: {
          memFree: undefined,
          memTotal: undefined
        },
        result: 0
      },
      {
        params: {
          memFree: 0,
          memTotal: 0
        },
        result: 0
      },
      {
        params: {
          memFree: 1,
          memTotal: 0
        },
        result: 0
      },
      {
        params: {
          memFree: 0,
          memTotal: 1
        },
        result: 0
      },
      {
        params: {
          memFree: 1,
          memTotal: 2
        },
        result: 50
      }
    ];
    testCases.forEach(function (test) {
      it('memFree - ' + test.params.memFree + ', memTotal - ' + test.params.memTotal, function () {
        host1.set('memFree', test.params.memFree);
        host1.set('memTotal', test.params.memTotal);
        host1.propertyDidChange('memoryUsage');

        expect(host1.get('memoryUsage')).to.equal(test.result);
      });
    });
  });

  describe.skip('#componentsWithStaleConfigs', function () {
    it('One component with stale configs', function () {
      host1.set('hostComponents', [Em.Object.create({
        staleConfigs: true
      })]);
      host1.propertyDidChange('componentsWithStaleConfigs');
      expect(host1.get('componentsWithStaleConfigs')).to.eql([Em.Object.create({
        staleConfigs: true
      })]);
    });
    it('No components with stale configs', function () {
      host1.set('hostComponents', [Em.Object.create({
        staleConfigs: false
      })]);
      host1.propertyDidChange('componentsWithStaleConfigs');
      expect(host1.get('componentsWithStaleConfigs')).to.be.empty;
    });
  });

  describe.skip('#componentsInPassiveStateCount', function () {
    it('No component in passive state', function () {
      host1.set('hostComponents', [Em.Object.create({
        passiveState: 'OFF'
      })]);
      host1.propertyDidChange('componentsInPassiveStateCount');

      expect(host1.get('componentsInPassiveStateCount')).to.equal(0);
    });
    it('One component in passive state', function () {
      host1.set('hostComponents', [Em.Object.create({
        passiveState: 'ON'
      })]);
      host1.propertyDidChange('componentsInPassiveStateCount');

      expect(host1.get('componentsInPassiveStateCount')).to.equal(1);
    });
  });

  describe('#disksMounted', function () {
    it('', function () {
      host1.set('diskInfo', [
        {}
      ]);
      host1.propertyDidChange('disksMounted');
      expect(host1.get('disksMounted')).to.equal(1);
    });
  });

  describe('#coresFormatted', function () {
    it('', function () {
      host1.set('cpu', 1);
      host1.set('cpuPhysical', 2);
      host1.propertyDidChange('coresFormatted');
      expect(host1.get('coresFormatted')).to.equal('1 (2)');
    });
  });

  describe('#diskUsed', function () {
    it('diskFree and diskTotal are 0', function () {
      host1.set('diskFree', 0);
      host1.set('diskTotal', 0);
      host1.propertyDidChange('diskUsed');
      expect(host1.get('diskUsed')).to.equal(0);
    });
    it('diskFree is 0 and diskTotal is 10', function () {
      host1.set('diskFree', 0);
      host1.set('diskTotal', 10);
      host1.propertyDidChange('diskUsed');
      expect(host1.get('diskUsed')).to.equal(10);
    });
  });

  describe('#diskUsage', function () {
    it('', function () {
      host1.reopen({
        diskUsed: 10
      });
      host1.set('diskTotal', 100);
      host1.propertyDidChange('diskUsage');
      expect(host1.get('diskUsage')).to.equal(10);
    });
  });

  describe('#memoryFormatted', function () {
    it('', function () {
      host1.set('memory', 1024);
      sinon.stub(misc, 'formatBandwidth', Em.K);
      host1.propertyDidChange('memoryFormatted');
      host1.get('memoryFormatted');
      expect(misc.formatBandwidth.calledWith(1048576)).to.be.true;
      misc.formatBandwidth.restore()
    });
  });

  describe('#loadAvg', function () {
    var testCases = [
      {
        params: {
          loadOne: null,
          loadFive: null,
          loadFifteen: null
        },
        result: null
      },
      {
        params: {
          loadOne: 1.111,
          loadFive: 5.555,
          loadFifteen: 15.555
        },
        result: '1.11'
      },
      {
        params: {
          loadOne: null,
          loadFive: 5.555,
          loadFifteen: 15.555
        },
        result: '5.55'
      },
      {
        params: {
          loadOne: null,
          loadFive: null,
          loadFifteen: 15.555
        },
        result: '15.55'
      }
    ];

    testCases.forEach(function (test) {
      it('loadOne - ' + test.params.loadOne + ', loadFive - ' + test.params.loadFive + ', loadFifteen - ' + test.params.loadFifteen, function () {
        host1.set('loadOne', test.params.loadOne);
        host1.set('loadFive', test.params.loadFive);
        host1.set('loadFifteen', test.params.loadFifteen);
        host1.propertyDidChange('loadAvg');
        expect(host1.get('loadAvg')).to.equal(test.result);
      });
    });
  });

  describe('#healthClass', function () {
    var testCases = [
      {
        params: {
          passiveState: 'ON',
          healthStatus: null
        },
        result: 'icon-medkit'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'UNKNOWN'
        },
        result: 'health-status-DEAD-YELLOW'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'HEALTHY'
        },
        result: 'health-status-LIVE'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'UNHEALTHY'
        },
        result: 'health-status-DEAD-RED'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: 'ALERT'
        },
        result: 'health-status-DEAD-ORANGE'
      },
      {
        params: {
          passiveState: 'OFF',
          healthStatus: null
        },
        result: 'health-status-DEAD-YELLOW'
      }
    ];

    testCases.forEach(function (test) {
      it('passiveState - ' + test.params.passiveState + ', healthStatus - ' + test.params.healthStatus, function () {
        host1.set('passiveState', test.params.passiveState);
        host1.set('healthStatus', test.params.healthStatus);
        host1.propertyDidChange('healthClass');
        expect(host1.get('healthClass')).to.equal(test.result);
      });
    });
  });

  describe('#healthIconClass', function () {
    var testCases = [
      {
        params: {
          healthClass: 'health-status-LIVE'
        },
        result: 'icon-ok-sign'
      },
      {
        params: {
          healthClass: 'health-status-DEAD-RED'
        },
        result: 'icon-warning-sign'
      },
      {
        params: {
          healthClass: 'health-status-DEAD-YELLOW'
        },
        result: 'icon-question-sign'
      },
      {
        params: {
          healthClass: 'health-status-DEAD-ORANGE'
        },
        result: 'icon-minus-sign'
      },
      {
        params: {
          healthClass: ''
        },
        result: ''
      }
    ];

    it('reset healthClass to plain property', function(){
      host1.reopen({
        healthClass: ''
      });
    });
    testCases.forEach(function (test) {
      it('healthClass - ' + test.params.healthClass, function () {
        host1.set('healthClass', test.params.healthClass);
        host1.propertyDidChange('healthIconClass');
        expect(host1.get('healthIconClass')).to.equal(test.result);
      });
    });
  });
});

});

;require.register("test/models/hosts_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/hosts');

var hostInfo,
  statusCases = [
    {
      status: 'REGISTERED',
      bootStatusForDisplay: 'Success',
      bootBarColor: 'progress-success',
      bootStatusColor: 'text-success',
      isBootDone: true
    },
    {
      status: 'FAILED',
      bootStatusForDisplay: 'Failed',
      bootBarColor: 'progress-danger',
      bootStatusColor: 'text-error',
      isBootDone: true
    },
    {
      status: 'PENDING',
      bootStatusForDisplay: 'Preparing',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'RUNNING',
      bootStatusForDisplay: 'Installing',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'DONE',
      bootStatusForDisplay: 'Registering',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    },
    {
      status: 'REGISTERING',
      bootStatusForDisplay: 'Registering',
      bootBarColor: 'progress-info',
      bootStatusColor: 'text-info',
      isBootDone: false
    }
  ],
  tests = ['bootStatusForDisplay', 'bootBarColor', 'bootStatusColor', 'isBootDone'];

describe('App.HostInfo', function () {

  beforeEach(function () {
    hostInfo = App.HostInfo.create();
  });

  tests.forEach(function (property) {
    describe('#' + property, function () {
      statusCases.forEach(function (testCase) {
        it('should be ' + testCase[property], function () {
          hostInfo.set('bootStatus', testCase.status);
          expect(hostInfo.get(property)).to.equal(testCase[property]);
        });
      });
    });
  });

});

});

;require.register("test/models/operating_system_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/operating_system');

describe('App.OperatingSystem', function () {

  var os;

  beforeEach(function () {
    os = App.OperatingSystem.createRecord();
  });

  describe('#isDeselected', function () {

    it('should be opposite to isSelected', function () {
      os.set('isSelected', true);
      expect(os.get('isDeselected')).to.be.false;
      os.set('isSelected', false);
      expect(os.get('isDeselected')).to.be.true;
    });

  });

});

});

;require.register("test/models/rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host');
require('models/rack');

describe('App.Rack', function () {

  var data = {
    id: 'rack1',
    name: 'rack1'
  };

  App.store.load(App.Rack, data);

  describe('#liveHostsCount', function () {

    it('rack1 has two live hosts', function () {
      var rack = App.Rack.find().findProperty('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(2);
    });

    it('rack1 has three live hosts', function () {
      App.store.load(App.Host, {
        id: 'host3',
        host_name: 'host3',
        health_status: 'HEALTHY'
      });
      var rack = App.Rack.find().findProperty('name', 'rack1');
      rack.set('name', 'rack1');
      expect(rack.get('liveHostsCount')).to.equal(3);
    });
  });


});

});

;require.register("test/models/repository_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/repository');

describe('App.Repository', function () {

  var model;

  beforeEach(function () {
    model = App.Repository.createRecord();
  });

  describe('#invalidFormatError', function () {

    var cases = [
      {
        baseUrl: 'http://domain-name_0.com/path/subpath?p0=v0&p1=v1@v2.v3#!~hash0,(hash1)+hash2[hash3]/*;hash_4%2F',
        invalidFormatError: false,
        title: 'valid http url'
      },
      {
        baseUrl: 'https://domain.com/path?p=v',
        invalidFormatError: false,
        title: 'valid https url'
      },
      {
        baseUrl: 'ftp://domain.com:123',
        invalidFormatError: false,
        title: 'valid ftp url'
      },
      {
        baseUrl: 'ftp://user_:password0@domain.com',
        invalidFormatError: false,
        title: 'valid ftp url with authorization'
      },
      {
        baseUrl: 'ftp://user :password/@domain.com',
        invalidFormatError: true,
        title: 'ftp url with disallowed characters'
      },
      {
        baseUrl: 'http://domain.com:/path',
        invalidFormatError: true,
        title: 'no port specified when expected'
      },
      {
        baseUrl: 'file://etc/file.repo',
        invalidFormatError: false,
        title: 'valid Unix file url'
      },
      {
        baseUrl: 'file:///etc/file.repo',
        invalidFormatError: false,
        title: 'valid Unix file url (3 slashes)'
      },
      {
        baseUrl: 'file://c:/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url'
      },
      {
        baseUrl: 'file:///c:/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url (3 slashes)'
      },
      {
        baseUrl: 'file://c|/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url (| separator)'
      },
      {
        baseUrl: 'file://C:/file.repo',
        invalidFormatError: false,
        title: 'valid Windows file url (capital drive char)'
      },
      {
        baseUrl: 'file://etc /file.repo',
        invalidFormatError: true,
        title: 'file url with disallowed characters'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.set('baseUrl', item.baseUrl);
        expect(model.get('invalidFormatError')).to.equal(item.invalidFormatError);
      });
    });

  });

});

});

;require.register("test/models/service/flume_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/flume');

var flumeAgent,
  flumeAgentData = {
    id: 'agent',
    name: 'agent'
  },
  cases = [
    {
      status: 'RUNNING',
      healthClass: App.healthIconClassGreen
    },
    {
      status: 'NOT_RUNNING',
      healthClass: App.healthIconClassRed
    },
    {
      status: 'UNKNOWN',
      healthClass: App.healthIconClassYellow
    },
    {
      status: 'ANOTHER_STATUS',
      healthClass: App.healthIconClassYellow
    }
  ];

describe('App.FlumeAgent', function () {

  beforeEach(function () {
    flumeAgent = App.FlumeAgent.createRecord(flumeAgentData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(flumeAgent);
  });

  describe('#healthClass', function () {
    cases.forEach(function (item) {
      var healthClass = item.healthClass;
      it('should be ' + healthClass, function () {
        flumeAgent.set('status', item.status);
        expect(flumeAgent.get('healthClass')).to.equal(healthClass);
      });
    });
  });

});

});

;require.register("test/models/service/hdfs_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/hdfs');

describe('App.HDFSService', function () {

    describe('#isNnHaEnabled', function () {
      var record = App.HDFSService.createRecord({
        id: 'hdfs'
      });
      it('ha disabled', function () {
        record.reopen({
          hostComponents: [Em.Object.create({componentName: 'NAMENODE'})],
          snameNode: true
        });
        record.propertyDidChange('isNnHaEnabled');
        expect(record.get('isNnHaEnabled')).to.be.false;
      });
      it('ha enabled', function () {
        record.setProperties({
          hostComponents: [
            Em.Object.create({componentName: 'NAMENODE'}),
            Em.Object.create({componentName: 'NAMENODE'})
          ],
          snameNode: null
        });
        record.propertyDidChange('isNnHaEnabled');
        expect(record.get('isNnHaEnabled')).to.be.true;
      });
    });


});

});

;require.register("test/models/service/yarn_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * License); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an AS IS BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service/yarn');

var yarnService,
  yarnServiceData = {
    id: 'yarn'
  },
  hostComponentsData = [
    {
      id: 'ats',
      componentName: 'APP_TIMELINE_SERVER',
      host: {
        id: 'host'
      }
    },
    {
      id: 'nodemanager',
      componentName: 'NODEMANAGER',
      host: {
        id: 'host'
      }
    },
    {
      id: 'yarnclient',
      componentName: 'YARN_CLIENT',
      host: {
        id: 'host'
      }
    }
  ],
  configs = [
    {
      properties: {
        'yarn.timeline-service.webapp.address': '0.0.0.0:0000'
      },
      tag: 'version2',
      type: 'yarn-site'
    }
  ],
  nodeCountCases = [
    {
      assets: {
        nodeManagersStarted: 0,
        nodeManagersInstalled: 1,
        nodeManagersTotal: 1,
        nodeManagersCountActive: 0,
        nodeManagersCountRebooted: 0,
        nodeManagersCountUnhealthy: 0,
        nodeManagersCountDecommissioned: 0
      },
      nodeManagersCountLost: 1
    },
    {
      assets: {
        nodeManagersStarted: 1,
        nodeManagersInstalled: 1,
        nodeManagersTotal: 1,
        nodeManagersCountActive: 1,
        nodeManagersCountRebooted: 1,
        nodeManagersCountUnhealthy: 0,
        nodeManagersCountDecommissioned: 0
      },
      nodeManagersCountLost: 0
    }
  ],
  setHostComponents = function () {
    yarnService.reopen({
      hostComponents: hostComponentsData
    });
  };

describe('App.YARNService', function () {

  beforeEach(function () {
    yarnService = App.YARNService.createRecord(yarnServiceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(yarnService);
  });

  describe('#ahsWebPort', function () {

    afterEach(function () {
      App.db.setConfigs([]);
    });

    it('should be 8188 as default', function () {
      App.db.setConfigs([]);
      expect(yarnService.get('ahsWebPort')).to.equal('8188');
    });

    it('should get value from configs', function () {
      App.db.setConfigs(configs);
      expect(yarnService.get('ahsWebPort')).to.equal('0000');
    });

  });

  describe('#queueFormatted', function () {
    it('should return formatted string', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queueFormatted')).to.equal('default (/root)<br/>');
    });
  });

  describe('#queuesCount', function () {
    it('should be 1', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('queuesCount')).to.equal(1);
    });
  });

  describe('#maxMemory', function () {
    it('should add availableMemory to allocatedMemory', function () {
      yarnService.set('allocatedMemory', 1024);
      yarnService.set('availableMemory', 2048);
      expect(yarnService.get('maxMemory')).to.equal(3072);
    });
  });

  describe('#allQueueNames', function () {
    it('should list all queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('allQueueNames')).to.eql(['root', 'root/default']);
    });
  });

  describe('#childQueueNames', function () {
    it('should list child queue names as array', function () {
      yarnService.set('queue', '{"root":{"default":{}}}');
      expect(yarnService.get('childQueueNames')).to.eql(['root/default']);
    });
  });
/*
  describe('#nodeManagersCountLost', function () {
    nodeCountCases.forEach(function (item) {
      it('should be ' + item.nodeManagersCountLost, function () {
        setHostComponents();
        for (var prop in item.assets) {
          yarnService.set(prop, item.assets[prop]);
        };
        expect(yarnService.get('nodeManagersCountLost')).to.equal(item.nodeManagersCountLost);
      });
    });
  });
*/
});

});

;require.register("test/models/service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/service');

var service,
  serviceData = {
    id: 'service'
  },
  healthCases = [
    {
      status: 'STARTED',
      health: 'green'
    },
    {
      status: 'STARTING',
      health: 'green-blinking'
    },
    {
      status: 'INSTALLED',
      health: 'red'
    },
    {
      status: 'STOPPING',
      health: 'red-blinking'
    },
    {
      status: 'UNKNOWN',
      health: 'yellow'
    },
    {
      status: 'ANOTHER',
      health: 'yellow'
    }
  ],
  statusPropertiesCases = [
    {
      status: 'INSTALLED',
      property: 'isStopped'
    },
    {
      status: 'STARTED',
      property: 'isStarted'
    }
  ],
  services = [
    {
      name: 'HDFS',
      configurable: true
    },
    {
      name: 'YARN',
      configurable: true
    },
    {
      name: 'MAPREDUCE2',
      configurable: true
    },
    {
      name:'TEZ',
      clientOnly: true,
      configurable: true
    },
    {
      name: 'HBASE',
      configurable: true
    },
    {
      name: 'HIVE',
      configurable: true
    },
    {
      name: 'FLUME',
      configurable: true
    },
    {
      name: 'FALCON',
      configurable: true
    },
    {
      name: 'STORM',
      configurable: true
    },
    {
      name: 'OOZIE',
      configurable: true
    },
    {
      name: 'GANGLIA',
      configurable: true
    },
    {
      name: 'ZOOKEEPER',
      configurable: true
    },
    {
      name: 'PIG',
      configurable: true,
      clientOnly: true
    },
    {
      name: 'SQOOP',
      clientOnly: true
    },
    {
      name: 'HUE',
      configurable: true
    }
  ],
  clientsOnly = services.filterProperty('clientOnly').mapProperty('name'),
  configurable = services.filterProperty('configurable').mapProperty('name'),
  hostComponentsDataFalse = [
    [],
    [
      {
        staleConfigs: false
      }
    ],
    [
      {
        service: {
          serviceName: 'HIVE'
        },
        staleConfigs: false
      }
    ]
  ],
  hostComponentsDataTrue = [
    [
      Em.Object.create({
        service: {
          serviceName: 'HDFS'
        },
        staleConfigs: true,
        displayName: 'service0'
      })
    ],
    [
      Em.Object.create({
        host: {
          publicHostName: 'host0'
        },
        service: {
          serviceName: 'HDFS'
        },
        staleConfigs: true,
        displayName: 'service1'
      })
    ]
  ],
  restartData = {
    host0: ['service0', 'service1']
};

describe('App.Service', function () {

  beforeEach(function () {
    service = App.Service.createRecord(serviceData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(service);
  });

  describe('#isInPassive', function () {
    it('should be true', function () {
      service.set('passiveState', 'ON');
      expect(service.get('isInPassive')).to.be.true;
    });
    it('should be false', function () {
      service.set('passiveState', 'OFF');
      expect(service.get('isInPassive')).to.be.false;
    });
  });

  describe('#healthStatus', function () {
    healthCases.forEach(function (item) {
      it('should be ' + item.health, function () {
        service.set('workStatus', item.status);
        expect(service.get('healthStatus')).to.equal(item.health);
      });
    });
  });

  statusPropertiesCases.forEach(function (item) {
    var status = item.status,
      property = item.property;
    describe('#' + property, function () {
      it('status ' + status + ' is for ' + property, function () {
        service.set('workStatus', status);
        expect(service.get(property)).to.be.true;
        var falseStates = statusPropertiesCases.mapProperty('property').without(property);
        var falseStatuses = [];
        falseStates.forEach(function (state) {
          falseStatuses.push(service.get(state));
        });
        expect(falseStatuses).to.eql([false]);
      });
    });
  });

  describe('#isRestartRequired', function () {

    beforeEach(function () {
      service.reopen({
        serviceName: 'HDFS',
        hostComponents: []
      });
    });
    hostComponentsDataFalse.forEach(function (item) {
      it('should be false', function () {
        service.set('hostComponents', item);
        expect(service.get('isRestartRequired')).to.be.false;
      });
    });
    hostComponentsDataTrue.forEach(function (item) {
      it('should be true', function () {
        service.set('hostComponents', item);
        expect(service.get('isRestartRequired')).to.be.true;
      });
    });
  });

  describe('#restartRequiredMessage', function () {
    it('should form message for 2 services on 1 host', function () {
      service.set('restartRequiredHostsAndComponents', restartData);
      expect(service.get('restartRequiredMessage')).to.contain('host0');
      expect(service.get('restartRequiredMessage')).to.contain('service0');
      expect(service.get('restartRequiredMessage')).to.contain('service1');
    });
  });

  describe('#serviceTypes', function () {
    var testCases = [
      {
        serviceName: 'PIG',
        result: []
      },
      {
        serviceName: 'GANGLIA',
        result: ['MONITORING']
      },
      {
        serviceName: 'HDFS',
        result: ['HA_MODE']
      },
      {
        serviceName: 'YARN',
        result: ['HA_MODE']
      }
    ];
    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        service.set('serviceName', test.serviceName);
        service.propertyDidChange('serviceTypes');
        expect(service.get('serviceTypes')).to.eql(test.result);
      });
    });
  });


});

});

;require.register("test/models/stack_service_component_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/stack_service_component');

/**

  Component properties template:

  {
    componentName: 'SUPERVISOR',
    expected: {
      displayName: 'Supervisor',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isClient: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      defaultNoOfMasterHosts: 1,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false,
      selectionSchemeForMasterComponent: {"else": 0}
    }
  }

**/
var componentPropertiesValidationTests = [
  {
    componentName: 'SUPERVISOR',
    expected: {
      displayName: 'Supervisor',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerSlaveClientPage: true,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'ZOOKEEPER_SERVER',
    expected: {
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isMaster: true,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: true,
      isMasterAddableInstallerWizard: true,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      defaultNoOfMasterHosts: 3,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'APP_TIMELINE_SERVER',
    expected: {
      displayName: 'App Timeline Server',
      minToInstall: 0,
      maxToInstall: 1,
      isRequired: false,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: true,
      isDeletable: false,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: false,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'GANGLIA_MONITOR',
    expected: {
      displayName: 'Ganglia Monitor',
      minToInstall: Infinity,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: true,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'FLUME_HANDLER',
    expected: {
      displayName: 'Flume',
      minToInstall: 0,
      maxToInstall: Infinity,
      isRequired: false,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: true,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'HIVE_METASTORE',
    expected: {
      displayName: 'Hive Metastore',
      minToInstall: 1,
      maxToInstall: 1,
      isRequired: true,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: true,
      isDeletable: true,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'HIVE_SERVER',
    expected: {
      displayName: 'HiveServer2',
      minToInstall: 1,
      maxToInstall: 1,
      isRequired: true,
      isMultipleAllowed: false,
      isSlave: false,
      isMaster: true,
      isRestartable: true,
      isReassignable: true,
      isDeletable: true,
      isRollinRestartAllowed: false,
      isDecommissionAllowed: false,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: true,
      isShownOnInstallerSlaveClientPage: false,
      isShownOnAddServiceAssignMasterPage: true,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: ['WEBHCAT_SERVER'],
      isOtherComponentCoHosted: true,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'DATANODE',
    expected: {
      displayName: 'DataNode',
      minToInstall: 1,
      maxToInstall: Infinity,
      isRequired: true,
      isMultipleAllowed: true,
      isSlave: true,
      isMaster: false,
      isRestartable: true,
      isReassignable: false,
      isDeletable: true,
      isRollinRestartAllowed: true,
      isDecommissionAllowed: true,
      isRefreshConfigsAllowed: false,
      isAddableToHost: true,
      isShownOnInstallerAssignMasterPage: false,
      isShownOnInstallerSlaveClientPage: true,
      isShownOnAddServiceAssignMasterPage: false,
      isMasterWithMultipleInstances: false,
      isMasterAddableInstallerWizard: false,
      isHAComponentOnly: false,
      isRequiredOnAllHosts: false,
      coHostedComponents: [],
      isOtherComponentCoHosted: false,
      isCoHostedComponent: false
    }
  },
  {
    componentName: 'POSTGRESQL_SERVER',
    expected: {
      isShownOnInstallerAssignMasterPage: false
    }
  },
  {
    componentName: 'MYSQL_SERVER',
    expected: {
      isShownOnInstallerAssignMasterPage: false
    }
  }
];

describe('App.StackServiceComponent', function() {
  before(function() {
    modelSetup.setupStackServiceComponent();
  });

  describe('component properties validation', function() {
    componentPropertiesValidationTests.forEach(function(test) {
      describe('properties validation for ' + test.componentName + ' component', function() {
        var component = App.StackServiceComponent.find(test.componentName);
        var properties = Em.keys(test.expected);
        properties.forEach(function(property) {
          it('#{0} should be {1}'.format(property, JSON.stringify(test.expected[property])), function() {
            expect(component.get(property)).to.be.eql(test.expected[property]);
          })
        });
      });
    });
  });

  describe('#isMasterAddableOnlyOnHA', function () {

    var cases = [
      {
        componentName: 'NAMENODE',
        isMasterAddableOnlyOnHA: true
      },
      {
        componentName: 'RESOURCEMANAGER',
        isMasterAddableOnlyOnHA: true
      },
      {
        componentName: 'RANGER_ADMIN',
        isMasterAddableOnlyOnHA: true
      },
      {
        componentName: 'OOZIE_SERVER',
        isMasterAddableOnlyOnHA: false
      }
    ];

    cases.forEach(function (item) {
      it(item.componentName, function () {
        expect(App.StackServiceComponent.find().findProperty('componentName', item.componentName).get('isMasterAddableOnlyOnHA')).to.equal(item.isMasterAddableOnlyOnHA);
      });
    });

  });

  describe('#isNotAddableOnlyInInstall', function () {

    var cases = [
      {
        componentName: 'HIVE_METASTORE',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'HIVE_SERVER',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'RANGER_KMS_SERVER',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'OOZIE_SERVER',
        isNotAddableOnlyInInstall: true
      },
      {
        componentName: 'NAMENODE',
        isNotAddableOnlyInInstall: false
      }
    ];

    cases.forEach(function (item) {
      it(item.componentName, function () {
        expect(App.StackServiceComponent.find().findProperty('componentName', item.componentName).get('isNotAddableOnlyInInstall')).to.equal(item.isNotAddableOnlyInInstall);
      });
    });

  });

  after(function() {
    modelSetup.cleanStackServiceComponent();
  });
});

});

;require.register("test/models/stack_service_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/stack_service');

describe('App.StackService', function () {

  App.store.load(App.StackService, {
    id: 'S1'
  });

  var ss = App.StackService.find('S1');
  ss.reopen({
    serviceComponents: []
  });

  describe('#isDFS', function () {
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.false;
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.true;
    });
    it('service name is "GLUSTERFS"', function () {
      ss.set('serviceName', 'GLUSTERFS');
      ss.propertyDidChange('isDFS');
      expect(ss.get('isDFS')).to.be.true;
    });
  });

  describe('#isPrimaryDFS', function () {
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('isPrimaryDFS');
      expect(ss.get('isPrimaryDFS')).to.be.false;
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('isPrimaryDFS');
      expect(ss.get('isPrimaryDFS')).to.be.true;
    });
  });

  describe('#configTypesRendered', function () {
    ss.set('configTypes', {
      'core-site': {},
      'hdfs-site': {},
      'oozie-site': {}
    });
    it('service name is "SERVICE"', function () {
      ss.set('serviceName', 'SERVICE');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {},'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "GLUSTERFS"', function () {
      ss.set('serviceName', 'GLUSTERFS');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {},'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "HDFS"', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {}, 'hdfs-site': {}, 'oozie-site': {}});
    });
    it('service name is "FALCON"', function () {
      ss.set('serviceName', 'FALCON');
      ss.propertyDidChange('configTypesRendered');
      expect(ss.get('configTypesRendered')).to.eql({'core-site': {}, 'hdfs-site': {}});
    });
  });

  describe('#displayNameOnSelectServicePage', function () {
    it('No coSelectedServices', function () {
      ss.set('serviceName', 'HDFS');
      ss.set('displayName', 'HDFS');
      ss.propertyDidChange('displayNameOnSelectServicePage');
      expect(ss.get('displayNameOnSelectServicePage')).to.equal('HDFS');
    });
    it('Present coSelectedServices', function () {
      ss.set('serviceName', 'YARN');
      ss.set('displayName', 'YARN');
      ss.propertyDidChange('displayNameOnSelectServicePage');
      expect(ss.get('displayNameOnSelectServicePage')).to.equal('YARN + MapReduce2');
    });
  });

  describe('#isHiddenOnSelectServicePage', function () {
    var testCases = [
      {
        serviceName: 'HDFS',
        isInstallable: true,
        result: false
      },
      {
        serviceName: 'MAPREDUCE2',
        isInstallable: true,
        result: true
      },
      {
        serviceName: 'KERBEROS',
        isInstallable: false,
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        ss.set('serviceName', test.serviceName);
        ss.set('isInstallable', test.isInstallable);
        ss.propertyDidChange('isHiddenOnSelectServicePage');
        expect(ss.get('isHiddenOnSelectServicePage')).to.equal(test.result);
      });
    });
  });

  describe('#isMonitoringService', function () {
    var testCases = [
      {
        serviceName: 'HDFS',
        result: false
      },
      {
        serviceName: 'GANGLIA',
        result: true
      }
    ];

    testCases.forEach(function (test) {
      it('service name - ' + test.serviceName, function () {
        ss.set('serviceName', test.serviceName);
        ss.propertyDidChange('isMonitoringService');
        expect(ss.get('isMonitoringService')).to.equal(test.result);
      });
    });
  });

  describe('#hasClient', function () {
    it('No client serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasClient');
      expect(ss.get('hasClient')).to.be.false;
    });
    it('Has client serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isClient: true})]);
      ss.propertyDidChange('hasClient');
      expect(ss.get('hasClient')).to.be.true;
    });
  });

  describe('#hasMaster', function () {
    it('No master serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasMaster');
      expect(ss.get('hasMaster')).to.be.false;
    });
    it('Has master serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isMaster: true})]);
      ss.propertyDidChange('hasMaster');
      expect(ss.get('hasMaster')).to.be.true;
    });
  });

  describe('#hasSlave', function () {
    it('No slave serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasSlave');
      expect(ss.get('hasSlave')).to.be.false;
    });
    it('Has slave serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isSlave: true})]);
      ss.propertyDidChange('hasSlave');
      expect(ss.get('hasSlave')).to.be.true;
    });
  });

  describe('#hasNonMastersWithCustomAssignment', function () {
    it('No serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.propertyDidChange('hasNonMastersWithCustomAssignment');
      expect(ss.get('hasNonMastersWithCustomAssignment')).to.be.false;
    });
    it('All non-master serviceComponents are required on all hosts', function () {
      ss.set('serviceComponents', [Em.Object.create({isMaster: true}), Em.Object.create({isSlave: true, cardinality: 'ALL'}), Em.Object.create({isClient: true, cardinality: 'ALL'})]);
      ss.propertyDidChange('hasNonMastersWithCustomAssignment');
      expect(ss.get('hasNonMastersWithCustomAssignment')).to.be.false;
    });
    it('Has non-master serviceComponents not required on all hosts', function () {
      ss.set('serviceComponents', [Em.Object.create({isSlave: true}), Em.Object.create({isClient: true})]);
      ss.propertyDidChange('hasNonMastersWithCustomAssignment');
      expect(ss.get('hasNonMastersWithCustomAssignment')).to.be.true;
    });
  });

  describe('#isClientOnlyService', function () {
    it('Has not only client serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isSlave: true}), Em.Object.create({isClient: true})]);
      ss.propertyDidChange('isClientOnlyService');
      expect(ss.get('isClientOnlyService')).to.be.false;
    });
    it('Has only client serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({isClient: true})]);
      ss.propertyDidChange('isClientOnlyService');
      expect(ss.get('isClientOnlyService')).to.be.true;
    });
  });

  describe('#isNoConfigTypes', function () {
    it('configTypes is null', function () {
      ss.set('configTypes', null);
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.true;
    });
    it('configTypes is empty', function () {
      ss.set('configTypes', {});
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.true;
    });
    it('configTypes is correct', function () {
      ss.set('configTypes', {'key': {}});
      ss.propertyDidChange('isNoConfigTypes');
      expect(ss.get('isNoConfigTypes')).to.be.false;
    });
  });

  describe('#customReviewHandler', function () {
    it('service name is HDFS', function () {
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('customReviewHandler');
      expect(ss.get('customReviewHandler')).to.be.undefined;
    });
    it('service name is HIVE', function () {
      ss.set('serviceName', 'HIVE');
      ss.propertyDidChange('customReviewHandler');
      expect(ss.get('customReviewHandler')).to.eql({
        "Database": "loadHiveDbValue"
      });
    });
  });

  describe('#configCategories', function () {
    it('HDFS service with no serviceComponents', function () {
      ss.set('serviceComponents', []);
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configCategories');
      expect(ss.get('configCategories').mapProperty('name')).to.eql([
        "General",
        "Advanced",
        "Advanced key",
        "Custom key"
      ]);
    });
    it('HDFS service with DATANODE serviceComponents', function () {
      ss.set('serviceComponents', [Em.Object.create({componentName: 'DATANODE'})]);
      ss.set('serviceName', 'HDFS');
      ss.propertyDidChange('configCategories');
      expect(ss.get('configCategories').mapProperty('name')).to.eql([
        "DATANODE",
        "General",
        "Advanced",
        "Advanced key",
        "Custom key"]);
    });
  });


});

});

;require.register("test/models/upgrade_entity_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/upgrade_entity');

describe('App.upgradeEntity', function () {
  var model;

  beforeEach(function () {
    model = App.upgradeEntity.create();
  });

  describe("#isRunning", function() {
    it("status IN_PROGRESS", function() {
      model.set('status', 'IN_PROGRESS');
      model.propertyDidChange('isRunning');
      expect(model.get('isRunning')).to.be.true;
    });
    it("status PENDING", function() {
      model.set('status', 'PENDING');
      model.propertyDidChange('isRunning');
      expect(model.get('isRunning')).to.be.false;
    });
  });

  describe("#progress", function() {
    it("progress_percent = 1.9", function() {
      model.set('progress_percent', 1.9);
      model.propertyDidChange('progress');
      expect(model.get('progress')).to.equal(1);
    });
    it("progress_percent = 1", function() {
      model.set('progress_percent', 1);
      model.propertyDidChange('progress');
      expect(model.get('progress')).to.equal(1);
    });
  });

  describe("#isActive", function() {
    it("status IN_PROGRESS", function() {
      model.set('status', 'IN_PROGRESS');
      model.propertyDidChange('isActive');
      expect(model.get('isActive')).to.be.true;
    });
    it("status PENDING", function() {
      model.set('status', 'PENDING');
      model.propertyDidChange('isActive');
      expect(model.get('isActive')).to.be.false;
    });
  });

  describe('#isExpandableGroup', function () {

    var cases = [
      {
        input: {
          type: 'ITEM'
        },
        isExpandableGroup: false,
        title: 'not upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: false
        },
        isExpandableGroup: false,
        title: 'pending upgrade group without expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: false
        },
        isExpandableGroup: false,
        title: 'aborted upgrade group without expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: true
        },
        isExpandableGroup: true,
        title: 'aborted upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'IN_PROGRESS',
          hasExpandableItems: false
        },
        isExpandableGroup: true,
        title: 'active upgrade group'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.setProperties(item.input);
        expect(model.get('isExpandableGroup')).to.equal(item.isExpandableGroup);
      });
    });

  });

  describe('#upgradeGroupStatus', function () {

    var cases = [
      {
        input: {
          type: 'ITEM'
        },
        upgradeGroupStatus: undefined,
        title: 'not upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: false
        },
        upgradeGroupStatus: 'PENDING',
        title: 'pending upgrade group'
      },
      {
        input: {
          type: 'GROUP',
          status: 'PENDING',
          hasExpandableItems: true
        },
        upgradeGroupStatus: 'SUBITEM_FAILED',
        title: 'pending upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'ABORTED',
          hasExpandableItems: true
        },
        upgradeGroupStatus: 'SUSPENDED',
        title: 'aborted upgrade group with expandable items'
      },
      {
        input: {
          type: 'GROUP',
          status: 'IN_PROGRESS',
          hasExpandableItems: false
        },
        upgradeGroupStatus: 'IN_PROGRESS',
        title: 'active upgrade'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        model.setProperties(item.input);
        expect(model.get('upgradeGroupStatus')).to.equal(item.upgradeGroupStatus);
      });
    });

  });
});
});

;require.register("test/models/user_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var modelSetup = require('test/init_model_test');
require('models/user');

var user,
  form,
  userNameField,
  userData = {
    id: 'user'
  },
  objectData = Em.Object.create({
    userName: 'name',
    isLdap: true
  });

describe('App.User', function () {

  beforeEach(function () {
    user = App.User.createRecord(userData);
  });

  afterEach(function () {
    modelSetup.deleteRecord(user);
  });

  describe('#id', function () {
    it('should take value from userName', function () {
      user.set('userName', 'name');
      expect(user.get('id')).to.equal('name');
    });
  });

  describe('#type', function () {
    it('should be LDAP', function () {
      user.set('isLdap', true);
      expect(user.get('type')).to.equal('LDAP');
    });
    it('should be Local', function () {
      user.set('isLdap', false);
      expect(user.get('type')).to.equal('Local');
    });
  });

});

describe('App.EditUserForm', function () {

  beforeEach(function () {
    form = App.EditUserForm.create();
  });

  describe('#object', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return userData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should take data from controller', function () {
      expect(form.get('object')).to.eql(userData);
    });

  });

  describe('#disableUsername', function () {
    it('should update userName field', function () {
      form.set('object', userData);
      expect(form.get('field.userName.disabled')).to.equal('disabled');
    });
  });

  describe('#disableAdminCheckbox', function () {

    before(function () {
      sinon.stub(App, 'get', function(k) {
        switch (k) {
          case 'router':
            return {
              getLoginName: Em.K
            };
          default:
            return Em.get(App, k);
        }
      });
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return objectData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.get.restore();
      App.router.get.restore();
    });

    it('should not disable', function () {
      expect(form.get('field.admin.disabled')).to.be.false;
    });

    it('should disable', function () {
      form.set('object', objectData);
      expect(form.get('field.admin.disabled')).to.be.false;
    });
  });

  describe('#isValid', function () {
    it('should be true as default', function () {
      expect(form.isValid()).to.be.true;
    });
    it('should be false', function () {
      form.set('field.new_password.isRequired', true);
      expect(form.isValid()).to.be.false;
    });
  });

  describe('#save', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserEditController.content') return objectData;
        return Em.get(App.router, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should record form values to object', function () {
      form.set('field.userName.value', 'name');
      form.save();
      expect(form.get('object.userName')).to.equal('name');
    });
  });

});

describe('App.CreateUserForm', function () {

  beforeEach(function () {
    form = App.CreateUserForm.create();
  });

  describe('#object', function () {

    before(function () {
      sinon.stub(App.router, 'get', function (k) {
        if (k === 'mainAdminUserCreateController.content') return userData;
        return Em.get(App, k);
      });
    });

    after(function () {
      App.router.get.restore();
    });

    it('should take data from controller', function () {
      expect(form.get('object')).to.eql(userData);
    });

  });

  describe('#field.userName.toLowerCase', function () {
    it('should convert userName into lower case', function () {
      userNameField = form.getField('userName');
      userNameField.set('value', 'NAME');
      expect(userNameField.get('value')).to.equal('name');
    });
  });

  describe('#isValid', function () {
    it('should be false as default', function () {
      expect(form.isValid()).to.be.false;
    });
    it('should be true', function () {
      form.get('fields').forEach(function (item) {
        if (item.get('isRequired')) {
          item.set('value', 'value');
        }
      });
      expect(form.isValid()).to.be.true;
    });
  });

  describe('#isWarn', function () {
    it('should be false as default', function () {
      expect(form.isWarn()).to.be.false;
    });
    it('should be true', function () {
      form.getField('userName').set('value', '1');
      expect(form.isWarn()).to.be.true;
    });
    it('should be false', function () {
      form.getField('userName').set('value', 'name');
      expect(form.isWarn()).to.be.false;
    });
  });

});

});

;require.register("test/router_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('router');

describe('App.Router', function () {
  var router = App.Router.create();

  describe.skip('#loginSuccessCallback()', function() {

    beforeEach(function () {
      sinon.stub(App.usersMapper, 'map');
      sinon.stub(router, 'setUserLoggedIn');
      sinon.stub(App.ajax, 'send');
    });

    afterEach(function() {
      App.usersMapper.map.restore();
      router.setUserLoggedIn.restore();
      App.ajax.send.restore();
    });

    it('should log in user and load views', function () {
      var userName = 'test';
      router.loginSuccessCallback({},{},{loginName: userName});
      expect(router.setUserLoggedIn.calledOnce).to.be.true;
      expect(router.setUserLoggedIn.calledWith(userName)).to.be.true;
    })
  });

  describe('#initAdmin()', function () {

    var cases = [
      {
        user: {
          admin: true
        },
        isAdmin: true,
        isOperator: false,
        isPermissionDataLoaded: true,
        title: 'admin'
      },
      {
        user: {
          operator: true
        },
        isAdmin: false,
        isOperator: true,
        isPermissionDataLoaded: true,
        title: 'operator'
      },
      {
        user: {},
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: true,
        title: 'read only access'
      },
      {
        user: null,
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: false,
        title: 'no user'
      }
    ];

    beforeEach(function () {
      App.setProperties({
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: false
      });
    });

    afterEach(function () {
      App.db.getUser.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App.db, 'getUser').returns(item.user);
        router.initAdmin();
        expect(App.get('isAdmin')).to.equal(item.isAdmin);
        expect(App.get('isOperator')).to.equal(item.isOperator);
        expect(App.get('isPermissionDataLoaded')).to.equal(item.isPermissionDataLoaded);
      });
    });

  });

  describe('#adminViewInfoSuccessCallback', function() {
    beforeEach(function() {
      sinon.stub(window.location, 'replace', Em.K);
    });
    afterEach(function() {
      window.location.replace.restore();
    });

    it('should redirect to the latest version of admin view', function() {
      var tests = [{
        mockData: {
          components: [{
            'RootServiceComponents': {
              'component_version': '1.9.0'
            }
          }, {
            'RootServiceComponents': {
              'component_version': '2.0.0'
            }
          }]
        },
        expected: '/views/ADMIN_VIEW/2.0.0/INSTANCE/#/'
      }, {
        mockData: {
          components: [{
            'RootServiceComponents': {
              'component_version': '1.9.0'
            }
          }, {
            'RootServiceComponents': {
              'component_version': '2.1.0'
            }
          }, {
            'RootServiceComponents': {
              'component_version': '2.0.0'
            }
          }]
        },
        expected: '/views/ADMIN_VIEW/2.1.0/INSTANCE/#/'
      }, {
        mockData: {
          versions: [{
            'RootServiceComponents': {
              version: '2.1.0'
            }
          }]
        },
        expected: '/views/ADMIN_VIEW/2.1.0/INSTANCE/#/'
      }];

      tests.forEach(function(data) {
        router.adminViewInfoSuccessCallback(data.mockData);
        expect(window.location.replace.calledWith(data.expected)).to.be.true;
      });
    });
  });

  describe.skip("#savePreferedPath()", function() {
    beforeEach(function () {
      router.set('preferedPath', null);
    });
    it("has no key", function() {
      router.savePreferedPath('path');
      expect(router.get('preferedPath')).to.equal('path');
    });
    it("path does not contain key", function() {
      router.savePreferedPath('path', 'key');
      expect(router.get('preferedPath')).to.be.null;
    });
    it("path contains key", function() {
      router.savePreferedPath('key=path', 'key=');
      expect(router.get('preferedPath')).to.equal('path');
    });
  });

  describe.skip("#restorePreferedPath()", function() {
    it("preferedPath is null", function() {
      router.set('preferedPath', null);
      expect(router.restorePreferedPath()).to.be.false;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is '/relativeURL'", function() {
      router.set('preferedPath', '/relativeURL');
      expect(router.restorePreferedPath()).to.be.true;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is '#/relativeURL'", function() {
      router.set('preferedPath', '#/relativeURL');
      expect(router.restorePreferedPath()).to.be.true;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is '#/login'", function() {
      router.set('preferedPath', '#/login');
      expect(router.restorePreferedPath()).to.be.false;
      expect(router.get('preferedPath')).to.be.null;
    });
    it("preferedPath is 'http://absoluteURL'", function() {
      router.set('preferedPath', 'http://absoluteURL');
      expect(router.restorePreferedPath()).to.be.false;
      expect(router.get('preferedPath')).to.be.null;
    });
  });

  describe.skip("#loginGetClustersSuccessCallback()", function () {
    var mock = {dataLoading: Em.K};
    beforeEach(function () {
      sinon.stub(router, 'setClusterInstalled', Em.K);
      sinon.stub(router, 'transitionToApp', Em.K);
      sinon.stub(router, 'transitionToViews', Em.K);
      sinon.stub(router, 'transitionToAdminView', Em.K);
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'dataLoading');
      App.setProperties({
        isAdmin: false,
        isOperator: false,
        isPermissionDataLoaded: false
      });
    });
    afterEach(function () {
      router.setClusterInstalled.restore();
      router.transitionToApp.restore();
      router.transitionToViews.restore();
      router.transitionToAdminView.restore();
      App.router.get.restore();
      mock.dataLoading.restore();
    });
    it("cluster exists, OPERATOR privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'CLUSTER.OPERATE'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToApp.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.true;
      expect(App.get('isOperator')).to.be.true;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster exists, READ privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'CLUSTER.READ'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToApp.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.false;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster exists, ADMIN privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'AMBARI.ADMIN'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToApp.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.true;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster exists, no privileges", function () {
      var clusterData = {
        items: [{
          Clusters: {
            cluster_name: 'c1'
          }
        }]
      };
      var params = {
        loginData: {
          privileges: []
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.setClusterInstalled.calledWith(clusterData)).to.be.true;
      expect(router.transitionToViews.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.false;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster not installed, ADMIN privileges", function () {
      var clusterData = {
        items: []
      };
      var params = {
        loginData: {
          privileges: [{
            PrivilegeInfo: {
              cluster_name: 'c1',
              permission_name: 'AMBARI.ADMIN'
            }
          }]
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.transitionToAdminView.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.true;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
    it("cluster not installed, non-admin privileges", function () {
      var clusterData = {
        items: []
      };
      var params = {
        loginData: {
          privileges: []
        }
      };
      router.loginGetClustersSuccessCallback(clusterData, {}, params);
      expect(router.transitionToViews.calledOnce).to.be.true;
      expect(App.get('isAdmin')).to.be.false;
      expect(App.get('isOperator')).to.be.false;
      expect(App.get('isPermissionDataLoaded')).to.be.true;
      expect(mock.dataLoading.calledOnce).to.be.true;
    });
  });

  describe("#transitionToAdminView()", function () {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send');
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it("", function () {
      router.transitionToAdminView();
      expect(App.ajax.send.calledWith({
        name: 'ambari.service.load_server_version',
        sender: router,
        success: 'adminViewInfoSuccessCallback',
        error: 'adminViewInfoErrorCallback'
      })).to.be.true;
    });
  });

  describe("#transitionToApp()", function () {
    beforeEach(function () {
      this.mock = sinon.stub(router, 'restorePreferedPath');
      sinon.stub(router, 'getSection', function (callback) {
        callback('route');
      });
      sinon.stub(router, 'transitionTo');
    });
    afterEach(function () {
      this.mock.restore();
      router.getSection.restore();
      router.transitionTo.restore();
    });
    it("has restore path", function () {
      this.mock.returns(true);
      router.transitionToApp();
      expect(router.getSection.called).to.be.false;
      expect(router.transitionTo.called).to.be.false;
    });
    it("does not have restore path", function () {
      this.mock.returns(false);
      router.transitionToApp();
      expect(router.getSection.calledOnce).to.be.true;
      expect(router.transitionTo.calledWith('route')).to.be.true;
    });
  });

  describe("#transitionToViews()", function () {
    var mock = {loadAmbariViews: Em.K};
    beforeEach(function () {
      sinon.stub(App.router, 'get').returns(mock);
      sinon.stub(router, 'transitionTo');
      sinon.spy(mock, 'loadAmbariViews');
    });
    afterEach(function () {
      App.router.get.restore();
      router.transitionTo.restore();
      mock.loadAmbariViews.restore();
    });
    it("", function () {
      router.transitionToViews();
      expect(mock.loadAmbariViews.calledOnce).to.be.true;
      expect(router.transitionTo.calledWith('main.views.index')).to.be.true;
    });
  });

  describe("#adminViewInfoErrorCallback()", function () {
    beforeEach(function () {
      sinon.stub(router, 'transitionToViews');
    });
    afterEach(function () {
      router.transitionToViews.restore();
    });
    it("", function () {
      router.adminViewInfoErrorCallback();
      expect(router.transitionToViews.calledOnce).to.be.true;
    });
  });
});

});

;require.register("test/routes/views_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var routeClass = require('routes/views');

describe('routes/views', function() {

  var route = routeClass.create().get('viewDetails').create();

  describe("#parseViewPath", function() {
    var testCases = [
      {
        url: 'viewName',
        result: ''
      },
      {
        url: 'viewName?foo=bar&count=1',
        result: '?foo=bar&count=1'
      },
      {
        url: 'viewName?viewPath=%2Fuser%2Fadmin%2Faddress',
        result: '/user/admin/address'
      },
      {
        url: 'viewName?viewPath=%2Fuser%2Fadmin%2Faddress&foo=bar&count=1',
        result: '/user/admin/address?foo=bar&count=1'
      }
    ].forEach(function(test){
        it("url = " + test.url, function() {
          expect(route.parseViewPath(test.url)).to.equal(test.result);
        });
      });
  });

});

});

;require.register("test/service_components", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

module.exports = {
  "items" : [
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON",
      "StackServices" : {
        "comments" : "Data management and processing platform",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "FALCON",
        "display_name" : "Falcon",
        "service_version" : "0.5.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "config_types" : {
          "falcon-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "falcon-runtime.properties" : {
            "supports" : {
              "final" : "false"
            }
          },
          "falcon-startup.properties" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        },
        "required_services" : [
          "OOZIE"
        ]
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "FALCON_CLIENT",
            "display_name" : "Falcon Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "FALCON_SERVER",
            "display_name" : "Falcon Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "FALCON",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_SERVER/dependencies/OOZIE_CLIENT",
              "Dependencies" : {
                "component_name" : "OOZIE_CLIENT",
                "dependent_component_name" : "FALCON_SERVER",
                "dependent_service_name" : "FALCON",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FALCON/components/FALCON_SERVER/dependencies/OOZIE_SERVER",
              "Dependencies" : {
                "component_name" : "OOZIE_SERVER",
                "dependent_component_name" : "FALCON_SERVER",
                "dependent_service_name" : "FALCON",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FLUME",
      "StackServices" : {
        "comments" : "Data management and processing platform",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "FLUME",
        "display_name" : "Flume",
        "service_version" : "1.4.0.2.1.1.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "config_types" : {
          "flume-conf" : {
            "supports" : {
              "final" : "false"
            }
          },
          "flume-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "flume-log4j" : {
            "supports" : {
              "final" : "false"
            }
          }
        },
        "required_services" : [
          "HDFS"
        ]
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/FLUME/components/FLUME_HANDLER",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "FLUME_HANDLER",
            "display_name" : "Flume",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "FLUME",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/GANGLIA",
      "StackServices" : {
        "comments" : "Ganglia Metrics Collection system (<a href=\"http://oss.oetiker.ch/rrdtool/\" target=\"_blank\">RRDTool</a> will be installed too)",
        "custom_commands" : [ ],
        "service_check_supported" : false,
        "service_name" : "GANGLIA",
        "display_name" : "Ganglia",
        "service_version" : "3.5.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : null,
        "config_types" : {
          "ganglia-env" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/GANGLIA/components/GANGLIA_MONITOR",
          "StackServiceComponents" : {
            "cardinality" : "ALL",
            "component_category" : "SLAVE",
            "component_name" : "GANGLIA_MONITOR",
            "display_name" : "Ganglia Monitor",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/GANGLIA/components/GANGLIA_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "GANGLIA_SERVER",
            "display_name" : "Ganglia Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "GANGLIA",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE",
      "StackServices" : {
        "comments" : "Non-relational distributed database and centralized service for configuration management &\n        synchronization\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HBASE",
        "display_name" : "HBase",
        "service_version" : "0.98.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER",
          "HDFS"
        ],
        "config_types" : {
          "hbase-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hbase-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hbase-policy" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hbase-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HBASE_CLIENT",
            "display_name" : "HBase Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_MASTER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "MASTER",
            "component_name" : "HBASE_MASTER",
            "display_name" : "HBase Master",
            "custom_commands" : [
              "DECOMMISSION"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_MASTER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "HBASE_MASTER",
                "dependent_service_name" : "HBASE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_MASTER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "HBASE_MASTER",
                "dependent_service_name" : "HBASE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HBASE/components/HBASE_REGIONSERVER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "HBASE_REGIONSERVER",
            "display_name" : "RegionServer",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HBASE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS",
      "StackServices" : {
        "comments" : "Apache Hadoop Distributed File System",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HDFS",
        "display_name" : "HDFS",
        "service_version" : "2.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER"
        ],
        "config_types" : {
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hadoop-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hadoop-policy" : {
            "supports" : {
              "final" : "true"
            }
          },
          "hdfs-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hdfs-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/DATANODE",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "DATANODE",
            "display_name" : "DataNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/HDFS_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HDFS_CLIENT",
            "display_name" : "HDFS Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/JOURNALNODE",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "JOURNALNODE",
            "display_name" : "JournalNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/NAMENODE",
          "StackServiceComponents" : {
            "cardinality" : "1-2",
            "component_category" : "MASTER",
            "component_name" : "NAMENODE",
            "display_name" : "NameNode",
            "custom_commands" : [
              "DECOMMISSION"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/SECONDARY_NAMENODE",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "SECONDARY_NAMENODE",
            "display_name" : "SNameNode",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HDFS/components/ZKFC",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "SLAVE",
            "component_name" : "ZKFC",
            "display_name" : "ZKFailoverController",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "HDFS",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE",
      "StackServices" : {
        "comments" : "Data warehouse system for ad-hoc queries & analysis of large datasets and table & storage management service",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "HIVE",
        "display_name" : "Hive",
        "service_version" : "0.13.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER",
          "YARN"
        ],
        "config_types" : {
          "hive-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-exec-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "hive-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "tez-site" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "HIVE_CLIENT",
            "display_name" : "Hive Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_METASTORE",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HIVE_METASTORE",
            "display_name" : "Hive Metastore",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true,
            "location" : "HIVE/HIVE_SERVER"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HIVE_SERVER",
            "display_name" : "HiveServer2",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/TEZ_CLIENT",
              "Dependencies" : {
                "component_name" : "TEZ_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HIVE_SERVER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "HIVE_SERVER",
                "dependent_service_name" : "HIVE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "WEBHCAT_SERVER",
            "display_name" : "WebHCat Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/WEBHCAT_SERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/WEBHCAT_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER/dependencies/ZOOKEEPER_CLIENT",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_CLIENT",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/WEBHCAT/components/WEBHCAT_SERVER/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "WEBHCAT_SERVER",
                "dependent_service_name" : "WEBHCAT",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/MYSQL_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "0-1",
            "component_category" : "MASTER",
            "component_name" : "MYSQL_SERVER",
            "display_name" : "MySQL Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/HIVE/components/HCAT",
          "StackServiceComponents" : {
            "cardinality" : null,
            "component_category" : "CLIENT",
            "component_name" : "HCAT",
            "display_name" : "HCat",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "HIVE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2",
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "MAPREDUCE2",
        "display_name" : "MapReduce2",
        "service_version" : "2.1.0.2.0.6.0",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "mapred-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "mapred-queue-acls" : {
            "supports" : {
              "final" : "true"
            }
          },
          "mapred-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2/components/HISTORYSERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "HISTORYSERVER",
            "display_name" : "History Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "auto_deploy" : {
            "enabled" : true,
            "location" : "YARN/RESOURCEMANAGER"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2/components/HISTORYSERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "HISTORYSERVER",
                "dependent_service_name" : "MAPREDUCE2",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/MAPREDUCE2/components/MAPREDUCE2_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "CLIENT",
            "component_name" : "MAPREDUCE2_CLIENT",
            "display_name" : "MapReduce2 Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "MAPREDUCE2",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE",
      "StackServices" : {
        "comments" : "System for workflow coordination and execution of Apache Hadoop jobs.  This also includes the installation of the optional Oozie Web Console which relies on and will install the <a target=\"_blank\" href=\"http://www.sencha.com/legal/open-source-faq/\">ExtJS</a> Library.\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "OOZIE",
        "display_name" : "Oozie",
        "service_version" : "4.0.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "oozie-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "oozie-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "yarn-site" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "OOZIE_CLIENT",
            "display_name" : "Oozie Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_CLIENT/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "OOZIE_CLIENT",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_CLIENT/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "OOZIE_CLIENT",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "OOZIE_SERVER",
            "display_name" : "Oozie Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "OOZIE",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/OOZIE/components/OOZIE_SERVER/dependencies/YARN_CLIENT",
              "Dependencies" : {
                "component_name" : "YARN_CLIENT",
                "dependent_component_name" : "OOZIE_SERVER",
                "dependent_service_name" : "OOZIE",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/PIG",
      "StackServices" : {
        "comments" : "Scripting platform for analyzing large datasets",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "PIG",
        "display_name" : "Pig",
        "service_version" : "0.12.1.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "pig-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "pig-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "pig-properties" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/PIG/components/PIG",
          "StackServiceComponents" : {
            "cardinality" : "0+",
            "component_category" : "CLIENT",
            "component_name" : "PIG",
            "display_name" : "Pig",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "PIG",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP",
      "StackServices" : {
        "comments" : "Tool for transferring bulk data between Apache Hadoop and\n        structured data stores such as relational databases\n      ",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "SQOOP",
        "display_name" : "Sqoop",
        "service_version" : "1.4.4.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "HDFS"
        ],
        "config_types" : {
          "sqoop-env" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP/components/SQOOP",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "SQOOP",
            "display_name" : "Sqoop",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "SQOOP",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP/components/SQOOP/dependencies/HDFS_CLIENT",
              "Dependencies" : {
                "component_name" : "HDFS_CLIENT",
                "dependent_component_name" : "SQOOP",
                "dependent_service_name" : "SQOOP",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            },
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/SQOOP/components/SQOOP/dependencies/MAPREDUCE2_CLIENT",
              "Dependencies" : {
                "component_name" : "MAPREDUCE2_CLIENT",
                "dependent_component_name" : "SQOOP",
                "dependent_service_name" : "SQOOP",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM",
      "StackServices" : {
        "comments" : "Apache Hadoop Stream processing framework",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "STORM",
        "display_name" : "Storm",
        "service_version" : "0.9.1.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "ZOOKEEPER"
        ],
        "config_types" : {
          "storm-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "storm-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/DRPC_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "DRPC_SERVER",
            "display_name" : "DRPC Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/NIMBUS",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "NIMBUS",
            "display_name" : "Nimbus",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [
            {
              "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/NIMBUS/dependencies/ZOOKEEPER_SERVER",
              "Dependencies" : {
                "component_name" : "ZOOKEEPER_SERVER",
                "dependent_component_name" : "NIMBUS",
                "dependent_service_name" : "STORM",
                "stack_name" : "HDP",
                "stack_version" : "2.1"
              }
            }
          ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/STORM_REST_API",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "STORM_REST_API",
            "display_name" : "Storm REST API Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/STORM_UI_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1",
            "component_category" : "MASTER",
            "component_name" : "STORM_UI_SERVER",
            "display_name" : "Storm UI Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/STORM/components/SUPERVISOR",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "SUPERVISOR",
            "display_name" : "Supervisor",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "STORM",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/TEZ",
      "StackServices" : {
        "comments" : "Tez is the next generation Hadoop Query Processing framework written on top of YARN.",
        "custom_commands" : [ ],
        "service_check_supported" : false,
        "service_name" : "TEZ",
        "display_name" : "Tez",
        "service_version" : "0.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "YARN"
        ],
        "config_types" : {
          "tez-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "tez-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/TEZ/components/TEZ_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "TEZ_CLIENT",
            "display_name" : "Tez Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "TEZ",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN",
      "StackServices" : {
        "comments" : "Apache Hadoop NextGen MapReduce (YARN)",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "YARN",
        "display_name" : "YARN",
        "service_version" : "2.4.0.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [
          "HDFS",
          "TEZ"
        ],
        "config_types" : {
          "capacity-scheduler" : {
            "supports" : {
              "final" : "true"
            }
          },
          "core-site" : {
            "supports" : {
              "final" : "true"
            }
          },
          "yarn-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "yarn-log4j" : {
            "supports" : {
              "final" : "false"
            }
          },
          "yarn-site" : {
            "supports" : {
              "final" : "true"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/APP_TIMELINE_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "0-1",
            "component_category" : "MASTER",
            "component_name" : "APP_TIMELINE_SERVER",
            "display_name" : "App Timeline Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/NODEMANAGER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "SLAVE",
            "component_name" : "NODEMANAGER",
            "display_name" : "NodeManager",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/RESOURCEMANAGER",
          "StackServiceComponents" : {
            "cardinality" : "1-2",
            "component_category" : "MASTER",
            "component_name" : "RESOURCEMANAGER",
            "display_name" : "ResourceManager",
            "custom_commands" : [
              "DECOMMISSION",
              "REFRESHQUEUES"
            ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/YARN/components/YARN_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "YARN_CLIENT",
            "display_name" : "YARN Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "YARN",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/ZOOKEEPER",
      "StackServices" : {
        "comments" : "Centralized service which provides highly reliable distributed\n        coordination.",
        "custom_commands" : [ ],
        "service_check_supported" : true,
        "service_name" : "ZOOKEEPER",
        "display_name" : "ZooKeeper",
        "service_version" : "3.4.5.2.1",
        "stack_name" : "HDP",
        "stack_version" : "2.1",
        "user_name" : null,
        "required_services" : [ ],
        "config_types" : {
          "zoo.cfg" : {
            "supports" : {
              "final" : "false"
            }
          },
          "zookeeper-env" : {
            "supports" : {
              "final" : "false"
            }
          },
          "zookeeper-log4j" : {
            "supports" : {
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/ZOOKEEPER/components/ZOOKEEPER_CLIENT",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "CLIENT",
            "component_name" : "ZOOKEEPER_CLIENT",
            "display_name" : "ZooKeeper Client",
            "custom_commands" : [ ],
            "is_client" : true,
            "is_master" : false,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.1/services/ZOOKEEPER/components/ZOOKEEPER_SERVER",
          "StackServiceComponents" : {
            "cardinality" : "1+",
            "component_category" : "MASTER",
            "component_name" : "ZOOKEEPER_SERVER",
            "display_name" : "ZooKeeper Server",
            "custom_commands" : [ ],
            "is_client" : false,
            "is_master" : true,
            "service_name" : "ZOOKEEPER",
            "stack_name" : "HDP",
            "stack_version" : "2.1"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.2/services/RANGER",
      "StackServices" : {
        "comments" : "Comprehensive security for Hadoop",
        "custom_commands" : [ ],
        "display_name" : "Ranger",
        "required_services" : [ ],
        "service_check_supported" : true,
        "service_name" : "RANGER",
        "service_version" : "0.4.0",
        "stack_name" : "HDP",
        "stack_version" : "2.2",
        "user_name" : null,
        "config_types" : {
          "admin-properties" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-env" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "true"
            }
          },
          "ranger-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "usersync-properties" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          }
        }
      },
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.2/services/RANGER/components/RANGER_ADMIN",
          "StackServiceComponents" : {
            "component_name" : "RANGER_ADMIN",
            "service_name" : "RANGER",
            "stack_name" : "HDP",
            "stack_version" : "2.2"
          },
          "dependencies" : [ ]
        },
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.2/services/RANGER/components/RANGER_USERSYNC",
          "StackServiceComponents" : {
            "component_name" : "RANGER_USERSYNC",
            "service_name" : "RANGER",
            "stack_name" : "HDP",
            "stack_version" : "2.2"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    },
    {
      "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/services/RANGER_KMS",
      "StackServices" : {
        "comments" : "Key Management Server",
        "custom_commands" : [ ],
        "display_name" : "Ranger KMS",
        "required_services" : [
          "RANGER",
          "HDFS"
        ],
        "service_check_supported" : true,
        "service_name" : "RANGER_KMS",
        "service_version" : "0.5.0.2.3",
        "stack_name" : "HDP",
        "stack_version" : "2.3",
        "user_name" : null,
        "config_types" : {
          "dbks-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-env" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-log4j" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-properties" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "kms-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-audit" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-policymgr-ssl" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-security" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          },
          "ranger-kms-site" : {
            "supports" : {
              "adding_forbidden" : "false",
              "do_not_extend" : "false",
              "final" : "false"
            }
          }
        }
      },
      "themes" : [ ],
      "components" : [
        {
          "href" : "http://c6401.ambari.apache.org:8080/api/v1/stacks/HDP/versions/2.3/services/RANGER_KMS/components/RANGER_KMS_SERVER",
          "StackServiceComponents" : {
            "component_name" : "RANGER_KMS_SERVER",
            "service_name" : "RANGER_KMS",
            "stack_name" : "HDP",
            "stack_version" : "2.3"
          },
          "dependencies" : [ ]
        }
      ],
      artifacts: []
    }
  ]
};

});

;require.register("test/stack", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


module.exports = {
  "items": [
    {
      "Versions": {
        "active": true,
        "min_upgrade_version": null,
        "parent_stack_version": "1.3.3",
        "stack_name": "HDP",
        "stack_version": "1.3"
      },
      "operating_systems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "1.3"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.7.0",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/1.x/updates/1.3.8.0",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-1.3",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "1.3"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.16",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "1.3"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "1.3"
          }, "repositories": [
          {
            "Repositories": {
              "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
              "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.7.0",
              "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/1.x/updates/1.3.8.0",
              "mirrors_list": null,
              "os_type": "redhat6",
              "repo_id": "HDP-1.3",
              "repo_name": "HDP",
              "stack_name": "HDP",
              "stack_version": "1.3"
            }
          },
          {
            "Repositories": {
              "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.16/repos/centos6",
              "mirrors_list": null,
              "os_type": "redhat6",
              "repo_id": "HDP-UTILS-1.1.0.16",
              "repo_name": "HDP-UTILS",
              "stack_name": "HDP",
              "stack_version": "1.3"
            }
          }
        ]
        }
      ]
    },
    {
      "Versions": {
        "active": false,
        "min_upgrade_version": null,
        "parent_stack_version": null,
        "stack_name": "HDP",
        "stack_version": "2.0.6"
      },
      "operating_systems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "2.0.6"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-2.0.6",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "2.0.6"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-2.0.6",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.0.6"
              }
            }
          ]
        }
      ]
    },
    {
      "Versions": {
        "active": true,
        "min_upgrade_version": null,
        "parent_stack_version": null,
        "stack_name": "HDP",
        "stack_version": "2.1"
      },
      "operating_systems": [
        {
          "OperatingSystems": {
            "os_type": "redhat5",
            "stack_name": "HDP",
            "stack_version": "2.1"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-2.1",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos5",
                "mirrors_list": null,
                "os_type": "redhat5",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        },
        {
          "OperatingSystems": {
            "os_type": "redhat6",
            "stack_name": "HDP",
            "stack_version": "2.1"
          },
          "repositories": [
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.0.6.1",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-2.1",
                "repo_name": "HDP",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            },
            {
              "Repositories": {
                "base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "default_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "latest_base_url": "http://public-repo-1.hortonworks.com/HDP-UTILS-1.1.0.17/repos/centos6",
                "mirrors_list": null,
                "os_type": "redhat6",
                "repo_id": "HDP-UTILS-1.1.0.17",
                "repo_name": "HDP-UTILS",
                "stack_name": "HDP",
                "stack_version": "2.1"
              }
            }
          ]
        }
      ]
    }
  ]
};

});

;require.register("test/utils/ajax/ajax_queue_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var ajaxQueue;

describe('App.ajaxQueue', function () {

  beforeEach(function() {
    ajaxQueue = App.ajaxQueue.create();
    sinon.spy(ajaxQueue, 'runNextRequest');
    sinon.spy(ajaxQueue, 'finishedCallback');
    sinon.spy(App.ajax, 'send');
  });

  afterEach(function() {
    ajaxQueue.clear();
    ajaxQueue.runNextRequest.restore();
    ajaxQueue.finishedCallback.restore();
    App.ajax.send.restore();
  });

  describe('#clear', function() {
    it('should clear queue', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      ajaxQueue.clear();
      expect(ajaxQueue.get('queue.length')).to.equal(0);
    });
  });

  describe('#addRequest', function() {
    it('should add request', function() {
      ajaxQueue.addRequest({name:'some', sender: Em.Object.create()});
      expect(ajaxQueue.get('queue.length')).to.equal(1);
    });
    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'', sender: Em.Object.create()})}).to.throw(Error);
    });
    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequest({name:'some', sender: {}})}).to.throw(Error);
    });
  });

  describe('#addRequests', function() {
    it('should add requests', function() {
      ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: Em.Object.create()}
      ]));
      expect(ajaxQueue.get('queue.length')).to.equal(2);
    });

    it('should throw `name` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'', sender: Em.Object.create()}
      ]));}).to.throw(Error);
    });

    it('should throw `sender` error', function() {
      expect(function() {ajaxQueue.addRequests(Em.A([
        {name:'some', sender: Em.Object.create()},
        {name:'some2', sender: {}}
      ]));}).to.throw(Error);
    });

  });

  describe('#start', function() {
    it('should call runNextRequest', function() {
      ajaxQueue.start();
      expect(ajaxQueue.runNextRequest.called).to.equal(true);
    });
  });

  describe('#runNextRequest', function() {
    it('for empty queue App.ajax.send shouldn\'t be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(App.ajax.send.called).to.equal(false);
    });
    it('when queue is empty finishedCallback should be called', function() {
      ajaxQueue.clear();
      ajaxQueue.runNextRequest();
      expect(ajaxQueue.finishedCallback.called).to.equal(true);
    });
    it('if abortOnError is false queue shouldn\'t be interrupted', function() {
      ajaxQueue.clear();
      ajaxQueue.set('abortOnError', false);
      ajaxQueue.addRequest({name:'some_fake', sender: Em.Object.create()}).addRequest({name: 'some_fake2', sender: Em.Object.create()}).start();
      expect(ajaxQueue.runNextRequest.callCount).to.equal(3); // One for empty-queue
    });
  });

});

});

;require.register("test/utils/ajax/ajax_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/ajax/ajax');

describe('App.ajax', function() {

  beforeEach(function() {
    App.set('apiPrefix', '/api/v1');
    App.set('clusterName', 'tdk');
  });

  describe('#send', function() {
    beforeEach(function() {
      sinon.spy($, 'ajax');
    });

    afterEach(function() {
      $.ajax.restore();
    });
    it('Without sender', function() {
      expect(App.ajax.send({})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('Invalid config.name', function() {
      expect(App.ajax.send({name:'fake_name', sender: this})).to.equal(null);
      expect($.ajax.called).to.equal(false);
    });

    it('With proper data', function() {
      App.ajax.send({name: 'router.logoff', sender: this});
      expect($.ajax.calledOnce).to.equal(true);
    });

  });

  describe('#formatUrl', function() {

    var tests = [
      {
        url: null,
        data: {},
        e: null,
        m: 'url is null'
      },
      {
        url: 'site/{param}',
        data: null,
        e: 'site/',
        m: 'url with one param, but data is null'
      },
      {
        url: 'clean_url',
        data: {},
        e: 'clean_url',
        m: 'url without placeholders'
      },
      {
        url: 'site/{param}',
        data: {},
        e: 'site/',
        m: 'url with param, but there is no such param in the data'
      },
      {
        url: 'site/{param}/{param}',
        data: {param: 123},
        e: 'site/123/123',
        m: 'url with param which appears two times'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        var r = App.ajax.fakeFormatUrl(test.url, test.data);
        expect(r).to.equal(test.e);
      });
    });
  });

  describe('Check "real" property for each url object', function() {
    var names = App.ajax.fakeGetUrlNames();
    names.forEach(function(name) {
      it('`' + name + '`', function() {
        var url = App.ajax.fakeGetUrl(name);
        expect(url.real).to.be.a('string');
      });
      it('`' + name + '` should not contain spaces', function () {
        var url = App.ajax.fakeGetUrl(name);
        expect(url.real.contains(' ')).to.be.false;
      });
    });
  });

  describe('#formatRequest', function() {

    it('App.testMode = true', function() {
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
      var r = App.ajax.fakeFormatRequest({real:'/', mock: '/some_url'}, {});
      expect(r.type).to.equal('GET');
      expect(r.url).to.equal('/some_url');
      expect(r.dataType).to.equal('json');
      App.get.restore();
    });
    var tests = [
      {
        urlObj: {
          real: '/real_url',
          format: function() {
            return {
              type: 'PUT'
            }
          }
        },
        data: {},
        m: '',
        e: {type: 'PUT', url: '/api/v1/real_url'}
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        sinon.stub(App, 'get', function(k) {
          if ('testMode' === k) return false;
          return Em.get(App, k);
        });
        var r = App.ajax.fakeFormatRequest(test.urlObj, test.data);
        expect(r.type).to.equal(test.e.type);
        expect(r.url).to.equal(test.e.url);
        App.get.restore();
      });
    });
  });

  describe("#doGetAsPost()", function () {
    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(1);
    });
    afterEach(function () {
      App.dateTime.restore();
    });
    it("url does not have '?'", function () {
      var opt = {
        type: 'GET',
        url: '',
        headers: {}
      };
      expect(App.ajax.fakeDoGetAsPost({}, opt)).to.eql({
        type: 'POST',
        url: '?_=1',
        headers: {"X-Http-Method-Override": "GET"}
      });
    });
    it("url has '?'", function () {
      var opt = {
        type: 'GET',
        url: 'root?params',
        headers: {}
      };
      expect(App.ajax.fakeDoGetAsPost({}, opt)).to.eql({
        type: 'POST',
        url: 'root?_=1',
        headers: {"X-Http-Method-Override": "GET"},
        data: "{\"RequestInfo\":{\"query\":\"params\"}}"
      });
    });
  });

  describe('#abortRequests', function () {

    var xhr = {
        abort: Em.K
      },
      requests;

    beforeEach(function () {
      sinon.spy(xhr, 'abort');
      xhr.isForcedAbort = false;
      requests = [xhr, xhr];
      App.ajax.abortRequests(requests);
    });

    afterEach(function () {
      xhr.abort.restore();
    });

    it('should abort all requests', function () {
      expect(xhr.abort.calledTwice).to.be.true;
    });

    it('should mark request as aborted', function () {
      expect(xhr.isForcedAbort).to.be.true;
    });

    it('should clear requests array', function () {
      expect(requests).to.have.length(0);
    });

  });
});

});

;require.register("test/utils/batch_scheduled_requests_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */

var App = require('app');
require('utils/helper');
require('views/common/rolling_restart_view');
var batchUtils = require('utils/batch_scheduled_requests');
var modelSetup = require('test/init_model_test');
describe('batch_scheduled_requests', function() {

  beforeEach(function(){
    modelSetup.setupStackServiceComponent();
  });
  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe('#getRollingRestartComponentName', function() {
    var tests = [
      {serviceName: 'HDFS', componentName: 'DATANODE'},
      {serviceName: 'YARN', componentName: 'NODEMANAGER'},
      {serviceName: 'HBASE', componentName: 'HBASE_REGIONSERVER'},
      {serviceName: 'STORM', componentName: 'SUPERVISOR'},
      {serviceName: 'SOME_INVALID_SERVICE', componentName: null}
    ];

    tests.forEach(function(test) {
      it(test.serviceName + ' - ' + test.componentName, function() {
        expect(batchUtils.getRollingRestartComponentName(test.serviceName)).to.equal(test.componentName);
      });
    });

  });

  describe('#getBatchesForRollingRestartRequest', function() {
    var tests = [
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 2,
        m: 'DATANODES on three hosts, batchSize = 2',
        e: {
          batchCount: 2
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 3,
        m: 'DATANODES on 3 hosts, batchSize = 3',
        e: {
          batchCount: 1
        }
      },
      {
        hostComponents: Em.A([
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host1'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host2'}}),
          Em.Object.create({componentName:'DATANODE', service:{serviceName:'HDFS'}, host:{hostName:'host3'}})
        ]),
        batchSize: 1,
        m: 'DATANODES on 3 hosts, batchSize = 1',
        e: {
          batchCount: 3
        }
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(batchUtils.getBatchesForRollingRestartRequest(test.hostComponents, test.batchSize).length).to.equal(test.e.batchCount);
      });
    });
  });

  describe('#launchHostComponentRollingRestart', function() {

    beforeEach(function() {
      sinon.spy(batchUtils, 'showRollingRestartPopup');
      sinon.spy(batchUtils, 'showWarningRollingRestartPopup');
      sinon.stub(App, 'get', function(k) {
        if ('components.rollinRestartAllowed' === k)
          return ['DATANODE', 'TASKTRACKER', 'NODEMANAGER', 'HBASE_REGIONSERVER', 'SUPERVISOR'];
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      batchUtils.showRollingRestartPopup.restore();
      batchUtils.showWarningRollingRestartPopup.restore();
      App.get.restore();
    });

    var tests = Em.A([
      {componentName: 'DATANODE', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'TASKTRACKER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'NODEMANAGER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'HBASE_REGIONSERVER', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SUPERVISOR', e:{showRollingRestartPopup:true, showWarningRollingRestartPopup:false}},
      {componentName: 'SOME_OTHER_COMPONENT', e:{showRollingRestartPopup:false, showWarningRollingRestartPopup:true}}
    ]);

    tests.forEach(function(test) {
      it(test.componentName, function() {
        batchUtils.launchHostComponentRollingRestart(test.componentName);
        expect(batchUtils.showRollingRestartPopup.calledOnce).to.equal(test.e.showRollingRestartPopup);
        expect(batchUtils.showWarningRollingRestartPopup.calledOnce).to.equal(test.e.showWarningRollingRestartPopup);
      });
    });

  });

  describe('#restartHostComponents', function() {

    beforeEach(function() {
      sinon.spy($, 'ajax');
      sinon.stub(App, 'get', function(k) {
        if ('testMode' === k) return true;
        return Em.get(App, k);
      });
    });

    afterEach(function() {
      $.ajax.restore();
      App.get.restore();
    });

    var tests = Em.A([
      {
        hostComponentList: Em.A([
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h1'
          }),
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h2'
          })
        ]),
        e: {
          ajaxCalledOnce: true,
          resource_filters: [{"service_name": "HDFS", "component_name":"NAMENODE","hosts":"h1,h2"}]
        },
        m: '1 component on 2 hosts'
      },
      {
        hostComponentList: Em.A([
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h1'
          }),
          Em.Object.create({
            componentName: 'NAMENODE',
            hostName: 'h2'
          }),
          Em.Object.create({
            componentName: 'HBASE_MASTER',
            hostName: 'h2'
          })
        ]),
        e: {
          ajaxCalledOnce: true,
          resource_filters: [{"service_name": "HDFS", "component_name":"NAMENODE","hosts":"h1,h2"},{"service_name": "HBASE", "component_name":"HBASE_MASTER","hosts":"h2"}]
        },
        m: '1 component on 2 hosts, 1 on 1 host'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        batchUtils.restartHostComponents(test.hostComponentList);
        expect($.ajax.calledOnce).to.equal(test.e.ajaxCalledOnce);
        expect( JSON.parse($.ajax.args[0][0].data)['Requests/resource_filters']).to.eql(test.e.resource_filters);
      });
    });

    it('Empty data', function() {
      batchUtils.restartHostComponents([]);
      expect($.ajax.called).to.equal(false);
    });

  });

});

});

;require.register("test/utils/blueprint_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var blueprintUtils = require('utils/blueprint');

describe('utils/blueprint', function() {
  var masterBlueprint = {
    blueprint: {
      host_groups: [
        {
          name: "host-group-1",
          components: [
            { name: "ZOOKEEPER_SERVER" },
            { name: "NAMENODE" },
            { name: "HBASE_MASTER" }
          ]
        },
        {
          name: "host-group-2",
          components: [
            { name: "SECONDARY_NAMENODE" }
          ]
        }
      ]
    },
    blueprint_cluster_binding: {
      host_groups: [
        {
          name: "host-group-1",
          hosts: [
            { fqdn: "host1" },
            { fqdn: "host2" }
          ]
        },
        {
          name: "host-group-2",
          hosts: [
            { fqdn: "host3" }
          ]
        }
      ]
    }
  };

  var slaveBlueprint = {
    blueprint: {
      host_groups: [
        {
          name: "host-group-1",
          components: [
            { name: "DATANODE" }
          ]
        },
        {
          name: "host-group-2",
          components: [
            { name: "DATANODE" },
            { name: "HDFS_CLIENT" },
            { name: "ZOOKEEPER_CLIENT" }
          ]
        }
      ]
    },
    blueprint_cluster_binding: {
      host_groups: [
        {
          name: "host-group-1",
          hosts: [
            { fqdn: "host3" }
          ]
        },
        {
          name: "host-group-2",
          hosts: [
            { fqdn: "host4" },
            { fqdn: "host5" }
          ]
        }
      ]
    }
  };

  describe('#matchGroups', function() {
    it('should compose same host group into pairs', function() {
      expect(blueprintUtils.matchGroups(masterBlueprint, slaveBlueprint)).to.deep.equal([
        { g1: "host-group-1" },
        { g1: "host-group-2", g2: "host-group-1" },
        { g2: "host-group-2" }
      ]);
    });
  });

  describe('#filterByComponents', function() {
    it('should remove all components except', function() {
      expect(blueprintUtils.filterByComponents(masterBlueprint, ["NAMENODE"])).to.deep.equal({
        blueprint: {
          host_groups: [
            {
              name: "host-group-1",
              components: [
                { name: "NAMENODE" }
              ]
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              name: "host-group-1",
              hosts: [
                { fqdn: "host1" },
                { fqdn: "host2" }
              ]
            }
          ]
        }
      });
    });
  });

  describe('#addComponentsToBlueprint', function() {
    it('should add components to blueprint', function() {
      var components = ["FLUME_HANDLER", "HCAT"];
      expect(blueprintUtils.addComponentsToBlueprint(masterBlueprint, components)).to.deep.equal({
        blueprint: {
          host_groups: [
            {
              name: "host-group-1",
              components: [
                { name: "ZOOKEEPER_SERVER" },
                { name: "NAMENODE" },
                { name: "HBASE_MASTER" },
                { name: "FLUME_HANDLER" },
                { name: "HCAT" }
              ]
            },
            {
              name: "host-group-2",
              components: [
                { name: "SECONDARY_NAMENODE" },
                { name: "FLUME_HANDLER" },
                { name: "HCAT" }
              ]
            }
          ]
        },
        blueprint_cluster_binding: {
          host_groups: [
            {
              name: "host-group-1",
              hosts: [
                { fqdn: "host1" },
                { fqdn: "host2" }
              ]
            },
            {
              name: "host-group-2",
              hosts: [
                { fqdn: "host3" }
              ]
            }
          ]
        }
      });
    });
  });

  describe('#mergeBlueprints', function() {
    it('should merge components', function() {
      expect(blueprintUtils.mergeBlueprints(masterBlueprint, slaveBlueprint)).to.deep.equal(
        {
          blueprint: {
            host_groups: [
              {
                name: "host-group-1",
                components: [
                  { name: "ZOOKEEPER_SERVER" },
                  { name: "NAMENODE" },
                  { name: "HBASE_MASTER" }
                ]
              },
              {
                name: "host-group-2",
                components: [
                  { name: "SECONDARY_NAMENODE" },
                  { name: "DATANODE" }
                ]
              },
              {
                name: "host-group-3",
                components: [
                  { name: "DATANODE" },
                  { name: "HDFS_CLIENT" },
                  { name: "ZOOKEEPER_CLIENT" }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                name: "host-group-1",
                hosts: [
                  { fqdn: "host1" },
                  { fqdn: "host2" }
                ]
              },
              {
                name: "host-group-2",
                hosts: [
                  { fqdn: "host3" }
                ]
              },
              {
                name: "host-group-3",
                hosts: [
                  { fqdn: "host4" },
                  { fqdn: "host5" }
                ]
              }
            ]
          }
        }
      );
    });
  });

  describe('#buildConfigsJSON', function () {
    var tests = [
      {
        "services": [
          Em.Object.create({
            serviceName: "YARN",
            configTypes: {
              "yarn-site": {},
              "yarn-env": {}
            },
            isInstalled: true
          })
        ],
        "stepConfigs": [
          Em.Object.create({
            serviceName: "YARN",
            configs: [
              Em.Object.create({
                name: "p1",
                value: "v1",
                filename: "yarn-site.xml"
              }),
              Em.Object.create({
                name: "p2",
                value: "v2",
                filename: "yarn-site.xml"
              }),
              Em.Object.create({
                name: "p3",
                value: "v3",
                filename: "yarn-env.xml"
              })
            ]
          })
        ],
        "configurations": {
          "yarn-site": {
            "properties": {
              "p1": "v1",
              "p2": "v2"
            }
          },
          "yarn-env": {
            "properties": {
              "p3": "v3"
            }
          }
        }
      }
    ];
    tests.forEach(function (test) {
      it("generate configs for request (use in validation)", function () {
        expect(blueprintUtils.buildConfigsJSON(test.services, test.stepConfigs)).to.eql(test.configurations);
      });
    });
  });

  describe('#generateHostGroups()', function () {
    beforeEach(function() {
      sinon.stub(blueprintUtils, 'getComponentForHosts').returns({
        "host1": ["C1", "C2"],
        "host2": ["C1", "C3"]
      });
    });
    afterEach(function() {
      blueprintUtils.getComponentForHosts.restore();
    });

    var tests = [
      {
        "hostNames": ["host1", "host2"],
        "hostComponents": [
          Em.Object.create({
            componentName: "C1",
            hostName: "host1"
          }),
          Em.Object.create({
            componentName: "C2",
            hostName: "host1"
          }),
          Em.Object.create({
            componentName: "C1",
            hostName: "host2"
          }),
          Em.Object.create({
            componentName: "C3",
            hostName: "host2"
          })
        ],
        result: {
          blueprint: {
            host_groups: [
              {
                name: "host-group-1",
                "components": [
                  {
                    "name": "C1"
                  },
                  {
                    "name": "C2"
                  }
                ]
              },
              {
                name: "host-group-2",
                "components": [
                  {
                    "name": "C1"
                  },
                  {
                    "name": "C3"
                  }
                ]
              }
            ]
          },
          blueprint_cluster_binding: {
            host_groups: [
              {
                "name": "host-group-1",
                "hosts": [
                  {
                    "fqdn": "host1"
                  }
                ]
              },
              {
                "name": "host-group-2",
                "hosts": [
                  {
                    "fqdn": "host2"
                  }
                ]
              }
            ]
          }
        }
      }
    ];
    tests.forEach(function (test) {
      it("generate host groups", function () {
        expect(blueprintUtils.generateHostGroups(test.hostNames)).to.eql(test.result);
      });
    });
  });

  describe("#getComponentForHosts()", function() {

    beforeEach(function() {
      sinon.stub(App.ClientComponent, 'find').returns([
        Em.Object.create({
          componentName: "C1",
          hostNames: ["host1", "host2"]
        })
      ]);
      sinon.stub(App.SlaveComponent, 'find').returns([
        Em.Object.create({
          componentName: "C2",
          hostNames: ["host2", "host3"]
        })
      ]);
      sinon.stub(App.MasterComponent, 'find').returns([
        Em.Object.create({
          componentName: "C3",
          hostNames: ["host3"]
        })
      ]);
    });
    afterEach(function() {
      App.ClientComponent.find.restore();
      App.SlaveComponent.find.restore();
      App.MasterComponent.find.restore();
    });

    it("generate components to host map", function() {
      var res = blueprintUtils.getComponentForHosts();
      expect(res['host1'][0]).to.eql("C1");
      expect(res['host2'][0]).to.eql("C1");
      expect(res['host2'][1]).to.eql("C2");
      expect(res['host3'][0]).to.eql("C2");
      expect(res['host3'][1]).to.eql("C3");
    });
  });

  describe('#_generateHostMap', function() {
    it('generate map', function() {
      var map = blueprintUtils._generateHostMap({}, ['h1','h2', 'h1'],'c1');
      expect(map['h1'][0]).to.eql('c1');
      expect(map['h2'][0]).to.eql('c1');
    });

    it('skip generations as hosts is empty', function() {
      expect(blueprintUtils._generateHostMap({}, [],'c1')).to.eql({});
    });

    it('skip throws error when data is wrong', function() {
      it('should assert error if no data returned from server', function () {
        expect(function () {
          blueprintUtils._generateHostMap();
        }).to.throw(Error);
      });
    });
  });
});
});

;require.register("test/utils/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('config');
require('utils/config');
require('models/service/hdfs');
var setups = require('test/init_model_test');
var modelSetup = setups.configs;

describe('App.config', function () {

  describe('#trimProperty',function() {
    var testMessage = 'displayType `{0}`, value `{1}`{3} should return `{2}`';
    var tests = [
      {
        config: {
          displayType: 'directory',
          value: ' /a /b /c'
        },
        e: '/a,/b,/c'
      },
      {
        config: {
          displayType: 'directories',
          value: ' /a /b '
        },
        e: '/a,/b'
      },
      {
        config: {
          displayType: 'directories',
          name: 'dfs.datanode.data.dir',
          value: ' [DISK]/a [SSD]/b '
        },
        e: '[DISK]/a,[SSD]/b'
      },
      {
        config: {
          displayType: 'directories',
          name: 'dfs.datanode.data.dir',
          value: '/a,/b, /c\n/d,\n/e  /f'
        },
        e: '/a,/b,/c,/d,/e,/f'
      },
      {
        config: {
          displayType: 'host',
          value: ' localhost '
        },
        e: 'localhost'
      },
      {
        config: {
          displayType: 'password',
          value: ' passw ord '
        },
        e: ' passw ord '
      },
      {
        config: {
          displayType: 'string',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'string',
          value: ' value'
        },
        e: ' value'
      },
      {
        config: {
          displayType: 'string',
          value: 'http://localhost ',
          name: 'javax.jdo.option.ConnectionURL'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'string',
          value: 'http://localhost    ',
          name: 'oozie.service.JPAService.jdbc.url'
        },
        e: 'http://localhost'
      },
      {
        config: {
          displayType: 'custom',
          value: ' custom value '
        },
        e: ' custom value'
      },
      {
        config: {
          displayType: 'componentHosts',
          value: ['host1.com', 'host2.com']
        },
        e: ['host1.com', 'host2.com']
      }
    ];

    tests.forEach(function(test) {
      it(testMessage.format(test.config.displayType, test.config.value, test.e, !!test.config.name ? ', name `' + test.config.name + '`' : ''), function() {
        expect(App.config.trimProperty(test.config)).to.eql(test.e);
        expect(App.config.trimProperty(Em.Object.create(test.config), true)).to.eql(test.e);
      });
    });
  });

  describe('#preDefinedConfigFile', function() {
    before(function() {
      setups.setupStackVersion(this, 'BIGTOP-0.8');
    });

    it('bigtop site properties should be ok.', function() {
      var bigtopSiteProperties = App.config.preDefinedConfigFile('BIGTOP', 'site_properties');
      expect(bigtopSiteProperties).to.be.ok;
    });

    it('a non-existing file should not be ok.', function () {
      var notExistingSiteProperty = App.config.preDefinedConfigFile('notExisting');
      expect(notExistingSiteProperty).to.not.be.ok;
    });

    after(function() {
      setups.restoreStackVersion(this);
    });
  });

  describe('#generateConfigPropertiesByName', function() {
    var tests = [
      {
        names: ['property_1', 'property_2'],
        properties: undefined,
        e: {
          keys: ['name']
        },
        m: 'Should generate base property object without additional fields'
      },
      {
        names: ['property_1', 'property_2'],
        properties: { category: 'SomeCat', serviceName: 'SERVICE_NAME' },
        e: {
          keys: ['name', 'category', 'serviceName']
        },
        m: 'Should generate base property object without additional fields'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).length).to.eql(test.names.length);
        expect(App.config.generateConfigPropertiesByName(test.names, test.properties).map(function(property) {
          return Em.keys(property);
        }).reduce(function(p, c) {
          return p.concat(c);
        }).uniq()).to.eql(test.e.keys);
      });
    });

  });

  describe('#setPreDefinedServiceConfigs', function() {
    beforeEach(function() {
      sinon.stub(App.StackService, 'find', function() {
        return [
          Em.Object.create({
            id: 'HDFS',
            serviceName: 'HDFS',
            configTypes: {
              'hadoop-env': {},
              'hdfs-site': {}
            }
          }),
          Em.Object.create({
            id: 'OOZIE',
            serviceName: 'OOZIE',
            configTypes: {
              'oozie-env': {},
              'oozie-site': {}
            }
          })
        ];
      });
      App.config.setPreDefinedServiceConfigs(true);
    });
    afterEach(function() {
      App.StackService.find.restore();
    });

    it('should include service MISC', function() {
      expect(App.config.get('preDefinedServiceConfigs').findProperty('serviceName', 'MISC')).to.be.ok;
    });

    it('should include -env config types according to stack services', function() {
      var miscCategory = App.config.get('preDefinedServiceConfigs').findProperty('serviceName', 'MISC');
      expect(Em.keys(miscCategory.get('configTypes'))).to.eql(['cluster-env', 'hadoop-env', 'oozie-env']);
    });

    it('should not load configs for missed config types', function() {
      var hdfsService = App.config.get('preDefinedServiceConfigs').findProperty('serviceName', 'HDFS');
      var rangerRelatedConfigs = hdfsService.get('configs').filterProperty('filename', 'ranger-hdfs-plugin-properties.xml');
      expect(rangerRelatedConfigs.length).to.be.eql(0);
      expect(hdfsService.get('configs.length') > 0).to.be.true;
    });
  });
  
  describe('#isManagedMySQLForHiveAllowed', function () {

    var cases = [
      {
        osFamily: 'redhat5',
        expected: false
      },
      {
        osFamily: 'redhat6',
        expected: true
      },
      {
        osFamily: 'suse11',
        expected: false
      }
    ],
      title = 'should be {0} for {1}';

    cases.forEach(function (item) {
      it(title.format(item.expected, item.osFamily), function () {
        expect(App.config.isManagedMySQLForHiveAllowed(item.osFamily)).to.equal(item.expected);
      });
    });

  });


  describe('#advancedConfigIdentityData', function () {

    var configs = [
      {
        input: {
          property_type: ['USER'],
          property_name: 'hdfs_user'
        },
        output: {
          category: 'Users and Groups',
          isVisible: true,
          serviceName: 'MISC',
          displayType: 'user',
          index: 30
        },
        title: 'user, no service name specified, default display name behaviour'
      },
      {
        input: {
          property_type: ['GROUP'],
          property_name: 'knox_group',
          service_name: 'KNOX'
        },
        output: {
          category: 'Users and Groups',
          isVisible: true,
          serviceName: 'MISC',
          displayType: 'user',
          index: 0
        },
        title: 'group, service_name = KNOX, default display name behaviour'
      },
      {
        input: {
          property_type: ['USER']
        },
        output: {
          isVisible: false
        },
        isHDPWIN: true,
        title: 'HDPWIN stack'
      },
      {
        input: {
          property_type: ['USER'],
          property_name: 'smokeuser',
          service_name: 'MISC'
        },
        output: {
          serviceName: 'MISC',
          belongsToService: ['MISC'],
          index: 30
        },
        title: 'smokeuser, service_name = MISC'
      },
      {
        input: {
          property_type: ['USER'],
          property_name: 'ignore_groupsusers_create'
        },
        output: {
          displayType: 'boolean'
        },
        title: 'ignore_groupsusers_create'
      },
      {
        input: {
          property_type: ['GROUP'],
          property_name: 'proxyuser_group'
        },
        output: {
          belongsToService: ['HIVE', 'OOZIE', 'FALCON']
        },
        title: 'proxyuser_group'
      },
      {
        input: {
          property_type: ['PASSWORD'],
          property_name: 'javax.jdo.option.ConnectionPassword'
        },
        output: {
          displayType: 'password'
        },
        title: 'password'
      }
    ];

    before(function () {
      sinon.stub(App.StackService, 'find').returns([
        {
          serviceName: 'KNOX'
        }
      ]);
    });

    afterEach(function () {
      App.get.restore();
    });

    after(function () {
      App.StackService.find.restore();
    });

    configs.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App, 'get').withArgs('isHadoopWindowsStack').returns(Boolean(item.isHDPWIN));
        var propertyData = App.config.advancedConfigIdentityData(item.input);
        Em.keys(item.output).forEach(function (key) {
          expect(propertyData[key]).to.eql(item.output[key]);
        });
      });
    });

  });

  describe('#shouldSupportFinal', function () {

    var cases = [
      {
        shouldSupportFinal: false,
        title: 'no service name specified'
      },
      {
        serviceName: 's0',
        shouldSupportFinal: false,
        title: 'no filename specified'
      },
      {
        serviceName: 'MISC',
        shouldSupportFinal: false,
        title: 'MISC'
      },
      {
        serviceName: 's0',
        filename: 's0-site',
        shouldSupportFinal: true,
        title: 'final attribute supported'
      },
      {
        serviceName: 's0',
        filename: 's0-env',
        shouldSupportFinal: false,
        title: 'final attribute not supported'
      },
      {
        serviceName: 'Cluster',
        filename: 'krb5-conf.xml',
        shouldSupportFinal: false,
        title: 'kerberos descriptor identities don\'t support final'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.StackService, 'find').returns([
        {
          serviceName: 's0'
        }
      ]);
      sinon.stub(App.config, 'getConfigTypesInfoFromService').returns({
        supportsFinal: ['s0-site']
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
      App.config.getConfigTypesInfoFromService.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(App.config.shouldSupportFinal(item.serviceName, item.filename)).to.equal(item.shouldSupportFinal);
      });
    });

  });

  describe('#removeRangerConfigs', function () {

    it('should remove ranger configs and categories', function () {
      var configs = [
        Em.Object.create({
          configs: [
            Em.Object.create({filename: 'filename'}),
            Em.Object.create({filename: 'ranger-filename'})
          ],
          configCategories: [
            Em.Object.create({name: 'ranger-name'}),
            Em.Object.create({name: 'name'}),
            Em.Object.create({name: 'also-ranger-name'})
          ]
        })
      ];
      App.config.removeRangerConfigs(configs);
      expect(configs).eql(
          [
            Em.Object.create({
              configs: [
                Em.Object.create({filename: 'filename'})
              ],
              configCategories: [
                Em.Object.create({name: 'name'})
              ]
            })
          ]
      );
    });

  });

  describe('#updateHostsListValue', function() {
    var tests = [
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1,host2'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        hostsList: 'host1',
        e: 'host1'
      },
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1:10,host2:10'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        hostsList: 'host2:10,host1:10',
        e: 'host1:10,host2:10'
      },
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1:10,host2:10,host3:10'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        hostsList: 'host2:10,host1:10',
        e: 'host2:10,host1:10'
      },
      {
        siteConfigs: {
          'hadoop.registry.zk.quorum': 'host1:10,host2:10,host3:10'
        },
        propertyName: 'hadoop.registry.zk.quorum',
        hostsList: 'host2:10,host1:10,host3:10,host4:11',
        e: 'host2:10,host1:10,host3:10,host4:11'
      },
      {
        siteConfigs: {
          'hive.zookeeper.quorum': 'host1'
        },
        propertyName: 'some.new.property',
        hostsList: 'host2,host1:10',
        e: 'host2,host1:10'
      }
    ];
    tests.forEach(function(test) {
      it('ZK located on {0}, current prop value is "{1}" "{2}" value should be "{3}"'.format(test.hostsList, ''+test.siteConfigs[test.propertyName], test.propertyName, test.e), function() {
        var result = App.config.updateHostsListValue(test.siteConfigs, test.propertyName, test.hostsList);
        expect(result).to.be.eql(test.e);
        expect(test.siteConfigs[test.propertyName]).to.be.eql(test.e);
      });
    });
  });

  describe("#createOverride", function() {
    var template = {
      name: "p1",
      filename: "f1",
      value: "v1",
      recommendedValue: "rv1",
      savedValue: "sv1",
      isFinal: true,
      recommendedIsFinal: false,
      savedIsFinal: true
    };

    var configProperty = App.ServiceConfigProperty.create(template);

    var group = App.ConfigGroup.create({name: "group1"});

    it('creates override with save properties as original config', function() {
      var override = App.config.createOverride(configProperty, {}, group);
      for (var key in template) {
        expect(override.get(key)).to.eql(template[key]);
      }
    });

    it('overrides some values that should be different for override', function() {
      var override = App.config.createOverride(configProperty, {}, group);
      expect(override.get('isOriginalSCP')).to.be.false;
      expect(override.get('overrides')).to.be.null;
      expect(override.get('group')).to.eql(group);
      expect(override.get('parentSCP')).to.eql(configProperty);
    });

    it('overrides some specific values', function() {
      var overridenTemplate = {
        value: "v2",
        recommendedValue: "rv2",
        savedValue: "sv2",
        isFinal: true,
        recommendedIsFinal: false,
        savedIsFinal: true
      };

      var override = App.config.createOverride(configProperty, overridenTemplate, group);
      for (var key in overridenTemplate) {
        expect(override.get(key)).to.eql(overridenTemplate[key]);
      }
    });

    it('throws error due to undefined configGroup', function() {
      expect(App.config.createOverride.bind(App.config, configProperty, {}, null)).to.throw(Error, 'configGroup can\' be null');
    });

    it('throws error due to undefined originalSCP', function() {
      expect(App.config.createOverride.bind(App.config, null, {}, group)).to.throw(Error, 'serviceConfigProperty can\' be null');
    });

    it('updates originalSCP object ', function() {
      configProperty.set('overrides', null);
      configProperty.set('overrideValues', []);
      configProperty.set('overrideIsFinalValues', []);

      var overridenTemplate2 = {
        value: "v12",
        recommendedValue: "rv12",
        savedValue: "sv12",
        isFinal: true,
        recommendedIsFinal: false,
        savedIsFinal: false
      };

      var override = App.config.createOverride(configProperty, overridenTemplate2, group);

      expect(configProperty.get('overrides')[0]).to.be.eql(override);
      expect(configProperty.get('overrideValues')).to.be.eql([overridenTemplate2.value]);
      expect(configProperty.get('overrideIsFinalValues')).to.be.eql([overridenTemplate2.isFinal]);
    });
  });

  describe('#getIsEditable', function() {
    [{
        isDefaultGroup: true,
        isReconfigurable: true,
        canEdit: true,
        res: true,
        m: "isEditable is true"
      },
      {
        isDefaultGroup: false,
        isReconfigurable: true,
        canEdit: true,
        res: false,
        m: "isEditable is false; config group is not default"
      },
      {
        isDefaultGroup: true,
        isReconfigurable: false,
        canEdit: true,
        res: false,
        m: "isEditable is true; config is not reconfigurable"
      },
      {
        isDefaultGroup: true,
        isReconfigurable: true,
        canEdit: false,
        res: false,
        m: "isEditable is true; edition restricted by controller state"
    }].forEach(function(t) {
        it(t.m, function() {
          var configProperty = Ember.Object.create({isReconfigurable: t.isReconfigurable});
          var configGroup = Ember.Object.create({isDefault: t.isDefaultGroup});
          var isEditable = App.config.getIsEditable(configProperty, configGroup, t.canEdit);
          expect(isEditable).to.equal(t.res);
        })
      });
  });

  describe('#getIsSecure', function() {
    var secureConfigs = App.config.get('secureConfigs');
    before(function() {
      App.config.set('secureConfigs', [{name: 'secureConfig'}]);
    });
    after(function() {
      App.config.set('secureConfigs', secureConfigs);
    });

    it('config is secure', function() {
      expect(App.config.getIsSecure('secureConfig')).to.equal(true);
    });
    it('config is not secure', function() {
      expect(App.config.getIsSecure('NotSecureConfig')).to.equal(false);
    });
  });

  describe('#getDefaultCategory', function() {
    it('returns custom category', function() {
      expect(App.config.getDefaultCategory(null, 'filename.xml')).to.equal('Custom filename');
    });
    it('returns advanced category', function() {
      expect(App.config.getDefaultCategory(Em.Object.create, 'filename.xml')).to.equal('Advanced filename');
    });
  });

  describe('#getDefaultDisplayType', function() {
    it('returns content displayType', function() {
      sinon.stub(App.config, 'isContentProperty', function () {return true});
      expect(App.config.getDefaultDisplayType('content','f1','anything')).to.equal('content');
      App.config.isContentProperty.restore();
    });
    it('returns singleLine displayType', function() {
      sinon.stub(App.config, 'isContentProperty', function () {return false});
      expect(App.config.getDefaultDisplayType('n1','f1','v1')).to.equal('string');
      App.config.isContentProperty.restore();
    });
    it('returns multiLine displayType', function() {
      sinon.stub(App.config, 'isContentProperty', function () {return false});
      expect(App.config.getDefaultDisplayType('n2', 'f2', 'v1\nv2')).to.equal('multiLine');
      App.config.isContentProperty.restore();
    });
    it('returns custom displayType for FALCON oozie-site properties', function() {
      sinon.stub(App.config, 'isContentProperty', function () {return false});
      expect(App.config.getDefaultDisplayType('n2', 'oozie-site.xml', 'v1\nv2', 'FALCON')).to.equal('custom');
      App.config.isContentProperty.restore();
    });
  });

  describe('#getDefaultDisplayName', function() {
    beforeEach(function() {
      sinon.stub(App.config, 'getConfigTagFromFileName', function(fName) {return fName} );
    });
    afterEach(function() {
      App.config.getConfigTagFromFileName.restore();
    });

    it('returns name', function() {
      sinon.stub(App.config, 'isContentProperty', function() {return false} );
      expect(App.config.getDefaultDisplayName('name')).to.equal('name');
      App.config.isContentProperty.restore();
    });
    it('returns name for env content', function() {
      sinon.stub(App.config, 'isContentProperty', function() {return true} );
      expect(App.config.getDefaultDisplayName('name', 'fileName')).to.equal('fileName template');
      App.config.isContentProperty.restore();
    });
  });

  describe('#isContentProperty', function() {
    beforeEach(function() {
      sinon.stub(App.config, 'getConfigTagFromFileName', function(fName) {return fName} );
    });
    afterEach(function() {
      App.config.getConfigTagFromFileName.restore();
    });
    var tests = [
      {
        name: 'content',
        fileName: 'something-env',
        tagEnds: null,
        res: true,
        m: 'returns true as it\'s content property'
      },
      {
        name: 'content',
        fileName: 'something-any-end',
        tagEnds: ['-any-end'],
        res: true,
        m: 'returns true as it\'s content property with specific fileName ending'
      },
      {
        name: 'notContent',
        fileName: 'something-env',
        tagEnds: ['-env'],
        res: false,
        m: 'returns false as name is not content'
      },
      {
        name: 'content',
        fileName: 'something-env1',
        tagEnds: ['-env'],
        res: false,
        m: 'returns false as fileName is not correct'
      }
    ].forEach(function(t) {
        it(t.m, function() {
          expect(App.config.isContentProperty(t.name, t.fileName, t.tagEnds)).to.equal(t.res);
        });
      });
  });

  describe('#formatValue', function() {
    it('formatValue for componentHosts', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'componentHosts', value: "['h1','h2']"});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.eql(['h1','h2']);
    });

    it('formatValue for int', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'int', value: '4.0'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('4');
    });

    it('formatValue for int with m', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'int', value: '4m'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('4');
    });

    it('formatValue for float', function () {
      var serviceConfigProperty = Em.Object.create({'displayType': 'float', value: '0.40'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('0.4');
    });

    it('formatValue for kdc_type', function () {
      var serviceConfigProperty = Em.Object.create({'name': 'kdc_type', value: 'mit-kdc'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal(Em.I18n.t('admin.kerberos.wizard.step1.option.kdc'));
    });

    it('don\'t format value', function () {
      var serviceConfigProperty = Em.Object.create({'name': 'any', displayType: 'any', value: 'any'});
      expect(App.config.formatPropertyValue(serviceConfigProperty)).to.equal('any');
    });
  });

  describe('#getPropertyIfExists', function() {
    [
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        firstObject: { someProperty: '1' },
        secondObject: { someProperty: '2' },
        res: '1',
        m: 'use value from first object'
      },
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        firstObject: { someOtherProperty: '1' },
        secondObject: { someProperty: '2' },
        res: '2',
        m: 'use value from second object'
      },
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        firstObject: { someOtherProperty: '1' },
        secondObject: { someOtherProperty: '2' },
        res: 'default',
        m: 'use default value'
      },
      {
        propertyName: 'someProperty',
        defaultValue: 'default',
        res: 'default',
        m: 'use default value'
      },
      {
        propertyName: 'someProperty',
        defaultValue: true,
        firstObject: { someProperty: false },
        secondObject: { someProperty: true },
        res: false,
        m: 'use value from first object, check booleans'
      },
      {
        propertyName: 'someProperty',
        defaultValue: true,
        firstObject: { someProperty: 0 },
        secondObject: { someProperty: 1 },
        res: 0,
        m: 'use value from first object, check 0'
      },
      {
        propertyName: 'someProperty',
        defaultValue: true,
        firstObject: { someProperty: '' },
        secondObject: { someProperty: '1' },
        res: '',
        m: 'use value from first object, check empty string'
      }
    ].forEach(function (t) {
        it(t.m, function () {
          expect(App.config.getPropertyIfExists(t.propertyName, t.defaultValue, t.firstObject, t.secondObject)).to.equal(t.res);
        })
      });
  });

  describe('#createDefaultConfig', function() {
    before(function () {
      sinon.stub(App.config, 'getDefaultDisplayName', function () {
        return 'pDisplayName';
      });
      sinon.stub(App.config, 'getDefaultDisplayType', function () {
        return 'pDisplayType';
      });
      sinon.stub(App.config, 'getDefaultCategory', function () {
        return 'pCategory';
      });
      sinon.stub(App.config, 'getIsSecure', function () {
        return false;
      });
      sinon.stub(App.config, 'getDefaultIsShowLabel', function () {
        return true;
      });
      sinon.stub(App.config, 'shouldSupportFinal', function () {
        return true;
      });
    });

    after(function () {
      App.config.getDefaultDisplayName.restore();
      App.config.getDefaultDisplayType.restore();
      App.config.getDefaultCategory.restore();
      App.config.getIsSecure.restore();
      App.config.getDefaultIsShowLabel.restore();
      App.config.shouldSupportFinal.restore();
    });

    var res = {
      /** core properties **/
      name: 'pName',
      filename: 'pFileName',
      value: '',
      savedValue: null,
      isFinal: false,
      savedIsFinal: null,
      /** UI and Stack properties **/
      recommendedValue: null,
      recommendedIsFinal: null,
      supportsFinal: true,
      serviceName: 'pServiceName',
      displayName: 'pDisplayName',
      displayType: 'pDisplayType',
      description: null,
      category: 'pCategory',
      isSecureConfig: false,
      showLabel: true,
      isVisible: true,
      isUserProperty: false,
      isRequired: true,
      group: null,
      isRequiredByAgent:  true,
      isReconfigurable: true,
      unit: null,
      hasInitialValue: false,
      isOverridable: true,
      index: Infinity,
      dependentConfigPattern: null,
      options: null,
      radioName: null,
      belongsToService: [],
      widgetType: null
    };
    it('create default config object', function () {
      expect(App.config.createDefaultConfig('pName', 'pServiceName', 'pFileName', true)).to.eql(res);
    });
    it('runs proper methods', function () {
      expect(App.config.getDefaultDisplayName.calledWith('pName', 'pFileName')).to.be.true;
      expect(App.config.getDefaultDisplayType.calledWith('pName', 'pFileName', '')).to.be.true;
      expect(App.config.getDefaultCategory.calledWith(true, 'pFileName')).to.be.true;
      expect(App.config.getIsSecure.calledWith('pName')).to.be.true;
      expect(App.config.getDefaultIsShowLabel.calledWith('pName', 'pFileName')).to.be.true;
      expect(App.config.shouldSupportFinal.calledWith('pServiceName', 'pFileName')).to.be.true;
    });
  });

  describe('#mergeStackConfigsWithUI', function() {
    beforeEach(function() {
      sinon.stub(App.config, 'getPropertyIfExists', function(key, value) {return 'res_' + value});
    });

    afterEach(function() {
      App.config.getPropertyIfExists.restore();
    });

    var template = {
      name: 'pName',
      filename: 'pFileName',
      value: 'pValue',
      savedValue: 'pValue',
      isFinal: true,
      savedIsFinal: true,

      serviceName: 'pServiceName',
      displayName: 'pDisplayName',
      displayType: 'pDisplayType',
      category: 'pCategory'
    };

    var result = {
      name: 'pName',
      filename: 'pFileName',
      value: 'pValue',
      savedValue: 'pValue',
      isFinal: true,
      savedIsFinal: true,

      serviceName: 'res_pServiceName',
      displayName: 'res_pDisplayName',
      displayType: 'res_pDisplayType',
      category: 'res_pCategory'
    };

    it('called generate property object', function () {
      expect(App.config.mergeStaticProperties(template, {}, {})).to.eql(result);
    });
  });

  describe('#createHostNameProperty', function() {
    it('create host property', function() {
      expect(App.config.createHostNameProperty('service1', 'component1', ['host1'], Em.Object.create({
        isMultipleAllowed: false,
        displayName: 'display name'
      }))).to.eql({
          "name": 'component1_host',
          "displayName": 'display name host',
          "value": ['host1'],
          "recommendedValue": ['host1'],
          "description": "The host that has been assigned to run display name",
          "displayType": "componentHost",
          "isOverridable": false,
          "isRequiredByAgent": false,
          "serviceName": 'service1',
          "filename": "service1-site.xml",
          "category": 'component1',
          "index": 0
        })
    });

    it('create hosts property', function() {
      expect(App.config.createHostNameProperty('service1', 'component1', ['host1'], Em.Object.create({
        isMultipleAllowed: true,
        displayName: 'display name'
      }))).to.eql({
          "name": 'component1_hosts',
          "displayName": 'display name host',
          "value": ['host1'],
          "recommendedValue": ['host1'],
          "description": "The hosts that has been assigned to run display name",
          "displayType": "componentHosts",
          "isOverridable": false,
          "isRequiredByAgent": false,
          "serviceName": 'service1',
          "filename": "service1-site.xml",
          "category": 'component1',
          "index": 0
        })
    });
  })
});

});

;require.register("test/utils/configs/config_property_helper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var configPropertyHelper = require('utils/configs/config_property_helper');

require('models/configs/objects/service_config_property');

var serviceConfig,
  group,
  serviceConfigProperty,

  components = [
    {
      name: 'NameNode',
      master: true
    },
    {
      name: 'SNameNode',
      master: true
    },
    {
      name: 'JobTracker',
      master: true
    },
    {
      name: 'HBase Master',
      master: true
    },
    {
      name: 'Oozie Master',
      master: true
    },
    {
      name: 'Hive Metastore',
      master: true
    },
    {
      name: 'WebHCat Server',
      master: true
    },
    {
      name: 'ZooKeeper Server',
      master: true
    },
    {
      name: 'Ganglia',
      master: true
    },
    {
      name: 'DataNode',
      slave: true
    },
    {
      name: 'TaskTracker',
      slave: true
    },
    {
      name: 'RegionServer',
      slave: true
    }
  ],
  masters = components.filterProperty('master'),
  slaves = components.filterProperty('slave');


describe('configPropertyHelper', function () {

  beforeEach(function () {
    serviceConfigProperty = App.ServiceConfigProperty.create();
  });

  describe('#setRecommendedValue', function () {
    it('should change the recommended value', function () {
      serviceConfigProperty.set('recommendedValue', 'value0');
      configPropertyHelper.setRecommendedValue(serviceConfigProperty, /\d/, '1');
      expect(serviceConfigProperty.get('recommendedValue')).to.equal('value1');
    });
  });


  describe('#initialValue', function () {

    var cases = {
      'kafka.ganglia.metrics.host': [
        {
          message: 'kafka.ganglia.metrics.host property should have the value of ganglia hostname when ganglia is selected',
          localDB: {
            masterComponentHosts: [
              {
                component: 'GANGLIA_SERVER',
                hostName: 'c6401'
              }
            ]
          },
          expected: 'c6401'
        },
        {
          message: 'kafka.ganglia.metrics.host property should have the value "localhost" when ganglia is not selected',
          localDB: {
            masterComponentHosts: [
              {
                component: 'NAMENODE',
                hostName: 'c6401'
              }
            ]
          },
          expected: 'localhost'
        }
      ],
      'hive_database': [
        {
          alwaysEnableManagedMySQLForHive: true,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New MySQL Database',
          value: 'New MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: false
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: 'configs',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New MySQL Database',
          value: 'New MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: false
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: true,
          receivedValue: 'New MySQL Database',
          value: 'New MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: false
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New MySQL Database',
          value: 'Existing MySQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: true
        },
        {
          alwaysEnableManagedMySQLForHive: false,
          currentStateName: '',
          isManagedMySQLForHiveEnabled: false,
          receivedValue: 'New PostgreSQL Database',
          value: 'New PostgreSQL Database',
          options: [
            {
              displayName: 'New MySQL Database'
            }
          ],
          hidden: true
        }
      ],
      'hbase.zookeeper.quorum': [
        {
          filename: 'hbase-site.xml',
          value: 'host0,host1',
          recommendedValue: 'host0,host1',
          title: 'should set ZooKeeper Server hostnames'
        },
        {
          filename: 'ams-hbase-site.xml',
          value: 'localhost',
          recommendedValue: null,
          title: 'should ignore ZooKeeper Server hostnames'
        }
      ],
      'hivemetastore_host': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            }
          ]
        },
        value: ['h0', 'h1'],
        title: 'array that contains names of hosts with Hive Metastore'
      },
      'hive_master_hosts': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_SERVER',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            },
            {
              component: 'WEBHCAT_SERVER',
              hostName: 'h2'
            }
          ]
        },
        value: 'h0,h1',
        title: 'comma separated list of hosts with Hive Server and Metastore'
      },
      'hive.metastore.uris': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            }
          ]
        },
        dependencies: {
          'hive.metastore.uris': 'thrift://localhost:9083'
        },
        recommendedValue: 'thrift://localhost:9083',
        value: 'thrift://h0:9083,thrift://h1:9083',
        title: 'comma separated list of Metastore hosts with thrift prefix and port'
      },
      'templeton.hive.properties': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'HIVE_METASTORE',
              hostName: 'h0'
            },
            {
              component: 'HIVE_METASTORE',
              hostName: 'h1'
            }
          ]
        },
        dependencies: {
          'hive.metastore.uris': 'thrift://localhost:9083'
        },
        recommendedValue: 'hive.metastore.local=false,hive.metastore.uris=thrift://localhost:9083,hive.metastore.sasl.enabled=false',
        value: 'hive.metastore.local=false,hive.metastore.uris=thrift://h0:9083\\,thrift://h1:9083,hive.metastore.sasl.enabled=false,hive.metastore.execute.setugi=true',
        title: 'should add relevant hive.metastore.uris value'
      },
      'yarn.resourcemanager.zk-address': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'ZOOKEEPER_SERVER',
              hostName: 'h0'
            },
            {
              component: 'ZOOKEEPER_SERVER',
              hostName: 'h1'
            }
          ]
        },
        dependencies: {
          clientPort: '2182'
        },
        recommendedValue: 'localhost:2181',
        value: 'h0:2182,h1:2182',
        title: 'should add ZK host and port dynamically'
      },
      'oozie_hostname': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'OOZIE_SERVER',
              hostName: 'h0'
            },
            {
              component: 'OOZIE_SERVER',
              hostName: 'h1'
            }
          ]
        },
        value: ['h0', 'h1'],
        title: 'array that contains names of hosts with Oozie Server'
      },
      'knox_gateway_host': {
        localDB: {
          masterComponentHosts: [
            {
              component: 'KNOX_GATEWAY',
              hostName: 'h0'
            },
            {
              component: 'KNOX_GATEWAY',
              hostName: 'h1'
            }
          ]
        },
        value: ['h0', 'h1'],
        title: 'array that contains names of hosts with Knox Gateway'
      }
    };

    cases['kafka.ganglia.metrics.host'].forEach(function (item) {
      it(item.message, function () {
        serviceConfigProperty.setProperties({
          name: 'kafka.ganglia.metrics.host',
          value: 'localhost'
        });
        configPropertyHelper.initialValue(serviceConfigProperty, item.localDB, []);
        expect(serviceConfigProperty.get('value')).to.equal(item.expected);
      });
    });

    cases['hive_database'].forEach(function (item) {
      var title = 'hive_database value should be set to {0}';
      it(title.format(item.value), function () {
        sinon.stub(App, 'get')
          .withArgs('supports.alwaysEnableManagedMySQLForHive').returns(item.alwaysEnableManagedMySQLForHive)
          .withArgs('router.currentState.name').returns(item.currentStateName)
          .withArgs('isManagedMySQLForHiveEnabled').returns(item.isManagedMySQLForHiveEnabled);
        serviceConfigProperty.setProperties({
          name: 'hive_database',
          value: item.receivedValue,
          options: item.options
        });
        configPropertyHelper.initialValue(serviceConfigProperty, {}, []);
        expect(serviceConfigProperty.get('value')).to.equal(item.value);
        expect(serviceConfigProperty.get('options').findProperty('displayName', 'New MySQL Database').hidden).to.equal(item.hidden);
        App.get.restore();
      });
    });

    cases['hbase.zookeeper.quorum'].forEach(function (item) {
      it(item.title, function () {
        serviceConfigProperty.setProperties({
          name: 'hbase.zookeeper.quorum',
          value: 'localhost',
          'filename': item.filename
        });
        configPropertyHelper.initialValue(serviceConfigProperty, {
          masterComponentHosts: {
            filterProperty: function () {
              return {
                mapProperty: function () {
                  return ['host0', 'host1'];
                }
              };
            }
          }
        }, []);
        expect(serviceConfigProperty.get('value')).to.equal(item.value);
        expect(serviceConfigProperty.get('recommendedValue')).to.equal(item.recommendedValue);
      });
    });

    it(cases['hive_master_hosts'].title, function () {
      serviceConfigProperty.set('name', 'hive_master_hosts');
      configPropertyHelper.initialValue(serviceConfigProperty, cases['hive_master_hosts'].localDB, []);
      expect(serviceConfigProperty.get('value')).to.equal(cases['hive_master_hosts'].value);
    });

    it(cases['hive.metastore.uris'].title, function () {
      serviceConfigProperty.setProperties({
        name: 'hive.metastore.uris',
        recommendedValue: cases['hive.metastore.uris'].recommendedValue
      });
      configPropertyHelper.initialValue(serviceConfigProperty, cases['hive.metastore.uris'].localDB, {'hive.metastore.uris': cases['hive.metastore.uris'].recommendedValue});
      expect(serviceConfigProperty.get('value')).to.equal(cases['hive.metastore.uris'].value);
      expect(serviceConfigProperty.get('recommendedValue')).to.equal(cases['hive.metastore.uris'].value);
    });

    it(cases['templeton.hive.properties'].title, function () {
      serviceConfigProperty.setProperties({
        name: 'templeton.hive.properties',
        recommendedValue: cases['templeton.hive.properties'].recommendedValue,
        value: cases['templeton.hive.properties'].recommendedValue
      });
      configPropertyHelper.initialValue(serviceConfigProperty, cases['templeton.hive.properties'].localDB,  {'hive.metastore.uris': cases['templeton.hive.properties'].recommendedValue});
      expect(serviceConfigProperty.get('value')).to.equal(cases['templeton.hive.properties'].value);
      expect(serviceConfigProperty.get('recommendedValue')).to.equal(cases['templeton.hive.properties'].value);
    });

    it(cases['yarn.resourcemanager.zk-address'].title, function () {
      serviceConfigProperty.setProperties({
        name: 'yarn.resourcemanager.zk-address',
        recommendedValue: cases['yarn.resourcemanager.zk-address'].recommendedValue
      });
      configPropertyHelper.initialValue(serviceConfigProperty, cases['yarn.resourcemanager.zk-address'].localDB,  cases['yarn.resourcemanager.zk-address'].dependencies);
      expect(serviceConfigProperty.get('value')).to.equal(cases['yarn.resourcemanager.zk-address'].value);
      expect(serviceConfigProperty.get('recommendedValue')).to.equal(cases['yarn.resourcemanager.zk-address'].value);
    });

  });

  describe('#getHiveMetastoreUris', function () {

    var cases = [
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          },
          {
            hostName: 'h1',
            component: 'HIVE_METASTORE'
          },
          {
            hostName: 'h2',
            component: 'HIVE_METASTORE'
          }
        ],
        recommendedValue: 'thrift://localhost:9083',
        expected: 'thrift://h1:9083,thrift://h2:9083',
        title: 'typical case'
      },
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          }
        ],
        recommendedValue: 'thrift://localhost:9083',
        expected: '',
        title: 'no Metastore hosts in DB'
      },
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          },
          {
            hostName: 'h1',
            component: 'HIVE_METASTORE'
          },
          {
            hostName: 'h2',
            component: 'HIVE_METASTORE'
          }
        ],
        recommendedValue: '',
        expected: '',
        title: 'default value without port'
      },
      {
        hosts: [
          {
            hostName: 'h0',
            component: 'HIVE_SERVER'
          },
          {
            hostName: 'h1',
            component: 'HIVE_METASTORE'
          },
          {
            hostName: 'h2',
            component: 'HIVE_METASTORE'
          }
        ],
        expected: '',
        title: 'no default value specified'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(configPropertyHelper.getHiveMetastoreUris(item.hosts, item.recommendedValue)).to.equal(item.expected);
      });
    });

  });

  describe('#unionAllMountPoints', function () {

    var localDB = {
        masterComponentHosts: [
          {
            component: 'NAMENODE',
            hostName: 'h0'
          },
          {
            component: 'SECONDARY_NAMENODE',
            hostName: 'h4'
          },
          {
            component: 'APP_TIMELINE_SERVER',
            hostName: 'h0'
          },
          {
            component: 'ZOOKEEPER_SERVER',
            hostName: 'h0'
          },
          {
            component: 'ZOOKEEPER_SERVER',
            hostName: 'h1'
          },
          {
            component: 'OOZIE_SERVER',
            hostName: 'h0'
          },
          {
            component: 'OOZIE_SERVER',
            hostName: 'h1'
          },
          {
            component: 'NIMBUS',
            hostName: 'h2'
          },
          {
            component: 'FALCON_SERVER',
            hostName: 'h3'
          },
          {
            component: 'KAFKA_BROKER',
            hostName: 'h0'
          },
          {
            component: 'KAFKA_BROKER',
            hostName: 'h1'
          }
        ],
        slaveComponentHosts: [
          {
            componentName: 'DATANODE',
            hosts: [
              {
                hostName: 'h0'
              },
              {
                hostName: 'h1'
              }
            ]
          },
          {
            componentName: 'TASKTRACKER',
            hosts: [
              {
                hostName: 'h0'
              },
              {
                hostName: 'h1'
              }
            ]
          },
          {
            componentName: 'NODEMANAGER',
            hosts: [
              {
                hostName: 'h0'
              },
              {
                hostName: 'h1'
              },
              {
                hostName: 'h4'
              }
            ]
          },
          {
            componentName: 'HBASE_REGIONSERVER',
            hosts: [
              {
                hostName: 'h0'
              },
              {
                hostName: 'h1'
              }
            ]
          },
          {
            componentName: 'SUPERVISOR',
            hosts: [
              {
                hostName: 'h0'
              },
              {
                hostName: 'h1'
              }
            ]
          }
        ],
        hosts: {
          h0: {
            disk_info: [
              {
                mountpoint: '/'
              },
              {
                mountpoint: '/home'
              },
              {
                mountpoint: '/boot'
              },
              {
                mountpoint: '/boot/efi'
              },
              {
                mountpoint: '/mnt'
              },
              {
                mountpoint: '/mnt/efi'
              },
              {
                mountpoint: '/media/disk0',
                available: '100000000'
              },
              {
                mountpoint: '/mount0',
                available: '100000000'
              }
            ]
          },
          h4: {
            disk_info: [
              {
                mountpoint: 'c:',
                available: '100000000'
              }
            ]
          }
        }
      },
      cases = [
        {
          name: 'dfs.namenode.name.dir',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n'
        },
        {
          name: 'dfs.name.dir',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n'
        },
        {
          name: 'fs.checkpoint.dir',
          isOnlyFirstOneNeeded: true,
          value: 'file:///c:/default\n'
        },
        {
          name: 'dfs.namenode.checkpoint.dir',
          isOnlyFirstOneNeeded: true,
          value: 'file:///c:/default\n'
        },
        {
          name: 'dfs.data.dir',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n/media/disk1/default\n/mount1/default\n'
        },
        {
          name: 'dfs.datanode.data.dir',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n/media/disk1/default\n/mount1/default\n'
        },
        {
          name: 'mapred.local.dir',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n/media/disk1/default\n/mount1/default\n'
        },
        {
          name: 'yarn.nodemanager.log-dirs',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n/media/disk1/default\n/mount1/default\nc:\\default\n'
        },
        {
          name: 'yarn.nodemanager.local-dirs',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n/media/disk1/default\n/mount1/default\nc:\\default\n'
        },
        {
          name: 'yarn.timeline-service.leveldb-timeline-store.path',
          isOnlyFirstOneNeeded: true,
          value: '/media/disk0/default'
        },
        {
          name: 'yarn.timeline-service.leveldb-state-store.path',
          isOnlyFirstOneNeeded: true,
          value: '/media/disk0/default'
        },
        {
          name: 'dataDir',
          isOnlyFirstOneNeeded: true,
          value: '/media/disk0/default'
        },
        {
          name: 'oozie_data_dir',
          isOnlyFirstOneNeeded: true,
          value: '/media/disk0/default'
        },
        {
          name: 'storm.local.dir',
          isOnlyFirstOneNeeded: true,
          value: '/media/disk0/default'
        },
        {
          name: '*.falcon.graph.storage.directory',
          isOnlyFirstOneNeeded: true,
          value: '/default'
        },
        {
          name: '*.falcon.graph.serialize.path',
          isOnlyFirstOneNeeded: true,
          value: '/default'
        },
        {
          name: 'log.dirs',
          isOnlyFirstOneNeeded: false,
          value: '/media/disk0/default\n/mount0/default\n/media/disk1/default\n/mount1/default\n'
        }
      ];

    beforeEach(function () {
      sinon.stub(App.Host, 'find').returns([
        Em.Object.create({
          id: 'h1',
          diskInfo: [
            {
              mountpoint: '/media/disk1',
              type: 'devtmpfs'
            },
            {
              mountpoint: '/media/disk1',
              type: 'tmpfs'
            },
            {
              mountpoint: '/media/disk1',
              type: 'vboxsf'
            },
            {
              mountpoint: '/media/disk1',
              type: 'CDFS'
            },
            {
              mountpoint: '/media/disk1',
              available: '0'
            },
            {
              mountpoint: '/media/disk1',
              available: '100000000'
            },
            {
              mountpoint: '/mount1',
              available: '100000000'
            }
          ]
        }),
        Em.Object.create({
          id: 'h2',
          diskInfo: [
            {
              mountpoint: '/'
            }
          ]
        }),
        Em.Object.create({
          id: 'h3',
          diskInfo: []
        })
      ]);
    });

    afterEach(function () {
      App.Host.find.restore();
    });

    cases.forEach(function (item) {
      it(item.name, function () {
        serviceConfigProperty.setProperties({
          name: item.name,
          recommendedValue: '/default'
        });
        configPropertyHelper.unionAllMountPoints(serviceConfigProperty, item.isOnlyFirstOneNeeded, localDB);
        expect(serviceConfigProperty.get('value')).to.equal(item.value);
        expect(serviceConfigProperty.get('recommendedValue')).to.equal(item.value);
      });
    });

  });
});
});

;require.register("test/utils/configs/database_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var dbUtils = require('utils/configs/database');

describe('Database Utils', function() {
  describe('#getDBLocationFromJDBC', function() {
    [
      {
        jdbcUrl: 'jdbc:mysql://localhost/somedb',
        e: 'localhost'
      },
      {
        jdbcUrl: 'jdbc:postgresql://some.hostname.com:5432/somedb',
        e: 'some.hostname.com'
      },
      {
        jdbcUrl: 'jdbc:derby:/some/dir/another_dir/somedb',
        e: '/some/dir/another_dir'
      },
      {
        jdbcUrl: 'jdbc:derby:${oozie-env/data-dir}/${oozie-env/database_name}-db',
        e: '${oozie-env/data-dir}'
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1;databaseName=some-db;integratedSecurity=true',
        e: '127.0.0.1'
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1:3030;databaseName=some-db;integratedSecurity=true',
        e: '127.0.0.1'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//localhost.com:1521/someDb',
        e: 'localhost.com'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@ec2-52-5-27-33.compute-1.amazonaws.com:1521:ORCL',
        e: 'ec2-52-5-27-33.compute-1.amazonaws.com'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@ec2-52-5-27-33.compute-1.amazonaws.com:3301:ORCL',
        e: 'ec2-52-5-27-33.compute-1.amazonaws.com'
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//{0}:1521/{1}',
        e: ""
      },
      {
        jdbcUrl: 'jdbc:oracl:thin:@//some.com:1521/some-db',
        e: ""
      }
    ].forEach(function(test) {
      it('when jdbc url is ' + test.jdbcUrl + ' host name is ' + test.e, function() {
        expect(dbUtils.getDBLocationFromJDBC(test.jdbcUrl)).to.eql(test.e);
      });
    });
  });

  describe('#parseJdbcUrl', function() {
    [
      {
        jdbcUrl: 'jdbc:mysql://localhost/somedb',
        e: {
          dbType: 'mysql',
          location: 'localhost'
        }
      },
      {
        jdbcUrl: 'jdbc:postgresql://some.hostname.com:5432/somedb',
        e: {
          dbType: 'postgres',
          location: 'some.hostname.com'
        }
      },
      {
        jdbcUrl: 'jdbc:postgresql://some.hostname.com:1111/somedb',
        e: {
          dbType: 'postgres',
          location: 'some.hostname.com'
        }
      },
      {
        jdbcUrl: 'jdbc:derby:/some/dir/another_dir/somedb',
        e: {
          dbType: 'derby',
          location: '/some/dir/another_dir'
        }
      },
      {
        jdbcUrl: 'jdbc:derby:${oozie-env/data-dir}/${oozie-env/database_name}-db',
        e: {
          dbType: 'derby',
          location: '${oozie-env/data-dir}'
        }
      },
      {
        jdbcUrl: 'jdbc:derby:${oozie.data.dir}/${oozie.db.schema.name}-db;create=true',
        e: {
          dbType: 'derby',
          location: '${oozie.data.dir}'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1;databaseName=some-db;integratedSecurity=true',
        e: {
          dbType: 'mssql',
          location: '127.0.0.1'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlserver://127.0.0.1:3011;databaseName=some-db;integratedSecurity=true',
        e: {
          dbType: 'mssql',
          location: '127.0.0.1'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//localhost.com:1521/someDb',
        e: {
          dbType: 'oracle',
          location: 'localhost.com'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@localhost.com:1521:someDb',
        e: {
          dbType: 'oracle',
          location: 'localhost.com'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//{0}:1521/{1}',
        e: {
          dbType: 'oracle',
          location: ""
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@//localhost:3301/somedb',
        e: {
          dbType: 'oracle',
          location: 'localhost'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:@localhost:3302/somedb',
        e: {
          dbType: 'oracle',
          location: 'localhost'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:host=some.com;database=somedb',
        e: {
          dbType: 'sqla',
          location: 'some.com'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:host=some.com:333;database=somedb',
        e: {
          dbType: 'sqla',
          location: 'some.com'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:database=somedb;host=some.com:333',
        e: {
          dbType: 'sqla',
          location: 'some.com'
        }
      },
      {
        jdbcUrl: 'jdbc:sqlanywhere:database=somedb;host=some2.com:333;someadditional=some_param',
        e: {
          dbType: 'sqla',
          location: 'some2.com'
        }
      },
      {
        jdbcUrl: 'jdbc:oracle:thin:scott/tiger@myhost:1521:orcl',
        e: {
          dbType: 'oracle',
          location: 'myhost'
        }
      },
      {
        jdbcUrl: 'jdbc:custom:custom/@@@',
        e: {
          dbType: null,
          location: ''
        }
      }
    ].forEach(function(test) {
      it('when jdbc url is ' + test.jdbcUrl + ' result is ' + JSON.stringify(test.e), function() {
        expect(dbUtils.parseJdbcUrl(test.jdbcUrl)).to.be.deep.eql(test.e);
      });
    });
  });
});

});

;require.register("test/utils/configs/modification_handlers/misc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements. See the NOTICE file distributed with this
 * work for additional information regarding copyright ownership. The ASF
 * licenses this file to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 * http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS, WITHOUT
 * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the
 * License for the specific language governing permissions and limitations under
 * the License.
 */


require('utils/configs/modification_handlers/modification_handler');

var App = require('app');

describe('#App.ServiceConfigModificationHandler MISC', function() {
  var genStepConfig = function(serviceName, properties) {
    return Em.Object.create({
      serviceName: serviceName,
      configs: properties
    });
  };
  var genProperty = function(propName, value, initialValue, filename) {
    return Em.Object.create({
      name: propName,
      value: value,
      initialValue: initialValue,
      filename: filename
    });
  };
  var genProperties = function(properties) {
    return properties.map(function(item) {
      return genProperty.apply(undefined, item);
    });
  };
  var handler = require('utils/configs/modification_handlers/misc');

  describe('#getDependentConfigChanges', function() {

    describe('YARN dependent configs', function() {
      var tests = [
        {
          miscHandlerParams: {
            changedConfig: genProperty('yarn_user', 'new-user', 'initial-user', 'yarn-env.xml'),
            selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'ZOOKEEPER'],
            allConfigs: [
              genStepConfig('YARN', genProperties([
                ['yarn.admin.acl', 'some-user2 some-group2', '', 'yarn-site.xml']
              ])),
              genStepConfig('MISC', genProperties([
                ['user_group', 'some-group', 'initial-group', 'cluster-env.xml'],
                ['yarn_user', 'new-user', 'initial-user', 'yarn-env.xml']
              ]))
            ]
          },
          m: 'yarn_user changed, yarn.admin.acl new user name should be appended to users joined joined comma',
          e: { propertyName: 'yarn.admin.acl', curValue: 'some-user2 some-group2', newValue: 'some-user2,new-user some-group2'}
        },
        {
          miscHandlerParams: {
            changedConfig: genProperty('yarn_user', 'new-user', 'initial-user', 'yarn-env.xml'),
            selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'ZOOKEEPER'],
            allConfigs: [
              genStepConfig('YARN', genProperties([
                ['yarn.admin.acl', 'initial-user some-group2', '', 'yarn-site.xml']
              ])),
              genStepConfig('MISC', genProperties([
                ['user_group', 'some-group', 'initial-group', 'cluster-env.xml'],
                ['yarn_user', 'some-user', 'initial-user', 'yarn-env.xml']
              ]))
            ]
          },
          m: 'yarn_user changed, yarn.admin.acl initial user name should be update with new one',
          e: { propertyName: 'yarn.admin.acl', curValue: 'initial-user some-group2', newValue: 'new-user some-group2'}
        },
        {
          miscHandlerParams: {
            changedConfig: genProperty('yarn_user', 'new-user', 'initial-user', 'yarn-env.xml'),
            selectedServices: ['HDFS', 'YARN', 'MAPREDUCE2', 'ZOOKEEPER'],
            allConfigs: [
              genStepConfig('YARN', genProperties([
                ['yarn.admin.acl', '', '', 'yarn-site.xml']
              ])),
              genStepConfig('MISC', genProperties([
                ['user_group', 'some-group', 'initial-group', 'cluster-env.xml'],
                ['yarn_user', 'new-user', 'initial-user', 'yarn-env.xml']
              ]))
            ]
          },
          m: 'yarn_user changed, yarn.admin.acl initial value is not in valid format its value should be set with yarn_user and user_group',
          e: { propertyName: 'yarn.admin.acl', curValue: '', newValue: 'new-user'}
        }
      ];

      tests.forEach(function(test) {
        it(test.m, function() {
          var handlerParams = test.miscHandlerParams;
          var result = handler.getDependentConfigChanges(handlerParams.changedConfig, handlerParams.selectedServices, handlerParams.allConfigs, false).toArray();
          // check the key => value according test.e from result
          expect(App.permit(result.findProperty('propertyName', test.e.propertyName), Em.keys(test.e))).to.eql(test.e);
        });
      });
    });
  });
});

});

;require.register("test/utils/configs/modification_handlers/modification_handler_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/configs/modification_handlers/modification_handler');

describe('App.ServiceConfigModificationHandler', function () {

  var handler = App.ServiceConfigModificationHandler.create();

  describe('#getConfig', function () {

    var allConfigs = [
        Em.Object.create({
          serviceName: 's',
          configs: [
            Em.Object.create({
              name: 'c1',
              filename: 'f1'
            })
          ]
        })
      ],
      cases = [
        {
          configName: 'c0',
          result: undefined,
          title: 'property isn\'t defined'
        },
        {
          configName: 'c1',
          result: Em.Object.create({
            name: 'c1',
            filename: 'f1'
          }),
          title: 'property is defined, filename isn\'t passed'
        },
        {
          configName: 'c1',
          configFilename: 'f1',
          result: Em.Object.create({
            name: 'c1',
            filename: 'f1'
          }),
          title: 'property is defined, filename is passed'
        },
        {
          configName: 'c1',
          configFilename: 'f2',
          result: undefined,
          title: 'property is defined, filenames don\'t match'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(handler.getConfig(allConfigs, item.configName, item.configFilename, 's')).to.eql(item.result);
      });
    });

  });

});

});

;require.register("test/utils/data_manipulation_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var data_manipulation = require('utils/data_manipulation');

describe('data_manipulation', function () {

  describe('#rejectPropertyValues', function () {

    it('Basic test', function () {
      var collection = [
          {n: 'v1'},
          {n: 'v2'},
          {n: 'v3'},
          {n: 'v4'}
        ],
        key = 'n',
        valuesToReject = ['v2', 'v3'];
      var result = data_manipulation.rejectPropertyValues(collection, key, valuesToReject);
      expect(result).to.eql([
        {n: 'v1'},
        {n: 'v4'}
      ]);
    });

  });

  describe('#filterPropertyValues', function () {

    it('Basic test', function () {
      var collection = [
          {n: 'v1'},
          {n: 'v2'},
          {n: 'v3'},
          {n: 'v4'}
        ],
        key = 'n',
        valuesToFilter = ['v2', 'v3'];
      var result = data_manipulation.filterPropertyValues(collection, key, valuesToFilter);
      expect(result).to.eql([
        {n: 'v2'},
        {n: 'v3'}
      ]);
    });

  });

  describe('#groupPropertyValues', function () {

    it('Basic test', function () {
      var collection = [
          {n: 'v1'},
          {n: 'v2'},
          {n: 'v2'},
          {n: 'v4'}
        ],
        key = 'n';
      var result = data_manipulation.groupPropertyValues(collection, key);
      expect(JSON.stringify(result)).to.equal(JSON.stringify({
        v1: [
          {n: 'v1'}
        ],
        v2: [
          {n: 'v2'},
          {n: 'v2'}
        ],
        v4: [
          {n: 'v4'}
        ]}));
    });

  });

});
});

;require.register("test/utils/date/date_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

var validator = require('utils/validator');
var date = require('utils/date/date');

describe('date', function () {

  var correct_tests = Em.A([
    {t: 1349752195000, e: 'Tue, Oct 09, 2012 03:09', e2: 'Tue Oct 09 2012'},
    {t: 1367752195000, e: 'Sun, May 05, 2013 11:09', e2: 'Sun May 05 2013'},
    {t: 1369952195000, e: 'Thu, May 30, 2013 22:16', e2: 'Thu May 30 2013'}
  ]);

  var incorrect_tests = Em.A([
    {t: null},
    {t: ''},
    {t: false},
    {t: []},
    {t: {}},
    {t: undefined},
    {t: function(){}}
  ]);

  describe('#dateFormatZeroFirst()', function() {
    var tests = [
      {
        t: 2,
        e: '02',
        m: 'should convert to `02`'
      },
      {
        t: 10,
        e: '10',
        m: 'should convert to `10`'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(date.dateFormatZeroFirst(test.t)).to.eql(test.e);
      });
    });
  });

  describe('#startTime()', function() {
    var today = new Date();
    var testDate = new Date(1349752195000);
    var tests = [
      { t: 1349752195000, e: testDate.toDateString() + ' {0}:{1}'.format(date.dateFormatZeroFirst(testDate.getHours()), date.dateFormatZeroFirst(testDate.getMinutes())) },
      { t: -10000000, e: 'Not started' },
      { t: today.getTime(), e: 'Today {0}:{1}'.format(date.dateFormatZeroFirst(today.getHours()), date.dateFormatZeroFirst(today.getMinutes())) },
      { t: today, e: ''}
    ];
    tests.forEach(function(test) {
      var testMessage = 'should convert {0} to {1}'.format(test.t, test.e);
      it(testMessage, function() {
        expect(date.startTime(test.t)).to.be.eql(test.e);
      });
    });
  });

  describe('#timingFormat', function() {
    var tests = Em.A([
      {i: '30', e:'30 ms'},
      {i: '300', e:'300 ms'},
      {i: '999', e:'999 ms'},
      {i: '1000', e:'1.00 secs'},
      {i: '3000', e:'3.00 secs'},
      {i: '35000', e:'35.00 secs'},
      {i: '350000', e:'350.00 secs'},
      {i: '999999', e:'1000.00 secs'},
      {i: '1000000', e:'16.67 mins'},
      {i: '3500000', e:'58.33 mins'},
      {i: '35000000', e:'9.72 hours'},
      {i: '350000000', e:'4.05 days'},
      {i: '3500000000', e:'40.51 days'},
      {i: '35000000000', e:'405.09 days'}
    ]);

    describe('Correct data', function(){
      tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.timingFormat(test.i)).to.equal(test.e);
        });
      });
    });

    describe('Incorrect data', function(){
      incorrect_tests.forEach(function(test) {
        it(test.t, function() {
          expect(date.timingFormat(test.t)).to.equal(null);
        });
      });
    });

  });

  describe('#duration', function() {
    var tests = Em.A([
      {startTime: 1, endTime: 2, e: 1},
      {startTime: 0, endTime: 2000, e: 0},
      {startTime: 200, endTime: 0, e: 19800}
    ]);

    beforeEach(function() {
      sinon.stub(App, 'dateTime', function () { return 20000; });
    });

    tests.forEach(function(test) {
      it(test.startTime + ' ' + test.endTime, function() {
        expect(date.duration(test.startTime, test.endTime)).to.equal(test.e);
      });
    });

    afterEach(function() {
      App.dateTime.restore();
    });
  });

  describe('#durationSummary()', function() {
    var tests = [
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1349752199000,
        e: '4.00 secs'
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: 1367752195000,
        e: '208.33 days'
      },
      {
        startTimestamp: -10000000,
        endTimestamp: 1367752195000,
        e: Em.I18n.t('common.na')
      },
      {
        startTimestamp: 1349752195000,
        endTimestamp: -1,
        stubbed: true,
        e: '0 secs'
      },
      {
        startTimestamp: 100000000,
        endTimestamp: -1,
        stubbed: true,
        e: '19.00 secs'
      }
    ];

    beforeEach(function() {
      sinon.stub(App, 'dateTimeWithTimeZone', function () { return 100019000; });
    });

    tests.forEach(function(test) {
      var testMessage = 'duration between {0} and {1} is {2}'.format(test.startTimestamp, test.endTimestamp, test.e) + (test.stubbed ? " App.dateTime() is stubbed" : "");
      it(testMessage, function() {
        expect(date.durationSummary(test.startTimestamp, test.endTimestamp)).to.be.eql(test.e);
      });
    });

    afterEach(function() {
      App.dateTimeWithTimeZone.restore();
    });
  });

});
});

;require.register("test/utils/date/timezone_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var timezoneUtils = require('utils/date/timezone');

describe('timezoneUtils', function () {

  describe('#_groupTimezones', function () {

    var formattedTimezones = [
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'a/Aa', region: 'a', city: 'Aa'},
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'a/Bb', region: 'a', city: 'Bb'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'a/Cc', region: 'a', city: 'Cc'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'a/Dd', region: 'a', city: 'Dd'},
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'b/Ee', region: 'b', city: 'Ee'},
      {utcOffset: 1, groupByKey: '1', formattedOffset: '+01:00', value: 'b/Ff', region: 'b', city: 'Ff'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b/Gg', region: 'b', city: 'Gg'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b/Hh', region: 'b', city: 'Hh'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b/II', region: 'b', city: 'II'},
      {utcOffset: 2, groupByKey: '2', formattedOffset: '+02:00', value: 'b', region: 'b', city: ''}
    ];

    before(function () {
      this.result = timezoneUtils._groupTimezones(formattedTimezones);
    });

    it('should group to 4 groups', function () {
      expect(this.result.length).to.equal(4);
    });

    it('UTCOffset should be [1,1,2,2]', function () {
      expect(this.result.mapProperty('utcOffset')).to.eql([1, 1, 2, 2]);
    });

    it('should map regions and cities correctly', function () {
      var expected = [
        '(UTC+01:00 UTC) a / Aa, Bb',
        '(UTC+01:00 UTC) b / Ee, Ff',
        '(UTC+02:00 UTC) a / Cc, Dd',
        '(UTC+02:00 UTC) b / Gg, Hh'
      ];
      var values = this.result.mapProperty('label');
      expect(values).to.eql(expected);
      expect(values.join('')).to.not.contain('II');
      expect(values.join('')).to.not.contain(', ,');
    });

  });

  describe('#_parseTimezones', function () {

    beforeEach(function () {
      sinon.stub(timezoneUtils, 'getAllTimezoneNames').returns([
        'Europe/Helsinki',
        'Asia/Magadan',
        'America/Lima'
      ]);
      sinon.stub(timezoneUtils, '_groupTimezones', function (list) {
        return list;
      });
      this.result = timezoneUtils._parseTimezones();
    });

    afterEach(function () {
      timezoneUtils.getAllTimezoneNames.restore();
      timezoneUtils._groupTimezones.restore();
    });

    it('should sort by offset and name', function () {
      expect(this.result.mapProperty('value')).to.eql(['America/Lima', 'Europe/Helsinki', 'Asia/Magadan']);
    });

    it('should split regions and cities', function () {
      expect(this.result.mapProperty('region')).to.eql(['America', 'Europe', 'Asia']);
      expect(this.result.mapProperty('city')).to.eql(['Lima', 'Helsinki', 'Magadan']);
    });

  });

  describe('#getAllTimezoneNames', function () {

    before(function () {
      this.result = timezoneUtils.getAllTimezoneNames();
    });

    after(function () {
      this.result = undefined;
    });

    it('timezone names are parsed', function () {
      expect(this.result).to.have.length.above(0);
    });

    it('Etc/* are excluded', function () {
      this.result.forEach(function (tz) {
        expect(tz.indexOf('Etc/')).to.equal(-1);
      });
    });

    it('Abbreviations are excluded', function () {
      this.result.forEach(function (tz) {
        expect(tz).to.not.equal(tz.toUpperCase());
      });
    });

  });

  describe('#detectUserTimezone', function () {

    var getTimezoneOffset = Date.prototype.getTimezoneOffset;

    function mockTimezoneOffset(jan, jul) {
      Date.prototype.getTimezoneOffset = function () {
        var month = this.getMonth();
        if (month > 3 && month < 9) {
          return -jul;
        }
        return -jan;
      };
    }

    afterEach(function () {
      Date.prototype.getTimezoneOffset = getTimezoneOffset;
    });

    it('Detect UTC+1', function () {
      mockTimezoneOffset(0, 60);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('0-60|Atlantic');
    });

    it('Detect UTC+1 for Europe', function () {
      mockTimezoneOffset(0, 60);
      var tz = timezoneUtils.detectUserTimezone('Europe');
      expect(tz).to.contain('0-60|Europe');
    });

    it('Detect UTC-4', function () {
      mockTimezoneOffset(-300, -240);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('300240|America');
    });

    it('Detect UTC+3 for Asia', function () {
      mockTimezoneOffset(120, 180);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('-120-180|Asia');
    });

    it('Detect UTC-7', function () {
      mockTimezoneOffset(-480, -420);
      var tz = timezoneUtils.detectUserTimezone();
      expect(tz).to.contain('480420|America');
    });

  });

});
});

;require.register("test/utils/ember_reopen_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

require('utils/ember_reopen');

describe('Ember functionality extension', function () {

  describe('#Em.View', function () {

    var view,
      cases = [
        {
          result: {
            p0: 'v3',
            p1: 'v4',
            p2: 'v5'
          },
          title: 'active view'
        },
        {
          result: {
            p0: 'v0',
            p1: 'v1',
            p2: 'v2'
          },
          propertyToSet: 'isDestroyed',
          title: 'destroyed view'
        },
        {
          result: {
            p0: 'v0',
            p1: 'v1',
            p2: 'v2'
          },
          propertyToSet: 'isDestroying',
          title: 'view being destroyed'
        }
      ];

    beforeEach(function () {
      view = Em.View.create({
        isDestroyed: false,
        isDestroying: false,
        p0: 'v0',
        p1: 'v1',
        p2: 'v2'
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        if (item.propertyToSet) {
          view.set(item.propertyToSet, true);
        }
        view.set('p0', 'v3');
        view.setProperties({
          p1: 'v4',
          p2: 'v5'
        });
        expect(view.getProperties(['p0', 'p1', 'p2'])).to.eql(item.result);
      });
    });

  });

});

});

;require.register("test/utils/form_field_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/form');


/*
 * formField.isValid property doesn't update correctly, so I have to work with errorMessage property
 */
describe('App.FormField', function () {

  describe('#validate()', function () {
    /*NUMBER TYPE END*/
    /*REQUIRE*/
    it('Required field shouldn\'t be empty', function () {
      var formField = App.FormField.create();
      formField.set('displayType', 'string');
      formField.set('value', '');
      formField.set('isRequired', true);
      formField.validate();
      expect(formField.get('errorMessage') === '').to.equal(false);
    });
    /*REQUIRE END*/

  });
});
});

;require.register("test/utils/helper_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
var App = require('app');
require('utils/helper');

describe('utils/helper', function() {
  describe('String helpers', function() {
    describe('#trim()', function(){
      it('should replace first space', function() {
        expect(' as d f'.trim()).to.eql('as d f');
      });
    });
    describe('#endsWith()', function() {
      it('`abcd` ends with `d`', function(){
        expect('abcd'.endsWith('d')).to.eql(true);
      });
      it('`abcd` doesn\'t end with `f`', function(){
        expect('abcd'.endsWith('f')).to.eql(false);
      });
    });
    describe('#contains()', function() {
      it('`abc` contains b', function(){
        expect('abc'.contains('b')).to.eql(true);
      });
      it('`abc` doesn\'t contain d', function() {
        expect('abc'.contains('d')).to.eql(false);
      });
    });
    describe('#capitalize()',function() {
      it('`abc d` should start with `A`', function() {
        expect('abc d'.capitalize()).to.eql('Abc d');
      });
    });
    describe('#findIn()', function(){
      var obj = {
        a: {
          a1: 'AVal1'
        },
        b: 'BVal',
        c: {
          c1: {
            c2: 'Cval2'
          },
          b: 'BVal'
        }
      };
      var testValue = function(key, value) {
        it('key `' + key + '` should have `' + JSON.stringify(value) + '` value', function() {
          expect(key.findIn(obj)).to.eql(value);
        });
      };
      it('expect return `null` on non-object input', function(){
        expect('a'.findIn('b')).to.null;
      });
      testValue('a', obj.a);
      testValue('c2', obj.c.c1.c2);
      testValue('b', obj.b);
      testValue('d', null);
    });
    describe('#format()', function(){
      it('should replace string correctly', function(){
        expect("{0} world{1}".format("Hello","!")).to.eql("Hello world!");
      });
    });
    describe('#highlight()', function() {
      var str = "Hello world! I want to highlight this word!";
      it('should highlight `word` with default template', function() {
        var result = str.highlight(['word']);
        expect(result).to.eql("Hello world! I want to highlight this <b>word</b>!");
      });
      it('should highlight `world` and `word` with template `<span class="yellow">{0}</span>`', function() {
        var result = str.highlight(["world", "word"], '<span class="yellow">{0}</span>');
        expect(result).to.eql('Hello <span class="yellow">world</span>! I want to highlight this <span class="yellow">word</span>!')
      });
      var str2 = "First word, second word";
      it('should highlight `word` multiply times with default template', function() {
        var result = str2.highlight(["word"]);
        expect(result).to.eql("First <b>word</b>, second <b>word</b>");
      });
    });
  });
  describe('Number helpers', function(){
    describe('#toDaysHoursMinutes()', function(){
      var time = 1000000000;
      var minute = 1000*60;
      var hour = 60*minute;
      var day = 24*hour;
      var result = time.toDaysHoursMinutes();
      var testDays = Math.floor(time/day);
      it('should correct convert days', function(){
        expect(testDays).to.eql(result.d);
      });
      it('should correct convert hours', function(){
        expect(Math.floor((time - testDays * day)/hour)).to.eql(result.h);
      });
      it('should correct convert minutes', function(){
        expect(((time - Math.floor((time - testDays*day)/hour)*hour - testDays*day)/minute).toFixed(2)).to.eql(result.m);
      });
    });
  });
  describe('Array helpers', function(){
    describe('#sortPropertyLight()', function(){
      var testable = [
        { a: 2 },
        { a: 1 },
        { a: 6},
        { a: 64},
        { a: 3},
        { a: 3}
      ];
      var result = testable.sortPropertyLight('a');
      it('should return array with same length', function(){
        expect(testable.length).to.eql(result.length);
      });
      it('should sort array', function() {
        result.forEach(function(resultObj, index, resultArr) {
          if (index > resultArr.length - 1)
            expect(resultObj.a < resultArr[index + 1].a).to.eql(false);
        });
      });
      it('should try to sort without throwing exception', function(){
        expect(testable.sortPropertyLight(['a'])).to.ok;
      });
    });
  });
  describe('App helpers', function(){
    var appendDiv = function() {
      $('body').append('<div id="tooltip-test"></div>');
    };
    var removeDiv = function() {
      $('body').remove('#tooltip-test');
    };
    describe('#isEmptyObject', function(){
      it('should return true on empty object', function() {
        expect(App.isEmptyObject({})).to.eql(true);
      });
      it('should return false on non-empty object', function() {
        expect(App.isEmptyObject({ a: 1 })).to.eql(false);
      });
    });
    describe('#parseJSON()', function(){
      var testable = '{"hello": "world"}';
      expect(App.parseJSON(testable).hello).to.eql('world');
    });
    describe('#tooltip()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add tooltip', function() {
        var tooltip = App.tooltip($('#tooltip-test'));
        expect($('#tooltip-test').data('tooltip').enabled).to.eql(true);
      });
    });
    describe('#popover()', function() {
      beforeEach(appendDiv);
      afterEach(removeDiv);
      it('should add popover', function() {
        var tooltip = App.popover($('#tooltip-test'));
        expect($('#tooltip-test').data('popover').enabled).to.eql(true);
      });
    });
    describe('#App.format', function(){
      describe('#commandDetail()', function() {
        var command = "GANGLIA_MONITOR STOP";
        var ignored = "DECOMMISSION, NAMENODE";
        var removeString = "SERVICE/HDFS STOP";
        var nagiosState = "nagios_update_ignore ACTIONEXECUTE";
        var installRepo = "install_packages ACTIONEXECUTE";
        it('should convert command to readable info', function() {
          expect(App.format.commandDetail(command)).to.eql(' Ganglia Monitor Stop');
        });
        it('should ignore decommission command', function(){
          expect(App.format.commandDetail(ignored)).to.eql('  NameNode');
        });
        it('should remove SERVICE string from command', function(){
          expect(App.format.commandDetail(removeString)).to.eql(' HDFS Stop');
        });
        it('should return maintenance message', function() {
          expect(App.format.commandDetail(nagiosState)).to.eql(' Toggle Maintenance Mode');
        });
        it('should return install repo message', function() {
          expect(App.format.commandDetail(installRepo)).to.eql(Em.I18n.t('common.installRepo.task'));
        });
      });
      describe('#taskStatus()', function(){
        var testable = [
          { status: 'PENDING', expectable: 'pending'},
          { status: 'QUEUED', expectable: 'queued'},
          { status: 'COMPLETED', expectable: 'completed'}
        ];
        testable.forEach(function(testObj){
          it('should convert `' + testObj.status + '` to `' + testObj.expectable + '`', function(){
            expect(App.format.taskStatus(testObj.status)).to.eql(testObj.expectable);
          });
        });
      });
      describe('#normalizeName()', function() {
        var testMessage = '`{0}` should be converted to `{1}`';
        var tests = {
          'APP_TIMELINE_SERVER': 'App Timeline Server',
          'DATANODE': 'DataNode',
          'DECOMMISSION_DATANODE': 'Update Exclude File',
          'DRPC_SERVER': 'DRPC Server',
          'FALCON': 'Falcon',
          'FALCON_CLIENT': 'Falcon Client',
          'FALCON_SERVER': 'Falcon Server',
          'FALCON_SERVICE_CHECK': 'Falcon Service Check',
          'FLUME_HANDLER': 'Flume',
          'FLUME_SERVICE_CHECK': 'Flume Service Check',
          'GANGLIA_MONITOR': 'Ganglia Monitor',
          'GANGLIA_SERVER': 'Ganglia Server',
          'GLUSTERFS_CLIENT': 'GLUSTERFS Client',
          'GLUSTERFS_SERVICE_CHECK': 'GLUSTERFS Service Check',
          'GMETAD_SERVICE_CHECK': 'Gmetad Service Check',
          'GMOND_SERVICE_CHECK': 'Gmond Service Check',
          'HADOOP_CLIENT': 'Hadoop Client',
          'HBASE_CLIENT': 'HBase Client',
          'HBASE_MASTER': 'HBase Master',
          'HBASE_REGIONSERVER': 'RegionServer',
          'HBASE_SERVICE_CHECK': 'HBase Service Check',
          'HCAT': 'HCat Client',
          'HDFS': 'HDFS',
          'HDFS_CLIENT': 'HDFS Client',
          'HDFS_SERVICE_CHECK': 'HDFS Service Check',
          'HISTORYSERVER': 'History Server',
          'HIVE_CLIENT': 'Hive Client',
          'HIVE_METASTORE': 'Hive Metastore',
          'HIVE_SERVER': 'HiveServer2',
          'HIVE_SERVICE_CHECK': 'Hive Service Check',
          'HUE_SERVER': 'Hue Server',
          'JAVA_JCE': 'Java JCE',
          'JOBTRACKER': 'JobTracker',
          'JOBTRACKER_SERVICE_CHECK': 'JobTracker Service Check',
          'JOURNALNODE': 'JournalNode',
          'KERBEROS_ADMIN_CLIENT': 'Kerberos Admin Client',
          'KERBEROS_CLIENT': 'Kerberos Client',
          'KERBEROS_SERVER': 'Kerberos Server',
          'MAPREDUCE2_CLIENT': 'MapReduce2 Client',
          'MAPREDUCE2_SERVICE_CHECK': 'MapReduce2 Service Check',
          'MYSQL_SERVER': 'MySQL Server',
          'NAMENODE': 'NameNode',
          'NAMENODE_SERVICE_CHECK': 'NameNode Service Check',
          'NIMBUS': 'Nimbus',
          'NODEMANAGER': 'NodeManager',
          'OOZIE_CLIENT': 'Oozie Client',
          'OOZIE_SERVER': 'Oozie Server',
          'OOZIE_SERVICE_CHECK': 'Oozie Service Check',
          'PIG': 'Pig',
          'PIG_SERVICE_CHECK': 'Pig Service Check',
          'RESOURCEMANAGER': 'ResourceManager',
          'SECONDARY_NAMENODE': 'SNameNode',
          'SQOOP': 'Sqoop',
          'SQOOP_SERVICE_CHECK': 'Sqoop Service Check',
          'STORM_REST_API': 'Storm REST API Server',
          'STORM_SERVICE_CHECK': 'Storm Service Check',
          'STORM_UI_SERVER': 'Storm UI Server',
          'SUPERVISOR': 'Supervisor',
          'TASKTRACKER': 'TaskTracker',
          'TEZ_CLIENT': 'Tez Client',
          'WEBHCAT_SERVER': 'WebHCat Server',
          'YARN_CLIENT': 'YARN Client',
          'YARN_SERVICE_CHECK': 'YARN Service Check',
          'ZKFC': 'ZKFailoverController',
          'ZOOKEEPER_CLIENT': 'ZooKeeper Client',
          'ZOOKEEPER_QUORUM_SERVICE_CHECK': 'ZK Quorum Service Check',
          'ZOOKEEPER_SERVER': 'ZooKeeper Server',
          'ZOOKEEPER_SERVICE_CHECK': 'ZooKeeper Service Check',
          'CLIENT': 'Client'
        };
        for (var inputName in tests) {
          (function(name) {
            it(testMessage.format(name, tests[name]), function() {
              expect(App.format.normalizeName(name)).to.eql(tests[name]);
            });
          })(inputName)
        }
      });
      describe('#kdcErrorMsg()', function() {
        var tests = [
          {
            r: "1 Missing KDC administrator credentials. and some text",
            f: "Missing KDC administrator credentials."
          },
          {
            r: "2 Invalid KDC administrator credentials. and some text",
            f: "Invalid KDC administrator credentials."
          },
          {
            r: "3 Failed to find a KDC for the specified realm - kadmin and some text",
            f: "Failed to find a KDC for the specified realm - kadmin"
          },
          {
            r: "4 some text",
            f: null,
            s: true
          },
          {
            r: "4 some text",
            f: "4 some text",
            s: false
          }
        ];

        tests.forEach(function(t) {
          it("kdcErrorMsg for " + t.f + " with strict " + t.s, function() {
            expect(App.format.kdcErrorMsg(t.r, t.s)).to.be.equal(t.f);
          })
        });

      });

      describe("#role()", function() {
        beforeEach(function () {
          sinon.stub(App.StackService, 'find').returns([Em.Object.create({
            id: 'S1',
            displayName: 's1'
          })]);
          sinon.stub(App.StackServiceComponent, 'find').returns([Em.Object.create({
            id: 'C1',
            displayName: 'c1'
          })])
        });
        afterEach(function () {
          App.StackService.find.restore();
          App.StackServiceComponent.find.restore();
        });
        it("", function() {
          App.format.stackServiceRolesMap = {};
          App.format.stackComponentRolesMap = {};
          expect(App.format.role('S1', true)).to.equal('s1');
          expect(App.format.role('C1', false)).to.equal('c1');
          expect(App.format.stackServiceRolesMap).to.not.be.empty;
          expect(App.format.stackComponentRolesMap).to.not.be.empty;
        });
      });
    });
  });
  describe('#App.permit()', function() {
    var obj = {
      a1: 'v1',
      a2: 'v2',
      a3: 'v3'
    };

    var tests = [
      {
        keys: 'a1',
        e: {
          a1: 'v1'
        }
      },
      {
        keys: ['a2','a3','a4'],
        e: {
          a2: 'v2',
          a3: 'v3'
        }
      }
    ];

    tests.forEach(function(test) {
      it('should return object `{0}` permitted keys `{1}`'.format(JSON.stringify(test.e), JSON.stringify(test.keys)), function() {
        expect(App.permit(obj, test.keys)).to.deep.eql(test.e);
      });
    });
  });

  describe('#App.keysUnderscoreToCamelCase()', function() {
    var tests = [
      {
        object: {
          'key_upper': '2'
        },
        expected: {
          keyUpper: '2'
        },
        m: 'One level object, key should be camelCased'
      },
      {
        object: {
          'key_upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key_upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key_upper': '2',
          'key_upone_uptwo_upthree': '4',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          keyUponeUptwoUpthree: '4',
          key: '1'
        },
        m: 'One level object, two keys should be camelCased, few dots notation.'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.keysUnderscoreToCamelCase(test.object)).to.deep.equal(test.expected);
      });
    });
  });

  describe('#App.keysDottedToCamelCase()', function() {
    var tests = [
      {
        object: {
          'key.upper': '2'
        },
        expected: {
          keyUpper: '2'
        },
        m: 'One level object, key should be camelCased'
      },
      {
        object: {
          'key.upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key.upper': '2',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          key: '1'
        },
        m: 'One level object, one key should be camelCased.'
      },
      {
        object: {
          'key.upper': '2',
          'key.upone.uptwo.upthree': '4',
          'key': '1'
        },
        expected: {
          keyUpper: '2',
          keyUponeUptwoUpthree: '4',
          key: '1'
        },
        m: 'One level object, two keys should be camelCased, few dots notation.'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(App.keysDottedToCamelCase(test.object)).to.deep.equal(test.expected);
      });
    });
  });

  describe('#App.formatDateTimeWithTimeZone()', function () {

    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('userSettingsController.userSettings.timezone').returns({
        zones: [{
          value: 'Europe/Amsterdam'
        }]
      });
    });

    afterEach(function () {
      App.router.get.restore();
    });

    it('should format date according to customized timezone', function () {
      expect(App.formatDateTimeWithTimeZone(1000000, 'YYYY-MM-DD HH:mm:ss (hh:mm A)')).to.equal('1970-01-01 01:16:40 (01:16 AM)');
    });

  });

});

});

;require.register("test/utils/host_progress_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var Ember = require('ember');
var App = require('app');

require('controllers/global/background_operations_controller');
require('views/common/modal_popup');
require('utils/helper');
require('utils/host_progress_popup');

describe('App.HostPopup', function () {

  var services = [
    {
      displayName: "Start service WebHCat",
      hosts: [
        {
          logTasks: [
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-12-123-90.ec2.internal",
                role: "WEBHCAT_SERVER",
                status: "QUEUED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/23/tasks/94"
            }
          ],
          name: "ip-10-12-123-90.ec2.internal",
          publicName: "ip-10-12-123-90.ec2.internal",
          serviceName: "Start service WebHCat"
        }
      ],
      isRunning: false
    },
    {
      displayName: "Start service Hive/HCat",
      hosts: [
        {
          logTasks: [
            {
              Tasks: {
                command: "INSTALL",
                host_name: "ip-10-12-123-90.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/76"
            }
          ],
          name: "ip-10-12-123-90.ec2.internal",
          publicName: "ip-10-12-123-90.ec2.internal",
          serviceName: "Start service Hive/HCat"
        },
        {
          logTasks: [
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-33-7-23.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/78"
            },
            {
              Tasks: {
                command: "START",
                host_name: "ip-10-33-7-23.ec2.internal",
                status: "COMPLETED"
              },
              href: "http://ec2-54-224-233-43.compute-1.amazonaws.com:8080/api/v1/clusters/mycluster/requests/15/tasks/79"
            }
          ],
          name: "ip-10-33-7-23.ec2.internal",
          publicName: "ip-10-33-7-23.ec2.internal",
          serviceName: "Start service Hive/HCat"
        }
      ],
      isRunning: false
    }
  ];

  var test_tasks = [
    {
      t: [
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'All COMPLETED',
      r: 'SUCCESS',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'FAILED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
        ,
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'One FAILED',
      r: 'FAILED',
      p: 100,
      ids: [1,2,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'ABORTED',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One ABORTED',
      r: 'ABORTED',
      p: 100,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'TIMEDOUT',
            id: 3
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 1
          }
        }
      ],
      m: 'One TIMEDOUT',
      r: 'TIMEDOUT',
      p: 100,
      ids: [1,3]
    },
    {
      t: [
        {
          Tasks: {
            status: 'IN_PROGRESS',
            id: 1
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 2
          }
        }
      ],
      m: 'One IN_PROGRESS',
      r: 'IN_PROGRESS',
      p: 68,
      ids: [1,2]
    },
    {
      t: [
        {
          Tasks: {
            status: 'QUEUED',
            id: 2
          }
        },
        {
          Tasks: {
            status: 'COMPLETED',
            id: 3
          }
        }
      ],
      m: 'Something else',
      r: 'PENDING',
      p: 55,
      ids: [2,3]
    }
  ];

  var statusCases = [
    {
      status: 'FAILED',
      result: false
    },
    {
      status: 'ABORTED',
      result: false
    },
    {
      status: 'TIMEDOUT',
      result: false
    },
    {
      status: 'IN_PROGRESS',
      result: true
    },
    {
      status: 'COMPLETED',
      result: false
    },
    {
      status: 'PENDING',
      result: true
    }
  ];

  describe('#setSelectCount', function () {
    var itemsForStatusTest = [
      {
        title: 'Empty',
        data: [],
        result: [0, 0, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Pending',
        data: [
          {status: 'pending'},
          {status: 'queued'}
        ],
        result: [2, 2, 0, 0, 0, 0, 0]
      },
      {
        title: 'All Completed',
        data: [
          {status: 'success'},
          {status: 'completed'}
        ],
        result: [2, 0, 0, 0, 2, 0, 0]
      },
      {
        title: 'All Failed',
        data: [
          {status: 'failed'},
          {status: 'failed'}
        ],
        result: [2, 0, 0, 2, 0, 0, 0]
      },
      {
        title: 'All InProgress',
        data: [
          {status: 'in_progress'},
          {status: 'in_progress'}
        ],
        result: [2, 0, 2, 0, 0, 0, 0]
      },
      {
        title: 'All Aborted',
        data: [
          {status: 'aborted'},
          {status: 'aborted'}
        ],
        result: [2, 0, 0, 0, 0, 2, 0]
      },
      {
        title: 'All Timedout',
        data: [
          {status: 'timedout'},
          {status: 'timedout'}
        ],
        result: [2, 0, 0, 0, 0, 0, 2]
      },
      {
        title: 'Every Category',
        data: [
          {status: 'pending'},
          {status: 'queued'},
          {status: 'success'},
          {status: 'completed'},
          {status: 'failed'},
          {status: 'in_progress'},
          {status: 'aborted'},
          {status: 'timedout'}
        ],
        result: [8, 2, 1, 1, 2, 1, 1]
      }
    ];
    var categories = [
      Ember.Object.create({value: 'all'}),
      Ember.Object.create({value: 'pending'}),
      Ember.Object.create({value: 'in_progress'}),
      Ember.Object.create({value: 'failed'}),
      Ember.Object.create({value: 'completed'}),
      Ember.Object.create({value: 'aborted'}),
      Ember.Object.create({value: 'timedout'})
    ];
    itemsForStatusTest.forEach(function(statusTest) {
      it(statusTest.title, function() {
        App.HostPopup.setSelectCount(statusTest.data, categories);
        expect(categories.mapProperty('count')).to.deep.equal(statusTest.result);
      });
    });
  });

  describe('#getStatus', function() {
    test_tasks.forEach(function(test_task) {
      it(test_task.m, function() {
        expect(App.HostPopup.getStatus(test_task.t)[0]).to.equal(test_task.r);
      });
    });
  });

  describe('#getProgress', function() {
    test_tasks.forEach(function(test_task) {
      it(test_task.m, function() {
        expect(App.HostPopup.getProgress(test_task.t)).to.equal(test_task.p);
      });
    });
  });

  describe('#isAbortableByStatus', function () {
    statusCases.forEach(function (item) {
      it('should return ' + item.result + ' for ' + item.status, function () {
        expect(App.HostPopup.isAbortableByStatus(item.status)).to.equal(item.result);
      });
    });
  });

  describe('#abortRequest', function () {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
      sinon.spy(App, 'showConfirmationPopup');
    });
    afterEach(function () {
      App.ajax.send.restore();
      App.showConfirmationPopup.restore();
    });
    it('should show confirmation popup', function () {
      App.HostPopup.abortRequest(Em.Object.create({
        name: 'name'
      }));
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
    });
  });

  describe('#abortRequestSuccessCallback', function () {
    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it('should open popup', function () {
      App.HostPopup.abortRequestSuccessCallback(null, null, {
        requestName: 'name',
        serviceInfo: Em.Object.create()
      });
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
  });

  describe('#abortRequestErrorCallback', function () {
    var popup = App.HostPopup;
    beforeEach(function () {
      sinon.stub(App.ajax, 'get', function(k) {
        if (k === 'modalPopup') return null;
        return Em.get(App, k);
      });
      sinon.spy(App.ModalPopup, 'show');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      App.ajax.get.restore();
    });
    it('should open popup', function () {
      popup.abortRequestErrorCallback({
        responseText: {
          message: 'message'
        },
        status: 404
      }, 'status', 'error', {
        url: 'url'
      }, {
        requestId: 0,
        serviceInfo: Em.Object.create()
      });
      expect(App.ModalPopup.show.calledOnce).to.be.true;
    });
    statusCases.forEach(function (item) {
      it('should set serviceInfo.isAbortable to' + item.result + ' if status is ' + item.status, function () {
        popup.abortRequestErrorCallback({
          responseText: {
            message: 'message'
          },
          status: 404
        }, 'status', 'error', {
          url: 'url'
        }, {
          requestId: 0,
          serviceInfo: Em.Object.create({
            status: item.status
          })
        });
        expect(App.HostPopup.isAbortableByStatus(item.status)).to.equal(item.result);
      });
    });
  });

  describe('#setBackgroundOperationHeader', function(){
    beforeEach(function (){
      sinon.stub(App.HostPopup, "get").returns(true);
      sinon.spy(App.HostPopup, "set");
    });

    afterEach(function (){
      App.HostPopup.get.restore();
      App.HostPopup.set.restore();
      App.router.get.restore();
    });

    it("should display '2 Background Operations Running' when there are 2 background operations running", function(){
      sinon.stub(App.router, "get").returns(2);
      App.HostPopup.setBackgroundOperationHeader(false);

      expect(App.HostPopup.set.calledWith("popupHeaderName", "2 Background Operations Running")).to.be.true;
    });

    it("should display '1 Background Operation Running' when there is 1 background operation running", function(){
      sinon.stub(App.router, "get").returns(1);
      App.HostPopup.setBackgroundOperationHeader(false);

      expect(App.HostPopup.set.calledWith("popupHeaderName", "1 Background Operation Running")).to.be.true;
    });
  });

});

});

;require.register("test/utils/lazy_loading_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var lazyLoading = require('utils/lazy_loading');

describe('lazy_loading', function () {

  describe('#run()', function () {
    var context = Em.Object.create({isLoaded: false});
    var options = {
      destination: [],
      source: [{'test':'test'}],
      context: context
    };
    it('load one item', function () {
      lazyLoading.run(options);
      expect(options.destination[0]).to.eql(options.source[0]);
      expect(context.get('isLoaded')).to.equal(true);
    });

    var testsInfo = [
      {
        title: 'load 11 item with initSize - 11',
        result: true,
        initSize: 11,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {
        title: 'load 11 item with initSize - 12',
        result: true,
        initSize: 12,
        destinationLength: 11,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create()
      },
      {//items will be completely loaded on next iteration of pushing chunk
        title: 'load 11 item with initSize - 10',
        result: false,
        initSize: 10,
        destinationLength: 10,
        destination: [],
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        context: Em.Object.create({isLoaded: false})
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        lazyLoading.run(test);
        expect(test.destinationLength).to.equal(test.destination.length);
        expect(test.context.get('isLoaded')).to.equal(test.result);
      });
    });
  });

  describe('#divideIntoChunks()', function () {
    var testsInfo = [
      {
        title: 'load 11 item with chunkSize - 3',
        chunkSize: 3,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}], [{i:4}, {i:5}, {i:6}], [{i:7}, {i:8}, {i:9}], [{i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 0',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 1',
        chunkSize: 1,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}], [{i:2}], [{i:3}], [{i:4}], [{i:5}], [{i:6}], [{i:7}], [{i:8}], [{i:9}], [{i:10}], [{i:11}]]
      },
      {
        title: 'load 11 item with chunkSize - 11',
        chunkSize: 0,
        source: [{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}],
        chunks: [[{i:1}, {i:2}, {i:3}, {i:4}, {i:5}, {i:6}, {i:7}, {i:8}, {i:9}, {i:10},{i:11}]]
      }
    ];
    testsInfo.forEach(function(test){
      it(test.title, function () {
        var chunks = lazyLoading.divideIntoChunks(test.source, test.chunkSize);
        expect(chunks).to.eql(test.chunks);
      });
    });
  });

  describe("#pushChunk()", function() {
    beforeEach(function () {
      this.clock = sinon.useFakeTimers();
      sinon.spy(lazyLoading, 'pushChunk');
    });
    afterEach(function () {
      this.clock.restore();
      lazyLoading.pushChunk.restore();
    });
    it("last chunk", function() {
      this.clock = sinon.useFakeTimers();

      var destination = [],
          chunks = [[1]],
          context = Em.Object.create(),
          instance = {
            context: context,
            timeoutRef: null,
            terminate: Em.K
          };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      this.clock.tick(10);
      expect(destination[0]).to.equal(1);
      expect(context.get('isLoaded')).to.be.true;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
    it("two chunks", function() {
      this.clock = sinon.useFakeTimers();
      var destination = [],
        chunks = [[1], [2]],
        context = Em.Object.create(),
        instance = {
          context: context,
          timeoutRef: null,
          terminate: Em.K
        };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      this.clock.tick(20);
      expect(destination.length).to.equal(2);
      expect(context.get('isLoaded')).to.be.true;
      expect(lazyLoading.pushChunk.calledTwice).to.be.true;
    });
    it("terminated chunks", function() {
      this.clock = sinon.useFakeTimers();
      var destination = [],
        chunks = [[1]],
        context = Em.Object.create({isLoaded: false}),
        instance = {
          context: context,
          timeoutRef: null,
          terminate: Em.K
        };
      lazyLoading.pushChunk(chunks, 0, 10, destination, instance);
      clearTimeout(instance.timeoutRef);
      this.clock.tick(10);
      expect(destination.length).to.empty;
      expect(context.get('isLoaded')).to.be.false;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
  });

  describe("#terminate()", function() {
    before(function () {
      sinon.spy(lazyLoading, 'pushChunk');
      this.clock = sinon.useFakeTimers();
    });
    after(function () {
      lazyLoading.pushChunk.restore();
      this.clock.restore();
    });
    it("loading terminated", function() {
      var context = Em.Object.create({isLoaded: false});
      var options = {
        destination: [],
        source: [1, 2],
        delay: 10,
        chunkSize: 1,
        initSize: 1,
        context: context
      };

      var ll = lazyLoading.run(options);
      lazyLoading.terminate(ll);
      this.clock.tick(10);
      expect(options.destination.length).to.equal(1);
      expect(context.get('isLoaded')).to.be.false;
      expect(lazyLoading.pushChunk.calledTwice).to.be.false;
    });
  });
});

});

;require.register("test/utils/load_timer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var misc = require('utils/load_timer');

describe('App.loadTimer', function () {

  window.performance = {
    now: function() {
      return 1;
    }
  };

  beforeEach(function() {
    App.set('supports.showPageLoadTime', true);
  });

  afterEach(function () {
    App.set('supports.showPageLoadTime', false);
    App.loadTimer.set('timeStampCache', {});
  });

  describe("#start()", function() {
    it("", function() {
      App.loadTimer.start('test');
      expect(App.loadTimer.get('timeStampCache')['test']).to.be.an('number');
    });
  });

  describe("#finish()", function() {
    it("", function() {
      App.loadTimer.start('test');
      expect(App.loadTimer.finish('test')).to.be.not.empty;
      expect(App.loadTimer.get('timeStampCache')).to.be.empty;
    });
  });
});

});

;require.register("test/utils/misc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var misc = require('utils/misc');

describe('misc', function () {

  describe('#formatBandwidth', function () {
    var tests = Em.A([
      {m:'undefined to undefined',i:undefined,e:undefined},
      {m:'0 to <1KB',i:'0',e:'<1KB'},
      {m:'1000 to <1KB',i:'1000',e:'<1KB'},
      {m:'1024 to 1.0KB',i:'1024',e:'1.0KB'},
      {m:'2048 to 2.0KB',i:'2048',e:'2.0KB'},
      {m:'1048576 to 1.0MB',i:'1048576',e:'1.0MB'},
      {m:'1782579 to 1.7MB',i:'1782579',e:'1.7MB'},
      {m:'1546188226 to 1.44GB',i:'1546188226',e:'1.44GB'}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.formatBandwidth(test.i)).to.equal(test.e);
      });
    });
    it('NaN to NaN' + ' ', function () {
      expect(isNaN(misc.formatBandwidth(NaN))).to.equal(true);
    });
  });

  describe('#ipToInt', function () {
    var tests = Em.A([
      {m:'0.0.0.0 to 0',i:'0.0.0.0',e:0},
      {m:'255.255.255.255 to 4294967295',i:'255.255.255.255',e:4294967295},
      {m:'"" to false',i:'',e:false},
      {m:'255.255.255.256 to false',i:'255.255.255.256',e:false},
      {m:'255.255.255 to false',i:'255.255.255',e:false}
    ]);
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(misc.ipToInt(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#sortByOrder', function() {
    var tests = Em.A([
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, Em.Object.create({id:'c'})],
        e: [{id:'b'}, Em.Object.create({id:'c'}), {id:'a'}],
        m: 'Array with Ember and native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [{id:'a'}, {id:'b'}, {id:'c'}],
        e: [{id:'b'}, {id:'c'}, {id:'a'}],
        m: 'Array with native objects'
      },
      {
        sortOrder: ['b', 'c', 'a'],
        array: [Em.Object.create({id:'a'}), Em.Object.create({id:'b'}), Em.Object.create({id:'c'})],
        e: [Em.Object.create({id:'b'}), Em.Object.create({id:'c'}), Em.Object.create({id:'a'})],
        m: 'Array with Ember objects'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        expect(misc.sortByOrder(test.sortOrder, test.array)).to.eql(test.e);
      });
    });
  });
});

});

;require.register("test/utils/number_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var numberUtils = require('utils/number_utils');

describe('utils/number_utils', function() {

  describe('#bytesToSize', function() {

    describe('check bytes', function() {
      var tests = Em.A([
        {
          bytes: null,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is null'
        },
        {
          bytes: undefined,
          precision: null,
          parseType: null,
          multiplyBy: null,
          e: 'n/a',
          m: '"n/a" if bytes is undefined'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: null,
          e: '0 Bytes',
          m: '0 if multiply is `null`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: undefined,
          e: '200 Bytes',
          m: '"200 Bytes" if `multiplyBy` and `parseType` are `undefined`'
        },
        {
          bytes: 200,
          precision: null,
          parseType: undefined,
          multiplyBy: 1,
          e: '200 Bytes',
          m: '`200 Bytes` if `parsetype` is `undefined`'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy)).to.equal(test.e);
        });
      });
    });

    describe('check sizes', function() {
      var tests = Em.A([
        {
          bytes: 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'Bytes',
          m: 'Bytes'
        },
        {
          bytes: 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'KB',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'MB',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'GB',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'TB',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 + 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: 'PB',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).endsWith(test.e)).to.equal(true);
        });
      });
    });

    describe('check calculated result', function() {
      var tests = Em.A([
        {
          bytes: 42,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '42',
          m: 'Bytes'
        },
        {
          bytes: 1024 * 12,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '12',
          m: 'KB'
        },
        {
          bytes: 1024 * 1024 * 23,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '23',
          m: 'MB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 34,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '34',
          m: 'GB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 45,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '45',
          m: 'TB'
        },
        {
          bytes: 1024 * 1024 * 1024 * 1024 * 1024 * 56,
          precision: null,
          parseType: 'parseInt',
          multiplyBy: 1,
          e: '56',
          m: 'PB'
        }
      ]);

      tests.forEach(function(test) {
        it(test.m, function() {
          expect(numberUtils.bytesToSize(test.bytes, test.precision, test.parseType, test.multiplyBy).startsWith(test.e)).to.equal(true);
        });
      });
    });

  });
  describe('#validateInteger()', function() {
    var tests = [
      {
        str: null,
        min: null,
        max: null,
        m: 'all params null to' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.empty')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.empty'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "string",
        min: null,
        max: null,
        m: 'try to validate `string` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1abc",
        min: null,
        max: null,
        m: 'try to validate `1abc` should return ' + Em.I18n.t('number.validate.notValidNumber'),
        e: Em.I18n.t('number.validate.notValidNumber')
      },
      {
        str: "1",
        min: null,
        max: null,
        m: 'try to validate `1` should return ' + Em.I18n.t('number.validate.moreThanMaximum').format(null),
        e: Em.I18n.t('number.validate.moreThanMaximum').format(null)
      },
      {
        str: "1",
        min: 2,
        max: 0,
        m: 'try to validate `1` with max = 0 and min = 2 should return ' + Em.I18n.t('number.validate.lessThanMinimum').format(2),
        e: Em.I18n.t('number.validate.lessThanMinimum').format(2)
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function(){
        expect(numberUtils.validateInteger(test.str, test.min, test.max)).to.eql(test.e);
      });
    });
  });

  describe('#getCardinalityValue()', function() {
    var generateTestObject = function(cardinality, isMax, expected) {
      return {
        cardinality: cardinality,
        isMax: isMax,
        e: expected
      }
    };
    var tests = [
      generateTestObject(null, true, 0),
      generateTestObject(undefined, true, 0),
      generateTestObject('1', true, 1),
      generateTestObject('1', false, 1),
      generateTestObject('0+', true, Infinity),
      generateTestObject('0+', false, 0),
      generateTestObject('1+', true, Infinity),
      generateTestObject('1-2', false, 1),
      generateTestObject('1-2', true, 2),
      generateTestObject('ALL', true, Infinity),
      generateTestObject('ALL', false, Infinity)
    ];
    var message = 'cardinality `{0}`. {1} value should be {2}';
    tests.forEach(function(test) {
      it(message.format('' + test.cardinality, (test.isMax ? 'maximum' : 'minimum'), test.e), function() {
        expect(numberUtils.getCardinalityValue(test.cardinality, test.isMax)).to.be.eql(test.e);
      });
    })
  });
});
});

;require.register("test/utils/object_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var objectUtils = require('utils/object_utils');

describe('utils/object_utils', function() {
  describe('#recursiveTree()', function() {
    var testObj = {
      a1: {
        a2: 'v1',
        a3: {
          a4: {
            a5: {
              a6: 'v2',
              a7: 'v3'
            }
          }
        }
      }
    };
    it('should return correct tree of childs', function(){
      var result = objectUtils.recursiveTree(testObj);
      expect(result).to.eql('a2 (/a1)<br/>a5 (/a1/a3/a4)<br/>');
    });

    it('should return `null` if type missed', function() {
      var result = objectUtils.recursiveTree('{ a1: "v1"}');
      expect(result).to.be.null;
    });
  });
  describe('#recursiveKeysCount()', function() {
    var tests = [
      {
        m: 'should return 1 child',
        e: 3,
        obj: {
          a1: {
            a2: 'v1',
            a3: 'v2',
            a4: {
              a5: 'v3'
            }
          }
        }
      },
      {
        m: 'should return 1 childs',
        e: 1,
        obj: {
          a1: 'c1'
        }
      },
      {
        m: 'should return `null`',
        e: null,
        obj: 'a1'
      }
    ];
    tests.forEach(function(test){
      it(test.m, function() {
        expect(objectUtils.recursiveKeysCount(test.obj)).to.be.eql(test.e);
      });
    });
  });

  describe('#deepEqual', function() {
    it('simple values', function() {
      expect(objectUtils.deepEqual(true, true)).to.true;
    });
    it('simple values strict', function() {
      expect(objectUtils.deepEqual(true, 1)).to.false;
    });
    it('simple with complex', function() {
      expect(objectUtils.deepEqual(true, {})).to.false;
    });
    it('complex with simple', function() {
      expect(objectUtils.deepEqual({}, 2)).to.false;
    });
    it('simple objects', function() {
      var a = {
        value: 1
      };
      var b = {
        value: 1
      };
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('simple objects failed', function() {
      var a = {
        value: 1,
        c: 1
      };
      var b = {
        value: 1
      };
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
    it('complex objects', function() {
      var a = {
        value: 1,
        c: {
          d: {
            x: {
              val: 1
            }
          }
        }
      };
      var b = {
        value: 1,
        c: {
          d: {
            x: {
              val: 1
            }
          }
        }
      };
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('complex objects failed', function() {
      var a = {
        value: 1,
        c: {
          d: {
            x: {
              val: 1
            }
          }
        }
      };
      var b = {
        value: 1,
        c: {
          d: {
            x: {
              val: 2
            }
          }
        }
      };
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
    it('complex array', function() {
      var a = [1,2,{a: 2}, 4, {b:{}}];
      var b = [1,2,{a: 2}, 4, {b:{}}];
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('complex array failed', function() {
      var a = [1,3,{a: 2}, 4, {b:{}}];
      var b = [1,2,{a: 2}, 4, {b:{}}];
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
    it('simple array', function() {
      var a = [1,3];
      var b = [1,3];
      expect(objectUtils.deepEqual(a, b)).to.true;
    });
    it('simple array failed', function() {
      var a = [3,1];
      var b = [1,3];
      expect(objectUtils.deepEqual(a, b)).to.false;
    });
  });

  describe('#deepMerge', function() {
    var tests = [
      {
        target: {
          a: [
            {
              c: 3
            }
          ]
        },
        source: {
          a: [
            {
              b: 2
            }
          ]
        },
        e: {
          a: [
            {
              c: 3
            },
            {
              b: 2
            }
          ]
        }
      },
      {
        target: {
          a: {}
        },
        source: {
          a: {
            b: 2,
            c: [1,2,3]
          }
        },
        e: {
          a: {
            b: 2,
            c: [1,2,3]
          }
        }
      },
      {
        target: {
          artifact_data: {
            services: [
              {
                name: "HIVE",
                configurations: [
                  {
                    "hive-site": {
                      hive_prop1: "hive_val1"
                    }
                  }
                ]
              }
            ]
          }
        },
        source: {
          artifact_data: {
            services: [
              {
                name: "HDFS",
                configurations: [
                  {
                    "hdfs-site": {
                      hdfs_prop1: "hdfs_val1"
                    }
                  }
                ]
              }
            ]
          }
        },
        e: {
          artifact_data: {
            services: [
              {
                name: "HIVE",
                configurations: [
                  {
                    "hive-site": {
                      hive_prop1: "hive_val1"
                    }
                  }
                ]
              },
              {
                name: "HDFS",
                configurations: [
                  {
                    "hdfs-site": {
                      hdfs_prop1: "hdfs_val1"
                    }
                  }
                ]
              }
            ]
          }
        }
      },
      {
        source: {
          "artifact_data" : {
            "identities" : [
              {
                "principal" : {
                  "value" : "HTTP/_HOST@${realm}",
                  "type" : "service"
                },
                "name" : "spnego",
                "keytab" : {
                  "file" : "${keytab_dir}/spnego.service.keytab",
                  "owner" : {
                    "name" : "root",
                    "access" : "r"
                  },
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "principal" : {
                  "value" : "${cluster-env/smokeuser}-----@${realm}",
                  "local_username" : "${cluster-env/smokeuser}",
                  "configuration" : "cluster-env/smokeuser_principal_name",
                  "type" : "user"
                },
                "name" : "smokeuser",
                "keytab" : {
                  "file" : "${keytab_dir}/smokeuser.headless.keytab",
                  "owner" : {
                    "name" : "${cluster-env/smokeuser}",
                    "access" : "r"
                  },
                  "configuration" : "cluster-env/smokeuser_keytab",
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              }
            ]
          }
        },
        target: {
          "artifact_data" : {
            "identities" : [
              {
                "principal" : {
                  "value" : "${cluster-env/smokeuser}@${realm}",
                  "local_username" : "${cluster-env/smokeuser}",
                  "configuration" : "cluster-env/smokeuser_principal_name",
                  "type" : "user"
                },
                "name" : "smokeuser",
                "keytab" : {
                  "file" : "${keytab_dir}/smokeuser.headless.keytab",
                  "owner" : {
                    "name" : "${cluster-env/smokeuser}",
                    "access" : "r"
                  },
                  "configuration" : "cluster-env/smokeuser_keytab",
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "principal" : {
                  "value" : "HTTP/_HOST@${realm}",
                  "local_username" : null,
                  "configuration" : null,
                  "type" : "service"
                },
                "name" : "spnego",
                "keytab" : {
                  "file" : "${keytab_dir}/spnego.service.keytab",
                  "owner" : {
                    "name" : "root",
                    "access" : "r"
                  },
                  "configuration" : null,
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "d"
                  }
                }
              },
              {
                "name": "anotherOne"
              }
            ]
          }
        },
        e: {
          "artifact_data" : {
            "identities" : [
              {
                "principal" : {
                  "value" : "${cluster-env/smokeuser}-----@${realm}",
                  "local_username" : "${cluster-env/smokeuser}",
                  "configuration" : "cluster-env/smokeuser_principal_name",
                  "type" : "user"
                },
                "name" : "smokeuser",
                "keytab" : {
                  "file" : "${keytab_dir}/smokeuser.headless.keytab",
                  "owner" : {
                    "name" : "${cluster-env/smokeuser}",
                    "access" : "r"
                  },
                  "configuration" : "cluster-env/smokeuser_keytab",
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "principal" : {
                  "value" : "HTTP/_HOST@${realm}",
                  "local_username" : null,
                  "configuration" : null,
                  "type" : "service"
                },
                "name" : "spnego",
                "keytab" : {
                  "file" : "${keytab_dir}/spnego.service.keytab",
                  "owner" : {
                    "name" : "root",
                    "access" : "r"
                  },
                  "configuration" : null,
                  "group" : {
                    "name" : "${cluster-env/user_group}",
                    "access" : "r"
                  }
                }
              },
              {
                "name": "anotherOne"
              }
            ]
          }
        }
      }
    ];

    tests.forEach(function(test) {
      it("Should merge objects `{0}`, `{1}`".format(JSON.stringify(test.target), JSON.stringify(test.source)), function() {
        expect(objectUtils.deepMerge(test.target, test.source, test.handler)).to.be.eql(test.e);
      });
    });
  });

  describe('#detectIndexedKey', function() {
    var tests = [
      {
        target: [
          {
            a: 1,
            b: []
          },
          {
            a: 3,
            b: 2
          },
          {
            a: 2,
            b: {}
          }
        ],
        e: 'a',
        m: 'should detect uniq key as `a`'
      },
      {
        target: [
          {
            "principal" : {
              "value" : "HTTP/_HOST@${realm}",
              "local_username" : null,
              "configuration" : null,
              "type" : "service"
            },
            "name" : "spnego",
            "keytab" : {
              "file" : "${keytab_dir}/spnego.service.keytab",
              "owner" : {
                "name" : "root",
                "access" : "r"
              },
              "configuration" : null,
              "group" : {
                "name" : "${cluster-env/user_group}",
                "access" : "r"
              }
            }
          },
          {
            "principal" : {
              "value" : "${cluster-env/smokeuser}-${cluster_name}@${realm}",
              "local_username" : "${cluster-env/smokeuser}",
              "configuration" : "cluster-env/smokeuser_principal_name",
              "type" : "user"
            },
            "name" : "smokeuser",
            "keytab" : {
              "file" : "${keytab_dir}/smokeuser.headless.keytab",
              "owner" : {
                "name" : "${cluster-env/smokeuser}",
                "access" : "r"
              },
              "configuration" : "cluster-env/smokeuser_keytab",
              "group" : {
                "name" : "${cluster-env/user_group}",
                "access" : "r"
              }
            }
          }
        ],
        e: 'name',
        m: 'should detect uniq key as `name`'
      },
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        expect(objectUtils.detectIndexedKey(test.target)).to.eql(test.e);
      });
    });
  });

  describe('#smartArrayObjectMerge', function() {
    var tests = [
      {
        target: [
          {
            a: 2,
            B: 2
          }
        ],
        source: [
          {
            a: 3,
            c: 4
          },
        ],
        m: 'should merge {0} {1}, into {2}',
        e: [
          {
            a: 2,
            B: 2
          },
          {
            a: 3,
            c: 4
          }
        ]
      },
      {
        target: [
          {
            a: 2,
            B: 2
          }
        ],
        source: [
          {
            a: 2,
            B: 3,
            b: 4
          },
          {
            a: 3,
            c: 4
          }
        ],
        m: 'should merge {0} {1}, into {2}',
        e: [
          {
            a: 2,
            B: 3,
            b: 4
          },
          {
            a: 3,
            c: 4
          }
        ]
      },
      {
        target: [
          {
            "spark-defaults" : {
              "spark.history.kerberos.enabled" : "true",
              "spark.history.enabled" : "no"
            }
          }
        ],
        source: [
          {
            "spark-defaults" : {
              "spark.history.kerberos.enabled" : "false"
            }
          },
          {
            "spark-site" : {
              "spark.property" : "false"
            }
          }
        ],
        m: 'should merge {0} {1}, into {2}',
        e: [
          {
            "spark-defaults" : {
              "spark.history.kerberos.enabled" : "true",
              "spark.history.enabled" : "no"
            }
          },
          {
            "spark-site" : {
              "spark.property" : "false"
            }
          }
        ]
      }
    ];

    tests.forEach(function(test) {
      it(test.m.format(JSON.stringify(test.target), JSON.stringify(test.source), JSON.stringify(test.e)), function() {
        expect(objectUtils.smartArrayObjectMerge(test.target, test.source).toArray()).to.be.eql(test.e);
      });
    });
  });
});

});

;require.register("test/utils/string_utils_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var string_utils = require('utils/string_utils');
require('utils/helper');

describe('string_utils', function () {

  describe('#underScoreToCamelCase', function () {
    var tests = [
      {m:'a_b_c to aBC',i:'a_b_c',e:'aBC'},
      {m:'a_bc to aBc',i:'a_bc',e:'aBc'},
      {m:'ab_c to abC',i:'ab_c',e:'abC'},
      {m:'_b_c to BC',i:'_b_c',e:'BC'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.underScoreToCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#pad', function () {
    var tests = [
      {m: '"name" to "    name"', i: 'name', l: 8, a: 1, f: ' ', e: '    name'},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 2, f: ' ', e: 'name    '},
      {m: '"name" to "  name  "', i: 'name', l: 8, a: 3, f: ' ', e: '  name  '},
      {m: '"name" to "name    "', i: 'name', l: 8, a: 0, f: ' ', e: 'name    '},
      {m: '"name" to "name    "', i: 'name', l: 8, a:-1, f: ' ', e: 'name    '},
      {m: '"name" to "name"', i: 'name', l: 4, a: 1, f: ' ', e: 'name'},
      {m: '"name" to "||||||||name"', i: 'name', l: 8, a:1, f: '||', e: '||||||||name'},
      {m: '"name" to "||||name||||"', i: 'name', l: 8, a:3, f: '||', e: '||||name||||'},
      {m: '"name" to "name||||||||"', i: 'name', l: 8, a:2, f: '||', e: 'name||||||||'},
      {m: '"name" to "name" `str` param passed only', i: 'name', e: 'name'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.pad(test.i, test.l, test.f, test.a)).to.equal(test.e);
      });
    });
  });

  describe('#compareVersions', function () {
    var tests = [
      {m: '1.2 equal to 1.2', v1:'1.2', v2:'1.2', e: 0},
      {m: '1.2 lower than 1.3', v1:'1.2', v2:'1.3', e: -1},
      {m: '1.3 higher than 1.2', v1:'1.3', v2:'1.2', e: 1},
      {m: '1.2.1 higher than 1.2', v1:'1.2.1', v2:'1.2', e: 1},
      {m: '11.2 higher than 2.2', v1:'11.2', v2:'2.2', e: 1},
      {m: '0.9 higher than 0.8', v1:'0.9', v2:'0.8', e: 1},
      {m: '1.1-2  equal to 1.1-2 ', v1:'1.1-2', v2:'1.1-2', e: 0},
      {m: '1.1-2 higher than 1.1-1', v1:'1.1-2', v2:'1.1-1', e: 1},
      {m: '1.1-4 lower than 1.1-46', v1:'1.1-4', v2:'1.1-46', e: -1},
      {m: 'return false if no string passed', v1: '0.9', e: -1}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(string_utils.compareVersions(test.v1, test.v2)).to.equal(test.e);
      });
    });
  });

  describe('#isSingleLine', function () {
    var tests = [
      {m: 'is single line text', t: 'a b', e: true},
      {m: 'is single line text', t: 'a b\n', e: true},
      {m: 'is single line text', t: '\na b', e: true},
      {m: 'is not single line text', t: 'a\nb', e: false}
    ];
    tests.forEach(function(test) {
      it(test.t + ' ' + test.m + ' ', function () {
        expect(string_utils.isSingleLine(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#arrayToCSV', function() {
    var test = [{a: 1, b:2, c:3}, {a: 1, b:2, c:3}, {a: 1, b:2, c:3}];
    it('array of object to csv-string', function () {
      expect(string_utils.arrayToCSV(test)).to.equal("1,2,3\n1,2,3\n1,2,3\n");
    });
  });

  describe('#getFileFromPath', function() {
    var tests = [
      {t: undefined, e: ''},
      {t: {}, e: ''},
      {t: [], e: ''},
      {t: '', e: ''},
      {t: function(){}, e: ''},
      {t: '/path/to/file.ext', e: 'file.ext'},
      {t: 'file.ext', e: 'file.ext'},
      {t: 'file', e: 'file'},
      {t: '/path/to/file', e: 'file'}
    ];
    tests.forEach(function(test) {
      it('Check ' + typeof test.t, function () {
        expect(string_utils.getFileFromPath(test.t)).to.equal(test.e);
      });
    });
  });

  describe('#getPath', function() {
      var tests = [
        {t: undefined, e: ''},
        {t: {}, e: ''},
        {t: [], e: ''},
        {t: '', e: ''},
        {t: function(){}, e: ''},
        {t: '/path/to/filename', e: '/path/to'},
        {t: '/path/to/', e: '/path/to'},
        {t: '/filename', e: '/'},
        {t: 'filename', e: ''},
        {t: '/path/', e: '/path'},
        {t: 'filename/', e: ''}
      ];
      tests.forEach(function(test) {
          it('Check ' + typeof test.t, function () {
            expect(string_utils.getPath(test.t)).to.equal(test.e);
          });
      });
  });

  describe('#getCamelCase', function () {
    var tests = [
      {i:'a',e:'A'},
      {i:'aB',e:'Ab'},
      {i:'a b',e:'A B'},
      {i:'a.b',e:'A.B'},
      {i:'a,b',e:'A,B'},
      {i:'a;b',e:'A;B'},
      {i:'a. b',e:'A. B'},
      {i:'a   b',e:'A   B'},
      {i:'aaa. bbb',e:'Aaa. Bbb'},
      {i:'aAA. bBB',e:'Aaa. Bbb'},
      {i:'STARTING',e:'Starting'},
      {i:'starting',e:'Starting'},
      {i:'starting,ending',e:'Starting,Ending'},
      {i: null, e: null},
      {i: undefined, e: undefined}
    ];
    tests.forEach(function(test) {
      it(test.i + ' to ' + test.e + ' ', function () {
        expect(string_utils.getCamelCase(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#findIn', function () {
    var tests = [
      {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2'
        },
        key: 'a',
        index: 1,
        e: null
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: '12'
          }
        },
        key: 'a',
        index: 1,
        e: '11'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 2,
        e: '22'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'a',
        index: 0,
        e: '1'
      }, {
        obj: {
          a: '1',
          b: '2',
          c: {
            a: '11',
            aa: {
              a: '22'
            }
          }
        },
        key: 'g',
        index: 0,
        e: null
      }
    ];
    tests.forEach(function(test) {
      it(test.key + ' @ ' + test.index + ' = ' + test.e, function () {
        expect(test.key.findIn(test.obj, test.index)).to.equal(test.e);
      });
    });
  });

  describe("#htmlEntities()", function() {
    var tests = [
      {t: undefined, e: ''},
      {t: '', e: ''},
      {t: 'abc', e: 'abc'},
      {t: 'abc<script>abc', e: 'abc&lt;script&gt;abc'}
    ];
    tests.forEach(function(test) {
      it('Check ' + typeof test.t, function () {
        expect(string_utils.htmlEntities(test.t)).to.equal(test.e);
      });
    });
  });
});

});

;require.register("test/utils/ui_effects_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var ui_utils = require('utils/ui_effects');
var App = require('app');

describe('utils/ui_effects', function(){
  describe('#pulsate()', function(){
    beforeEach(function(){
      $('body').append('<div id="pulsate-test-dom"></div>');
      this.clock = sinon.useFakeTimers();
    });

    it('opacity should be 0.2 on 5-th iteration', function() {
      var domEl = $('#pulsate-test-dom');
      ui_utils.pulsate(domEl, 1000);
      this.clock.tick(300);
      expect(parseFloat(domEl.css('opacity')).toFixed(1)).to.eql('0.2');
    });
    it('should call callback at the end', function() {
      var domEl = $('#pulsate-test-dom');
      var stub = sinon.stub();
      ui_utils.pulsate(domEl, 1000, stub);
      this.clock.tick(2000);
      expect(stub.calledOnce).to.be.ok;
    });

    afterEach(function(){
      $('#pulsate-test-dom').remove();
      this.clock.restore();
    });
  });
});

});

;require.register("test/utils/updater_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/updater');
describe('utils/updater', function() {
  describe('#App.updater', function() {
    beforeEach(function() {
      this.clock = sinon.useFakeTimers();
      sinon.stub(App.router, "get").returns('test');
    });

    var tests = {
      t1: {
        obj: Em.Object.create({
          method: sinon.spy(),
          isWorking: true
        }),
        m: 'method called once with default interval in 15 000 ms'
      },
      t2: {
        obj: Em.Object.create({
          method: function() {}
        }),
        m: 'should return false if key name is invalid or absent'
      },
      t3: {
        obj: Em.Object.create({
          method2: sinon.spy(),
          isWorking: true
        }),
        m: 'method should be called immediately'
      },
      t4: {
        obj: Em.Object.create({
          method3: sinon.spy(),
          isWorking: true
        }),
        m: 'method call should be ignored if `isWorking` set to false'
      },
      t5: {
        obj: Em.Object.create({
          method4: sinon.spy(),
          isWorking: true
        }),
        m: 'method call should be ignored if urlPattern is not matching router location'
      }
    };

    it(tests.t1.m, function() {
      App.updater.run(tests.t1.obj, 'method', 'isWorking');
      this.clock.tick(15000);
      expect(tests.t1.obj.method.called).to.be.ok;
    });

    it(tests.t2.m, function() {
      var methodCall = App.updater.run(tests.t2.obj, 'method', 'isWorking');
      expect(methodCall).to.be.false;
    });

    it(tests.t3.m, function() {
      App.updater.run(tests.t3.obj, 'method2', 'isWorking');
      App.updater.immediateRun('method2');
      expect(tests.t3.obj.method2.called).to.be.ok;
    });

    it(tests.t4.m, function() {
      App.updater.run(tests.t4.obj, 'method3', 'isWorking');
      this.clock.tick(10000);
      tests.t4.obj.set('isWorking', false);
      this.clock.tick(5000);
      expect(tests.t4.obj.method3.called).to.be.false;
    });

    it(tests.t5.m, function () {
      App.updater.run(tests.t5.obj, 'method4', 'isWorking', 15000, 'pattern');
      this.clock.tick(15000);
      expect(tests.t5.obj.method4.called).to.be.false;
    });

    afterEach(function() {
      this.clock.restore();
      App.router.get.restore();
    });
  });
});

});

;require.register("test/utils/validator_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var validator = require('utils/validator');

describe('validator', function () {

  describe('#isValidEmail(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidEmail(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidEmail('')).to.equal(false);
    });
    it('should return false if value is "a.com"', function () {
      expect(validator.isValidEmail('a.com')).to.equal(false);
    });
    it('should return false if value is "@a.com"', function () {
      expect(validator.isValidEmail('@a.com')).to.equal(false);
    });
    it('should return false if value is "a@.com"', function () {
      expect(validator.isValidEmail('a@.com')).to.equal(false);
    });
    it('should return true if value is "a@a.com"', function () {
      expect(validator.isValidEmail('a@a.com')).to.equal(true);
    });
    it('should return true if value is "user@a.b.com"', function () {
      expect(validator.isValidEmail('user@a.b.com')).to.equal(true);
    })
  });

  describe('#isValidInt(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidInt(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidInt('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidInt('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidInt('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidInt(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidInt('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidInt('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidInt('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidInt('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidInt(10)).to.equal(true);
    })
  });

  describe('#isValidFloat(value)', function () {
    it('should return false if value is null', function () {
      expect(validator.isValidFloat(null)).to.equal(false);
    });
    it('should return false if value is ""', function () {
      expect(validator.isValidFloat('')).to.equal(false);
    });
    it('should return false if value is "abc"', function () {
      expect(validator.isValidFloat('abc')).to.equal(false);
    });
    it('should return false if value is "0xff"', function () {
      expect(validator.isValidFloat('0xff')).to.equal(false);
    });
    it('should return false if value is " 1""', function () {
      expect(validator.isValidFloat(' 1')).to.equal(false);
    });
    it('should return false if value is "1 "', function () {
      expect(validator.isValidFloat('1 ')).to.equal(false);
    });
    it('should return true if value is "10"', function () {
      expect(validator.isValidFloat('10')).to.equal(true);
    });
    it('should return true if value is "-123"', function () {
      expect(validator.isValidFloat('-123')).to.equal(true);
    });
    it('should return true if value is "0"', function () {
      expect(validator.isValidFloat('0')).to.equal(true);
    });
    it('should return true if value is 10', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is -123', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is 0', function () {
      expect(validator.isValidFloat(10)).to.equal(true);
    });
    it('should return true if value is "0.0"', function () {
      expect(validator.isValidFloat("0.0")).to.equal(true);
    });
    it('should return true if value is "10.123"', function () {
      expect(validator.isValidFloat("10.123")).to.equal(true);
    });
    it('should return true if value is "-10.123"', function () {
      expect(validator.isValidFloat("-10.123")).to.equal(true);
    });
    it('should return true if value is 10.123', function () {
      expect(validator.isValidFloat(10.123)).to.equal(true);
    });
    it('should return true if value is -10.123', function () {
      expect(validator.isValidFloat(-10.123)).to.equal(true);
    })

  });
  describe('#isIpAddress(value)', function () {
    it('"127.0.0.1" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.1')).to.equal(true);
    })
    it('"227.3.67.196" - valid IP', function () {
      expect(validator.isIpAddress('227.3.67.196')).to.equal(true);
    })
    it('"327.0.0.0" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0')).to.equal(false);
    })
    it('"127.0.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.0.')).to.equal(false);
    })
    it('"127.0." - invalid IP', function () {
      expect(validator.isIpAddress('127.0.')).to.equal(false);
    })
    it('"127" - invalid IP', function () {
      expect(validator.isIpAddress('127')).to.equal(false);
    })
    it('"127.333.0.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.333.0.1')).to.equal(false);
    })
    it('"127.0.333.1" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.333.1')).to.equal(false);
    })
    it('"127.0.1.333" - invalid IP', function () {
      expect(validator.isIpAddress('127.0.1.333')).to.equal(false);
    })
    it('"127.0.0.0:45555" - valid IP', function () {
      expect(validator.isIpAddress('127.0.0.0:45555')).to.equal(true);
    })
    it('"327.0.0.0:45555" - invalid IP', function () {
      expect(validator.isIpAddress('327.0.0.0:45555')).to.equal(false);
    })
  });

  describe('#isDomainName(value)', function () {
    it('"google.com" - valid Domain Name', function () {
      expect(validator.isDomainName('google.com')).to.equal(true);
    });
    it('"google" - invalid Domain Name', function () {
      expect(validator.isDomainName('google')).to.equal(false);
    });
    it('"123.123" - invalid Domain Name', function () {
      expect(validator.isDomainName('123.123')).to.equal(false);
    });
    it('"4goog.le" - valid Domain Name', function () {
      expect(validator.isDomainName('4goog.le')).to.equal(true);
    });
    it('"55454" - invalid Domain Name', function () {
      expect(validator.isDomainName('55454')).to.equal(false);
    })
  });

  describe('#hasSpaces()', function(){
    var testable = [
      { str: ' hello', detect: true },
      { str: 'hello world', detect: true },
      { str: 'hello ', detect: true },
      { str: 'hello', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + ' detects spaces in `' + value.str + '`', function(){
        expect(validator.hasSpaces(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#isNotTrimmed', function(){
    var testable = [
      { str: ' hello world', detect: true },
      { str: ' hello world ', detect: true },
      { str: 'hello world ', detect: true },
      { str: 'hello world', detect: false },
      { str: 'hello world !', detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + 'trimmed string', function() {
        expect(validator.isNotTrimmed(value.str)).to.eql(value.detect);
      });
    });
  });
  describe('#empty()', function(){
    var testable = [
      { obj: "", detect: true },
      { obj: 0, detect: true },
      { obj: "0", detect: true },
      { obj: null, detect: true },
      { obj: undefined, detect: true },
      { obj: 'hello', detect: false },
      { obj: {}, detect: false },
      { obj: [], detect: false },
      { obj: ['a'], detect: false },
      { obj: 1, detect: false },
      { obj: true, detect: false }
    ];
    testable.forEach(function(value){
      it('should ' + (value.detect ? '' : 'not') + ' detect empty value in `' + new String(value.obj) + '`', function(){
        expect(validator.empty(value.obj)).to.eql(value.detect);
      });
    });
  });
  describe('#isValidUserName(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"root$" - invalid',i:'root$',e:false},
      {m:'"rootU" - invalid',i:'rootU',e:false},
      {m:'"rUoot" - invalid',i:'rUoot',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUserName(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidUNIXUser(value)', function() {
    var tests = [
      {m:'"" - invalid',i:'',e:false},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'"1abc123" - invalid',i:'1abc123',e:false},
      {m:'"abc123$" - invalid',i:'abc123$',e:false},
      {m:'"~1abc123" - invalid',i: '~1abc123',e:false},
      {m:'"abc12345679abc1234567890abc1234567890$" - invalid',i:'abc12345679abc1234567890abc1234567890$',e:false},
      {m:'"1abc123$$" - invalid',i:'1abc123$$',e:false},
      {m:'"a" - valid',i:'a',e:true},
      {m:'"!" - invalid',i:'!',e:false},
      {m:'"abc_" - valid',i:'abc_',e:true},
      {m:'"_abc" - valid',i:'_abc',e:true},
      {m:'"abc_abc" - valid',i:'_abc',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidUNIXUser(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidDir(value)', function() {
    var tests = [
      {m:'"dir" - invalid',i:'dir',e:false},
      {m:'" /dir" - invalid',i:' /dir',e:false},
      {m:'"/dir" - valid',i:'/dir',e:true},
      {m:'"/dir1,dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1, /dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1,/dir2" - valid',i:'/dir1,/dir2',e:true},
      {m:'"/123" - valid',i:'/111',e:true},
      {m:'"/abc" - valid',i:'/abc',e:true},
      {m:'"/1a2b3c" - valid',i:'/1a2b3c',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidDir(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isConfigValueLink', function() {
    var tests = [
      {m:'link valid',i:'${asd}',e:true},
      {m:'empty link ${} -invalid',i:'${}',e:false},
      {m:'${ just wrong',i:'${',e:false},
      {m:'anything  just wrong',i:'anything',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isConfigValueLink(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidDataNodeDir(value)', function() {
    var tests = [
      {m:'"dir" - invalid',i:'dir',e:false},
      {m:'"/dir" - valid',i:'/dir',e:true},
      {m:'"/dir1,dir2" - invalid',i:'/dir1,dir2',e:false},
      {m:'"/dir1,/dir2" - valid',i:'/dir1,/dir2',e:true},
      {m:'" /dir1,/dir2" - valid',i:' /dir1,/dir2',e:false},
      {m:'"/dir1, /dir2" - valid',i:' /dir1,/dir2',e:false},
      {m:'"/123" - valid',i:'/111',e:true},
      {m:'"/abc" - valid',i:'/abc',e:true},
      {m:'"/1a2b3c" - valid',i:'/1a2b3c',e:true},
      {m:'"[ssd]/1a2b3c" - valid',i:'[ssd]/1a2b3c',e:true},
      {m:'"[DISK]/1a2b3c" - valid',i:'[DISK]/1a2b3c',e:true},
      {m:'"[DISK]file:///1a2b3c" - valid',i:'[DISK]file:///1a2b3c',e:true},
      {m:'"[] /1a2b3c" - invalid',i:'[] /1a2b3c',e:false},
      {m:'"[ssd] /1a2b3c" - invalid',i:'[ssd] /1a2b3c',e:false},
      {m:'"[/1a2b3c]" - invalid',i:'[/1a2b3c]',e:false},
      {m:'"[s]ss /sd" - invalid',i:'[s]ss /sd',e:false},
      {m:'" [s]ss/sd" - invalid',i:' [s]ss/sd',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidDataNodeDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isAllowedDir(value)', function() {
    var tests = [
      {m:'"/home" - not allowed',i:'/home',e:false},
      {m:'"/homes" - not allowed',i:'/homes',e:false},
      {m:'"/home/" - not allowed',i:'/home/',e:false},
      {m:'"/homes/" - not allowed',i:'/homes/',e:false},
      {m:'"/dir" - allowed',i:'/dir',e:true},
      {m:'"/dir/home" - allowed',i:'/dir/home',e:true},
      {m:'"/dir/homes" - allowed',i:'/dir/homes',e:true},
      {m:'"/dir/home/" - allowed',i:'/dir/home/',e:true},
      {m:'"/dir/homes/" - allowed',i:'/dir/homes/',e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isAllowedDir(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidConfigKey(value)', function() {
    var tests = [
      {m:'"123" - valid',i:'123',e:true},
      {m:'"abc" - valid',i:'abc',e:true},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'".abc." - valid',i:'.abc.',e:true},
      {m:'"_abc_" - valid',i:'_abc_',e:true},
      {m:'"-abc-" - valid',i:'-abc-',e:true},
      {m:'"abc 123" - invalid',i:'abc 123',e:false},
      {m:'"a"b" - invalid',i:'a"b',e:false},
      {m:'"a\'b" - invalid',i:'a\'b',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidConfigKey(test.i)).to.equal(test.e);
      })
    });
  });
  describe('#isValidConfigGroupName(value)', function() {
    var tests = [
      {m:'"123" - valid',i:'123',e:true},
      {m:'"abc" - valid',i:'abc',e:true},
      {m:'"abc123" - valid',i:'abc123',e:true},
      {m:'".abc." - invalid',i:'.abc.',e:false},
      {m:'"_abc_" - valid',i:'_abc_',e:true},
      {m:'"-abc-" - valid',i:'-abc-',e:true},
      {m:'" abc  123 " - valid',i:' abc  123 ',e:true},
      {m:'"a"b" - invalid',i:'a"b',e:false},
      {m:'"a\'b" - invalid',i:'a\'b',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidConfigGroupName(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isValidMatchesRegexp()', function() {
    var message = '`{0}` should be {1}',
      tests = [
        { value: '.*', expected: true },
        { value: '..', expected: true },
        { value: '.a1', expected: true },
        { value: '.*a1', expected: true },
        { value: '.*a1.*', expected: true },
        { value: '.*a1.a2', expected: true },
        { value: '.*a1.*.a2', expected: true },
        { value: '.*a1.*.a2.*.a3.a4.*.*', expected: true },
        { value: '*', expected: false },
        { value: '1>1', expected: false },
        //{ value: '.*a1,*', expected: false },
        { value: '?a1[1]asd[1]', expected: false },
        { value: 'a1[1]asd[1]', expected: true },
        { value: 'a1[1]asd[1][', expected: false },
        { value: 'a1[1|1]asd[1]', expected: true },
        { value: '/a1[1|1]asd[1]', expected: true },
        { value: 'a1-2!', expected: true },
        { value: '|a1-2', expected: false },
        { value: '[a1', expected: false },
        { value: 'a{1}', expected: true },
        { value: 'a{1,2}', expected: true },
        { value: 'a{1,2}{', expected: false }
      ];
    tests.forEach(function(test) {
      it(message.format(test.value, (test.expected) ? 'valid' : 'not valid'), function() {
        expect(validator.isValidMatchesRegexp(test.value)).to.equal(test.expected);
      })
    });
  });

  describe('#isValidURL', function() {
    var tests = [
      {m:'"http://apache.org" - valid',i:'http://apache.org',e:true},
      {m:'"http://ambari.apache.org" - valid',i:'http://ambari.apache.org',e:true},
      {m:'"https://ambari.apache.org" - valid',i:'https://ambari.apache.org',e:true},
      {m:'"htp://ambari.apache.org." - invalid',i:'.htp://ambari.apache.org.',e:false},
      {m:'"ambari.apache.org" - invalid',i:'ambari.apache.org',e:false},
      {m:'"www.ambari.apache.org" - invalid',i:'www.ambari.apache.org',e:false},
      {m:'"" - invalid',i:'',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isValidURL(test.i)).to.equal(test.e);
      })
    });
  });

  describe('#isHostname()', function() {
    var tests = [
      {m:'"localhost" - valid',i:'localhost',e:true},
      {m:'"c6401.apache.ambari.org" - valid',i:'c6401.apache.ambari.org',e:true},
      {m:'"c6401.org" - valid',i:'c6401.org',e:true},
      {m:'"c6401" - invalid',i:'c6401',e:false},
      {m:'"c6401." - invalid',i:'c6401.',e:false}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(validator.isHostname(test.i)).to.equal(test.e);
      })
    });
  });
});

});

;require.register("test/views/application_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/application');

var view,
  modals = [],
  removed = false,
  events = [
      {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span class="close"></span></div></div>',
      particle: '',
      length: 0
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      which: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      keyCode: 27,
      key: 'Esc',
      html: '<div id="modal"><div class="modal-header"><span></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      which: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      keyCode: 13,
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success" disabled="disabled"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keydown',
      key: 'Enter',
      html: '<div id="modal"><div class="modal-footer"><span class="btn-success"></span></div></div>',
      particle: 'not ',
      length: 1
    },
    {
      event: 'keyup',
      key: 'Esc',
      html: '<div id="modal"><div class="modal-footer"><span class="close"></span></div></div>',
      particle: 'not ',
      length: 1
    }
  ];

describe.skip('App.ApplicationView', function () {

  before(function () {
    if($('#modal').length) {
      removed = true;
    }
    while($('#modal').length) {
      modals.push({
        modal: $('#modal'),
        parent: $('modal').parent()
      });
      $('#modal').remove();
    }
  });

  beforeEach(function () {
    view = App.ApplicationView.create({
      template: null
    });
  });

  afterEach(function () {
    $('#modal').remove();
  });

  after(function () {
    if (removed) {
      modals.forEach(function (item) {
        item.parent.append(item.modal);
      });
    }
  });

  describe('#didInsertElement', function () {
    events.forEach(function (item) {
      it('should ' + item.particle + 'close modal window on ' + item.key + ' press', function () {
        $('body').append(item.html);
        $('span').click(function () {
          $('#modal').remove();
        });
        view.didInsertElement();
        var e = $.Event(item.event);
        e.which = item.which;
        e.keyCode = item.keyCode;
        $(document).trigger(e);
        expect($('#modal')).to.have.length(item.length);
      });
    });
  });

});

});

;require.register("test/views/common/ajax_default_error_popup_body_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/ajax_default_error_popup_body');

describe('App.AjaxDefaultErrorPopupBodyView', function () {

  describe('#statusCode', function () {

    var view = App.AjaxDefaultErrorPopupBodyView.create();

    it('should format status code', function () {
      view.set('status', 404);
      expect(view.get('statusCode')).to.equal(Em.I18n.t('utils.ajax.defaultErrorPopupBody.statusCode').format(404));
    });

  });

  describe('#showMessage', function () {

    var view = App.AjaxDefaultErrorPopupBodyView.create(),
      title = 'should be {0}',
      cases = [
        {
          message: 'error',
          showMessage: true
        },
        {
          message: '',
          showMessage: false
        },
        {
          message: null,
          showMessage: false
        },
        {
          message: undefined,
          showMessage: false
        },
        {
          message: 0,
          showMessage: false
        }
      ];

    cases.forEach(function (item) {
      it(title.format(item.showMessage), function () {
        view.set('message', item.message);
        expect(view.get('showMessage')).to.equal(item.showMessage);
      });
    });

  });

  describe('#api', function () {

    var view = App.AjaxDefaultErrorPopupBodyView.create();

    it('should format string with request type and URL', function () {
      view.setProperties({
        type: 'GET',
        url: 'api/v1/clusters'
      });
      expect(view.get('api')).to.equal(Em.I18n.t('utils.ajax.defaultErrorPopupBody.message').format('GET', 'api/v1/clusters'));
    });

  });

});

});

;require.register("test/views/common/chart/linear_time_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/linear_time');

describe('App.ChartLinearTimeView', function () {

  var chartLinearTimeView = App.ChartLinearTimeView.create({});

  describe('#transformData', function () {

    var result;

    beforeEach(function () {
      var data = [[1, 1200000000], [2, 1200000000], [3, 1200000000]];
      var name = 'abc';
      sinon.stub(App.router, 'get').withArgs('userSettingsController.userSettings.timezone').returns('(UTC+00:00) Greenwich');
      result = chartLinearTimeView.transformData(data, name);
    });

    afterEach(function () {
      App.router.get.restore();
    });

    it('"name" should be "abc" ', function () {
      expect(result.name).to.equal('abc');
    });

    it('data size should be 3 ', function () {
      expect(result.data.length).to.equal(3);
    });

    it('data[0].y should be 1 ', function () {
      expect(result.data[0].y).to.equal(1);
    })

  });

  describe('#yAxisFormatter', function() {
    var tests = [
      {m:'undefined to 0',i:undefined,e:0},
      {m:'NaN to 0',i:NaN,e:0},
      {m:'0 to 0',i:'0',e:'0'},
      {m:'1000 to 1K',i:'1000',e:'1K'},
      {m:'1000000 to 1M',i:'1000000',e:'1M'},
      {m:'1000000000 to 1B',i:'1000000000',e:'1B'},
      {m:'1000000000000 to 1T',i:'1000000000000',e:'1T'},
      {m:'1048576 to 1.049M',i:'1048576',e:'1.049M'},
      {m:'1073741824 to 1.074B',i:'1073741824',e:'1.074B'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.yAxisFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#checkSeries', function() {
    var tests = [
      {m:'undefined - false',i:undefined,e:false},
      {m:'NaN - false',i:NaN,e:false},
      {m:'object without data property - false',i:[{}],e:false},
      {m:'object with empty data property - false',i:[{data:[]}],e:false},
      {m:'object with invalid data property - false',i:[{data:[1]}],e:false},
      {m:'object with valid data property - true',i:[{data:[{x:1,y:1},{x:2,y:2}]}],e:true}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(chartLinearTimeView.checkSeries(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#BytesFormatter', function() {
    var tests = [
      {m:'undefined to "0 B"',i:undefined,e:'0 B'},
      {m:'NaN to "0 B"',i:NaN,e:'0 B'},
      {m:'0 to "0 B"',i:0,e:'0 B'},
      {m:'124 to "124 B"',i:124,e:'124 B'},
      {m:'1024 to "1 KB"',i:1024,e:'1 KB'},
      {m:'1536 to "1 KB"',i:1536,e:'1.5 KB'},
      {m:'1048576 to "1 MB"',i:1048576,e:'1 MB'},
      {m:'1073741824 to "1 GB"',i:1073741824,e:'1 GB'},
      {m:'1610612736 to "1.5 GB"',i:1610612736,e:'1.5 GB'}
    ];

    tests.forEach(function(test) {
      it(test.m + ' ', function () {

        expect(App.ChartLinearTimeView.BytesFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#PercentageFormatter', function() {
    var tests = [
      {m:'undefined to "0 %"',i:undefined,e:'0 %'},
      {m:'NaN to "0 %"',i:NaN,e:'0 %'},
      {m:'0 to "0 %"',i:0,e:'0 %'},
      {m:'1 to "1%"',i:1,e:'1%'},
      {m:'1.12341234 to "1.123%"',i:1.12341234,e:'1.123%'},
      {m:'-11 to "-11%"',i:-11,e:'-11%'},
      {m:'-11.12341234 to "-11.123%"',i:-11.12341234,e:'-11.123%'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.PercentageFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe('#TimeElapsedFormatter', function() {
    var tests = [
      {m:'undefined to "0 ms"',i:undefined,e:'0 ms'},
      {m:'NaN to "0 ms"',i:NaN,e:'0 ms'},
      {m:'0 to "0 ms"',i:0,e:'0 ms'},
      {m:'1000 to "1000 ms"',i:1000,e:'1000 ms'},
      {m:'120000 to "2 m"',i:120000,e:'2 m'},
      {m:'3600000 to "60 m"',i:3600000,e:'60 m'},
      {m:'5000000 to "1 hr"',i:5000000,e:'1 hr'},
      {m:'7200000 to "2 hr"',i:7200000,e:'2 hr'},
      {m:'90000000 to "1 d"',i:90000000,e:'1 d'}
    ];
    tests.forEach(function(test) {
      it(test.m + ' ', function () {
        expect(App.ChartLinearTimeView.TimeElapsedFormatter(test.i)).to.equal(test.e);
      });
    });
  });

  describe("#getDataForAjaxRequest()", function() {
    var services = {
      yarnService: [],
      hdfsService: []
    };
    var rangeCases = [
      {
        currentTimeIndex: 0,
        customStartTime: 100000,
        customEndTime: 200000,
        fromSeconds: -3599,
        toSeconds: 1,
        title: 'preset time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: 100000,
        customEndTime: 200000,
        fromSeconds: 100,
        toSeconds: 200,
        title: 'custom time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: null,
        customEndTime: null,
        fromSeconds: -3599,
        toSeconds: 1,
        title: 'custom time range, no boundaries set'
      }
    ];
    beforeEach(function(){
      sinon.stub(App.HDFSService, 'find', function(){return services.hdfsService});
      sinon.stub(App.YARNService, 'find', function(){return services.yarnService});
      sinon.stub(App, 'dateTime').returns(1000);
      chartLinearTimeView.set('content', null);
    });
    afterEach(function(){
      App.HDFSService.find.restore();
      App.YARNService.find.restore();
      App.dateTime.restore();
    });

    it("content has hostName", function() {
      chartLinearTimeView.set('content', Em.Object.create({
        hostName: 'host1'
      }));
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: 'host1',
        nameNodeName: '',
        resourceManager: ''
      });
    });
    it("get Namenode host", function() {
      services.hdfsService = [
        Em.Object.create({
          nameNode: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: 'host1',
        resourceManager: ''
      });
      services.hdfsService = [];
    });
    it("get Namenode host HA", function() {
      services.hdfsService = [
        Em.Object.create({
          activeNameNode: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: 'host1',
        resourceManager: ''
      });
      services.hdfsService = [];
    });
    it("get resourceManager host", function() {
      services.yarnService = [
        Em.Object.create({
          resourceManager: {hostName: 'host1'}
        })
      ];
      expect(chartLinearTimeView.getDataForAjaxRequest()).to.be.eql({
        toSeconds: 1,
        fromSeconds: -3599,
        stepSeconds: 15,
        hostName: '',
        nameNodeName: '',
        resourceManager: 'host1'
      });
      services.yarnService = [];
    });
    rangeCases.forEach(function (item) {
      it(item.title, function () {
        chartLinearTimeView.setProperties({
          currentTimeIndex: item.currentTimeIndex,
          customStartTime: item.customStartTime,
          customEndTime: item.customEndTime,
          timeUnitSeconds: 3600
        });
        var requestData = Em.Object.create(chartLinearTimeView.getDataForAjaxRequest());
        expect(requestData.getProperties(['fromSeconds', 'toSeconds'])).to.eql({
          fromSeconds: item.fromSeconds,
          toSeconds: item.toSeconds
        });
      });
    });
  });

  describe('#setCurrentTimeIndexFromParent', function () {

    var view,
      cases = [
        {
          parent: 1,
          child: 2,
          result: 2,
          title: 'child and parent have currentTimeRangeIndex'
        },
        {
          parent: undefined,
          child: 2,
          result: 2,
          title: 'only child has currentTimeRangeIndex'
        },
        {
          parent: 1,
          child: undefined,
          result: 1,
          title: 'only parent has currentTimeRangeIndex'
        }
      ],
      isReadyCases = [
        {
          inWidget: true,
          isClusterMetricsWidget: true,
          parentViewIsLoaded: true,
          isReady: false,
          title: 'cluster metrics widget'
        },
        {
          inWidget: true,
          isClusterMetricsWidget: false,
          parentViewIsLoaded: false,
          isReady: true,
          title: 'enhanced service widget'
        },
        {
          inWidget: false,
          isClusterMetricsWidget: false,
          parentViewIsLoaded: true,
          isReady: false,
          title: 'non-widget graph'
        }
      ];

    beforeEach(function () {
      view = App.ChartLinearTimeView.create({
        isReady: true,
        controller: {},
        parentView: Em.Object.create({
          currentTimeRangeIndex: 1,
          isLoaded: true,
          parentView: Em.Object.create({
            currentTimeRangeIndex: 2
          })
        })
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('parentView.currentTimeRangeIndex', item.child);
        view.set('parentView.parentView.currentTimeRangeIndex', item.parent);
        view.propertyDidChange('parentView.currentTimeRangeIndex');
        expect(view.get('currentTimeIndex')).to.equal(item.result);
      });
    });

    isReadyCases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App.ajax, 'abortRequests', Em.K);
          view.set('inWidget', item.inWidget);
          view.set('parentView.isClusterMetricsWidget', item.isClusterMetricsWidget);
          view.propertyDidChange('parentView.currentTimeRangeIndex');
        });

        afterEach(function () {
          App.ajax.abortRequests.restore();
        });

        it('parentView.isLoaded', function () {
          expect(view.get('parentView.isLoaded')).to.eql(item.parentViewIsLoaded);
        });

        it('isReady', function () {
          expect(view.get('isReady')).to.eql(item.isReady);
        });

      });

    });

  });

  describe('#loadDataSuccessCallback', function () {

    beforeEach(function () {
      sinon.stub(chartLinearTimeView, '_refreshGraph', Em.K);
    });

    afterEach(function () {
      chartLinearTimeView._refreshGraph.restore();
    });

    it('should refresh graph', function () {
      var response = {
        key: 'value'
      };
      chartLinearTimeView.loadDataSuccessCallback(response);
      expect(chartLinearTimeView._refreshGraph.calledOnce).to.be.true;
      expect(chartLinearTimeView._refreshGraph.calledWith(response)).to.be.true;
    });
  });

  describe('#setYAxisFormatter', function () {

    var view,
      cases = [
        {
          displayUnit: '%',
          formatter: 'PercentageFormatter'
        },
        {
          displayUnit: 'B',
          formatter: 'BytesFormatter'
        },
        {
          displayUnit: 'ms',
          formatter: 'TimeElapsedFormatter'
        },
        {
          displayUnit: 'kg',
          formatter: 'DefaultFormatter',
          title: 'other display unit'
        },
        {
          formatter: 'DefaultFormatter',
          title: 'no display unit'
        }
      ],
      methodNames = ['PercentageFormatter', 'CreateRateFormatter', 'BytesFormatter', 'TimeElapsedFormatter', 'DefaultFormatter'];

    beforeEach(function () {
      view = App.ChartLinearTimeView.create();
      methodNames.forEach(function (name) {
        sinon.stub(App.ChartLinearTimeView, name, Em.K);
      });
    });

    afterEach(function () {
      methodNames.forEach(function (name) {
        App.ChartLinearTimeView[name].restore();
      });
    });

    cases.forEach(function (item) {
      it(item.title || item.displayUnit, function () {
        view.set('displayUnit', item.displayUnit);
        view.setYAxisFormatter();
        view.yAxisFormatter();
        methodNames.forEach(function (name) {
          expect(App.ChartLinearTimeView[name].callCount).to.equal(Number(name == item.formatter));
        });
      });
    });

  });

  describe('#localeTimeUnit', function () {

    var cases = [
      {
        timeUnitSeconds: 240,
        localeTimeUnit: '1 minute'
      },
      {
        timeUnitSeconds: 172788,
        localeTimeUnit: '719.95 minute'
      },
      {
        timeUnitSeconds: 172800,
        localeTimeUnit: 'day'
      },
      {
        timeUnitSeconds: 1209599,
        localeTimeUnit: 'day'
      },
      {
        timeUnitSeconds: 1209600,
        localeTimeUnit: 'week'
      },
      {
        timeUnitSeconds: 5183999,
        localeTimeUnit: 'week'
      },
      {
        timeUnitSeconds: 5184000,
        localeTimeUnit: 'month'
      },
      {
        timeUnitSeconds: 62207999,
        localeTimeUnit: 'month'
      },
      {
        timeUnitSeconds: 622080000,
        localeTimeUnit: 'year'
      },
      {
        timeUnitSeconds: 700000000,
        localeTimeUnit: 'year'
      }
    ];

    beforeEach(function () {
      sinon.stub(Rickshaw.Fixtures, 'Time').returns({
        unit: function (name) {
          return {
            name: name
          };
        }
      });
    });

    afterEach(function () {
      Rickshaw.Fixtures.Time.restore();
    });

    cases.forEach(function (item) {
      it(item.timeUnitSeconds + 's', function () {
        expect(chartLinearTimeView.localeTimeUnit(item.timeUnitSeconds).name).to.equal(item.localeTimeUnit);
      });
    });

  });

});


describe('App.ChartLinearTimeView.LoadAggregator', function () {

  var aggregator = App.ChartLinearTimeView.LoadAggregator;

  describe("#add()", function () {
    beforeEach(function () {
      sinon.stub(window, 'setTimeout').returns('timeId');
    });
    afterEach(function () {
      window.setTimeout.restore();
    });
    it("timeout started", function () {
      aggregator.set('timeoutId', 'timeId');
      aggregator.get('requests').clear();
      aggregator.add({}, {});
      expect(aggregator.get('requests')).to.not.be.empty;
      expect(window.setTimeout.called).to.be.false;
    });
    it("timeout started", function () {
      aggregator.set('timeoutId', null);
      aggregator.get('requests').clear();
      aggregator.add({}, {});
      expect(aggregator.get('requests')).to.not.be.empty;
      expect(window.setTimeout.calledOnce).to.be.true;
      expect(aggregator.get('timeoutId')).to.equal('timeId');
    });
  });

  describe("#groupRequests()", function () {
    it("", function () {
      var requests = [
        {
          name: 'r1',
          context: 'c1',
          fields: ['f1']
        },
        {
          name: 'r2',
          context: 'c2',
          fields: ['f2']
        },
        {
          name: 'r2',
          context: 'c3',
          fields: ['f3', 'f4']
        }
      ];
      var result = aggregator.groupRequests(requests);

      expect(result['r1'].subRequests.length).to.equal(1);
      expect(result['r1'].fields.length).to.equal(1);
      expect(result['r2'].subRequests.length).to.equal(2);
      expect(result['r2'].fields.length).to.equal(3);
    });
  });

  describe("#runRequests()", function () {
    beforeEach(function () {
      sinon.stub(aggregator, 'groupRequests', function (requests) {
        return requests;
      });
      sinon.stub(aggregator, 'formatRequestData', function(_request){
        return _request.fields;
      });
      sinon.stub(App.ajax, 'send', function(){
        return {
          done: Em.K,
          fail: Em.K,
          always: Em.K
        }
      });
    });
    afterEach(function () {
      aggregator.groupRequests.restore();
      App.ajax.send.restore();
      aggregator.formatRequestData.restore();
    });
    it("", function () {
      var context = Em.Object.create({
        content: {
          hostName: 'host1'
        },
        runningRequests: []
      });
      var requests = {
        'r1': {
          name: 'r1',
          context: context,
          fields: ['f3', 'f4']
        }
      };
      aggregator.runRequests(requests);
      expect(App.ajax.send.getCall(0).args[0]).to.eql({
        name: 'r1',
        sender: context,
        data: {
          fields: ['f3', 'f4'],
          hostName: 'host1'
        }
      });
    });
  });

  describe("#formatRequestData()", function () {
    var cases = [
      {
        currentTimeIndex: 0,
        customStartTime: 100000,
        customEndTime: 200000,
        result: 'f3[400,4000,15],f4[400,4000,15]',
        title: 'preset time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: 100000,
        customEndTime: 200000,
        result: 'f3[100,200,15],f4[100,200,15]',
        title: 'custom time range'
      },
      {
        currentTimeIndex: 8,
        customStartTime: null,
        customEndTime: null,
        result: 'f3[400,4000,15],f4[400,4000,15]',
        title: 'custom time range, no boundaries set'
      }
    ];
    beforeEach(function () {
      sinon.stub(App, 'dateTime').returns(4000000);
    });
    afterEach(function () {
      App.dateTime.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        var context = Em.Object.create({
          timeUnitSeconds: 3600,
          currentTimeIndex: item.currentTimeIndex,
          customStartTime: item.customStartTime,
          customEndTime: item.customEndTime
        });
        var request = {
          name: 'r1',
          context: context,
          fields: ['f3', 'f4']
        };
        expect(aggregator.formatRequestData(request)).to.equal(item.result);
      });
    });
  });

});

});

;require.register("test/views/common/configs/config_history_flow_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/config_history_flow');


describe.skip('App.ConfigHistoryFlowView', function () {

  var view = App.ConfigHistoryFlowView.create({
    controller: Em.Object.create({
      loadSelectedVersion: Em.K,
      loadStep: Em.K
    }),
    displayedServiceVersion: Em.Object.create(),
    serviceVersions: []
  });

  describe('#isSaveDisabled', function () {
    var testCases = [
      {
        params: {
          isSubmitDisabled: false,
          versionLoaded: true
        },
        result: false
      },
      {
        params: {
          isSubmitDisabled: true,
          versionLoaded: true
        },
        result: true
      },
      {
        params: {
          isSubmitDisabled: false,
          versionLoaded: false
        },
        result: true
      },
      {
        params: {
          isSubmitDisabled: true,
          versionLoaded: false
        },
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it('isSubmitDisabled - ' + test.params.isSubmitDisabled + ', versionLoaded - ' + test.params.versionLoaded, function () {
        view.set('controller.isSubmitDisabled', test.params.isSubmitDisabled);
        view.set('controller.versionLoaded', test.params.versionLoaded);
        expect(view.get('isSaveDisabled')).to.equal(test.result);
      });
    });
  });

  describe('#showMoreLink', function () {
    var testCases = [
      {
        params: {
          count: 0
        },
        result: false
      },
      {
        params: {
          count: 100
        },
        result: false
      },
      {
        params: {
          count: 101
        },
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it('notes length - ' + test.params.count, function () {
        view.set('displayedServiceVersion', Em.Object.create({
          notes: new Array(test.params.count)
        }));
        expect(view.get('showMoreLink')).to.equal(test.result);
      });
    });
  });

  describe('#shortNotes', function () {
    it('notes length more than 100', function () {
      view.set('displayedServiceVersion', Em.Object.create({
        notes: '12345678901234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890123'
      }));
      expect(view.get('shortNotes')).to.equal('1234567890123456789012345678901234567890123456789012345678901234567890123456789012345678901234567890...');
    });
    it('notes length less than 100', function () {
      view.set('displayedServiceVersion', Em.Object.create({
        notes: 'notes'
      }));
      expect(view.get('shortNotes')).to.equal('notes');
    });
  });

  describe('#visibleServiceVersion', function () {
    var testCases = [
      {
        params: {
          startIndex: 0,
          serviceVersions: []
        },
        result: []
      },
      {
        params: {
          startIndex: 0,
          serviceVersions: [1, 2, 3]
        },
        result: [1, 2, 3]
      },
      {
        params: {
          startIndex: 0,
          serviceVersions: [1, 2, 3, 4, 5, 6, 7]
        },
        result: [1, 2, 3, 4, 5]
      },
      {
        params: {
          startIndex: 3,
          serviceVersions: [1, 2, 3, 4, 5, 6, 7]
        },
        result: [4, 5, 6, 7]
      }
    ];
    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length, function () {
        view.set('serviceVersions', test.params.serviceVersions);
        view.set('startIndex', test.params.startIndex);
        view.propertyDidChange('visibleServiceVersion');
        expect(view.get('visibleServiceVersion')).to.eql(test.result);
      });
    });
  });

  describe('#versionActionsDisabled', function () {
    it('versionLoaded is false', function () {
      view.set('controller.versionLoaded', false);
      expect(view.get('versionActionsDisabled')).to.be.true;
    });
    it('versionLoaded is true', function () {
      view.set('controller.versionLoaded', true);
      expect(view.get('versionActionsDisabled')).to.be.false;
    });
  });

  describe('#dropDownList', function () {
    var displayedServiceVersion = {version: 1};

    it('Only one service version is present', function () {
      view.set('serviceVersions', [displayedServiceVersion]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.be.empty;
    });
    it('Three service version', function () {
      view.set('serviceVersions', [displayedServiceVersion, {version: 2}, {version: 3}]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([{version: 3}, {version: 2}]);
    });
    it('Seven service version, showFullList is false', function () {
      view.set('serviceVersions', [
        displayedServiceVersion,
        {version: 2},
        {version: 3},
        {version: 4},
        {version: 5},
        {version: 6},
        {version: 7},
        {version: 8}
      ]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.set('showFullList', false);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([
        {version: 8},
        {version: 7},
        {version: 6},
        {version: 5},
        {version: 4},
        {version: 3}
      ]);
    });
    it('Seven service version, showFullList is true', function () {
      view.set('serviceVersions', [
        displayedServiceVersion,
        {version: 2},
        {version: 3},
        {version: 4},
        {version: 5},
        {version: 6},
        {version: 7},
        {version: 8}
      ]);
      view.set('displayedServiceVersion', displayedServiceVersion);
      view.set('showFullList', true);
      view.propertyDidChange('dropDownList');
      expect(view.get('dropDownList')).to.eql([
        {version: 8},
        {version: 7},
        {version: 6},
        {version: 5},
        {version: 4},
        {version: 3},
        {version: 2}
      ]);
    });
  });

  describe('#openFullList()', function () {
    it('', function () {
      var event = {
        stopPropagation: Em.K
      };
      sinon.spy(event, 'stopPropagation');
      view.openFullList(event);
      expect(event.stopPropagation.calledOnce).to.be.true;
      expect(view.get('showFullList')).to.be.true;
      event.stopPropagation.restore();
    });
  });

  describe('#hideFullList()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: new Array(0)
        },
        result: true
      },
      {
        params: {
          serviceVersions: new Array(6)
        },
        result: true
      },
      {
        params: {
          serviceVersions: new Array(7)
        },
        result: false
      }
    ];
    testCases.forEach(function (test) {
      it('notes length - ' + test.params.count, function () {
        view.set('serviceVersions', test.params.serviceVersions);
        view.hideFullList();
        expect(view.get('showFullList')).to.equal(test.result);
      });
    });
  });

  describe('#didInsertElement()', function () {
    it('', function () {
      sinon.stub(App, 'tooltip');
      view.didInsertElement();
      expect(App.tooltip.calledOnce).to.be.true;
      App.tooltip.restore();
    });
  });

  describe('#willInsertElement()', function () {
    beforeEach(function () {
      sinon.stub(view, 'adjustFlowView', Em.K);
      sinon.stub(view, 'keepInfoBarAtTop', Em.K);
    });
    afterEach(function () {
      view.adjustFlowView.restore();
      view.keepInfoBarAtTop.restore();
    });
    it('Only current version is present', function () {
      view.set('serviceVersions', [Em.Object.create({isCurrent: true})]);

      view.willInsertElement();
      expect(view.adjustFlowView.calledOnce).to.be.true;
      expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      expect(view.get('startIndex')).to.equal(0);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true]);
    });
    it('Five service versions are present', function () {
      view.set('serviceVersions', [
        Em.Object.create({isCurrent: true}),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create()
      ]);

      view.willInsertElement();
      expect(view.adjustFlowView.calledOnce).to.be.true;
      expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      expect(view.get('startIndex')).to.equal(0);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true, false, false, false, false]);
    });
    it('Six service versions are present', function () {
      view.set('serviceVersions', [
        Em.Object.create({isCurrent: true}),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create(),
        Em.Object.create()
      ]);

      view.willInsertElement();
      expect(view.adjustFlowView.calledOnce).to.be.true;
      expect(view.keepInfoBarAtTop.calledOnce).to.be.true;
      expect(view.get('startIndex')).to.equal(1);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true, false, false, false, false, false]);
    });
  });

  describe('#setInfoBarPosition()', function () {
    var testCases = [
      {
        params: {
          scrollTop: 0,
          defaultTop: 0
        },
        result: 'auto'
      },
      {
        params: {
          scrollTop: 1,
          defaultTop: 11
        },
        result: '10px'
      },
      {
        params: {
          scrollTop: 1,
          defaultTop: 0
        },
        result: '10px'
      }
    ];
    var infoBar = {
      css: Em.K
    };
    testCases.forEach(function (test) {
      it('scroll top - ' + test.params.scrollTop + ', default top - ' + test.params.defaultTop, function () {
        sinon.spy(infoBar, 'css');
        view.setInfoBarPosition(infoBar, test.params.defaultTop, test.params.scrollTop);
        expect(infoBar.css.calledWith('top', test.result)).to.be.true;
        infoBar.css.restore();
      });
    });
  });

  describe('#adjustFlowView()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: [Em.Object.create()],
          startIndex: 0
        },
        result: {
          first: [true],
          showLeftArrow: false,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 0
        },
        result: {
          first: [true, false, false, false, false],
          showLeftArrow: false,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 0
        },
        result: {
          first: [true, false, false, false, false, false],
          showLeftArrow: false,
          showRightArrow: true
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 1
        },
        result: {
          first: [false, true, false, false, false, false],
          showLeftArrow: true,
          showRightArrow: false
        }
      },
      {
        params: {
          serviceVersions: [
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create(),
            Em.Object.create()
          ],
          startIndex: 1
        },
        result: {
          first: [false, true, false, false, false, false, false],
          showLeftArrow: true,
          showRightArrow: true
        }
      }
    ];

    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length, function () {
        view.set('startIndex', test.params.startIndex);
        view.set('serviceVersions', test.params.serviceVersions);

        view.adjustFlowView();
        expect(view.get('serviceVersions').mapProperty('first')).to.eql(test.result.first);
        expect(view.get('showLeftArrow')).to.eql(test.result.showLeftArrow);
        expect(view.get('showRightArrow')).to.eql(test.result.showRightArrow);
      });
    });
  });

  describe('#switchVersion()', function () {
    var event = {
      context: Em.Object.create({
        version: 2
      })
    };
    beforeEach(function(){
      sinon.stub(view, 'shiftFlowOnSwitch', Em.K);
      sinon.spy(view.get('controller'), 'loadSelectedVersion');
    });
    afterEach(function(){
      view.shiftFlowOnSwitch.restore();
      view.get('controller').loadSelectedVersion.restore();
    });
    it('Only one service version is present', function () {
      view.set('serviceVersions', [Em.Object.create({version: 2})]);
      view.switchVersion(event);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([true]);
      expect(view.get('controller').loadSelectedVersion.calledWith(2)).to.be.true;
      expect(view.shiftFlowOnSwitch.calledWith(0)).to.be.true;
    });
    it('Two service versions are present', function () {
      view.set('serviceVersions', [
        Em.Object.create({version: 1}),
        Em.Object.create({version: 2})
      ]);
      view.switchVersion(event);
      expect(view.get('serviceVersions').mapProperty('isDisplayed')).to.eql([false, true]);
      expect(view.get('controller').loadSelectedVersion.calledWith(2)).to.be.true;
      expect(view.shiftFlowOnSwitch.calledWith(1)).to.be.true;
    });
  });

  describe('#compare()', function () {
    it('should set compareServiceVersion', function () {
      view.compare({context: Em.Object.create({version: 1})});

      expect(view.get('controller.compareServiceVersion')).to.eql(Em.Object.create({version: 1}));
    });
  });

  describe('#revert()', function () {
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show', function (options) {
        options.onPrimary.call(Em.Object.create({
          serviceConfigNote: 'note',
          hide: Em.K
        }));
      });
      sinon.stub(view, 'sendRevertCall', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      view.sendRevertCall.restore();
    });
    it('context passed', function () {
      view.revert({context: Em.Object.create({
        version: 1,
        serviceName: 'S1'
      })});

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(view.sendRevertCall.calledWith(Em.Object.create({
        version: 1,
        serviceName: 'S1',
        serviceConfigNote: 'note'
      }))).to.be.true;
    });
    it('context is not passed', function () {
      view.set('displayedServiceVersion', Em.Object.create({
        version: 1,
        serviceName: 'S1'
      }));
      view.revert({});

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      expect(view.sendRevertCall.calledWith(Em.Object.create({
        version: 1,
        serviceName: 'S1',
        serviceConfigNote: 'note',
        notes: ''
      }))).to.be.true;
    });
  });

  describe('#sendRevertCall()', function () {
    it('', function () {
      sinon.stub(App.ajax, 'send', Em.K);
      view.sendRevertCall(Em.Object.create());

      expect(App.ajax.send.calledOnce).to.be.true;
      App.ajax.send.restore();
    });
  });

  describe('#sendRevertCallSuccess()', function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadStep');
      sinon.stub(App.router.get('updateController'), 'updateComponentConfig', Em.K);
    });
    afterEach(function () {
      view.get('controller').loadStep.restore();
      App.router.get('updateController').updateComponentConfig.restore();
    });
    it('', function () {
      view.sendRevertCallSuccess();

      expect(view.get('controller').loadStep.calledOnce).to.be.true;
      expect(App.router.get('updateController').updateComponentConfig.calledOnce).to.be.true;
    });
  });

  describe('#save()', function () {
    it('modal popup should be displayed', function () {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      view.save();

      expect(App.ModalPopup.show.calledOnce).to.be.true;
      App.ModalPopup.show.restore();
    });

    it('controller properties should be modified on save', function () {
      sinon.stub(App.ServiceConfigVersion, 'find').returns([
        {
          serviceName: 'service'
        }
      ]);
      view.setProperties({
        'serviceName': 'service',
        'controller.saveConfigsFlag': false,
        'controller.serviceConfigVersionNote': '',
        'controller.serviceConfigNote': '',
        'controller.preSelectedConfigVersion': null,
        'serviceConfigNote': 'note',
        'displayedServiceVersion.serviceName': 'service',
        'controller.selectedConfigGroup.name': 'group'
      });
      var popup = view.save();
      popup.onSave();
      expect(view.get('controller.saveConfigsFlag')).to.be.true;
      expect(view.get('controller').getProperties(['saveConfigsFlag', 'serviceConfigVersionNote', 'serviceConfigNote', 'preSelectedConfigVersion'])).to.eql({
        saveConfigsFlag: true,
        serviceConfigVersionNote: 'note',
        serviceConfigNote: this.get('serviceConfigNote'),
        preSelectedConfigVersion: Em.Object.create({
          version: 2,
          serviceName: 'service',
          groupName: 'group'
        })
      });
    });
  });

  describe('#shiftBack()', function () {
    it('', function () {
      sinon.stub(view, 'decrementProperty', Em.K);
      sinon.stub(view, 'adjustFlowView', Em.K);
      view.shiftBack();

      expect(view.decrementProperty.calledWith('startIndex')).to.be.true;
      expect(view.adjustFlowView.calledOnce).to.be.true;
      view.adjustFlowView.restore();
      view.decrementProperty.restore();
    });
  });

  describe('#shiftForward()', function () {
    it('', function () {
      sinon.stub(view, 'incrementProperty', Em.K);
      sinon.stub(view, 'adjustFlowView', Em.K);
      view.shiftForward();

      expect(view.incrementProperty.calledWith('startIndex')).to.be.true;
      expect(view.adjustFlowView.calledOnce).to.be.true;
      view.adjustFlowView.restore();
      view.incrementProperty.restore();
    });
  });

  describe('#adjustFlowView()', function () {
    var testCases = [
      {
        params: {
          serviceVersions: [],
          startIndex: 0,
          versionIndex: 1
        },
        result: {
          startIndex: 0,
          adjustFlowViewCall: false
        }
      },
      {
        params: {
          serviceVersions: new Array(6),
          startIndex: 7,
          versionIndex: 6
        },
        result: {
          startIndex: 1,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(12),
          startIndex: 7,
          versionIndex: 6
        },
        result: {
          startIndex: 6,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(12),
          startIndex: 0,
          versionIndex: 6
        },
        result: {
          startIndex: 6,
          adjustFlowViewCall: true
        }
      },
      {
        params: {
          serviceVersions: new Array(6),
          startIndex: 0,
          versionIndex: 6
        },
        result: {
          startIndex: 1,
          adjustFlowViewCall: true
        }
      }
    ];

    testCases.forEach(function (test) {
      it('start index - ' + test.params.startIndex + ', serviceVersions length - ' + test.params.serviceVersions.length + ', versionIndex - ' + test.params.versionIndex, function () {
        sinon.stub(view, 'adjustFlowView', Em.K);
        view.set('serviceVersions', test.params.serviceVersions);
        view.set('startIndex', test.params.startIndex);
        view.shiftFlowOnSwitch(test.params.versionIndex);

        expect(view.get('startIndex')).to.eql(test.result.startIndex);
        expect(view.adjustFlowView.calledOnce).to.eql(test.result.adjustFlowViewCall);
        view.adjustFlowView.restore();
      });
    });
  });
});

});

;require.register("test/views/common/configs/custom_category_views/notification_configs_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/custom_category_views/notification_configs_view');
var view;

describe('App.NotificationsConfigsView', function () {

  beforeEach(function () {
    view = App.NotificationsConfigsView.create({
      $: function() {
        return {show: Em.K, hide: Em.K};
      },
      category: {
        name: 'name'
      },
      serviceConfigs: [],
      parentView: Em.View.create({
        filter: '',
        columns: []
      })
    });
  });

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.stub(view, 'updateCategoryConfigs', Em.K);
    });

    afterEach(function () {
      view.updateCategoryConfigs.restore();
    });

    it('should not do nothing if no configs', function () {

      view.set('categoryConfigsAll', []);
      view.didInsertElement();
      expect(view.updateCategoryConfigs.called).to.equal(false);

    });

  });

});

});

;require.register("test/views/common/configs/overriddenProperty_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/configs/overriddenProperty_view');

describe('App.ServiceConfigView.SCPOverriddenRowsView', function () {

  var view = App.ServiceConfigView.SCPOverriddenRowsView.create();

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.spy(view, 'setSwitchText');
      sinon.stub(App, 'tooltip', Em.K);
    });

    afterEach(function () {
      view.setSwitchText.restore();
      App.tooltip.restore();
    });

    it('setSwitchLinks method should be executed', function () {
      view.didInsertElement();
      expect(view.setSwitchText.calledOnce).to.be.true;
    });

  });

  describe('#setSwitchText', function () {

    var view = App.ServiceConfigView.SCPOverriddenRowsView.create({
      serviceConfigProperty: {
        overrides: [
          Em.Object.create({
            group: Em.Object.create({
              displayName: 'hcg',
              switchGroupTextShort: 'short',
              switchGroupTextFull: 'full'
            })
          })
        ]
      }
    });

    beforeEach(function () {
      sinon.stub(App, 'tooltip', Em.K);
    });

    afterEach(function () {
      App.tooltip.restore();
    });

    it('should not modify overrides', function () {
      view.set('isDefaultGroupSelected', false);
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextShort')).to.equal('short');
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextFull')).to.equal('full');
    });

    it('should set switchGroupTextShort and switchGroupTextFull', function () {
      view.set('isDefaultGroupSelected', true);
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextShort')).to.equal(Em.I18n.t('services.service.config_groups.switchGroupTextShort').format('hcg'));
      expect(view.get('serviceConfigProperty.overrides.firstObject.group.switchGroupTextFull')).to.equal(Em.I18n.t('services.service.config_groups.switchGroupTextFull').format('hcg'));
    });

  });

});

});

;require.register("test/views/common/configs/service_config_container_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');

describe('App.ServiceConfigContainerView', function () {

  var view,
    selectedService = {
      configCategories: []
    };

  beforeEach(function () {
    view = App.ServiceConfigContainerView.create({
      filter: ''
    });
  });

  describe('#pushView', function () {
    it('shouldn\'t be launched before selectedService is set', function () {
      view.set('controller', {});
      view.pushView();
      expect(view.get('childViews')).to.be.empty;
    });
  });

  describe('#selectedServiceObserver', function () {

    it('should add a child view', function () {
      view.set('controller', Em.Object.create({
        selectedService: {
          configCategories: [],
          configs: []
        }
      }));
      expect(view.get('childViews')).to.have.length(1);
    });

    it('should set controller for the view', function () {
      view.set('controller', Em.Object.create({
        name: 'controller',
        selectedService: {
          configCategories: [],
          configs: []
        }
      }));
      expect(view.get('childViews.firstObject.controller.name')).to.equal('controller');
    });

    it('should add config categories', function () {
      view.set('controller', Em.Object.create({
        selectedService: {
          configCategories: [Em.Object.create(), Em.Object.create()],
          configs: []
        }
      }));
      expect(view.get('childViews.firstObject.serviceConfigsByCategoryView.childViews')).to.have.length(2);
    });

  });

});

});

;require.register("test/views/common/configs/service_config_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');

describe('App.ServiceConfigView', function () {

  var controller = App.WizardStep7Controller.create({
    selectedServiceObserver: Em.K,
    switchConfigGroupConfigs: Em.K
  });

  var view = App.ServiceConfigView.create({
    controller: controller
  });

  var testCases = [
    {
      title: 'selectedConfigGroup is null',
      result: {
        'category1': false,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: null,
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: false}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'xml', canAddProperty: false})
        ],
        configs: []
      }
    },
    {
      title: 'selectedConfigGroup is default group',
      result: {
        'category1': true,
        'category2': true,
        'category3': false
      },
      selectedConfigGroup: {isDefault: true},
      selectedService: {
        serviceName: 'TEST',
        configCategories: [
          App.ServiceConfigCategory.create({ name: 'category1', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category2', siteFileName: 'xml', canAddProperty: true}),
          App.ServiceConfigCategory.create({ name: 'category3', siteFileName: 'xml', canAddProperty: false})
        ],
        configs: []
      }
    }
  ];

  describe('#checkCanEdit', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        controller.set('selectedService', test.selectedService);
        controller.set('selectedConfigGroup', test.selectedConfigGroup);
        view.checkCanEdit();
        controller.get('selectedService.configCategories').forEach(function (category) {
          expect(category.get('canAddProperty')).to.equal(test.result[category.get('name')]);
        });
      });
    });
  });

  describe('#pickActiveTab', function () {

    Em.A([
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `settings` active (1)',
          e: 'settings'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: true}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `advanced` active (1)',
          e: 'advanced'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: true, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `settings` active (2)',
          e: 'settings'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: true, name: 'settings', isHiddenByFilter: true}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `advanced` active (2)',
          e: 'advanced'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: false, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `settings` active (3)',
          e: 'settings'
        },
        {
          tabs: [
            Em.Object.create({isAdvanced: false, isActive: false, name: 'settings', isHiddenByFilter: false}),
            Em.Object.create({isAdvanced: true, isActive: true, name: 'advanced', isHiddenByFilter: false})
          ],
          m: 'Should make `advanced` active (3)',
          e: 'advanced'
        }
    ]).forEach(function (test) {
        it(test.m, function () {
          view.pickActiveTab(test.tabs);
          expect(test.tabs.findProperty('name', test.e).get('isActive')).to.be.true;
        });
      });

  });

});

});

;require.register("test/views/common/configs/service_configs_by_category_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/chart/pie');
require('views/common/configs/services_config');

describe('App.ServiceConfigsByCategoryView', function () {

  var view = App.ServiceConfigsByCategoryView.create({
    serviceConfigs: []
  });

  var result = [1, 2, 3, 4];

  var testData = [
    {
      title: 'four configs in correct order',
      configs: [
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4})
      ]
    },
    {
      title: 'four configs in reverse order',
      configs: [
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'four configs in random order',
      configs: [
        Em.Object.create({index: 3, resultId: 3}),
        Em.Object.create({index: 4, resultId: 4}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2})
      ]
    },
    {
      title: 'four configs with no index',
      configs: [
        Em.Object.create({resultId: 1}),
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4})
      ]
    },
    {
      title: 'four configs but one with index',
      configs: [
        Em.Object.create({resultId: 2}),
        Em.Object.create({resultId: 3}),
        Em.Object.create({resultId: 4}),
        Em.Object.create({index: 1, resultId: 1})
      ]
    },
    {
      title: 'index is null or not number',
      configs: [
        Em.Object.create({index: null, resultId: 3}),
        Em.Object.create({index: 1, resultId: 1}),
        Em.Object.create({index: 2, resultId: 2}),
        Em.Object.create({index: 'a', resultId: 4})
      ]
    },
    {
      title: 'four configs when indexes skipped',
      configs: [
        Em.Object.create({index: 88, resultId: 3}),
        Em.Object.create({index: 67, resultId: 2}),
        Em.Object.create({index: 111, resultId: 4}),
        Em.Object.create({index: 3, resultId: 1})
      ]
    }
  ];

  describe('#sortByIndex', function () {
    testData.forEach(function(_test){
      it(_test.title, function () {
        expect(view.sortByIndex(_test.configs).mapProperty('resultId')).to.deep.equal(result);
      })
    })
  });

  describe('#isShowBlock', function() {
    var tests = [
      {
        categoryConfigs: Em.A([
          Em.Object.create({ isHiddenByFilter: false })
        ]),
        category: {},
        m: 'no configs with widget, filtered properties are visible. Panel should be shown',
        e: true
      },
      {
        categoryConfigs: Em.A([]),
        category: Em.Object.create({ customCanAddProperty: true}),
        m: 'Category with custom properties. Panel shouldn\'t be shown',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ isHiddenByFilter: false })
        ]),
        category: Em.Object.create({ customCanAddProperty: true}),
        m: 'Category with custom properties. Filtered configs are hidden. Panel should be shown',
        e: true
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ isHiddenByFilter: true })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Filtered configs are hidden. Category not for custom properties. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Category without properties and not for custom configurations. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: {someProp: 'a'}}),
          Em.Object.create({ widget: {someProp: 'b'}})
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'All properties have widgets and category is not custom. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: null }),
          Em.Object.create({ widget: null })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'All properties have widgets set to `null` and category is not custom. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: {someProp: 'a'} }),
          Em.Object.create({ isHiddenByFilter: true })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Category contains mixed properties. Properties are hidden by filter. Panel should be hidden',
        e: false
      },
      {
        categoryConfigs: Em.A([
          Em.Object.create({ widget: {someProp: 'a'} }),
          Em.Object.create({ isHiddenByFilter: false })
        ]),
        category: Em.Object.create({ customCanAddProperty: false }),
        m: 'Category contains mixed properties. Properties are visible. Panel should be shown',
        e: true
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        var _view = App.ServiceConfigsByCategoryView.create({
          serviceConfigs: Em.A([]),
          category: test.category,
          categoryConfigs: test.categoryConfigs
        });
        sinon.stub(_view, 'filteredCategoryConfigs', Em.K);
        _view.filteredCategoryConfigs.restore();
        expect(_view.get('isShowBlock')).to.be.eql(test.e);
        _view.destroy();
      });
    });
  });

  describe('#isSecureConfig', function () {

    var cases = [
      {
        name: 'n0',
        filename: 'f0',
        isSecureConfig: true,
        title: 'secure config'
      },
      {
        name: 'n1',
        filename: 'f1',
        isSecureConfig: false,
        title: 'secure config with the same name is present in another filename'
      },
      {
        name: 'n2',
        filename: 'f2',
        isSecureConfig: false,
        title: 'no configs of the specified filename are secure'
      }
    ];

    before(function () {
      App.config.reopen({
        secureConfigs: [
          {
            name: 'n0',
            filename: 'f0'
          },
          {
            name: 'n1',
            filename: 'f0'
          },
          {
            name: 'n2',
            filename: 'f1'
          }
        ]
      })
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        expect(view.isSecureConfig(item.name, item.filename)).to.equal(item.isSecureConfig);
      });
    });

  });

  describe('#createProperty', function () {

    var cases = [
      {
        propertyObj: {
          name: 'n0',
          displayName: 'd0',
          value: 'v0',
          filename: 'f0',
          categoryName: 'c0',
          serviceName: 's0'
        },
        isDefaultConfigGroup: true,
        result: {
          name: 'n0',
          displayName: 'd0',
          value: 'v0',
          displayType: 'string',
          isSecureConfig: true,
          category: 'c0',
          serviceName: 's0',
          savedValue: null,
          supportsFinal: true,
          filename: 'f0',
          isUserProperty: true,
          isNotSaved: true,
          isRequired: false,
          group: null,
          isOverridable: true
        },
        title: 'single line value, secure config, final attribute supported, default config group'
      },
      {
        propertyObj: {
          name: 'n1',
          value: 'v\n1',
          filename: '',
          categoryName: 'c1',
          serviceName: 's1'
        },
        isDefaultConfigGroup: false,
        result: {
          name: 'n1',
          displayName: 'n1',
          value: 'v\n1',
          displayType: 'multiLine',
          isSecureConfig: false,
          category: 'c1',
          serviceName: 's1',
          savedValue: null,
          supportsFinal: false,
          filename: '',
          isUserProperty: true,
          isNotSaved: true,
          isRequired: false,
          group: Em.Object.create({
            isDefault: false
          }),
          isOverridable: false
        },
        title: 'multiline value, non-secure config, no display name and filename, final attribute not supported, custom config group'
      }
    ];

    before(function () {
      view.get('serviceConfigs').clear();
      sinon.stub(view, 'isSecureConfig').withArgs('n0', 'f0').returns(true).withArgs('n1', '').returns(false);
      sinon.stub(App.config, 'shouldSupportFinal').withArgs('s0', 'f0').returns(true).withArgs('s1', '').returns(false);
    });

    after(function () {
      view.get('serviceConfigs').clear();
      view.isSecureConfig.restore();
      App.config.shouldSupportFinal.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.reopen({
          filteredCategoryConfigs: [],
          controller: {
            selectedConfigGroup: Em.Object.create({
              isDefault: item.isDefaultConfigGroup
            })
          }
        });
        view.createProperty(item.propertyObj);
        expect(view.get('serviceConfigs').filterProperty('name', item.propertyObj.name)).to.have.length(1);
        expect(view.get('serviceConfigs').findProperty('name', item.propertyObj.name).getProperties([
          'name', 'displayName', 'value', 'displayType', 'isSecureConfig', 'category', 'serviceName', 'savedValue',
          'supportsFinal', 'filename', 'isUserProperty', 'isNotSaved', 'isRequired', 'group', 'isOverridable'
        ])).to.eql(item.result);
      });
    });

  });

  describe('#categoryConfigs', function () {
    var view,
      result = [1,2,3,4,5],
      cases = [
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", index: 1, name: "a", isVisible: true, resultId: 1}),
            Em.Object.create({category: "TestCategory", index: 2, name: "b", isVisible: true, resultId: 2}),
            Em.Object.create({category: "TestCategory", index: 5, name: "c", isVisible: true, resultId: 5}),
            Em.Object.create({category: "TestCategory", index: 4, name: "d", isVisible: true, resultId: 4}),
            Em.Object.create({category: "TestCategory", index: 3, name: "e", isVisible: true, resultId: 3})
          ],
          title: 'Order by index with no content type'
        },
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", index: 1, name: "a", isVisible: true, resultId: 1, displayType: 'int'}),
            Em.Object.create({category: "TestCategory", index: 2, name: "b", isVisible: true, resultId: 4, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 3, name: "c", isVisible: true, resultId: 2}),
            Em.Object.create({category: "TestCategory", index: 4, name: "d", isVisible: true, resultId: 5, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 5, name: "e", isVisible: true, resultId: 3})
          ],
          title: 'Order configs by index and display type equal to content'
        },
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", name: "a", isVisible: true, resultId: 1, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "b", isVisible: true, resultId: 2, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "c", isVisible: true, resultId: 3, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "d", isVisible: true, resultId: 4, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", name: "e", isVisible: true, resultId: 5, displayType: 'content'})
          ],
          title: 'Order configs by display type equal to content - so they will be sorted alphabetically'
        },
        {
          categoryNname: 'TestCategory',
          serviceConfigs: [
            Em.Object.create({category: "TestCategory", index: 5, name: "a", isVisible: true, resultId: 1, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 4, name: "b", isVisible: true, resultId: 2, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 3, name: "c", isVisible: true, resultId: 3, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 2, name: "d", isVisible: true, resultId: 4, displayType: 'content'}),
            Em.Object.create({category: "TestCategory", index: 1, name: "e", isVisible: true, resultId: 5, displayType: 'content'})
          ],
          title: 'Order configs by display type equal to content - so they will be sorted alphabetically not by index'
        }
      ];

    cases.forEach(function (item) {
      it(item.title, function () {
        view = App.ServiceConfigsByCategoryView.create({
          category: {
            name: item.categoryNname
          },
          serviceConfigs: item.serviceConfigs
        });
        expect(view.get('categoryConfigs').mapProperty('resultId')).to.deep.equal(result);
      });
    });
  });
});

});

;require.register("test/views/common/configs/widgets/combo_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ComboConfigWidgetView', function() {

  beforeEach(function() {
    this.view = App.ComboConfigWidgetView.create({
      initPopover: Em.K
    });
  });

  afterEach(function() {
    this.view.destroy();
    this.view = null;
  });

  describe('#convertToWidgetUnits', function() {
    var tests = [
      {
        valueAttributes: {
          entries: [
            {
              label: "Item A",
              value: "a"
            },
            {
              label: "Item B",
              value: "b"
            },
          ]
        },
        e: [
          {
            configValue: "a",
            widgetValue: "Item A"
          },
          {
            configValue: "b",
            widgetValue: "Item B"
          }
        ]
      }
    ];

    tests.forEach(function(test) {
      it('should convert {0} to {1}'.format(JSON.stringify(test.valueAttributes), JSON.stringify(test.e)), function() {
        var result = this.view.convertToWidgetUnits(test.valueAttributes);
        expect(JSON.parse(JSON.stringify(result))).to.eql(test.e);
      });
    });
  });

  describe('#generateWidgetValue', function() {
    var tests = [
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'a',
        e: 'Item A'
      },
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'b',
        e: 'Item B'
      }
    ];

    tests.forEach(function(test) {
      it('should convert config value: `{0}` to widget value: `{1}`'.format(test.value, test.e), function() {
        this.view.set('content', {});
        this.view.set('content.valuesList', Em.A(test.valuesList));
        this.view.set('config', {
          isValid: true,
          value: test.value
        });
        expect(this.view.generateWidgetValue(test.value)).to.be.equal(test.e);
      });
    });
  });

  describe('#generateConfigValue', function() {
    var tests = [
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'Item A',
        e: 'a'
      },
      {
        valuesList: [
          Em.Object.create({
            configValue: 'a',
            widgetValue: 'Item A'
          }),
          Em.Object.create({
            configValue: 'b',
            widgetValue: 'Item B'
          })
        ],
        value: 'Item B',
        e: 'b'
      }
    ];

    tests.forEach(function(test) {
      it('should convert widget value: `{0}` to config value: `{1}`'.format(test.value, test.e), function() {
        this.view.set('content', {});
        this.view.set('content.valuesList', Em.A(test.valuesList));
        expect(this.view.generateConfigValue(test.value)).to.be.equal(test.e);
      });
    });
  });

  describe('#isValueCompatibleWithWidget()', function() {
    beforeEach(function() {
      this.view.set('content', {});
      this.view.set('config', {});
    });
    it('pass validation', function() {
      this.view.set('config.isValid', true);
      this.view.set('config.value', 'v1');
      this.view.set('content.valuesList', [{configValue: 'v1'}, {configValue: 'v2'}]);
      expect(this.view.isValueCompatibleWithWidget()).to.be.true;
    });

    it('fail validation by isValid', function() {
      this.view.set('config.isValid', false);
      expect(this.view.isValueCompatibleWithWidget()).to.be.false;
    });

    it('fail validation value that missing from list', function() {
      this.view.set('config.isValid', true);
      this.view.set('config.value', 'v3');
      this.view.set('content.valuesList', [{configValue: 'v1'}, {configValue: 'v2'}]);
      expect(this.view.isValueCompatibleWithWidget()).to.be.false;
    });
  });
});

});

;require.register("test/views/common/configs/widgets/config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;
describe('App.ConfigWidgetView', function () {

  beforeEach(function () {
    view = App.ConfigWidgetView.create({
      initPopover: Em.K,
      config: Em.Object.create({
        isOriginalSCP: false,
        isPropertyOverridable: false,
        cantBeUndone: false,
        isNotDefaultValue: false
      })
    });
  });

  describe('#undoAllowed', function () {

    Em.A([
      {
        cfg: {
          cantBeUndone: false,
          isNotDefaultValue: false
        },
        view: {
          disabled: false,
          isOriginalSCP: false
        },
        e: false
      },
      {
        cfg: {
          cantBeUndone: true,
          isNotDefaultValue: false
        },
        view: {
          disabled: false,
          isOriginalSCP: false
        },
        e: false
      },
      {
        cfg: {
          cantBeUndone: false,
          isNotDefaultValue: true
        },
        view: {
          disabled: false,
          isOriginalSCP: true
        },
        e: true
      },
      {
        cfg: {
          cantBeUndone: true,
          isNotDefaultValue: true
        },
        view: {
          disabled: true,
          isOriginalSCP: false
        },
        e: false
      }
    ]).forEach(function (test, index) {
        it('test #' + index, function () {
          view.get('config').setProperties(test.cfg);
          view.setProperties(test.view);
          expect(view.get('undoAllowed')).to.equal(test.e);
        });
      });

  });

  describe('#overrideAllowed', function () {

    Em.A([
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: false,
            isComparison: false
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: false,
            isComparison: false
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: true,
            isComparison: false
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: true,
            isComparison: false
          },
          e: true
        },
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: false,
            isComparison: true
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: false,
            isComparison: true
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: false,
            isPropertyOverridable: true,
            isComparison: true
          },
          e: false
        },
        {
          cfg: {
            isOriginalSCP: true,
            isPropertyOverridable: true,
            isComparison: true
          },
          e: false
        }
      ]).forEach(function (test, index) {
        it('test #' + index, function () {
          view.get('config').setProperties(test.cfg);
          expect(view.get('overrideAllowed')).to.equal(test.e);
        });
      });

  });

  describe('#restoreDependentConfigs', function() {
    beforeEach(function() {
      view = App.ConfigWidgetView.create({
        controller: Em.Object.extend(App.EnhancedConfigsMixin, {
        }).create({
          updateDependentConfigs: function() {},
        }),
        config: Em.Object.create({ name: 'config1'})
      });
    });

    var tests = [
      {
        dependentConfigs: [
          {name: 'dependent1', parentConfigs: ['config1']},
          {name: 'dependent2', parentConfigs: ['config2']},
          {name: 'dependent3', parentConfigs: ['config1']}
        ],
        e: ['dependent2'],
        m: 'when dependent configs has one parent they should be removed'
      },
      {
        dependentConfigs: [
          {name: 'dependent1', parentConfigs: ['config1', 'config2']},
          {name: 'dependent2', parentConfigs: ['config2']},
          {name: 'dependent3', parentConfigs: ['config1']}
        ],
        e: ['dependent1', 'dependent2'],
        m: 'when dependent configs has multiple parents they should not be removed'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller._dependentConfigValues', test.dependentConfigs);
        view.restoreDependentConfigs(view.get('config'));
        expect(view.get('controller._dependentConfigValues').mapProperty('name')).to.be.eql(test.e);
      });
    });

    it('when dependent configs has multiple parents appropriate parent config should be removed', function() {
      view.set('controller._dependentConfigValues', [
        {name: 'dependent1', parentConfigs: ['config1', 'config2']},
        {name: 'dependent2', parentConfigs: ['config2', 'config1']},
        {name: 'dependent3', parentConfigs: ['config1']}
      ]);
      view.restoreDependentConfigs(view.get('config'));
      expect(view.get('controller._dependentConfigValues').findProperty('name', 'dependent1').parentConfigs.toArray()).to.be.eql(["config2"]);
      expect(view.get('controller._dependentConfigValues').findProperty('name', 'dependent2').parentConfigs.toArray()).to.be.eql(["config2"]);
      expect(view.get('controller._dependentConfigValues.length')).to.be.eql(2);
    });

    it('dependent config value should be set with inital or saved when it has one parent', function() {
      var ctrl = view.get('controller');
      ctrl.set('stepConfigs', [
        Em.Object.create({
          configs: Em.A([
            Em.Object.create({ name: 'dependent3', savedValue: '1', value: 2, filename: 'some-file.xml' }),
            Em.Object.create({ name: 'dependent2', savedValue: '4', value: '10', filename: 'some-file.xml' })
          ])
        })
      ]);
      view.set('controller._dependentConfigValues', [
        {propertyName: 'dependent1', parentConfigs: ['config1', 'config2'], fileName: 'some-file' },
        {propertyName: 'dependent2', parentConfigs: ['config2', 'config1'], fileName: 'some-file'},
        {propertyName: 'dependent3', parentConfigs: ['config1'], fileName: 'some-file' }
      ]);
      view.restoreDependentConfigs(view.get('config'));
      expect(view.get('controller').findConfigProperty('dependent3', 'some-file.xml').get('value')).to.be.eql('1');
      // config with multi dependency should not be updated
      expect(view.get('controller').findConfigProperty('dependent2', 'some-file.xml').get('value')).to.be.eql('10');
    });

  });

  describe('#isValueCompatibleWithWidget()', function() {
    it('pass validation', function() {
      view.set('config.isValid', true);
      expect(view.isValueCompatibleWithWidget()).to.be.true;
    });

    it('fail validation', function() {
      view.set('config.isValid', false);
      view.set('supportSwitchToTextBox', true);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });
  });

  describe('#setRecommendedValue', function () {

    beforeEach(function () {
      sinon.stub(view, 'sendRequestRorDependentConfigs', function () {
        return $.Deferred().resolve().promise();
      });
      sinon.stub(view, 'restoreDependentConfigs', Em.K);
      view.set('config', Em.Object.create({
        value: 1,
        recommendedValue: 1,
        savedValue: 1
      }));
    });

    afterEach(function () {
      view.sendRequestRorDependentConfigs.restore();
      view.restoreDependentConfigs.restore();
    });

    it('should call restoreDependentConfigs if config.value is equal to config.savedValue', function () {
      view.setRecommendedValue();
      expect(view.restoreDependentConfigs.calledOnce).to.be.true;
    });

    it('should not call restoreDependentConfigs if config.value is not equal to config.savedValue', function () {
      view.set('config.savedValue', 2);
      view.setRecommendedValue();
      expect(view.restoreDependentConfigs.called).to.be.false;
    });

  });

});

});

;require.register("test/views/common/configs/widgets/list_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;
describe('App.ListConfigWidgetView', function () {

  beforeEach(function () {

    view = App.ListConfigWidgetView.create({
      initPopover: Em.K,
      config: Em.Object.create({
        validate: App.ServiceConfigProperty.prototype.validate,
        name: 'a.b.c',
        savedValue: '2,1',
        value: '2,1',
        filename: 'f1',
        isFinal: false,
        supportsFinal: true,
        stackConfigProperty: Em.Object.create({
          valueAttributes: {
            entries: [
              {
                value: '1',
                label: 'first label',
                description: '1'
              },
              {
                value: '2',
                label: 'second label',
                description: '2'
              },
              {
                value: '3',
                label: 'third label',
                description: '3'
              },
              {
                value: '4',
                label: '4th label',
                description: '4'
              },
              {
                value: '5',
                label: '4th label',
                description: '5'
              }
            ],
            selection_cardinality: '3'
          }
        })
      }),
      controller: App.MainServiceInfoConfigsController.create({})
    });
    view.willInsertElement();
    view.didInsertElement();

  });

  describe('#displayVal', function () {

    it('init value', function () {
      expect(view.get('displayVal')).to.equal('second label, first label');
    });

    it('deselect all', function () {
      view.get('options').setEach('isSelected', false);
      expect(view.get('displayVal')).to.equal(Em.I18n.t('services.service.widgets.list-widget.nothingSelected'));
    });

    it('check that value is trimmed', function () {
      view.get('options').setEach('isSelected', true);
      expect(view.get('displayVal').endsWith(' ...')).to.be.true;
    });

  });

  describe('#calculateOptions', function () {

    it('should create options for each entry', function () {
      view.set('options', []);
      view.calculateOptions();
      expect(view.get('options.length')).to.equal(view.get('config.stackConfigProperty.valueAttributes.entries.length'));
    });

    it('should selected options basing on `value`-property', function () {
      expect(view.get('options').mapProperty('isSelected')).to.eql([true, true, false, false, false]);
    });

    it('should set order to the options basing on `value`-property', function () {
      expect(view.get('options').mapProperty('order')).to.eql([2, 1, 0, 0, 0]);
    });

    it('should disable options basing on `valueAttributes.selection_cardinality`-property', function () {
      expect(view.get('options').everyProperty('isDisabled', false)).to.be.true;
    });

  });

  describe('#calculateInitVal', function () {

    it('should take only selected options', function () {
      expect(view.get('val').length).to.equal(2);
    });

    it('should set `val` empty if `value` is empty', function() {
      view.set('val', [{}]);
      view.set('config.value', '');
      view.calculateInitVal();
      expect(view.get('val')).to.eql([]);
    });

  });

  describe('#calculateVal', function () {

    it('value updates if some option', function () {
      view.toggleOption({context: view.get('options')[2]});
      expect(view.get('config.value')).to.equal('2,1,3');
      view.toggleOption({context: view.get('options')[1]});
      expect(view.get('config.value')).to.equal('1,3');
      view.toggleOption({context: view.get('options')[1]});
      expect(view.get('config.value')).to.equal('1,3,2');
    });

  });

  describe('#restoreValue', function () {

    beforeEach(function() {
      sinon.stub(view, 'restoreDependentConfigs', Em.K);
      sinon.stub(view.get('controller'), 'removeCurrentFromDependentList', Em.K)
    });
    afterEach(function() {
      view.restoreDependentConfigs.restore();
      view.get('controller.removeCurrentFromDependentList').restore();
    });
    it('should restore saved value', function () {
      view.toggleOption({context: view.get('options')[0]});
      view.toggleOption({context: view.get('options')[1]});
      view.toggleOption({context: view.get('options')[2]});
      expect(view.get('config.value')).to.equal('3');
      view.restoreValue();
      expect(view.get('config.value')).to.equal('2,1');
      expect(view.get('controller.removeCurrentFromDependentList')).to.be.called
    });

  });

  describe('#toggleOption', function () {

    it('should doesn\'t do nothing if maximum number of options is selected', function () {
      view.toggleOption({context: view.get('options')[2]});
      expect(view.get('options')[2].get('isSelected')).to.be.true;
      expect(view.get('options')[3].get('isDisabled')).to.be.true;
      expect(view.get('options')[3].get('isSelected')).to.be.false;
      expect(view.get('options')[4].get('isDisabled')).to.be.true;
      expect(view.get('options')[4].get('isSelected')).to.be.false;
      view.toggleOption({context: view.get('options')[3]});
      expect(view.get('options')[3].get('isDisabled')).to.be.true;
      expect(view.get('options')[3].get('isSelected')).to.be.false;
    });

  });

  describe('#checkSelectedItemsCount', function () {

    beforeEach(function () {
      view.set('config.stackConfigProperty.valueAttributes.selection_cardinality', '1+');
      view.parseCardinality();
    });

    it('should check minimum count of the selected items', function () {
      view.get('options').setEach('isSelected', false);
      expect(view.get('config.errorMessage')).to.have.property('length').that.is.least(1);
      view.get('options').setEach('isSelected', true);
      expect(view.get('config.errorMessage')).to.equal('');
    });
  });

  describe('#onOptionsChangeBeforeRender', function () {

    beforeEach(function () {
      sinon.stub(view, 'calculateOptions', Em.K);
      sinon.stub(view, 'calculateInitVal', Em.K);
      view.onOptionsChangeBeforeRender();
    });

    afterEach(function () {
      view.calculateOptions.restore();
      view.calculateInitVal.restore();
    });

    it('should calculate options array', function () {
      expect(view.calculateOptions.calledOnce).to.be.true;
    });

    it('should calculate initial value', function () {
      expect(view.calculateInitVal.calledOnce).to.be.true;
    });

  });

  describe('#onOptionsChangeAfterRender', function () {

    var cases = [
      {
        calculateValCallCount: 1,
        isValueCompatibleWithWidget: true,
        title: 'correct value'
      },
      {
        calculateValCallCount: 0,
        isValueCompatibleWithWidget: false,
        title: 'incorrect value'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(view, 'addObserver', Em.K);
          sinon.stub(view, 'calculateVal', Em.K);
          sinon.stub(view, 'checkSelectedItemsCount', Em.K);
          sinon.stub(view, 'isValueCompatibleWithWidget').returns(item.isValueCompatibleWithWidget);
          view.onOptionsChangeAfterRender();
        });

        afterEach(function () {
          view.addObserver.restore();
          view.calculateVal.restore();
          view.checkSelectedItemsCount.restore();
          view.isValueCompatibleWithWidget.restore();
        });

        it('observers registration', function () {
          expect(view.addObserver.calledTwice).to.be.true;
        });

        it('calculateVal observer', function () {
          expect(view.addObserver.firstCall.args).to.eql(['options.@each.isSelected', view, view.calculateVal]);
        });

        it('checkSelectedItemsCount observer', function () {
          expect(view.addObserver.secondCall.args).to.eql(['options.@each.isSelected', view, view.checkSelectedItemsCount]);
        });

        it('value calculation', function () {
          expect(view.calculateVal.callCount).to.equal(item.calculateValCallCount);
        });

        it('should check selected items count', function () {
          expect(view.checkSelectedItemsCount.calledOnce).to.be.true;
        });

      });

    });

  });

  describe('#entriesObserver', function () {

    beforeEach(function () {
      sinon.stub(view, 'removeObserver', Em.K);
      sinon.stub(view, 'onOptionsChangeBeforeRender', Em.K);
      sinon.stub(view, 'initIncompatibleWidgetAsTextBox', Em.K);
      sinon.stub(view, 'onOptionsChangeAfterRender', Em.K);
      view.entriesObserver();
    });

    afterEach(function () {
      view.removeObserver.restore();
      view.onOptionsChangeBeforeRender.restore();
      view.initIncompatibleWidgetAsTextBox.restore();
      view.onOptionsChangeAfterRender.restore();
    });

    it('observers removal', function () {
      expect(view.removeObserver.calledTwice).to.be.true;
    });

    it('calculateVal observer', function () {
      expect(view.removeObserver.firstCall.args).to.eql(['options.@each.isSelected', view, view.calculateVal]);
    });

    it('checkSelectedItemsCount observer', function () {
      expect(view.removeObserver.secondCall.args).to.eql(['options.@each.isSelected', view, view.checkSelectedItemsCount]);
    });

    it('first options change handler', function () {
      expect(view.onOptionsChangeBeforeRender.calledOnce).to.be.true;
    });

    it('incompatible value processing', function () {
      expect(view.initIncompatibleWidgetAsTextBox.calledOnce).to.be.true;
    });

    it('second options change handler', function () {
      expect(view.onOptionsChangeAfterRender.calledOnce).to.be.true;
    });


  });


});

});

;require.register("test/views/common/configs/widgets/slider_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var validator = require('utils/validator');
var viewInt, viewFloat, viewPercent;

describe('App.SliderConfigWidgetView', function () {

  beforeEach(function () {
    viewInt = App.SliderConfigWidgetView.create({
      initSlider: Em.K,
      initPopover: Em.K,
      slider: {
        enable: Em.K,
        disable: Em.K,
        setValue: Em.K
      },
      config: App.ServiceConfigProperty.create({
        name: 'a.b.c',
        description: 'A B C',
        value: '486',
        savedValue: '486',
        stackConfigProperty: Em.Object.create({
          valueAttributes: Em.Object.create({
            type: 'int',
            minimum: '0',
            maximum: '2096',
            unit: 'MB',
            group1: {
              maximum: '3072'
            }
          }),
          widget: Em.Object.create({
            type: 'slider',
            units: [{ 'unit-name': 'MB'}]
          })
        })
      })
    });
    viewInt.willInsertElement();
    viewInt.didInsertElement();

    viewFloat = App.SliderConfigWidgetView.create({
      initSlider: Em.K,
      initPopover: Em.K,
      slider: {
        enable: Em.K,
        disable: Em.K,
        setValue: Em.K
      },
      config: App.ServiceConfigProperty.create({
        name: 'a.b.c2',
        description: 'A B C 2',
        value: '72.2',
        savedValue: '72.2',
        stackConfigProperty: Em.Object.create({
          valueAttributes: Em.Object.create({
            type: 'float',
            minimum: '0',
            maximum: '100'
          }),
          widget: Em.Object.create({
            type: 'slider',
            units: [{ 'unit-name': 'float'}]
          })
        })
      })
    });
    viewFloat.willInsertElement();
    viewFloat.didInsertElement();

    viewPercent = App.SliderConfigWidgetView.create({
      initSlider: Em.K,
      initPopover: Em.K,
      slider: {
        enable: Em.K,
        disable: Em.K,
        setValue: Em.K
      },
      config: App.ServiceConfigProperty.create({
        name: 'a.b.c3',
        description: 'A B C 3',
        value: '0.22',
        savedValue: '0.22',
        stackConfigProperty: Em.Object.create({
          valueAttributes: Em.Object.create({
            type: 'float',
            minimum: '0',
            maximum: '0.8'
          }),
          widget: Em.Object.create({
            type: 'slider',
            units: [{ 'unit-name': 'percent'}]
          })
        })
      })
    });
    viewPercent.willInsertElement();
    viewPercent.didInsertElement();

    sinon.stub(viewInt, 'changeBoundaries', Em.K);
    sinon.stub(viewFloat, 'changeBoundaries', Em.K);
    sinon.stub(viewPercent, 'changeBoundaries', Em.K);
  });

  afterEach(function() {
    viewInt.changeBoundaries.restore();
    viewFloat.changeBoundaries.restore();
    viewPercent.changeBoundaries.restore();
  });

  describe('#mirrorValue', function () {
    it('should be equal to config.value after init', function () {
      expect('' + viewInt.get('mirrorValue')).to.equal(viewInt.get('config.value'));
      expect('' + viewFloat.get('mirrorValue')).to.equal(viewFloat.get('config.value'));
    });

    it('should be converted according to widget format', function() {
      expect(viewPercent.get('mirrorValue')).to.equal(22);
    });
  });

  describe('#mirrorValueObs', function () {

    it('check int', function () {
      viewInt.set('mirrorValue', 1000);
      expect(viewInt.get('isMirrorValueValid')).to.be.true;
      expect(viewInt.get('config.value')).to.equal('1000');
      expect(viewInt.get('config.errorMessage')).to.equal('');
      expect(viewInt.get('config.warnMessage')).to.equal('');
      expect(viewInt.get('config.warn')).to.be.false;

      viewInt.set('mirrorValue', 100500);
      expect(viewInt.get('isMirrorValueValid')).to.be.false;
      expect(viewInt.get('config.value')).to.equal('1000');
      expect(viewInt.get('config.errorMessage')).to.equal('');
      expect(viewInt.get('config.warnMessage')).to.have.property('length').that.is.least(1);
      expect(viewInt.get('config.warn')).to.be.true;
    });

    it('check float', function () {
      viewFloat.set('mirrorValue', 55.5);
      expect(viewFloat.get('isMirrorValueValid')).to.be.true;
      expect(viewFloat.get('config.value')).to.equal('55.5');
      expect(viewFloat.get('config.errorMessage')).to.equal('');
      expect(viewFloat.get('config.warnMessage')).to.equal('');
      expect(viewFloat.get('config.warn')).to.be.false;

      viewFloat.set('mirrorValue', 100500.5);
      expect(viewFloat.get('isMirrorValueValid')).to.be.false;
      expect(viewFloat.get('config.value')).to.equal('55.5');
      expect(viewFloat.get('config.errorMessage')).to.equal('');
      expect(viewFloat.get('config.warnMessage')).to.have.property('length').that.is.least(1);
      expect(viewFloat.get('config.warn')).to.be.true;
    });

    it('check percent', function () {
      viewPercent.set('mirrorValue', 32);
      expect(viewPercent.get('isMirrorValueValid')).to.be.true;
      expect(viewPercent.get('config.value')).to.equal('0.32');
      expect(viewPercent.get('config.errorMessage')).to.equal('');
      expect(viewPercent.get('config.warnMessage')).to.equal('');
      expect(viewPercent.get('config.warn')).to.be.false;

      viewPercent.set('mirrorValue', 100500.5);
      expect(viewPercent.get('isMirrorValueValid')).to.be.false;
      expect(viewPercent.get('config.value')).to.equal('0.32');
      expect(viewPercent.get('config.errorMessage')).to.equal('');
      expect(viewPercent.get('config.warnMessage')).to.have.property('length').that.is.least(1);
      expect(viewPercent.get('config.warn')).to.be.true;
    });
  });

  describe('#getValueAttributeByGroup', function() {
    it('returns default max value', function() {
      viewInt.set('config.group', null);
      expect(viewInt.getValueAttributeByGroup('maximum')).to.equal('2096');
    });

    it('returns max value for group1', function() {
      viewInt.set('config.group', {name: 'group1'});
      expect(viewInt.getValueAttributeByGroup('maximum')).to.equal('3072');
    });
  });

  describe('#initSlider', function() {
    beforeEach(function() {
      this.view = App.SliderConfigWidgetView;
    });

    afterEach(function() {
      this.view.destroy();
      this.view = null;
    });

    var tests = [
      {
        viewSetup: {
          minMirrorValue: 20,
          maxMirrorValue: 100,
          widgetRecommendedValue: 30,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'float' },
              widget: { units: [ { 'unit-name': "percent"}]}
            })
          })
        },
        e: {
          ticks: [20,30,40,60,80,90,100],
          ticksLabels: ['20 %', '', '', '60 %', '', '', '100 %']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 5,
          maxMirrorValue: 50,
          widgetRecommendedValue: 35,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int' },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [5, 16, 22, 28, 35, 39, 50],
          ticksLabels: ['5 ','', '', '28 ', '', '', '50 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 2,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [1,2],
          ticksLabels: ['1 ', '2 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 3,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [1,2,3],
          ticksLabels: ['1 ', '2 ', '3 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0,
          maxMirrorValue: 3,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [0,1,2,3],
          ticksLabels: ['0 ', '1 ', '2 ', '3 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 5,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [1,2,3,4,5],
          ticksLabels: ['1 ', '', '3 ', '', '5 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0,
          maxMirrorValue: 5,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [0,2,3,5],
          ticksLabels: ['0 ', '2 ', '3 ', '5 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0,
          maxMirrorValue: 23,
          widgetRecommendedValue: 2,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { type: 'int', increment_step: 1 },
              widget: { units: [ { 'unit-name': "int"}]}
            })
          })
        },
        e: {
          ticks: [0,2,6,12,17,20,23],
          ticksLabels: ['0 ', '', '', '12 ', '', '', '23 ']
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 30,
          widgetRecommendedValue: 1,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: { unit: "B", type: "int", minimum: "1048576", maximum: "31457280", increment_step: "262144" },
              widget: { units: [ { 'unit-name': "MB"}]}
            })
          })
        },
        e: {
          ticks: [1, 8.25, 15.5, 22.75, 30],
          ticksLabels: ["1 MB", "", "15.5 MB", "", "30 MB"]
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 100,
          widgetRecommendedValue: 10,
          config: Em.Object.create({
            stackConfigProperty: Em.Object.create({
              valueAttributes: {unit: "B", type: "int", minimum: "1073741824", maximum: "107374182400", increment_step: "1073741824"},
              widget: { units: [ { 'unit-name': "GB"}]}
            })
          })
        },
        e: {
          ticks: [1, 10, 26, 51, 75, 87.5, 100],
          ticksLabels: ["1 GB", "", "", "51 GB", "", "", "100 GB"]
        }
      },
      {
        viewSetup: {
          minMirrorValue: 1,
          maxMirrorValue: 100,
          isCompareMode: true,
          widgetRecommendedValue: 10,
          config: Em.Object.create({
            isOriginalSCP: false,
            stackConfigProperty: Em.Object.create({
              valueAttributes: {unit: "B", type: "int", minimum: "1073741824", maximum: "107374182400", increment_step: "1073741824"},
              widget: { units: [ { 'unit-name': "GB"}]}
            })
          })
        },
        e: {
          ticks: [1, 26, 51, 75, 100],
          ticksLabels: ["1 GB", "", "51 GB", "", "100 GB"]
        }
      },
      {
        viewSetup: {
          minMirrorValue: 0.166,
          maxMirrorValue: 0.5,
          isCompareMode: false,
          widgetRecommendedValue: 0.166,
          config: Em.Object.create({
            isOriginalSCP: true,
            stackConfigProperty: Em.Object.create({
              valueAttributes: {unit: "MB", type: "int", minimum: "170", maximum: "512", increment_step: "256"},
              widget: {"units":[{"unit-name":"GB"}]}
            })
          })
        },
        e: {
          ticks: [0.166, 0.416, 0.5],
          ticksLabels: ["0.166 GB", "0.416 GB", "0.5 GB"]
        }
      }
    ];

    tests.forEach(function(test) {
      it('should generate ticks: {0} - tick labels: {1}'.format(test.e.ticks, test.e.ticksLabels), function() {
        var ticks, ticksLabels;
        this.view = this.view.create(test.viewSetup);
        this.view.set('controller', {
          isCompareMode: test.viewSetup.isCompareMode
        });
        var sliderCopy= window.Slider.prototype;
        window.Slider = function(a, b) {
          ticks = b.ticks;
          ticksLabels = b.ticks_labels;
          return {
            on: function() {
              return this;
            }
          };
        };
        sinon.stub(this.view, '$')
          .withArgs('input.slider-input').returns([])
          .withArgs('.ui-slider-wrapper:eq(0) .slider-tick').returns({
            eq: Em.K,
            addClass: Em.K,
            on: Em.K,
            append: Em.K,
            find: Em.K,
            css: Em.K,
            width: function() {},
            last: Em.K,
            hide: Em.K
          });
        this.view.willInsertElement();
        this.view.initSlider();
        window.Slider.prototype = sliderCopy;
        this.view.$.restore();
        expect(ticks.toArray()).to.be.eql(test.e.ticks);
        expect(ticksLabels.toArray()).to.be.eql(test.e.ticksLabels);
      });
    });
  });

  describe('#isValueCompatibleWithWidget', function() {
    var stackConfigProperty = null;

    beforeEach(function() {
      viewInt.set('config', {});
      stackConfigProperty = App.StackConfigProperty.createRecord({name: 'p1', widget: { units: [ { 'unit-name': "int"}]}, valueAttributes: {minimum: 1, maximum: 10, increment_step: 4, type: 'int'}});
      viewInt.set('config.stackConfigProperty', stackConfigProperty);
      viewInt.set('config.isValid', true);
    });

    it ('fail by config validation', function() {
      viewInt.set('config.isValid', false);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation', function() {
      viewInt.set('config.value', 'a');
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation int', function() {
      viewInt.set('config.value', '2.2');
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation float', function() {
      viewFloat.set('config.value', '2.2.2');
      viewFloat.set('validateFunction', validator.isValidFloat);
      expect(viewFloat.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail: to large', function() {
      viewInt.set('config.value', 12);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
      expect(viewInt.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(viewInt.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: to small', function() {
      viewInt.set('config.value', 0);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.false;
      expect(viewInt.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(viewInt.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: for wrong step', function() {
      viewInt.set('config.stackConfigProperty', stackConfigProperty);
      viewInt.set('config.value', '3');
      expect(viewInt.isValueCompatibleWithWidget()).to.be.true;
    });

    it ('ok', function() {
      viewInt.set('config.value', 4);
      expect(viewInt.isValueCompatibleWithWidget()).to.be.true;
      expect(viewInt.get('warnMessage')).to.equal('');
      expect(viewInt.get('issueMessage')).to.equal('');
    });
  });

});

});

;require.register("test/views/common/configs/widgets/time_interval_spinner_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.TimeIntervalSpinnerView', function () {

  beforeEach(function () {
    view = App.TimeIntervalSpinnerView.create({
      controller: Em.Object.create({
        removeCurrentFromDependentList: Em.K
      }),
      initPopover: Em.K
    });
    sinon.stub(Em.run, 'once', Em.K);
  });

  afterEach(function () {
    view.destroy();
    Em.run.once.restore();
  });

  describe('#generateWidgetValue', function () {

    var createProperty = function (widgetUnits, configPropertyUnits, incrementStep) {
      return Em.Object.create({
        stackConfigProperty: Em.Object.create({
          widget: {
            units: [
              { unit: widgetUnits }
            ]
          },
          valueAttributes: {
            unit: configPropertyUnits,
            increment_step: incrementStep
          }
        })
      });
    };

    var tests = [
      {
        input: 60000,
        config: createProperty("days,hours,minutes", "milliseconds", 1000),
        e: [
          { label: 'Days', value: 0, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 0, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 1, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "2592000000",
        config: createProperty("days,hours,minutes", "milliseconds", 60000),
        e: [
          { label: 'Days', value: 30, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 0, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 0, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "604800000",
        config: createProperty("days,hours,minutes", "milliseconds", 60000),
        e: [
          { label: 'Days', value: 7, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 0, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 0, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "804820200",
        config: createProperty("days,hours,minutes", "milliseconds", 60000),
        e: [
          { label: 'Days', value: 9, incrementStep: 1, enabled: true},
          { label: 'Hours', value: 7, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 33, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "70000",
        config: createProperty("minutes", "milliseconds", 1000),
        e: [
          { label: 'Minutes', value: 1, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "140",
        config: createProperty("hours,minutes", "minutes", 1),
        e: [
          { label: 'Hours', value: 2, incrementStep: 1, enabled: true},
          { label: 'Minutes', value: 20, incrementStep: 1, enabled: true}
        ]
      },
      {
        input: "2",
        config: createProperty("hours", "hours", 1),
        e: [
          { label: 'Hours', value: 2, incrementStep: 1, enabled: true}
        ]
      }
    ];

    tests.forEach(function (test) {
      it('should convert {0} {1} to {2}'.format(test.input, test.config.get('stackConfigProperty.valueAttributes.unit'), JSON.stringify(test.e)), function () {
        view.set('config', test.config);
        var result = view.generateWidgetValue(test.input, test.inputType, test.desiredUnits).map(function (item) {
          // remove unnecessary keys
          return App.permit(item, ['label', 'value', 'enabled', 'incrementStep']);
        });
        expect(result).to.eql(test.e);
      });
    });

  });

  describe('#parseIncrement', function () {

    var createProperty = function (widgetUnits, configPropertyUnits, incrementStep, value, min, max) {
      return Em.Object.create({
        value: value,
        isValid: true,
        stackConfigProperty: Em.Object.create({
          widget: {
            units: [
              { unit: widgetUnits }
            ]
          },
          valueAttributes: {
            unit: configPropertyUnits,
            minimum: min,
            maximum: max,
            increment_step: incrementStep
          }
        })
      });
    };

    Em.A([
        {
          input: "120000",
          config: createProperty("minutes,seconds", "milliseconds", 10000, "120000", 0, 240000),
          e: [
            { label: 'Minutes', value: 2, incrementStep: 1, enabled: true},
            { label: 'Seconds', value: 0, incrementStep: 10, enabled: true}
          ]
        },
        {
          input: "120000",
          config: createProperty("minutes,seconds", "milliseconds", 60000, "120000", "0", "240000"),
          e: [
            { label: 'Minutes', value: 2, incrementStep: 1, enabled: true},
            { label: 'Seconds', value: 0, incrementStep: 60, enabled: false}
          ]
        }
      ]).forEach(function (test) {
        it('should convert {0} {1} to {2}'.format(test.input, test.config.get('stackConfigProperty.valueAttributes.unit'), JSON.stringify(test.e)), function () {
          view.set('config', test.config);
          view.prepareContent();
          var result = view.get('content').map(function (c) {
            return App.permit(c, ['label', 'value', 'incrementStep', 'enabled']);
          });
          expect(result).to.eql(test.e);
        });
      });

  });

  describe('#checkErrors', function () {

    Em.A([
        {
          config: Em.Object.create({
            value: "540",
            isValid: true,
            stackConfigProperty: Em.Object.create({
              widget: {
                units: [
                  { unit: "hours,minutes" }
                ]
              },
              valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
            })
          }),
          e: {
            warnMessage: Em.I18n.t('config.warnMessage.outOfBoundaries.less').format("10 Minutes"),
            warn: true
          }
        },
        {
          config: Em.Object.create({
            value: "86460",
            isValid: true,
            stackConfigProperty: Em.Object.create({
              widget: {
                units: [
                  { unit: "hours,minutes" }
                ]
              },
              valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
            })
          }),
          e: {
            warnMessage: Em.I18n.t('config.warnMessage.outOfBoundaries.greater').format("24 Hours"),
            warn: true
          }
        },
        {
          config: Em.Object.create({
            value: "12000",
            stackConfigProperty: Em.Object.create({
              widget: {
                units: [
                  { unit: "hours,minutes" }
                ]
              },
              valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
            })
          }),
          e: {
            warnMessage:'',
            warn: false
          }
        }
      ]).forEach(function (test) {
        it('', function () {
          view.set('config', test.config);
          view.prepareContent();
          view.checkErrors();
          expect(view.get('config.warnMessage')).to.equal(test.e.warnMessage);
          expect(view.get('config.warn')).to.equal(test.e.warn);
        });
      });

  });

  describe('#isValueCompatibleWithWidget', function() {
    var stackConfigProperty = null;

    beforeEach(function() {
      view.set('config', Em.Object.create({}));
      stackConfigProperty = App.StackConfigProperty.createRecord({
        name: 'p1', valueAttributes: {
          minimum: 1, maximum: 10, increment_step: 4, type: 'int', unit: 'seconds'
        },
        widget: {
          units: [
            {
              'unit-name': 'hours,minutes'
            }
          ]
        }
      });
      view.set('config.stackConfigProperty', stackConfigProperty);
      view.set('config.isValid', true);
      view.set('maxValue', [{"value":10,"type":"hours","minValue":0,"maxValue":10,"incrementStep":1,"enabled":true},{"value":0,"type":"minutes","minValue":0,"maxValue":59,"incrementStep":1,"enabled":true}]);
      view.set('minValue', [{"value":0,"type":"hours","minValue":0,"maxValue":23,"incrementStep":1,"enabled":true},{"value":10,"type":"minutes","minValue":0,"maxValue":59,"incrementStep":1,"enabled":true}]);
    });

    it ('fail by config validation', function() {
      view.set('config.isValid', false);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation', function() {
      view.set('config.value', 'a');
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail by view validation int', function() {
      view.set('config.value', '2.2');
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('fail: to large', function() {
      view.set('config.value', 12);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
      expect(view.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(view.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: to small', function() {
      view.set('config.value', 0);
      expect(view.isValueCompatibleWithWidget()).to.be.false;
      expect(view.get('warnMessage')).to.have.property('length').that.is.least(1);
      expect(view.get('issueMessage')).to.have.property('length').that.is.least(1);
    });

    it ('fail: wrong step', function() {
      view.set('config.stackConfigProperty', stackConfigProperty);
      view.set('config.value', '3');
      expect(view.isValueCompatibleWithWidget()).to.be.false;
    });

    it ('ok', function() {
      view.set('config.value', 4);
      expect(view.isValueCompatibleWithWidget()).to.be.true;
      expect(view.get('warnMessage')).to.equal('');
      expect(view.get('issueMessage')).to.equal('');
    });
  });

  describe('#showAsTextBox', function() {
    Em.A([
      {
        config: App.ServiceConfigProperty.create({
          value: "600",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          })
        }),
        m: 'original config with valid value should be shown as widget',
        e: false
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "test",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          })
        }),
        m: 'original config with invalid value should be shown as textbox',
        e: true
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "600",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          }),
          parentSCP: Em.Object.create({ value: "600" })
        }),
        m: 'overriden config have same value as original and values of both configs are valid, widget should be shown',
        e: false
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "test",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          }),
          parentSCP: Em.Object.create({ value: "test" })
        }),
        m: 'overriden config have same value as original and values of both configs are NOT valid, textbox should be shown',
        e: true
      },
      {
        config: App.ServiceConfigProperty.create({
          value: "test",
          isValid: true,
          stackConfigProperty: Em.Object.create({
            widget: {
              units: [
                { unit: "hours,minutes" }
              ]
            },
            valueAttributes: {type: "int", maximum: "86400", minimum: "600", unit: "seconds"}
          }),
          parentSCP: Em.Object.create({ value: "500" })
        }),
        m: 'overriden config have different value as original and values of override NOT valid, textbox should be shown',
        e: true
      }
    ]).forEach(function (test) {
      it(test.m, function() {
        view.set('config', test.config);
        view.didInsertElement();
        expect(view.get('config.showAsTextBox')).to.eql(test.e);
      });
    });
  });
});

});

;require.register("test/views/common/configs/widgets/toggle_config_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ToggleConfigWidgetView', function () {

  beforeEach(function () {

    this.view = App.ToggleConfigWidgetView.create({
      initSwitcher: Em.K,
      initPopover: Em.K,
      config: Em.Object.create({
        name: 'a.b.c',
        value: 'active',
        savedValue: 'active',
        stackConfigProperty: Em.Object.create({
          valueAttributes: {
            "type": "value-list",
            "entries":
              [
                {value: "active", label: "Active"},
                {value: "inactive", label: "Inactive"}
              ],
            "entries_editable": "false",
            "selection_cardinality": 1
          }
        })
      })
    });
    this.view.didInsertElement();
  });

  afterEach(function() {
    this.view.destroy();
    this.view = null;
  });

  describe('#getNewSwitcherValue', function () {

    it('should represent string value to boolean', function () {
      expect(this.view.getNewSwitcherValue('inactive')).to.be.false;
      expect(this.view.getNewSwitcherValue('active')).to.be.true;
    });

  });

  describe('#updateConfigValue', function () {

    it('should represent boolean value to string', function () {
      this.view.set('switcherValue', false);
      expect(this.view.get('config.value')).to.equal('inactive');
      this.view.set('switcherValue', true);
      expect(this.view.get('config.value')).to.equal('active');
    });

  });

  describe('#isValueCompatibleWithWidget', function () {

    Em.A([
      {
        m: 'valid',
        v: 'active',
        e: true
      },
      {
        m: 'invalid',
        v: 'invalid',
        e: false
      }
    ]).forEach(function (test) {
      it(test.m, function () {
        this.view.get('config').setProperties({
          value: test.v,
          isValid: true
        });
        expect(this.view.isValueCompatibleWithWidget()).to.equal(test.e);
        if (test.e) {
          expect(this.view.get('warnMessage')).to.equal('');
          expect(this.view.get('issueMessage')).to.equal('');
        }
        else {
          expect(this.view.get('warnMessage')).to.have.property('length').that.is.least(1);
          expect(this.view.get('issueMessage')).to.have.property('length').that.is.least(1);
        }
      });
    });

  });

});

});

;require.register("test/views/common/controls_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/controls_view');

describe('App.ServiceConfigRadioButtons', function () {

  var view;

  beforeEach(function () {
    view = App.ServiceConfigRadioButtons.create();
  });

  describe('#setConnectionUrl', function () {
    beforeEach(function () {
      sinon.stub(view, 'getPropertyByType', function (name) {
        return App.ServiceConfigProperty.create({'name': name});
      });
      sinon.stub(view, 'getDefaultPropertyValue', function () {
        return 'host:{0},db:{1}';
      });
    });

    afterEach(function () {
      view.getPropertyByType.restore();
      view.getDefaultPropertyValue.restore();
    });

    it('updates value for connection url', function () {
      expect(view.setConnectionUrl('hostName', 'dbName').get('value')).to.equal('host:hostName,db:dbName');
    });
  });

  describe('#setRequiredProperties', function () {

    beforeEach(function () {
      view.reopen({
        serviceConfig: Em.Object.create(),
        categoryConfigsAll: [
          App.ServiceConfigProperty.create({
            name: 'p1',
            value: 'v1'
          }),
          App.ServiceConfigProperty.create({
            name: 'p2',
            value: 'v2'
          })
        ]
      });
      sinon.stub(view, 'getPropertyByType', function (name) {
        return view.get('categoryConfigsAll').findProperty('name', name);
      });
      sinon.stub(view, 'getDefaultPropertyValue', function (name) {
        return name + '_v';
      });
    });

    afterEach(function () {
      view.getPropertyByType.restore();
      view.getDefaultPropertyValue.restore();
    });

    it('updates value for connection url', function () {
      view.setRequiredProperties(['p2', 'p1']);
      expect(view.get('categoryConfigsAll').findProperty('name', 'p1').get('value')).to.equal('p1_v');
      expect(view.get('categoryConfigsAll').findProperty('name', 'p2').get('value')).to.equal('p2_v');
    });
  });

  describe('#handleDBConnectionProperty', function () {

    var cases = [
        {
          dbType: 'mysql',
          driver: 'mysql-connector-java.jar',
          serviceConfig: {
            name: 'hive_database',
            value: 'New MySQL Database',
            serviceName: 'HIVE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'javax.jdo.option.ConnectionURL',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'hive_database',
                  displayName: 'Hive Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'javax.jdo.option.ConnectionURL',
          propertyAppendTo2: 'hive_database',
          isAdditionalView1Null: true,
          isAdditionalView2Null: true,
          title: 'Hive, embedded database'
        },
        {
          dbType: 'postgres',
          driver: 'postgresql.jar',
          serviceConfig: {
            name: 'hive_database',
            value: 'Existing PostgreSQL Database',
            serviceName: 'HIVE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'javax.jdo.option.ConnectionURL',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'hive_database',
                  displayName: 'Hive Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'javax.jdo.option.ConnectionURL',
          propertyAppendTo2: 'hive_database',
          isAdditionalView1Null: false,
          isAdditionalView2Null: false,
          title: 'Hive, external database'
        },
        {
          dbType: 'derby',
          driver: 'driver.jar',
          serviceConfig: {
            name: 'oozie_database',
            value: 'New Derby Database',
            serviceName: 'OOZIE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'oozie.service.JPAService.jdbc.url',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'oozie_database',
                  displayName: 'Oozie Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'oozie.service.JPAService.jdbc.url',
          propertyAppendTo2: 'oozie_database',
          isAdditionalView1Null: true,
          isAdditionalView2Null: true,
          title: 'Oozie, embedded database'
        },
        {
          dbType: 'oracle',
          driver: 'ojdbc6.jar',
          serviceConfig: {
            name: 'oozie_database',
            value: 'Existing Oracle Database',
            serviceName: 'OOZIE'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'oozie.service.JPAService.jdbc.url',
                  displayName: 'Database URL'
                }),
                Em.Object.create({
                  name: 'oozie_database',
                  displayName: 'Oozie Database'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'oozie.service.JPAService.jdbc.url',
          propertyAppendTo2: 'oozie_database',
          isAdditionalView1Null: false,
          isAdditionalView2Null: false,
          title: 'Oozie, external database'
        },
        {
          dbType: 'mysql',
          driver: 'mysql-connector-java.jar',
          serviceConfig: {
            name: 'DB_FLAVOR',
            value: 'MYSQL',
            serviceName: 'RANGER'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'ranger.jpa.jdbc.url'
                }),
                Em.Object.create({
                  name: 'DB_FLAVOR'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.2',
          rangerVersion: '0.4.0',
          propertyAppendTo1: 'ranger.jpa.jdbc.url',
          propertyAppendTo2: 'DB_FLAVOR',
          isAdditionalView1Null: true,
          isAdditionalView2Null: true,
          title: 'Ranger, HDP 2.2, external database'
        },
        {
          dbType: 'mssql',
          driver: 'sqljdbc4.jar',
          serviceConfig: {
            name: 'DB_FLAVOR',
            value: 'MSSQL',
            serviceName: 'RANGER'
          },
          controller: Em.Object.create({
            selectedService: {
              configs: [
                Em.Object.create({
                  name: 'ranger.jpa.jdbc.url'
                }),
                Em.Object.create({
                  name: 'DB_FLAVOR'
                })
              ]
            }
          }),
          currentStackVersion: 'HDP-2.3',
          rangerVersion: '0.5.0',
          propertyAppendTo1: 'ranger.jpa.jdbc.url',
          propertyAppendTo2: 'DB_FLAVOR',
          isAdditionalView1Null: false,
          isAdditionalView2Null: false,
          title: 'Ranger, HDP 2.3, external database'
        }
      ];

    before(function () {
      sinon.stub(Em.run, 'next', function (arg) {
        arg();
      });
    });

    afterEach(function () {
      App.get.restore();
      App.StackService.find.restore();
      view.sendRequestRorDependentConfigs.restore();
    });

    after(function () {
      Em.run.next.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App, 'get').withArgs('currentStackName').returns('HDP').withArgs('currentStackVersion').returns(item.currentStackVersion);
        sinon.stub(App.StackService, 'find', function() {
          return [Em.Object.create({
            serviceName: 'RANGER',
            serviceVersion: item.rangerVersion || ''
          })];
        });
        view.reopen({controller: item.controller});
        sinon.stub(view, 'sendRequestRorDependentConfigs', Em.K);
        view.setProperties({
          categoryConfigsAll: item.controller.get('selectedService.configs'),
          serviceConfig: item.serviceConfig
        });
        var additionalView1 = view.get('categoryConfigsAll').findProperty('name', item.propertyAppendTo1).get('additionalView'),
          additionalView2 = view.get('categoryConfigsAll').findProperty('name', item.propertyAppendTo2).get('additionalView');
        expect(Em.isNone(additionalView1)).to.equal(item.isAdditionalView1Null);
        expect(Em.isNone(additionalView2)).to.equal(item.isAdditionalView2Null);
        if (!item.isAdditionalView2Null) {
          expect(additionalView2.create().get('message')).to.equal(Em.I18n.t('services.service.config.database.msg.jdbcSetup').format(item.dbType, item.driver));
        }
      });
    });

  });

  describe('#options', function () {

    var options = [
        {
          displayName: 'MySQL'
        },
        {
          displayName: 'New PostgreSQL Database'
        },
        {
          displayName: 'existing postgres db'
        },
        {
          displayName: 'sqla database: existing'
        },
        {
          displayName: 'SQL Anywhere database (New)'
        },
        {
          displayName: 'displayName'
        }
      ],
      classNames = ['mysql', 'new-postgres', 'postgres', 'sqla', 'new-sqla', undefined];

    beforeEach(function () {
      view.reopen({
        serviceConfig: Em.Object.create({
          options: options
        })
      });
    });

    it('should set class names for options', function () {
      expect(view.get('options').mapProperty('displayName')).to.eql(options.mapProperty('displayName'));
      expect(view.get('options').mapProperty('className')).to.eql(classNames);
    });

  });

  describe('#name', function () {

    var cases = [
      {
        serviceConfig: {
          radioName: 'n0',
          isOriginalSCP: true,
          isComparison: false
        },
        name: 'n0',
        title: 'original value'
      },
      {
        serviceConfig: {
          radioName: 'n1',
          isOriginalSCP: false,
          isComparison: true,
          compareConfigs: []
        },
        controller: {
          selectedVersion: 1
        },
        name: 'n1-v1',
        title: 'comparison view, original value'
      },
      {
        serviceConfig: {
          radioName: 'n2',
          isOriginalSCP: false,
          isComparison: true,
          compareConfigs: null
        },
        version: 2,
        name: 'n2-v2',
        title: 'comparison view, value to be compared with'
      },
      {
        serviceConfig: {
          radioName: 'n3',
          isOriginalSCP: false,
          isComparison: false,
          group: {
            name: 'g'
          }
        },
        name: 'n3-g',
        title: 'override value'
      }
    ];

    beforeEach(function () {
      view.reopen({
        serviceConfig: Em.Object.create()
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        if (item.controller) {
          view.reopen({
            controller: item.controller
          });
        }
        view.set('version', item.version);
        view.get('serviceConfig').setProperties(item.serviceConfig);
        expect(view.get('name')).to.equal(item.name);
      });
    });

  });

  describe('#dontUseHandleDbConnection', function () {
    var rangerService = Em.Object.create({
      serviceName: 'RANGER'
    });
    beforeEach(function () {
      sinon.stub(App.StackService, 'find', function () {
        return [rangerService];
      });
    });

    afterEach(function () {
      App.StackService.find.restore();
    });

    var cases = [
      {
        title: 'Should return properties for old version of Ranger',
        version: '0.1',
        result: ['DB_FLAVOR', 'authentication_method']
      },
      {
        title: 'Should return properties for old version of Ranger',
        version: '0.4.0',
        result: ['DB_FLAVOR', 'authentication_method']
      },
      {
        title: 'Should return properties for old version of Ranger',
        version: '0.4.9',
        result: ['DB_FLAVOR', 'authentication_method']
      },
      {
        title: 'Should return properties for new version of Ranger',
        version: '0.5.0',
        result: ['ranger.authentication.method']
      },
      {
        title: 'Should return properties for new version of Ranger',
        version: '1.0.0',
        result: ['ranger.authentication.method']
      },
      {
        title: 'Should return properties for new version of Ranger',
        version: '0.5.0.1',
        result: ['ranger.authentication.method']
      }
    ];

    cases.forEach(function (test) {
      it(test.title, function () {
        rangerService.set('serviceVersion', test.version);
        expect(view.get('dontUseHandleDbConnection')).to.eql(test.result);
      });
    });
  });

});

describe('App.ServiceConfigRadioButton', function () {

  describe('#disabled', function () {

    var cases = [
      {
        wizardControllerName: 'addServiceController',
        value: 'New MySQL Database',
        title: 'Add Service Wizard, new database',
        disabled: false
      },
      {
        wizardControllerName: 'installerController',
        value: 'New MySQL Database',
        title: 'Install Wizard, new database',
        disabled: false
      },
      {
        wizardControllerName: 'addServiceController',
        value: 'Existing MySQL Database',
        title: 'Add Service Wizard, existing database',
        disabled: false
      },
      {
        wizardControllerName: 'installerController',
        value: 'Existing MySQL Database',
        title: 'Install Wizard, existing database',
        disabled: false
      },
      {
        wizardControllerName: null,
        value: 'New MySQL Database',
        title: 'No installer, new database',
        disabled: true
      },
      {
        wizardControllerName: null,
        value: 'Existing MySQL Database',
        title: 'No installer, existing database',
        disabled: false
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        var view = App.ServiceConfigRadioButton.create({
          parentView: Em.Object.create({
            serviceConfig: Em.Object.create()
          }),
          controller: Em.Object.create({
            wizardController: Em.Object.create({
              name: null
            })
          })
        });
        view.set('value', item.value);
        view.set('controller.wizardController.name', item.wizardControllerName);
        view.set('parentView.serviceConfig.isEditable', true);
        expect(view.get('disabled')).to.equal(item.disabled);
      });
    });

    it('parent view is disabled', function () {
      var view = App.ServiceConfigRadioButton.create({
        parentView: Em.Object.create({
          serviceConfig: Em.Object.create()
        })
      });
      view.set('parentView.serviceConfig.isEditable', false);
      expect(view.get('disabled')).to.be.true;
    });

  });

});

describe('App.CheckDBConnectionView', function () {

  describe('#masterHostName', function () {

    var cases = [
        {
          serviceName: 'OOZIE',
          value: 'h0'
        },
        {
          serviceName: 'KERBEROS',
          value: 'h1'
        },
        {
          serviceName: 'HIVE',
          value: 'h2'
        },
        {
          serviceName: 'RANGER',
          value: 'h3'
        }
      ],
      categoryConfigsAll = [
        Em.Object.create({
          name: 'oozie_server_hosts',
          value: 'h0'
        }),
        Em.Object.create({
          name: 'kdc_host',
          value: 'h1'
        }),
        Em.Object.create({
          name: 'hive_metastore_hosts',
          value: 'h2'
        }),
        Em.Object.create({
          name: 'ranger_server_hosts',
          value: 'h3'
        })
      ];

    cases.forEach(function (item) {
      it(item.serviceName, function () {
        var view = App.CheckDBConnectionView.create({
          parentView: {
            service: {
              serviceName: item.serviceName
            },
            categoryConfigsAll: categoryConfigsAll
          }
        });
        expect(view.get('masterHostName')).to.equal(item.value);
      });
    });

  });

  describe('#setResponseStatus', function () {

    var view,
      cases = [
        {
          isSuccess: 'success',
          logsPopupBefore: null,
          logsPopup: null,
          responseCaption: Em.I18n.t('services.service.config.database.connection.success'),
          isConnectionSuccess: true,
          title: 'success, no popup displayed'
        },
        {
          isSuccess: 'success',
          logsPopupBefore: {},
          logsPopup: {
            header: Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.success'))
          },
          responseCaption: Em.I18n.t('services.service.config.database.connection.success'),
          isConnectionSuccess: true,
          title: 'success, popup is displayed'
        },
        {
          isSuccess: 'error',
          logsPopupBefore: {},
          logsPopup: {
            header: Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.error'))
          },
          responseCaption: Em.I18n.t('services.service.config.database.connection.failed'),
          isConnectionSuccess: false,
          title: 'error, popup is displayed'
        }
      ];

    beforeEach(function () {
      view = App.CheckDBConnectionView.create({
        databaseName: 'MySQL'
      });
      sinon.stub(view, 'setConnectingStatus', Em.K);
    });

    afterEach(function () {
      view.setConnectingStatus.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('logsPopup', item.logsPopupBefore);
        view.setResponseStatus(item.isSuccess);
        expect(view.get('isRequestResolved')).to.be.true;
        expect(view.setConnectingStatus.calledOnce).to.be.true;
        expect(view.setConnectingStatus.calledWith(false)).to.be.true;
        expect(view.get('responseCaption')).to.equal(item.responseCaption);
        expect(view.get('isConnectionSuccess')).to.equal(item.isConnectionSuccess);
        expect(view.get('logsPopup')).to.eql(item.logsPopup);
      });
    });

  });

  describe('#showLogsPopup', function () {

    var view,
      cases = [
        {
          isConnectionSuccess: true,
          showAlertPopupCallCount: 0,
          title: 'successful connection'
        },
        {
          isConnectionSuccess: false,
          isRequestResolved: true,
          showAlertPopupCallCount: 1,
          responseFromServer: 'fail',
          header: Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.error')),
          popupMethodExecuted: 'onClose',
          title: 'failed connection without output data, popup dismissed with Close button'
        },
        {
          isConnectionSuccess: false,
          isRequestResolved: false,
          showAlertPopupCallCount: 1,
          responseFromServer: {
            stderr: 'stderr',
            stdout: 'stdout',
            structuredOut: 'structuredOut'
          },
          header: Em.I18n.t('services.service.config.connection.logsPopup.header').format('MySQL', Em.I18n.t('common.testing')),
          popupMethodExecuted: 'onPrimary',
          title: 'check in progress with output data, popup dismissed with OK button'
        }
      ];

    beforeEach(function () {
      view = App.CheckDBConnectionView.create({
        databaseName: 'MySQL'
      });
      sinon.spy(App, 'showAlertPopup');
    });

    afterEach(function () {
      App.showAlertPopup.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.setProperties({
          isConnectionSuccess: item.isConnectionSuccess,
          isRequestResolved: item.isRequestResolved,
          responseFromServer: item.responseFromServer
        });
        view.showLogsPopup();
        expect(App.showAlertPopup.callCount).to.equal(item.showAlertPopupCallCount);
        if (!item.isConnectionSuccess) {
          expect(view.get('logsPopup.header')).to.equal(item.header);
          if (typeof item.responseFromServer == 'object') {
            expect(view.get('logsPopup.bodyClass').create().get('openedTask')).to.eql(item.responseFromServer);
          } else {
            expect(view.get('logsPopup.body')).to.equal(item.responseFromServer);
          }
          view.get('logsPopup')[item.popupMethodExecuted]();
          expect(view.get('logsPopup')).to.be.null;
        }
      });
    });

  });

  describe("#createCustomAction()", function() {
    var view;
    beforeEach(function () {
      view = App.CheckDBConnectionView.create({
        databaseName: 'MySQL',
        getConnectionProperty: Em.K,
        masterHostName: 'host1'
      });
      sinon.stub(App.ajax, 'send');
      this.mock = sinon.stub(App.Service, 'find');
    });
    afterEach(function () {
      App.ajax.send.restore();
      this.mock.restore();
    });

    it("service not installed", function() {
      this.mock.returns(Em.Object.create({isLoaded: false}));
      view.createCustomAction();
      expect(App.ajax.send.getCall(0).args[0].name).to.equal('custom_action.create');
    });
    it("service is installed", function() {
      this.mock.returns(Em.Object.create({isLoaded: true}));
      view.createCustomAction();
      expect(App.ajax.send.getCall(0).args[0].name).to.equal('cluster.custom_action.create');
    });
  });

});

describe('App.BaseUrlTextField', function () {

  var view;

  beforeEach(function () {
    view = App.BaseUrlTextField.create({
      repository: Em.Object.create({
        baseUrl: 'val'
      })
    });
    view.didInsertElement();
  });

  describe('#valueWasChanged', function () {

    it('should be recalculated after value is changed', function () {
      view.setProperties({
        value: 'val',
        recommendedValue: 'val'
      });
      expect(view.get('valueWasChanged')).to.be.false;
      view.set('value', 'newVal');
      expect(view.get('valueWasChanged')).to.be.true;
    });

  });

  describe('#restoreValue', function () {

    it('should unset value', function () {
      view.setProperties({
        value: 'valNew',
        savedValue: 'val'
      });
      view.restoreValue();
      expect(view.get('value')).to.equal('val');
    });

  });
});

});

;require.register("test/views/common/filter_combo_cleanable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;
describe('App.FilterComboCleanableView', function() {

  beforeEach(function() {
    view = App.FilterComboCleanableView.create();
  });

  describe('#didInsertElement', function() {

    it('should clean filter when created', function() {
      sinon.stub(App, 'popover', Em.K);
      view.setProperties({
        filter: 'some value',
        popoverDescription: ['', '']
      });
      view.didInsertElement();
      App.popover.restore();
      expect(view.get('filter')).to.be.empty;
    });

  });

});
});

;require.register("test/views/common/filter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var filters = require('views/common/filter_view');
require('utils/helper');

describe('filters.getFilterByType', function () {

  describe('ambari-bandwidth', function () {

    var filter = filters.getFilterByType('ambari-bandwidth');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1GB',
        result: true
      },
      {
        condition: '1g',
        value: '1GB',
        result: true
      },
      {
        condition: '=1g',
        value: '1GB',
        result: true
      },
      {
        condition: '<1g',
        value: '0.9GB',
        result: true
      },
      {
        condition: '>1g',
        value: '1.1GB',
        result: true
      },
      {
        condition: '=1k',
        value: '1KB',
        result: true
      },
      {
        condition: '<1k',
        value: '0.9KB',
        result: true
      },
      {
        condition: '>1k',
        value: '1.1KB',
        result: true
      },
      {
        condition: '=1m',
        value: '1MB',
        result: true
      },
      {
        condition: '<1m',
        value: '0.9MB',
        result: true
      },
      {
        condition: '>1m',
        value: '1.1MB',
        result: true
      },
      {
        condition: '=1024k',
        value: '1MB',
        result: true
      },
      {
        condition: '=1024m',
        value: '1GB',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('duration', function () {

    var filter = filters.getFilterByType('duration');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1000',
        result: true
      },
      {
        condition: '1s',
        value: '1000',
        result: true
      },
      {
        condition: '=1s',
        value: '1000',
        result: true
      },
      {
        condition: '>1s',
        value: '1001',
        result: true
      },
      {
        condition: '<1s',
        value: '999',
        result: true
      },
      {
        condition: '=1m',
        value: '60000',
        result: true
      },
      {
        condition: '>1m',
        value: '60001',
        result: true
      },
      {
        condition: '<1m',
        value: '59999',
        result: true
      },
      {
        condition: '=1h',
        value: '3600000',
        result: true
      },
      {
        condition: '>1h',
        value: '3600001',
        result: true
      },
      {
        condition: '<1h',
        value: '3599999',
        result: true
      }

    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('date', function () {

    var filter = filters.getFilterByType('date');
    var currentTime = new Date().getTime();
    var testData = [
      {
        condition: 'Past 1 Day',
        value: currentTime - 86300000,
        result: true
      },
      {
        condition: 'Past 2 Days',
        value: currentTime - 172700000,
        result: true
      },
      {
        condition: 'Past 7 Days',
        value: currentTime - 604700000,
        result: true
      },
      {
        condition: 'Past 14 Days',
        value: currentTime - 1209500000,
        result: true
      },
      {
        condition: 'Past 30 Days',
        value: currentTime - 2591900000,
        result: true
      },
      {
        condition: 'Any',
        value: 'any value',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('number', function () {

    var filter = filters.getFilterByType('number');
    var testData = [
      {
        condition: '<',
        value: 'any value',
        result: true
      },
      {
        condition: '=',
        value: 'any value',
        result: true
      },
      {
        condition: '>',
        value: 'any value',
        result: true
      },
      {
        condition: '1',
        value: '1',
        result: true
      },
      {
        condition: '=1',
        value: '1',
        result: true
      },
      {
        condition: '<1',
        value: '0',
        result: true
      },
      {
        condition: '>1',
        value: '2',
        result: true
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ' - match value: ' + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('multiple', function () {

    var filter = filters.getFilterByType('multiple');
    var commonValue = [
      {componentName: 'DATANODE'},
      {componentName: 'NAMENODE'},
      {componentName: 'JOBTRACKER'}
    ];
    var testData = [
      {
        condition: 'DATANODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE',
        value: commonValue,
        result: true
      },
      {
        condition: 'DATANODE,NAMENODE,JOBTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'JOBTRACKER,TASKTRACKER',
        value: commonValue,
        result: true
      },
      {
        condition: 'TASKTRACKER',
        value: commonValue,
        result: false
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ((item.result) ? ' - match ' : ' - doesn\'t match ' + 'value: ') +
        item.value.mapProperty('componentName').join(" "), function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('string', function () {

    var filter = filters.getFilterByType('string');

    var testData = [
      {
        condition: '',
        value: '',
        result: true
      },
      {
        condition: '',
        value: 'hello',
        result: true
      },
      {
        condition: 'hello',
        value: 'hello',
        result: true
      },
      {
        condition: 'HeLLo',
        value: 'hello',
        result: true
      },
      {
        condition: 'he',
        value: 'hello',
        result: true
      },
      {
        condition: 'lo',
        value: 'hello',
        result: true
      },
      {
        condition: 'lol',
        value: 'hello',
        result: false
      },
      {
        condition: 'hello',
        value: '',
        result: false
      },
      {
        condition: '?',
        value: 'hello',
        result: false
      }
    ];

    testData.forEach(function(item){
      it('Condition: ' + item.condition + ((item.result) ? ' - match ' : ' - doesn\'t match ' + 'value: ') + item.value, function () {
        expect(filter(item.value, item.condition)).to.equal(item.result);
      })
    });
  });

  describe('sub-resource', function () {

    var filter = filters.getFilterByType('sub-resource');

    var testData = [
      {
        title: 'condition is null',
        condition: null,
        value: [Em.Object.create({
          prop1: 1
        })],
        result: true
      },
      {
        title: 'condition is empty',
        condition: [],
        value: [Em.Object.create({
          prop1: 1
        })],
        result: true
      },
      {
        title: 'condition match one property',
        condition: [
          {
            property: 'prop1',
            value: 1
          }
        ],
        value: [Em.Object.create({
          prop1: 1
        })],
        result: true
      },
      {
        title: 'condition match two properties',
        condition: [
          {
            property: 'prop1',
            value: 1
          },
          {
            property: 'prop2',
            value: 2
          }
        ],
        value: [Em.Object.create({
          prop1: 1,
          prop2: 2
        })],
        result: true
      },
      {
        title: 'only one of two properties match',
        condition: [
          {
            property: 'prop1',
            value: 3
          },
          {
            property: 'prop2',
            value: 2
          }
        ],
        value: [Em.Object.create({
          prop1: 1,
          prop2: 2
        })],
        result: false
      },
      {
        title: 'none of two properties match',
        condition: [
          {
            property: 'prop1',
            value: 3
          },
          {
            property: 'prop2',
            value: 4
          }
        ],
        value: [Em.Object.create({
          prop1: 1,
          prop2: 2
        })],
        result: false
      }
    ];

    testData.forEach(function (test) {
      it(test.title, function () {
        expect(filter(test.value, test.condition)).to.equal(test.result);
      })
    });
  });

  describe('alert_status', function () {

    var filter = filters.getFilterByType('alert_status');

    Em.A([
      {
        origin: {OK: {count: 1, maintenanceCount: 0}},
        compareValue: 'OK',
        e: true
      },
      {
        origin: {OK: {count: 0, maintenanceCount: 1}},
        compareValue: 'OK',
        e: true
      },
      {
        origin: {WARN: {count: 1, maintenanceCount: 0}},
        compareValue: 'OK',
        e: false
      },
      {
        origin: {WARN: {count: 0, maintenanceCount: 0}},
        compareValue: 'WARN',
        e: false
      },
      {
        origin: {OK: {count: 0, maintenanceCount: 0}, WARN: {count: 0, maintenanceCount: 0}},
        compareValue: 'PENDING',
        e: true
      },
      {
        origin: {},
        compareValue: 'PENDING',
        e: true
      },
      {
        origin: {OK: {count: 1, maintenanceCount: 0}},
        compareValue: 'PENDING',
        e: false
      }
    ]).forEach(function(test, i) {
        it('test #' + (i + 1), function() {
          expect(filter(test.origin, test.compareValue)).to.equal(test.e);
        });
      });

  });

  describe('alert_group', function () {

    var filter = filters.getFilterByType('alert_group');

    Em.A([
        {
          origin: [{id: 1}, {id: 2}, {id: 3}],
          compareValue: 1,
          e: true
        },
        {
          origin: [],
          compareValue: 1,
          e: false
        },
        {
          origin: [{id: 2}, {id: 3}],
          compareValue: 1,
          e: false
        }
      ]).forEach(function(test, i) {
        it('test #' + (i + 1), function() {
          expect(filter(test.origin, test.compareValue)).to.equal(test.e);
        });
      });

  });

  describe('os', function () {

    var filter = filters.getFilterByType('os');

    [
      {
        origin: [{osType: 'os1'}, {osType: 'os2'}, {osType: 'os3'}],
        compareValue: 'os1',
        e: true
      },
      {
        origin: [{osType: 'os1'}, {osType: 'os2'}, {osType: 'os3'}],
        compareValue: 'os2',
        e: true
      },
      {
        origin: [{osType: 'os1'}, {osType: 'os2'}, {osType: 'os3'}],
        compareValue: 'os3',
        e: true
      },
      {
        origin: [],
        compareValue: 'os1',
        e: false
      },
      {
        origin: [{}, {}, {}],
        compareValue: 'os1',
        e: false
      }
    ].forEach(function (test, i) {
      it('test #' + (i + 1), function () {
        expect(filter(test.origin, test.compareValue)).to.be.equal(test.e);
      });
    });

  });

  describe('range', function () {

    var filter = filters.getFilterByType('range');

    [
      {
        compareValue: [2],
        origin: 1,
        e: false
      },
      {
        compareValue: [0, 1],
        origin: 1,
        e: true
      },
      {
        compareValue: [1, 1],
        origin: 1,
        e: true
      },
      {
        compareValue: [2, 2],
        origin: 1,
        e: false
      },
      {
        compareValue: [4, 2],
        origin: 1,
        e: false
      }
    ].forEach(function (test, i) {
      it('test #' + (i + 1), function () {
        expect(filter(test.origin, test.compareValue)).to.be.equal(test.e);
      });
    });

  });

});

});

;require.register("test/views/common/form/manage_kdc_credentials_form_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var credentialUtils = require('utils/credentials');

var view;

describe('#App.ManageCredentialsFormView', function() {
  beforeEach(function() {
    view = App.ManageCredentialsFormView.create({
      parentView: Em.Object.create({})
    });
  });

  afterEach(function() {
    view.destroy();
  });

  describe('#prepareContent', function() {
    [
      {
        isStorePersistent: true,
        credentials: [
          {
            alias: 'kdc.admin.credential',
            type: 'persisted'
          }
        ],
        e: {
          isRemovable: true,
          isRemoveDisabled: false,
          storePersisted: true
        },
        m: 'persistent store is available, previous credentials were stored as persisted. Remove button should be visible and active.'
      },
      {
        isStorePersistent: true,
        credentials: [
          {
            alias: 'kdc.admin.credential',
            type: 'temporary'
          }
        ],
        e: {
          isRemovable: false,
          isRemoveDisabled: true,
          storePersisted: true
        },
        m: 'persistent store is available, previous credentials were stored as temporary. Remove button should be hidden and disabled.'
      }
    ].forEach(function(test) {
      it(test.m, function(done) {
        sinon.stub(credentialUtils, 'credentials', function(clusterName, callback) {
          callback(test.credentials);
        });
        sinon.stub(App, 'get').withArgs('isCredentialStorePersistent').returns(test.e.storePersisted);
        view.prepareContent();
        Em.run.next(function() {
          assert.equal(view.get('isRemovable'), test.e.isRemovable, '#isRemovable property validation');
          assert.equal(view.get('isRemoveDisabled'), test.e.isRemoveDisabled, '#isRemoveDisabled property validation');
          assert.equal(view.get('storePersisted'), test.e.storePersisted, '#storePersisted property validation');
          credentialUtils.credentials.restore();
          App.get.restore();
          done();
        });
      });
    });
  });

  describe('#isSubmitDisabled', function() {
    it('save button disabled by default', function() {
      expect(view.get('isSubmitDisabled')).to.be.true;
    });
    it('save button disabled when password is empty', function() {
      view.set('principal', 'some_principal');
      expect(view.get('isSubmitDisabled')).to.be.true;
    });
    it('save button disabled when principal is empty', function() {
      view.set('password', 'some_password');
      expect(view.get('isSubmitDisabled')).to.be.true;
    });
    it('save button should be enabled when principal and password are filled', function() {
      view.set('password', 'some_password');
      view.set('principal', 'principal');
      expect(view.get('isSubmitDisabled')).to.be.false;
    });
  });

  describe('fields validation', function() {
    it('should flow validation', function() {
      var t = Em.I18n.t;
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled on initial state');
      view.set('principal', ' a');
      assert.equal(view.get('principalError'), t('host.spacesValidation'), 'principal contains spaces, appropriate message shown');
      assert.isTrue(view.get('isPrincipalDirty'), 'principal name modified');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled because principal not valid');
      view.set('principal', '');
      assert.equal(view.get('principalError'), t('admin.users.editError.requiredField'), 'principal is empty, appropriate message shown');
      view.set('principal', 'some_name');
      assert.isFalse(view.get('principalError'), 'principal name valid no message shown');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled because password field not modified');
      view.set('password', '1');
      view.set('password', '');
      assert.equal(view.get('passwordError'), t('admin.users.editError.requiredField'), 'password is empty, appropriate message shown');
      assert.isTrue(view.get('isPasswordDirty'), 'password modified');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit disabled because password field is empty');
      view.set('password', 'some_pass');
      assert.isFalse(view.get('passwordError'), 'password valid no message shown');
      assert.isFalse(view.get('isSubmitDisabled'), 'submit enabled all fields are valid');
    });
  });

  describe('#removeKDCCredentials', function() {
    it('should show confirmation popup', function() {
      var popup = view.removeKDCCredentials().popup;
      expect(popup).be.instanceof(App.ModalPopup);
      popup.destroy();
    });
    it('should call credentialUtils#removeCredentials', function() {
      this.clock = sinon.useFakeTimers();
      var popup = view.removeKDCCredentials().popup;
      assert.isFalse(view.get('actionStatus'), '#actionStatus before remove');
      sinon.stub(credentialUtils, 'removeCredentials', function() {
        var dfd = $.Deferred();
        setTimeout(function() {
          dfd.resolve();
        }, 500);
        return dfd.promise();
      });
      popup.onPrimary();
      assert.isTrue(view.get('isActionInProgress'), 'action in progress');
      assert.isTrue(view.get('isRemoveDisabled'), 'remove button disabled');
      assert.isTrue(view.get('isSubmitDisabled'), 'submit button disabled');
      this.clock.tick(1000);
      assert.isFalse(view.get('isActionInProgress'), 'action finished');
      assert.equal(Em.I18n.t('common.success'), view.get('actionStatus'), '#actionStatus after remove');
      assert.isTrue(view.get('parentView.isCredentialsRemoved'), 'parentView#isCredentialsRemoved property should be triggered when remove complete');
      credentialUtils.removeCredentials.restore();
      this.clock.restore();
      popup.destroy();
    });
  });

});

});

;require.register("test/views/common/form/spinner_input_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;
var e;
describe('App.SpinnerInputView', function () {

  beforeEach(function () {
    view = App.SpinnerInputView.create({});
    e = {
      preventDefault: Em.K
    };
    sinon.spy(e, 'preventDefault');
  });

  afterEach(function () {
    e.preventDefault.restore();
  });

  describe('#keyDown', function () {

    Em.A([
      {
        charCode: 46,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 8,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 9,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 27,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 13,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 110,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 65,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 67,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 88,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 35,
        ctrlKey: true,
        e: {
          preventDefault: false
        }
      }
    ]).forEach(function (test) {
      it('charCode: ' + test.charCode + ', ctrlKey: ' + test.ctrlKey, function () {
        e.charCode = test.charCode;
        e.ctrlKey = test.ctrlKey;
        view.keyDown(e);
        expect(e.preventDefault.called).to.equal(test.e.preventDefault);
      });
    });

    Em.A([
      {
        charCode: 35,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 36,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 37,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 38,
        e: {
          preventDefault: false
        }
      },
      {
        charCode: 39,
        e: {
          preventDefault: false
        }
      }
    ]).forEach(function (test) {
      it('charCode: ' + test.charCode, function () {
        e.charCode = test.charCode;
        view.keyDown(e);
        expect(e.preventDefault.called).to.equal(test.e.preventDefault);
      });
    });

    Em.A([
      {
        charCode: 190,
        shiftKey: false,
        e: {
          preventDefault: true
        }
      },
      {
        charCode: 190,
        shiftKey: true,
        e: {
          preventDefault: true
        }
      }
    ]).forEach(function (test) {
      it('charCode: ' + test.charCode + ', shiftKey: ' + test.shiftKey, function () {
        e.charCode = test.charCode;
        e.shiftKey = test.shiftKey;
        view.keyDown(e);
        expect(e.preventDefault.calledOnce).to.equal(test.e.preventDefault);
      });
    });

  });

});

});

;require.register("test/views/common/modal_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/modal_popup');

describe('App.ModalPopup', function() {

  var popup;

  beforeEach(function () {
    popup = App.ModalPopup.create(
      {
        primary: 'test',
        secondary: 'test',
        header: 'test',
        body: '<p>text</p><input type="text"><input type="checkbox"><input type="button">',
        $: function () {
          return $(this);
        }
      }
    );
  });

  describe('#didInsertElement', function () {

    it('should focus on the first input element', function () {
      var spy = sinon.spy(popup, "focusElement");
      popup.didInsertElement();
      expect(spy.called).to.be.true;
    });
  });

});
});

;require.register("test/views/common/modal_popups/cluster_check_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/modal_popups/cluster_check_popup');

describe('App.showClusterCheckPopup', function () {

  var isCallbackExecuted,
    callback = function () {
      isCallbackExecuted = true;
    },
    cases = [
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'p0',
                  status: 'PASS'
                }
              },
              {
                UpgradeChecks: {
                  id: 'p1',
                  status: 'PASS'
                }
              }
            ]
          }
        },
        result: {
          primary: Em.I18n.t('common.proceedAnyway'),
          secondary: Em.I18n.t('common.cancel'),
          header: '&nbsp;'
        },
        bodyResult: {
          failTitle: undefined,
          failAlert: undefined,
          warningTitle: undefined,
          warningAlert: undefined,
          fails: [],
          warnings: [],
          hasConfigsMergeConflicts: false,
          isAllPassed: true
        },
        isCallbackExecuted: false,
        title: 'no fails, no warnings, no popup customization'
      },
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'w0',
                  status: 'WARNING'
                }
              },
              {
                UpgradeChecks: {
                  id: 'w1',
                  status: 'WARNING'
                }
              }
            ]
          },
          popup: {
            header: 'checks',
            failTitle: 'fail',
            failAlert: 'something has failed',
            warningTitle: 'warning',
            warningAlert: 'something is not good',
            callback: callback
          }
        },
        result: {
          primary: Em.I18n.t('common.proceedAnyway'),
          secondary: Em.I18n.t('common.cancel'),
          header: 'checks'
        },
        bodyResult: {
          failTitle: 'fail',
          failAlert: 'something has failed',
          warningTitle: 'warning',
          warningAlert: 'something is not good',
          fails: [],
          warnings: [
            {
              UpgradeChecks: {
                id: 'w0',
                status: 'WARNING'
              }
            },
            {
              UpgradeChecks: {
                id: 'w1',
                status: 'WARNING'
              }
            }
          ],
          hasConfigsMergeConflicts: false,
          isAllPassed: false
        },
        isCallbackExecuted: true,
        title: 'no fails, default buttons, callback executed'
      },
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'f0',
                  status: 'FAIL'
                }
              },
              {
                UpgradeChecks: {
                  id: 'f1',
                  status: 'FAIL'
                }
              }
            ]
          },
          popup: {
            callback: callback,
            noCallbackCondition: true
          }
        },
        result: {
          primary: Em.I18n.t('common.dismiss'),
          secondary: false,
          header: '&nbsp;'
        },
        bodyResult: {
          failTitle: undefined,
          failAlert: undefined,
          warningTitle: undefined,
          warningAlert: undefined,
          fails: [
            {
              UpgradeChecks: {
                id: 'f0',
                status: 'FAIL'
              }
            },
            {
              UpgradeChecks: {
                id: 'f1',
                status: 'FAIL'
              }
            }
          ],
          warnings: [],
          hasConfigsMergeConflicts: false,
          isAllPassed: false
        },
        isCallbackExecuted: false,
        title: 'fails detected, default buttons, callback not executed'
      },
      {
        inputData: {
          data: {
            items: [
              {
                UpgradeChecks: {
                  id: 'p0',
                  status: 'PASS'
                }
              },
              {
                UpgradeChecks: {
                  id: 'p1',
                  status: 'PASS'
                }
              }
            ]
          },
          popup: {
            primary: 'ok',
            secondary: 'cancel'
          },
          configs: [
            {
              name: 'c0'
            },
            {
              name: 'c1'
            }
          ],
          upgradeVersion: 'HDP-2.3.0.0'
        },
        result: {
          primary: 'ok',
          secondary: 'cancel',
          header: '&nbsp;'
        },
        bodyResult: {
          failTitle: undefined,
          failAlert: undefined,
          warningTitle: undefined,
          warningAlert: undefined,
          fails: [],
          warnings: [],
          hasConfigsMergeConflicts: true,
          isAllPassed: false
        },
        configsResult: [
          {
            name: 'c0'
          },
          {
            name: 'c1'
          }
        ],
        isCallbackExecuted: false,
        title: 'configs merge conflicts detected, custom buttons'
      }
    ];

  beforeEach(function () {
    isCallbackExecuted = false;
    sinon.stub(App, 'tooltip', Em.K);
  });

  afterEach(function () {
    App.tooltip.restore();
  });

  cases.forEach(function (item) {
    it(item.title, function () {
      var popup = App.showClusterCheckPopup(item.inputData.data, item.inputData.popup, item.inputData.configs, item.inputData.upgradeVersion),
        popupBody = popup.bodyClass.create();
      popup.onPrimary();
      Em.keys(item.result).forEach(function (key) {
        expect(popup[key]).to.equal(item.result[key]);
      });
      Em.keys(item.bodyResult).forEach(function (key) {
        expect(popupBody[key]).to.eql(item.bodyResult[key]);
      });
      expect(isCallbackExecuted).to.equal(item.isCallbackExecuted);
      if (item.bodyResult.hasConfigsMergeConflicts) {
        var configsMergeTable = popupBody.configsMergeTable.create();
        configsMergeTable.didInsertElement();
        expect(configsMergeTable.configs).to.eql(item.configsResult);
        expect(App.tooltip.calledOnce).to.be.true;
        expect(App.tooltip.firstCall.args[1].title).to.equal(item.inputData.upgradeVersion);
      } else {
        expect(App.tooltip.calledOnce).to.be.false;
      }
    });
  });

});

});

;require.register("test/views/common/modal_popups/dependent_configs_list_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/common/modal_popups/hosts_table_list_popup');

var view;

describe('App.showDependentConfigsPopup', function () {

  beforeEach(function () {
    view = App.showDependentConfigsPopup();
    sinon.stub(Em.run, 'next', Em.K);
    sinon.stub(Em.run, 'once', Em.K);
  });

  afterEach(function () {
    Em.run.next.restore();
    Em.run.once.restore();
  });

  describe('#onClose', function () {

    beforeEach(function () {
      this.ff = function () {};
      sinon.spy(this, 'ff');
      view = App.showDependentConfigsPopup({}, Em.K, this.ff);
    });

    afterEach(function () {
      this.ff.restore();
    });

    it('should call secondary-callback', function () {
      view.onClose();
      expect(this.ff.calledOnce).to.be.true;
    });

  });

});
});

;require.register("test/views/common/modal_popups/hosts_table_list_popup_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/common/modal_popups/hosts_table_list_popup');

describe('App.showHostsTableListPopup', function () {

  var cases = [
    {
      header: 'h0',
      hostName: 'hn0',
      items: ['i0', 'i1'],
      isObjectsList: false,
      title: 'strings list'
    },
    {
      header: 'h1',
      hostName: 'hn1',
      items: [
        {
          name: 'n0',
          status: 's0'
        },
        {
          name: 'n1',
          status: 's1'
        }
      ],
      isObjectsList: true,
      title: 'objects list'
    }
  ];

  cases.forEach(function (item) {
    it(item.title, function () {
      var popup = App.showHostsTableListPopup(item.header, item.hostName, item.items),
        popupBody = popup.bodyClass.create();
      expect(popup.header).to.equal(item.header);
      expect(popupBody.get('hostName')).to.equal(item.hostName);
      expect(popupBody.get('items')).to.eql(item.items);
      expect(popupBody.get('isObjectsList')).to.equal(item.isObjectsList);
    });
  });

});

});

;require.register("test/views/common/progress_bar_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.ProgressBarView', function () {
  var view = App.ProgressBarView.create();

  describe("#progressWidth", function () {
    it("", function () {
      view.set('progress', 1);
      view.propertyDidChange('progressWidth');
      expect(view.get('progressWidth')).to.equal('width:1%;');
    });
  });

  describe("#barClass", function () {
    var testCases = [
      {
        status: 'FAILED',
        result: 'progress-danger'
      },
      {
        status: 'ABORTED',
        result: 'progress-warning'
      },
      {
        status: 'TIMED_OUT',
        result: 'progress-warning'
      },
      {
        status: 'COMPLETED',
        result: 'progress-success'
      },
      {
        status: 'QUEUED',
        result: 'progress-info active progress-striped'
      },
      {
        status: 'PENDING',
        result: 'progress-info active progress-striped'
      },
      {
        status: 'IN_PROGRESS',
        result: 'progress-info active progress-striped'
      },
      {
        status: null,
        result: 'progress-info'
      }
    ];
    testCases.forEach(function (test) {
      it("status is " + test.status, function () {
        view.set('status', test.status);
        view.propertyDidChange('barClass');
        expect(view.get('barClass')).to.equal(test.result);
      });
    });
  });
});
});

;require.register("test/views/common/quick_link_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/quick_view_link_view');

describe('App.QuickViewLinks', function () {

  var quickViewLinks = App.QuickViewLinks.create({});

  describe('#setProtocol', function() {
    var tests = [
      { serviceName: "GANGLIA", ambariProperties: { 'ganglia.https': 'true' }, m: "https for ganglia", result: "https" },
      { serviceName: "GANGLIA", ambariProperties: { 'ganglia.https': 'false' }, m: "http for ganglia 1", result: "http" },
      { serviceName: "GANGLIA", m: "http for ganglia 2", result: "http" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTPS_ONLY' }}
      ], m: "https for yarn", result: "https" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTP_ONLY' }}
      ], m: "http for yarn", result: "http" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTP_ONLY' }}
      ], m: "http for yarn (overrides hadoop.ssl.enabled)", result: "http" },
      { serviceName: "YARN", configProperties: [
        { type: 'yarn-site', properties: { 'yarn.http.policy': 'HTTPS_ONLY' }}
      ], m: "https for yarn (overrides hadoop.ssl.enabled)", result: "https" },
      { serviceName: "MAPREDUCE2", configProperties: [
        { type: 'mapred-site', properties: { 'mapreduce.jobhistory.http.policy': 'HTTPS_ONLY' }}
      ], m: "https for mapreduce2", result: "https" },
      { serviceName: "MAPREDUCE2", configProperties: [
        { type: 'mapred-site', properties: { 'mapreduce.jobhistory.http.policy': 'HTTP_ONLY' }}
      ], m: "http for mapreduce2", result: "http" },
      { serviceName: "ANYSERVICE", configProperties: [
        { type: 'hdfs-site', properties: { 'dfs.http.policy': 'HTTPS_ONLY' }}
      ], m: "https for anyservice", servicesSupportsHttps: ["ANYSERVICE"], result: "https" },
      { serviceName: "RANGER", configProperties: [
        { type: 'ranger-site', properties: { 'http.enabled': 'true' }}
      ], m: "http for ranger (HDP2.2)", result: "http" },
      { serviceName: "RANGER", configProperties: [
        { type: 'ranger-site', properties: { 'http.enabled': 'false' }}
      ], m: "https for ranger (HDP2.2)", result: "https" },
      { serviceName: "RANGER", configProperties: [
        { type: 'ranger-admin-site', properties: { 'ranger.service.http.enabled': 'true', 'ranger.service.https.attrib.ssl.enabled': 'false'}}
      ], m: "http for ranger (HDP2.3)", result: "http" },
      { serviceName: "RANGER", configProperties: [
        { type: 'ranger-admin-site', properties: { 'ranger.service.http.enabled': 'false', 'ranger.service.https.attrib.ssl.enabled': 'true'}}
      ], m: "https for ranger (HDP2.3)", result: "https" }
    ];

    tests.forEach(function(t) {
      it(t.m, function() {
        quickViewLinks.set('servicesSupportsHttps', t.servicesSupportsHttps);
        expect(quickViewLinks.setProtocol(t.serviceName, t.configProperties, t.ambariProperties)).to.equal(t.result);
      });
    });
  });

  describe('#setPort', function () {
    var testData = [
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'http',
        'result': '8088',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'https_config': 'https_config',
        'result': '8090',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'https_config': 'https_config',
        'result': '8090',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)'
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'https_config': 'https_config',
        'config': 'https_config_custom',
        'site': 'yarn-site',
        'result': '9091',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)',
        'configProperties': [{
          'type': 'yarn-site',
          'properties': {
            'https_config': 'h:9090',
            'https_config_custom': 'h:9091'
          }
        }]
      }),
      Em.Object.create({
        'service_id': 'YARN',
        'protocol': 'https',
        'http_config': 'http_config',
        'https_config': 'https_config',
        'site': 'yarn-site',
        'result': '9090',
        'default_http_port': '8088',
        'default_https_port': '8090',
        'regex': '\\w*:(\\d+)',
        'configProperties': [{
          'type': 'yarn-site',
          'properties': {
            'http_config': 'h:9088',
            'https_config': 'h:9090'
          }
        }]
      }),
      Em.Object.create({
        'service_id': 'RANGER',
        'protocol': 'http',
        'http_config': 'http_config',
        'https_config': 'https_config',
        'result': '6080',
        'default_http_port': '6080',
        'default_https_port': '6182',
        'regex': '(\\d*)+'
      }),
      Em.Object.create({
        'service_id': 'RANGER',
        'protocol': 'https',
        'http_config': 'http_config',
        'https_config': 'https_config',
        'result': '6182',
        'default_http_port': '6080',
        'default_https_port': '6182',
        'regex': '(\\d*)+'
      })
    ];

    after(function () {
      quickViewLinks.set('configProperties', []);
    });

    testData.forEach(function(item) {
      it(item.service_id + ' ' + item.protocol, function () {
        quickViewLinks.set('configProperties', item.configProperties || []);
        expect(quickViewLinks.setPort(item, item.protocol, item.config)).to.equal(item.result);
      })
    },this);
  });

  describe('#setHost', function () {

    var quickViewLinks = App.QuickViewLinks.create({
        content: Em.Object.create()
      }),
      cases = [
        {
          singleNodeInstall: true,
          hosts: ['host0'],
          title: 'single node install'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'STORM_UI_SERVER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host3'
                }
              }
            ]
          },
          serviceName: 'STORM',
          hosts: ['host3']
        },
        {
          serviceName: 'PIG',
          hosts: [],
          title: 'client only service'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'ZOOKEEPER_SERVER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host4'
                }
              }
            ]
          },
          serviceName: 'ZOOKEEPER',
          hosts: ['host4'],
          setup: function () {
            quickViewLinks.set('content', {
              hostComponents: [
                Em.Object.create({
                  componentName: 'ZOOKEEPER_SERVER',
                  isMaster: true
                })
              ]
            });
          },
          title: 'service with master component, except HDFS, HBase, YARN and Storm'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host5'
                }
              }
            ]
          },
          serviceName: 'HDFS',
          hosts: ['host5'],
          setup: function () {
            quickViewLinks.set('content', {
              snameNode: true
            });
          },
          title: 'HDFS, HA disabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host6',
                  public_host_name: 'host6'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host7',
                  public_host_name: 'host7'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'NAMENODE'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host8',
                  public_host_name: 'host8'
                }
              }
            ]
          },
          serviceName: 'HDFS',
          multipleMasters: true,
          hosts: ['host6', 'host7', 'host8'],
          setup: function () {
            quickViewLinks.set('content', {
              hostComponents: [
                Em.Object.create({
                  componentName: 'NAMENODE',
                  hostName: 'host6'
                }),
                Em.Object.create({
                  componentName: 'NAMENODE',
                  hostName: 'host7'
                }),
                Em.Object.create({
                  componentName: 'NAMENODE',
                  hostName: 'host8'
                })
              ],
              activeNameNode: {
                hostName: 'host6'
              },
              standbyNameNode: {
                hostName: 'host7'
              },
              standbyNameNode2: {
                hostName: 'host8'
              }
            });
          },
          title: 'HDFS, HA enabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  public_host_name: 'host9'
                }
              }
            ]
          },
          serviceName: 'YARN',
          hosts: ['host9'],
          title: 'YARN, HA disabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host10',
                  public_host_name: 'host10'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host11',
                  public_host_name: 'host11'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'RESOURCEMANAGER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host12',
                  public_host_name: 'host12'
                }
              }
            ]
          },
          serviceName: 'YARN',
          multipleMasters: true,
          hosts: ['host10', 'host11', 'host12'],
          setup: function () {
            quickViewLinks.set('content', {
              hostComponents: [
                Em.Object.create({
                  componentName: 'RESOURCEMANAGER',
                  hostName: 'host10'
                }),
                Em.Object.create({
                  componentName: 'RESOURCEMANAGER',
                  hostName: 'host11'
                }),
                Em.Object.create({
                  componentName: 'RESOURCEMANAGER',
                  hostName: 'host12'
                })
              ]
            });
          },
          title: 'YARN, HA enabled'
        },
        {
          response: {
            items: [
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HBASE_MASTER'
                    },
                    metrics: {
                      hbase: {
                        master: {
                          IsActiveMaster: true
                        }
                      }
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host13',
                  public_host_name: 'host13'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HBASE_MASTER'
                    },
                    metrics: {
                      hbase: {
                        master: {
                          IsActiveMaster: false
                        }
                      }
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host14',
                  public_host_name: 'host14'
                }
              },
              {
                host_components: [
                  {
                    HostRoles: {
                      component_name: 'HBASE_MASTER'
                    }
                  }
                ],
                Hosts: {
                  host_name: 'host15',
                  public_host_name: 'host15'
                }
              }
            ]
          },
          serviceName: 'HBASE',
          multipleMasters: true,
          hosts: ['host13', 'host14', 'host15']
        }
      ];

    before(function () {
      sinon.stub(App.StackService, 'find', function () {
        return [
          Em.Object.create({
            serviceName: 'ZOOKEEPER',
            hasMaster: true
          }),
          Em.Object.create({
            serviceName: 'PIG',
            hasMaster: false
          })
        ];
      })
    });

    after(function () {
      App.StackService.find.restore();
    });

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      it(item.title || item.serviceName, function () {
        if (item.setup) {
          item.setup();
        }
        sinon.stub(App, 'get').withArgs('singleNodeInstall').returns(item.singleNodeInstall).
          withArgs('singleNodeAlias').returns('host0').
          withArgs('isRMHaEnabled').returns(item.multipleMasters);
        if (item.multipleMasters) {
          expect(quickViewLinks.setHost(item.response, item.serviceName).mapProperty('publicHostName')).to.eql(item.hosts);
        } else {
          expect(quickViewLinks.setHost(item.response, item.serviceName)).to.eql(item.hosts);
        }
      });
    });

  });

});

});

;require.register("test/views/common/quick_view_link_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.QuickViewLinks', function () {

  var view;

  beforeEach(function () {
    view = App.QuickViewLinks.create();
  });

  describe('#setQuickLinksErrorCallback', function () {

    beforeEach(function () {
      view.setProperties({
        quickLinks: [],
        isLoaded: false,
        areQuickLinksUndefined: false
      });
      view.setQuickLinksErrorCallback();
    });

    it('should fill array for dropdown', function () {
      expect(view.getProperties(['quickLinks', 'isLoaded', 'areQuickLinksUndefined'])).to.eql({
        quickLinks: [{
          label: Em.I18n.t('quick.links.error.label'),
          url: 'javascript:alert("' + Em.I18n.t('contact.administrator') + '");'
        }],
        isLoaded: true,
        areQuickLinksUndefined: true
      });
    });

  });

  describe('#linkTarget', function () {

    var serviceNameCases = [
      {
        serviceName: 'HDFS',
        target: '_blank'
      },
      {
        serviceName: 'YARN',
        target: '_blank'
      },
      {
        serviceName: 'MAPREDUCE2',
        target: '_blank'
      },
      {
        serviceName: 'HBASE',
        target: '_blank'
      },
      {
        serviceName: 'OOZIE',
        target: '_blank'
      },
      {
        serviceName: 'GANGLIA',
        target: '_blank'
      },
      {
        serviceName: 'STORM',
        target: '_blank'
      },
      {
        serviceName: 'SPARK',
        target: '_blank'
      },
      {
        serviceName: 'FALCON',
        target: '_blank'
      },
      {
        serviceName: 'ACCUMULO',
        target: '_blank'
      },
      {
        serviceName: 'ATLAS',
        target: '_blank'
      },
      {
        serviceName: 'RANGER',
        target: '_blank'
      },
      {
        serviceName: 'AMBARI_METRICS',
        target: '_blank'
      },
      {
        serviceName: 'ZOOKEEPER',
        target: ''
      }
    ];

    beforeEach(function () {
      view.set('content', {});
    });

    serviceNameCases.forEach(function (item) {

      it(item.serviceName, function () {
        view.setProperties({
          'isLoaded': false,
          'areQuickLinksUndefined': false,
          'content.serviceName': item.serviceName
        });
        view.propertyDidChange('service');
        expect(view.get('linkTarget')).to.equal(item.target);
      });

    });

    it('quick links not defined', function () {
      view.setProperties({
        isLoaded: true,
        areQuickLinksUndefined: true
      });
      expect(view.get('linkTarget')).to.equal('');
    });

  });

});
});

;require.register("test/views/common/rolling_restart_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/rolling_restart_view');

describe('App.RollingRestartView', function () {

  var view = App.RollingRestartView.create({
    restartHostComponents: []
  });

  describe('#initialize', function () {
    var testCases = [
      {
        restartHostComponents: [],
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        hostComponentName: 'NOT_DATANODE',
        restartHostComponents: new Array(10),
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      },
      {
        hostComponentName: 'NOT_DATANODE',
        restartHostComponents: new Array(11),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      },
      {
        hostComponentName: 'NOT_DATANODE',
        restartHostComponents: new Array(20),
        result: {
          batchSize: 2,
          tolerateSize: 2
        }
      },
      {
        hostComponentName: 'DATANODE',
        restartHostComponents: new Array(20),
        result: {
          batchSize: 1,
          tolerateSize: 1
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.restartHostComponents.length + ' components to restart', function () {
        view.set('batchSize', -1);
        view.set('interBatchWaitTimeSeconds', -1);
        view.set('tolerateSize', -1);
        view.set('hostComponentName', test.hostComponentName);
        view.set('restartHostComponents', test.restartHostComponents);
        view.initialize();
        expect(view.get('batchSize')).to.equal(test.result.batchSize);
        expect(view.get('tolerateSize')).to.equal(test.result.tolerateSize);
      })
    }, this);
  });
});

});

;require.register("test/views/common/select_custom_date_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/select_custom_date_view');

describe('App.JobsCustomDatesSelectView', function () {

  var view;

  beforeEach(function () {
    view = App.JobsCustomDatesSelectView.create();
  });

  describe('#isCustomEndDate', function () {

    var cases = [
      {
        duration: null,
        isCustomEndDate: false,
        title: 'duration not set'
      },
      {
        duration: 1000,
        isCustomEndDate: false,
        title: 'preset duration'
      },
      {
        duration: 0,
        isCustomEndDate: true,
        title: 'custom duration'
      }
    ];

    beforeEach(function () {
      view.reopen({
        validate: Em.K
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('customDateFormFields.duration', {
          value: item.duration
        });
        expect(view.get('isCustomEndDate')).to.equal(item.isCustomEndDate);
      });
    });

  });

  describe('#createCustomStartDate', function () {

    var cases = [
      {
        startDate: '01/01/2016',
        hoursForStart: '01',
        minutesForStart: '00',
        middayPeriodForStart: 'AM',
        isInvalidDate: false,
        title: 'valid date and time'
      },
      {
        startDate: '',
        hoursForStart: '01',
        minutesForStart: '00',
        middayPeriodForStart: 'AM',
        isInvalidDate: true,
        title: 'no date specified'
      },
      {
        startDate: '01/01/2016',
        hoursForStart: '',
        minutesForStart: '00',
        middayPeriodForStart: 'AM',
        isInvalidDate: true,
        title: 'no hours specified'
      },
      {
        startDate: '01/01/2016',
        hoursForStart: '01',
        minutesForStart: '',
        middayPeriodForStart: 'AM',
        isInvalidDate: true,
        title: 'no minutes specified'
      },

      {
        startDate: '01/01/2016',
        hoursForStart: '01',
        minutesForStart: '00',
        middayPeriodForStart: '',
        isInvalidDate: true,
        title: 'no midday period specified'
      }
    ];

    beforeEach(function () {
      view.reopen({
        validate: Em.K
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.get('customDateFormFields').setProperties({
          startDate: item.startDate,
          hoursForStart: item.hoursForStart,
          minutesForStart: item.minutesForStart,
          middayPeriodForStart: item.middayPeriodForStart
        });
        expect(Em.isNone(view.createCustomStartDate())).to.equal(item.isInvalidDate);
      });
    });

  });

  describe('#createCustomEndDate', function () {

    var customEndCases = [
      {
        endDate: '01/01/2016',
        hoursForEnd: '01',
        minutesForEnd: '00',
        middayPeriodForEnd: 'AM',
        isInvalidDate: false,
        title: 'valid date and time'
      },
      {
        endDate: '',
        hoursForEnd: '01',
        minutesForEnd: '00',
        middayPeriodForEnd: 'AM',
        isInvalidDate: true,
        title: 'no date specified'
      },
      {
        endDate: '01/01/2016',
        hoursForEnd: '',
        minutesForEnd: '00',
        middayPeriodForEnd: 'AM',
        isInvalidDate: true,
        title: 'no hours specified'
      },
      {
        endDate: '01/01/2016',
        hoursForEnd: '01',
        minutesForEnd: '',
        middayPeriodForEnd: 'AM',
        isInvalidDate: true,
        title: 'no minutes specified'
      },

      {
        endDate: '01/01/2016',
        hoursForEnd: '01',
        minutesForEnd: '00',
        middayPeriodForEnd: '',
        isInvalidDate: true,
        title: 'no midday period specified'
      }
    ];

    beforeEach(function () {
      view.reopen({
        validate: Em.K
      });
    });

    customEndCases.forEach(function (item) {
      it(item.title, function () {
        view.get('customDateFormFields').setProperties({
          endDate: item.endDate,
          hoursForEnd: item.hoursForEnd,
          minutesForEnd: item.minutesForEnd,
          middayPeriodForEnd: item.middayPeriodForEnd,
          duration: {
            value: 0
          }
        });
        expect(Em.isNone(view.createCustomEndDate(1000))).to.equal(item.isInvalidDate);
      });
    });

    it('preset duration', function () {
      view.set('customDateFormFields.duration', {
        value: 900000
      });
      expect(view.createCustomEndDate(1000)).to.equal(901000);
    });

  });

  describe('#setErrorMessage', function () {

    var cases = [
      {
        key: 'startDate',
        property: 'isStartDateError',
        value: true,
        message: 'error',
        errorMessage: 'error',
        title: 'error'
      },
      {
        key: 'endDate',
        property: 'isEndDateError',
        value: false,
        message: null,
        errorMessage: '',
        title: 'no error'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          view.get('errors').setProperties({
            isStartDateError: false,
            isEndDateError: true
          });
          view.get('errorMessages').setProperties({
            startDate: '',
            endDate: 'error'
          });
          view.setErrorMessage(item.key, item.message);
        });

        it('should set error flag', function () {
          expect(view.get('errors').get(item.property)).to.equal(item.value);
        });

        it('should set error message', function () {
          expect(view.get('errorMessages').get(item.key)).to.equal(item.errorMessage);
        });

      });

    });

  });

  describe('#durationSelect', function () {

    var select;

    beforeEach(function () {
      select = view.get('durationSelect').create();
    });

    describe('#willInsertElement', function () {

      var cases = [
        {
          duration: 1800000,
          selection: {
            value: 1800000,
            label: Em.I18n.t('jobs.customDateFilter.duration.30min')
          },
          title: 'should detect preset option by value'
        },
        {
          duration: Em.I18n.t('jobs.customDateFilter.duration.2hr'),
          selection: {
            value: 7200000,
            label: Em.I18n.t('jobs.customDateFilter.duration.2hr')
          },
          title: 'should detect preset option by label'
        },
        {
          duration: '40 minutes',
          selection: {
            value: 0,
            label: Em.I18n.t('common.custom')
          },
          title: 'should set "Custom" option if preset one can\'t be detected'
        }
      ];

      cases.forEach(function (item) {
        it(item.title, function () {
          select.set('selection', item.duration);
          select.willInsertElement();
          expect(select.get('selection')).to.eql(item.selection);
        });
      });

    });

  });

});

});

;require.register("test/views/common/sort_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var sort = require('views/common/sort_view');
require('utils/misc');
require('utils/string_utils');

describe('#wrapperView', function () {

  describe('#getSortFunc', function () {

    describe('number', function () {

      var property = Em.Object.create({type: 'number', name: 'lastTriggered'});

      Em.A([
          {
            a: Em.Object.create({lastTriggered: 1}),
            b: Em.Object.create({lastTriggered: 0}),
            order: true,
            e: 1
          },
          {
            a: Em.Object.create({lastTriggered: 1}),
            b: Em.Object.create({lastTriggered: 0}),
            order: false,
            e: -1
          },
          {
            a: Em.Object.create({lastTriggered: null}),
            b: Em.Object.create({lastTriggered: 1}),
            order: true,
            e: -Infinity
          },
          {
            a: Em.Object.create({lastTriggered: null}),
            b: Em.Object.create({lastTriggered: 1}),
            order: false,
            e: Infinity
          }
        ]).forEach(function (test, i) {
          it('test #' + (i + 1), function () {
            var func = sort.wrapperView.create().getSortFunc(property, test.order);
            expect(func(test.a, test.b)).to.equal(test.e);
          });
      });

    });

    describe('default', function () {

      var property = Em.Object.create({type: 'string', name: 'serviceName'});

      Em.A([
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 's2'}),
            order: true,
            e: 1
          },
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 's2'}),
            order: false,
            e: -1
          },
          {
            a: Em.Object.create({serviceName: 's1'}),
            b: Em.Object.create({serviceName: 's1'}),
            order: true,
            e: 0
          },
          {
            a: Em.Object.create({serviceName: null}),
            b: Em.Object.create({serviceName: 's2'}),
            order: true,
            e: 1
          },
          {
            a: Em.Object.create({serviceName: null}),
            b: Em.Object.create({serviceName: 's2'}),
            order: false,
            e: -1
          }
        ]).forEach(function (test, i) {
          it('test #' + (i + 1), function () {
            var func = sort.wrapperView.create().getSortFunc(property, test.order);
            expect(func(test.a, test.b)).to.equal(test.e);
          });
      });

      it('test non-string values', function () {
        property = Em.Object.create({type: 'string', name: 'enabled'});
        var func = sort.wrapperView.create().getSortFunc(property, true),
        a = Em.Object.create({enabled: false}),
        b = Em.Object.create({enabled: true});
        expect(func(a, b)).to.equal(1);
      });

    });

  });

  describe('#fieldView', function () {

    var fieldView, wrapperView;

    describe('#click', function () {

      beforeEach(function () {
        fieldView = sort.fieldView.create({
          controller: Em.Object.create({
            sortingColumn: null
          })
        });
        wrapperView = sort.wrapperView.create({
          childViews: [fieldView]
        });
        fieldView.reopen({'parentView': wrapperView});

        sinon.stub(wrapperView, 'sort', Em.K);
        sinon.stub(wrapperView, 'removeSortingObserver', Em.K);
        sinon.stub(wrapperView, 'addSortingObserver', Em.K);
      });

      afterEach(function () {
        wrapperView.sort.restore();
        wrapperView.removeSortingObserver.restore();
        wrapperView.addSortingObserver.restore();
      });

      it('should call sort function of wrapperView', function () {
        fieldView.click();
        expect(wrapperView.sort.calledOnce).to.be.true;
      });

      it('should call removeSortingObserver function of wrapperView if sortingColumn is absent in controller', function () {
        fieldView.reopen({
          controller: Em.Object.create({
            sortingColumn: {name: 'test'}
          })
        });
        fieldView.click();
        expect(wrapperView.removeSortingObserver.calledOnce).to.be.true;
      });

      it('should not call removeSortingObserver function of wrapperView if sortingColumn exists in controller', function () {
        fieldView.click();
        expect(wrapperView.removeSortingObserver.calledOnce).to.be.false;
      });

      it('should call addSortingObserver function of wrapperView', function () {
        fieldView.click();
        expect(wrapperView.addSortingObserver.calledOnce).to.be.true;
      });

    })
  })

});
});

;require.register("test/views/common/table_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('utils/db');
require('views/common/filter_view');
require('views/common/sort_view');
require('mixins');
require('mixins/common/userPref');
require('views/common/table_view');

describe('App.TableView', function () {

  var view;

  beforeEach(function() {
    App.db.cleanUp();
  });

  afterEach(function() {
    App.db.cleanUp();
  });

  describe('#init', function() {

    it('should set filterConditions on instance', function() {
      var tableView = App.TableView.create();
      expect(tableView.get('filterConditions') === App.TableView.prototype.filterConditions).to.be.false;
    });

  });

  describe('#updatePaging', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should set "startIndex" to 0 if "filteredContent" is empty', function() {
      view.set('filteredContent', []);
      expect(view.get('startIndex')).to.equal(0);
    });

    it('should set "startIndex" to 1 if "filteredContent" is not empty', function() {
      view.set('filteredContent', d3.range(1, 10));
      expect(view.get('startIndex')).to.equal(1);
    });

  });

  describe('#endIndex', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('endIndex')).to.equal(11);
    });

    it('should be recalculated if "displayLength" was changed', function() {
      view.set('displayLength', 5);
      expect(view.get('endIndex')).to.equal(5);
    });

    it('should be recalculated (but not changed) if "filteredContent" was changed (and "filterContent.length" is more than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('endIndex')).to.equal(endIndexBefore);
    });

    it('should be recalculated (and changed) if "filteredContent" was changed (and "filterContent.length" is less than "startIndex + displayLength")', function() {
      var endIndexBefore = view.get('endIndex');
      var indx = 4;
      view.set('filteredContent', d3.range(1,indx));
      expect(view.get('endIndex')).to.not.equal(endIndexBefore);
      expect(view.get('endIndex')).to.equal(indx - 1);
    });

  });

  describe('#pageContent', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filtersUsedCalc: function() {},
        filter: function() {}
      });
      view.clearFilters();
      view.updateFilter();
    });

    it('should be recalculated if "startIndex" was changed', function() {
      view.set('startIndex', 2);
      expect(view.get('pageContent').length).to.equal(9);
    });

    it('should be recalculated if "endIndex" was changed', function() {
      view.set('endIndex', 5);
      expect(view.get('pageContent').length).to.equal(5);
    });

    it('should be recalculated if "filteredContent" was changed', function() {
      var pageContentBefore = view.get('pageContent');
      view.set('filteredContent', d3.range(2,100));
      expect(view.get('pageContent').length).to.equal(pageContentBefore.length);
      expect(view.get('pageContent')).to.not.eql(pageContentBefore);
    });

  });

  describe('#clearFilters', function() {

    it('should set "filterConditions" to empty array', function() {
      view.clearFilters();
      expect(view.get('filterConditions')).to.eql([]);
    });

  });

  describe('#filtersUsedCalc', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "filtersUsed" to false if "filterConditions" is empty array', function() {
      view.set('filterConditions', []);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to false if each value in "filterConditions" is empty', function() {
      view.set('filterConditions', [{value:''}, {value:''}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(false);
    });

    it('should set "filtersUsed" to true if one or more values in "filterConditions" are not empty', function() {
      view.set('filterConditions', [{value:''}, {value:'lol'}]);
      view.filtersUsedCalc();
      expect(view.get('filtersUsed')).to.equal(true);
    });

  });

  describe('#nextPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 1,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 10,
        filter: function() {}
      });
    });

    it('should set "startIndex" if "filteredContent.length is greater than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex + displayLength);
    });

    it('should not set "startIndex" if "filteredContent.length is equal to "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 99;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

    it('should not set "startIndex" if "filteredContent.length is less than "startIndex" + "displayLength"', function() {
      var oldStartIndex = view.get('startIndex');
      var displayLength = 100;
      view.set('displayLength', displayLength);
      view.nextPage();
      expect(view.get('startIndex')).to.equal(oldStartIndex);
    });

  });

  describe('#previousPage', function() {

    beforeEach(function() {
      view = App.TableView.create(App.UserPref, {
        controller: Em.Object.create({}),
        displayLength: 10,
        startIndex: 50,
        content: d3.range(1, 100),
        filteredContent: d3.range(1, 100),
        endIndex: 60,
        filter: function() {}
      });
    });

    it('should set "startIndex" to 1', function() {
      var displayLength = 50;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(1);
    });

    it('should not set "startIndex" to 40', function() {
      view.set('startIndex', 50);
      var displayLength = 10;
      view.set('displayLength', displayLength);
      view.previousPage();
      expect(view.get('startIndex')).to.equal(40);
    });

  });

  describe("#showFilteredContent", function() {
    beforeEach(function() {
      view = App.TableView.create({});
    });

    it('hide clear filters link', function () {
      view.set('filterConditions', []);
      expect(view.get('showFilteredContent')).to.be.false;
    });

    it('shows clear filters link', function () {
      view.set('filterConditions', [{value: "1"}]);
      expect(view.get('showFilteredContent')).to.be.true;
    });

    it('shows clear filters link for array filter', function () {
      view.set('filterConditions', [{value: ["1", "2"]}]);
      expect(view.get('showFilteredContent')).to.be.true;
    });
  });

  describe('#filter', function () {

    var cases = [
      {
        filterConditions: [
          {
            iColumn: 1,
            type: 'string',
            value: 'v0'
          }
        ],
        content: [
          Em.Object.create({
            c0: 'v0'
          }),
          Em.Object.create({
            c1: 'v1'
          })
        ],
        filteredContent: [],
        title: 'no matches'
      },
      {
        filterConditions: [
          {
            iColumn: 0,
            type: 'string',
            value: 'v1'
          }
        ],
        content: [
          Em.Object.create({
            c0: 'v1'
          }),
          Em.Object.create({
            c0: 'v11'
          }),
          Em.Object.create({
            c1: 'v01'
          })
        ],
        filteredContent: [
          Em.Object.create({
            c0: 'v1'
          }),
          Em.Object.create({
            c0: 'v11'
          })
        ],
        title: 'matches present'
      },
      {
        filterConditions: [],
        content: [
          Em.Object.create({
            c0: 'v0'
          }),
          Em.Object.create({
            c1: 'v1'
          })
        ],
        filteredContent: [
          Em.Object.create({
            c0: 'v0'
          }),
          Em.Object.create({
            c1: 'v1'
          })
        ],
        title: 'no filter conditions'
      },
      {
        filterConditions: [],
        filteredContent: [],
        title: 'no filter conditions, no content'
      }
    ];

    beforeEach(function () {
      view = App.TableView.create({
        colPropAssoc: ['c0', 'c1']
      });
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.setProperties({
          filterConditions: item.filterConditions,
          content: item.content
        });
        view.filter();
        expect(view.get('filteredContent')).to.eql(item.filteredContent);
      });
    });

  });

});

});

;require.register("test/views/common/widget/gauge_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/widget/gauge_widget_view');

describe('App.GaugeWidgetView', function () {
  var view = App.GaugeWidgetView.create({
    value: 0,
    content: {
      properties: {
        warning_threshold: 0,
        critical_threshold: 0
      }
    }
  });

  describe("#chartView.contentColor()", function() {
    var testCases = [
      {
        title: 'both thresholds NOT existed',
        data: {
          value: 0.2,
          warningThreshold: null,
          criticalThreshold: null
        },
        result: App.healthStatusGreen
      },
      {
        title: 'both thresholds existed 1',
        data: {
          value: 0.2,
          warningThreshold: 0.1,
          criticalThreshold: 0.3
        },
        result: App.healthStatusOrange
      },
      {
        title: 'both thresholds existed 2',
        data: {
          value: 0.2,
          warningThreshold: 0.3,
          criticalThreshold: 0.1
        },
        result: App.healthStatusOrange
      },
      {
        title: 'both thresholds existed 3',
        data: {
          value: 0.05,
          warningThreshold: 0.1,
          criticalThreshold: 0.3
        },
        result: App.healthStatusGreen
      },
      {
        title: 'both thresholds existed 4',
        data: {
          value: 0.35,
          warningThreshold: 0.3,
          criticalThreshold: 0.1
        },
        result: App.healthStatusGreen
      },
      {
        title: 'both thresholds existed 5',
        data: {
          value: 0.35,
          warningThreshold: 0.1,
          criticalThreshold: 0.3
        },
        result: App.healthStatusRed
      },
      {
        title: 'both thresholds existed 6',
        data: {
          value: 0.05,
          warningThreshold: 0.3,
          criticalThreshold: 0.1
        },
        result: App.healthStatusRed
      },
      {
        title: 'only warning threshold existed 1',
        data: {
          value: 0,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: App.healthStatusGreen
      },
      {
        title: 'only warning threshold existed 2',
        data: {
          value: 2,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: App.healthStatusOrange
      },
      {
        title: 'only critical threshold existed 1',
        data: {
          value: 0.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: App.healthStatusGreen
      },
      {
        title: 'only critical threshold existed 2',
        data: {
          value: 1.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: App.healthStatusRed
      },
      {
        title: 'invalid thresholds 1',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: 1
        },
        result: App.healthStatusRed
      },
      {
        title: 'invalid thresholds 2',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: '@#^^'
        },
        result: App.healthStatusGreen
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('value', test.data.value);
        view.set('content.properties.warning_threshold', test.data.warningThreshold);
        view.set('content.properties.error_threshold', test.data.criticalThreshold);
        var chartView = view.chartView.create({
          parentView: view
        });
        expect(chartView.get('contentColor')).to.eql(test.result);
      });
    });
  });
});
});

;require.register("test/views/common/widget/graph_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/widget/graph_widget_view');
var fileUtils = require('utils/file_utils');

describe('App.GraphWidgetView', function () {
  var view = App.GraphWidgetView.create();

  describe("#adjustData()", function() {
    var testCases = [
      {
        title: 'empty data',
        data: {
          dataLinks: {},
          dataLength: 0
        },
        result: {}
      },
      {
        title: 'correct data',
        data: {
          dataLinks: {
            s1: [[0, 0]]
          },
          dataLength: 1
        },
        result:  {
          s1: [[0, 0]]
        }
      },
      {
        title: 'second series empty',
        data: {
          dataLinks: {
            s1: [[1, 0]],
            s2: []
          },
          dataLength: 1
        },
        result:  {
          s1: [[1, 0]],
          s2: [[null, 0]]
        }
      },
      {
        title: 'second series missing data at the end',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[1, 0]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[1, 0], [null, 1], [null, 2]]
        }
      },
      {
        title: 'second series missing data at the beginning',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[3, 2]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[null, 0], [null, 1], [3, 2]]
        }
      },
      {
        title: 'second series missing data in the middle',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[1, 1]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[null, 0], [1, 1], [null, 2]]
        }
      },
      {
        title: 'second and third series missing data',
        data: {
          dataLinks: {
            s1: [[1, 0], [2, 1], [3, 2]],
            s2: [[1, 1]],
            s3: [[1, 2]]
          },
          dataLength: 3
        },
        result:  {
          s1: [[1, 0], [2, 1], [3, 2]],
          s2: [[null, 0], [1, 1], [null, 2]],
          s3: [[null, 0], [null, 1], [1, 2]]
        }
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        view.adjustData(test.data.dataLinks, test.data.dataLength);
        expect(test.data.dataLinks).to.eql(test.result);
      });
    });
  });

  describe('#exportGraphData', function () {

    var cases = [
      {
        data: null,
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'no data'
      },
      {
        data: {},
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'invalid data'
      },
      {
        data: [
          {
            data: null
          }
        ],
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'empty data'
      },
      {
        data: [
          {
            data: {}
          }
        ],
        downloadTextFileCallCount: 0,
        showAlertPopupCallCount: 1,
        title: 'malformed data'
      },
      {
        data: [
          {
            name: 'name',
            data: [0,1]
          }
        ],
        downloadTextFileCallCount: 1,
        showAlertPopupCallCount: 0,
        fileData: '[{"name":"name","data":[0,1]}]',
        title: 'JSON export'
      },
      {
        data: [
          {
            data: [
              {
                key: 'value'
              }
            ]
          }
        ],
        event: {
          context: true
        },
        downloadTextFileCallCount: 1,
        showAlertPopupCallCount: 0,
        fileData: 'key,value',
        title: 'CSV export'
      }
    ];

    beforeEach(function () {
      sinon.stub(view, 'prepareCSV').returns('key,value');
      sinon.stub(fileUtils, 'downloadTextFile', Em.K);
      sinon.stub(App, 'showAlertPopup', Em.K);
    });

    afterEach(function () {
      view.prepareCSV.restore();
      fileUtils.downloadTextFile.restore();
      App.showAlertPopup.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('data', item.data);
        view.exportGraphData(item.event || {});
        expect(view.get('isExportMenuHidden')).to.be.true;
        expect(fileUtils.downloadTextFile.callCount).to.equal(item.downloadTextFileCallCount);
        expect(App.showAlertPopup.callCount).to.equal(item.showAlertPopupCallCount);
        if (item.downloadTextFileCallCount) {
          var fileType = item.event && item.event.context ? 'csv' : 'json',
            downloadArgs = fileUtils.downloadTextFile.firstCall.args;
          expect(downloadArgs[0].replace(/\s/g, '')).to.equal(item.fileData);
          expect(downloadArgs[1]).to.equal(fileType);
          expect(downloadArgs[2]).to.equal('data.' + fileType);
        }
      });
    });

  });

  describe('#exportTargetView', function () {

    var childViews = [
        {
          p0: 'v0'
        },
        {
          p1: 'v1'
        }
      ],
      title = 'should take last child view';

    beforeEach(function () {
      view.get('childViews').pushObjects(childViews);
      view.propertyDidChange('exportTargetView');
    });

    it(title, function () {
      expect(view.get('exportTargetView')).to.eql(childViews[1]);
    });
  });

});
});

;require.register("test/views/common/widget/number_widget_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/common/widget/number_widget_view');

describe('App.NumberWidgetView', function () {
  var view = App.NumberWidgetView.create({
    value: 0,
    content: {
      properties: {
        warning_threshold: 0,
        critical_threshold: 0
      }
    }
  });

  describe("#contentColor()", function() {
    var testCases = [
      {
        title: 'no value',
        data: {
          value: null,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'grey'
      },
      {
        title: 'no value',
        data: {
          value: null,
          warningThreshold: null,
          criticalThreshold: null
        },
        result: 'grey'
      },
      {
        title: 'no value',
        data: {
          value: null,
          warningThreshold: null,
          criticalThreshold: 3
        },
        result: 'grey'
      },
      {
        title: 'both thresholds NOT existed',
        data: {
          value: 2,
          warningThreshold: null,
          criticalThreshold: null
        },
        result: 'green'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 2,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'orange'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 2,
          warningThreshold: 3,
          criticalThreshold: 1
        },
        result: 'orange'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 0.5,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'green'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 3.5,
          warningThreshold: 3,
          criticalThreshold: 1
        },
        result: 'green'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 3.5,
          warningThreshold: 1,
          criticalThreshold: 3
        },
        result: 'red'
      },
      {
        title: 'both thresholds existed',
        data: {
          value: 0.5,
          warningThreshold: 3,
          criticalThreshold: 1
        },
        result: 'red'
      },
      {
        title: 'only warning threshold existed',
        data: {
          value: 0,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: 'green'
      },
      {
        title: 'only warning threshold existed',
        data: {
          value: 2,
          warningThreshold: 1,
          criticalThreshold: null
        },
        result: 'orange'
      },
      {
        title: 'only critical threshold existed',
        data: {
          value: 0.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: 'green'
      },
      {
        title: 'only critical threshold existed',
        data: {
          value: 1.5,
          warningThreshold: null,
          criticalThreshold: 1
        },
        result: 'red'
      },
      {
        title: 'invalid thresholds',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: 1
        },
        result: 'red'
      },
      {
        title: 'invalid thresholds',
        data: {
          value: 1.5,
          warningThreshold: '&*&%',
          criticalThreshold: '@#^^'
        },
        result: 'green'
      }
    ];

    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('value', test.data.value);
        view.set('content.properties.warning_threshold', test.data.warningThreshold);
        view.set('content.properties.error_threshold', test.data.criticalThreshold);
        expect(view.get('contentColor')).to.eql(test.result);
      });
    });
  });
});
});

;require.register("test/views/installer_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/installer');

var view,
  stepsCount = 11,
  isStepDisabled = [],
  properties = [];

for (var i = 0; i < stepsCount; i++ ) {
  isStepDisabled.push(Em.Object.create({
    step: i,
    value: Boolean(Math.floor(Math.random() * 2))
  }));
  properties.push('isStep' + i + 'Disabled');
}

describe('App.InstallerView', function () {

  beforeEach(function () {
    view = App.InstallerView.create({
      controller: {
        isStepDisabled: isStepDisabled
      }
    });
  });

  properties.forEach(function (item, index) {
    describe(item, function () {
      it('should take value from isStepDisabled', function () {
        expect(view.get(item)).to.equal(isStepDisabled.findProperty('step', index).get('value'));
      });
    });
  });

});

});

;require.register("test/views/login_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/login');

var view,
  controller,
  pass;

describe('App.LoginView', function () {

  before(function () {
    sinon.stub(App, 'get', function(k) {
      if (k === 'router') return {
        login: Em.K
      };
      return Em.get(App, k);
    });
  });

  beforeEach(function () {
    view = App.LoginView.create();
    pass = view.passTextField.create({
      controller: App.LoginController.create()
    });
  });

  after(function () {
    App.get.restore();
  });

  describe('#passTextField', function () {
    it('should change error message', function () {
      pass.insertNewline();
      expect(pass.get('controller.errorMessage')).to.be.empty;
    });
  });

});

});

;require.register("test/views/main/admin/highAvailability/nameNode/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step1_view');

describe('App.HighAvailabilityWizardStep1View', function () {
  var view = App.HighAvailabilityWizardStep1View.create({
    controller: Em.Object.create({
      content: {}
    })
  });

  describe("#didInsertElement()", function() {
    before(function(){
      sinon.stub(App, 'popover', Em.K);
    });
    after(function(){
      App.popover.restore();
    });
    it("init popover", function() {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.be.true;
    });
  });

  describe("#showInputError", function() {
    it("isNameServiceIdValid is true, nameServiceId is empty", function() {
      view.set('controller.isNameServiceIdValid', true);
      view.set('controller.content.nameServiceId', "");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.false;
    });
    it("isNameServiceIdValid is false, nameServiceId is empty", function() {
      view.set('controller.isNameServiceIdValid', false);
      view.set('controller.content.nameServiceId', "");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.false;
    });
    it("isNameServiceIdValid is true, nameServiceId is valid", function() {
      view.set('controller.isNameServiceIdValid', true);
      view.set('controller.content.nameServiceId', "name");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.false;
    });
    it("isNameServiceIdValid is false, nameServiceId is valid", function() {
      view.set('controller.isNameServiceIdValid', false);
      view.set('controller.content.nameServiceId', "name");
      view.propertyDidChange('showInputError');
      expect(view.get('showInputError')).to.be.true;
    });
  });
});

});

;require.register("test/views/main/admin/highAvailability/nameNode/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step3_view');

describe('App.HighAvailabilityWizardStep3View', function () {
  var view = App.HighAvailabilityWizardStep3View.create({
    controller: Em.Object.create({
      content: {},
      loadStep: Em.K
    })
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.spy(view.get('controller'), 'loadStep');
    });
    after(function () {
      view.get('controller').loadStep.restore();
    });
    it("call loadStep", function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });

  describe("#curNameNode", function() {
    it("", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: true,
        hostName: 'host1'
      }]);
      view.propertyDidChange('curNameNode');
      expect(view.get('curNameNode')).to.equal('host1');
    });
  });

  describe("#addNameNode", function() {
    it("", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: false,
        hostName: 'host1'
      }]);
      view.propertyDidChange('addNameNode');
      expect(view.get('addNameNode')).to.equal('host1');
    });
  });

  describe("#secondaryNameNode", function() {
    it("", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'SECONDARY_NAMENODE',
        hostName: 'host1'
      }]);
      view.propertyDidChange('secondaryNameNode');
      expect(view.get('secondaryNameNode')).to.equal('host1');
    });
  });

  describe("#journalNodes", function() {
    it("", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'JOURNALNODE',
        hostName: 'host1'
      }]);
      view.propertyDidChange('journalNodes');
      expect(view.get('journalNodes')).to.eql([{
        component: 'JOURNALNODE',
        hostName: 'host1'
      }]);
    });
  });
});

});

;require.register("test/views/main/admin/highAvailability/nameNode/step4_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step4_view');

describe('App.HighAvailabilityWizardStep4View', function () {
  var view = App.HighAvailabilityWizardStep4View.create({
    controller: Em.Object.create({
      content: {},
      pullCheckPointStatus: Em.K
    })
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.spy(view.get('controller'), 'pullCheckPointStatus');
    });
    after(function () {
      view.get('controller').pullCheckPointStatus.restore();
    });
    it("call pullCheckPointStatus", function () {
      view.didInsertElement();
      expect(view.get('controller').pullCheckPointStatus.calledOnce).to.be.true;
    });
  });

  describe("#step4BodyText", function() {
    it("", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: true,
        hostName: 'host1'
      }]);
      view.set('controller.content.hdfsUser', 'user');
      view.propertyDidChange('step4BodyText');
      expect(view.get('step4BodyText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step4.body').format('user', 'host1'));
    });
  });

  describe("#nnCheckPointText", function() {
    it("isNextEnabled true", function() {
      view.set('controller.isNextEnabled', true);
      view.propertyDidChange('nnCheckPointText');
      expect(view.get('nnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step4.ckCreated'));
    });
    it("isNextEnabled false", function() {
      view.set('controller.isNextEnabled', false);
      view.propertyDidChange('nnCheckPointText');
      expect(view.get('nnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step4.ckNotCreated'));
    });
  });
});

});

;require.register("test/views/main/admin/highAvailability/nameNode/step6_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step6_view');

describe('App.HighAvailabilityWizardStep6View', function () {
  var view = App.HighAvailabilityWizardStep6View.create({
    controller: Em.Object.create({
      content: {},
      loadStep: Em.K
    })
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.spy(view.get('controller'), 'loadStep');
    });
    after(function () {
      view.get('controller').loadStep.restore();
    });
    it("call loadStep", function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.be.true;
    });
  });

  describe("#step6BodyText", function() {
    it("", function() {
      view.set('controller.content.masterComponentHosts', [{
        component: 'NAMENODE',
        isInstalled: true,
        hostName: 'host1'
      }]);
      view.set('controller.content.hdfsUser', 'user');
      view.propertyDidChange('step6BodyText');
      expect(view.get('step6BodyText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.body').format('user', 'host1'));
    });
  });

  describe("#jnCheckPointText", function() {
    it("status is done", function() {
      view.set('controller.status', 'done');
      view.propertyDidChange('jnCheckPointText');
      expect(view.get('jnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.jsInit'));
    });
    it("status is waiting", function() {
      view.set('controller.status', 'waiting');
      view.propertyDidChange('jnCheckPointText');
      expect(view.get('jnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.jsNoInit'));
    });
    it("status is journalnode_stopped", function() {
      view.set('controller.status', 'journalnode_stopped');
      view.propertyDidChange('jnCheckPointText');
      expect(view.get('jnCheckPointText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step6.jnStopped'));
    });
  });
});

});

;require.register("test/views/main/admin/highAvailability/nameNode/step8_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/step8_view');

describe('App.HighAvailabilityWizardStep8View', function () {
  var view = App.HighAvailabilityWizardStep8View.create({
    controller: Em.Object.create({
      content: {},
      pullCheckPointStatus: Em.K
    })
  });

  describe("#step8BodyText", function() {
    it("", function() {
      view.set('controller.content.masterComponentHosts', [
        {
          component: 'NAMENODE',
          isInstalled: true,
          hostName: 'host1'
        },
        {
          component: 'NAMENODE',
          isInstalled: false,
          hostName: 'host2'
        }
      ]);
      view.set('controller.content.hdfsUser', 'user');
      view.propertyDidChange('step8BodyText');
      expect(view.get('step8BodyText')).to.equal(Em.I18n.t('admin.highAvailability.wizard.step8.body').format('user', 'host1', 'host2'));
    });
  });
});

});

;require.register("test/views/main/admin/highAvailability/nameNode/wizard_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/highAvailability/nameNode/wizard_view');

describe('App.HighAvailabilityWizardView', function () {
  var view = App.HighAvailabilityWizardView.create({
    controller: Em.Object.create({
      content: {},
      setLowerStepsDisable: Em.K,
      isStepDisabled: []
    })
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'setLowerStepsDisable');
    });
    afterEach(function () {
      view.get('controller').setLowerStepsDisable.restore();
    });
    it("currentStep is 0", function () {
      view.set('controller.currentStep', 0);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.called).to.be.false;
    });
    it("currentStep is 4", function () {
      view.set('controller.currentStep', 4);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.called).to.be.false;
    });
    it("currentStep is 5", function () {
      view.set('controller.currentStep', 5);
      view.didInsertElement();
      expect(view.get('controller').setLowerStepsDisable.calledWith(5)).to.be.true;
    });
  });
});
});

;require.register("test/views/main/admin/stack_upgrade/failed_hosts_modal_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/failed_hosts_modal_view');

describe('App.FailedHostsPopupBodyView', function () {
  var view = App.FailedHostsPopupBodyView.create({
    parentView: Em.Object.create({
      content: {}
    })
  });


  describe("#subHeader", function() {
    it("", function() {
      view.set('parentView.content', {
        hosts: ['host1', 'host2', 'host3']
      });
      view.propertyDidChange('subHeader');
      expect(view.get('subHeader')).to.equal(Em.I18n.t('admin.stackUpgrade.failedHosts.subHeader').format(3));
    });
  });

  describe("#hosts", function() {
    beforeEach(function(){
      sinon.stub(App.format, 'role', function(name){
        return name;
      })
    });
    afterEach(function(){
      App.format.role.restore();
    });

    it("", function() {
      view.set('parentView.content', {
        hosts: ['host1', 'long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm'],
        host_detail: {
          "host1": [
            {
              component: 'DATANODE',
              service: 'HDFS'
            },
            {
              component: 'HBASE_REGIONSERVER',
              service: 'HBASE'
            }
          ],
          "long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm": [
            {
              service: 'FLUME',
              component: 'FLUME_AGENT'
            }
          ]
        }
      });
      view.propertyDidChange('hosts');
      expect(view.get('hosts')).to.eql([
        Em.Object.create({
          hostName: 'host1',
          displayName: 'host1',
          collapseId: 'collapse0',
          collapseHref: '#collapse0',
          hostComponents: [
            Em.Object.create({
              componentName: 'DATANODE',
              serviceName: 'HDFS'
            }),
            Em.Object.create({
              componentName: 'HBASE_REGIONSERVER',
              serviceName: 'HBASE'
            })
          ]
        }),
        Em.Object.create({
          hostName: 'long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmmm',
          displayName: 'long.host.50.chars.commmmmmmmmmmmmmmmmmmmmmmmmmmmm...',
          collapseId: 'collapse1',
          collapseHref: '#collapse1',
          hostComponents: [
            Em.Object.create({
              componentName: 'FLUME_AGENT',
              serviceName: 'FLUME'
            })
          ]
        })
      ]);
    });
  });
});

});

;require.register("test/views/main/admin/stack_upgrade/menu_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.MainAdminStackMenuView', function () {

  beforeEach(function () {
    view = App.MainAdminStackMenuView.create({});
  });

  describe('#content', function () {

    afterEach(function () {
      App.get.restore();
    });

    Em.A([
        {
          stackVersionsAvailable: true,
          m: '`versions` is visible',
          e: false
        },
        {
          stackVersionsAvailable: false,
          m: '`versions` is invisible',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          var stub = sinon.stub(App, 'get');
          stub.withArgs('stackVersionsAvailable').returns(test.stackVersionsAvailable);
          view.propertyDidChange('content');
          expect(view.get('content').findProperty('name', 'versions').get('hidden')).to.equal(test.e);
        });
      });

  });

});
});

;require.register("test/views/main/admin/stack_upgrade/services_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/services_view');

describe('App.MainAdminStackServicesView', function () {
  var view = App.MainAdminStackServicesView.create();

  describe("#services", function () {
    before(function () {
      sinon.stub(App.StackService, 'find').returns([
        Em.Object.create({serviceName: 'S1', isInstalled: false}),
        Em.Object.create({serviceName: 'S2', isInstalled: false})
      ]);
      sinon.stub(App.Service, 'find').returns([
        Em.Object.create({serviceName: 'S1'})
      ]);
    });
    after(function () {
      App.StackService.find.restore();
      App.Service.find.restore();
    });
    it("", function () {
      view.propertyDidChange('services');
      expect(view.get('services')).to.eql([
        Em.Object.create({serviceName: 'S1', isInstalled: true}),
        Em.Object.create({serviceName: 'S2', isInstalled: false})
      ]);
    });
  });

  describe("#goToAddService()" , function() {
    var mock = Em.Object.create({
        checkAndStartKerberosWizard: Em.K,
        setDBProperty: sinon.spy()
      }),
      isAccessibleMock;
    beforeEach(function() {
      sinon.stub(App.get('router'), 'transitionTo', Em.K);
      sinon.stub(App.router, 'get').returns(mock);
      sinon.spy(mock, 'checkAndStartKerberosWizard');
      isAccessibleMock = sinon.stub(App, 'isAccessible');
    });
    afterEach(function() {
      App.get('router').transitionTo.restore();
      App.router.get.restore();
      mock.checkAndStartKerberosWizard.restore();
      App.isAccessible.restore();
    });
    it ("operations locked", function () {
      isAccessibleMock.returns(false);
      view.goToAddService();
      expect(App.router.get.called).to.be.false;
      expect(App.get('router').transitionTo.called).to.be.false;
    });
    it("routes to Add Service Wizard and set redirect path on wizard close", function() {
      isAccessibleMock.returns(true);
      view.goToAddService({context: "serviceName"});
      expect(App.router.get.calledWith('addServiceController') && mock.setDBProperty.calledWith('onClosePath', 'main.admin.stackAndUpgrade.services')).to.be.true;
      expect(App.get('router').transitionTo.calledWith('main.serviceAdd')).to.be.true;
      expect(mock.get('serviceToInstall')).to.be.equal("serviceName");
    });
    it("routes to Security Wizard", function() {
      isAccessibleMock.returns(true);
      view.goToAddService({context: "KERBEROS"});
      expect(App.router.get.calledWith('kerberosWizardController') && mock.setDBProperty.calledWith('onClosePath', 'main.admin.stackAndUpgrade.services')).to.be.true;
      expect(mock.checkAndStartKerberosWizard.calledOnce).to.be.true;
    });
  });

  describe('#isAddServiceAvailable', function () {

    var cases = [true, false],
      titleTemplate = 'should be {0}',
      isAccessibleMock;

    beforeEach(function() {
      isAccessibleMock = sinon.stub(App, 'isAccessible');
    });

    afterEach(function() {
      App.isAccessible.restore();
    });

    cases.forEach(function (item) {
      it(titleTemplate.format(item.toString()), function () {
        isAccessibleMock.returns(item);
        view.propertyDidChange('isAddServiceAvailable');
        expect(view.get('isAddServiceAvailable')).to.equal(item);
      });
    });

  });
});

});

;require.register("test/views/main/admin/stack_upgrade/upgrade_group_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_group_view');

describe('App.upgradeGroupView', function () {
  var view = App.upgradeGroupView.create({
    content: Em.Object.create({}),
    failedStatuses: ['FAILED']
  });

  describe("#toggleExpanded()", function () {
    before(function () {
      sinon.stub(view, 'collapseLowerLevels', Em.K);
    });
    after(function () {
      view.collapseLowerLevels.restore();
    });
    it("", function () {
      var data = {
        context: Em.Object.create({
          isExpanded: true
        }),
        contexts: [
          [],
          [
            Em.Object.create({
              isExpanded: true
            })
          ]
        ]
      };
      view.toggleExpanded(data);
      expect(view.collapseLowerLevels.calledTwice).to.be.true;
      expect(data.context.get('isExpanded')).to.be.false;
      expect(data.contexts[1][0].get('isExpanded')).to.be.false;
    });
  });

  describe("#collapseLowerLevels()", function () {
    beforeEach(function () {
      sinon.spy(view, 'collapseLowerLevels');
    });
    afterEach(function () {
      view.collapseLowerLevels.restore();
    });
    it("isExpanded false", function () {
      var data = Em.Object.create({
        isExpanded: false
      });
      view.collapseLowerLevels(data);
      expect(view.collapseLowerLevels.calledOnce).to.be.true;
      expect(data.get('isExpanded')).to.be.false;
    });
    it("ITEM expanded", function () {
      var data = Em.Object.create({
        isExpanded: true,
        type: 'ITEM',
        tasks: [
          Em.Object.create({
            isExpanded: true
          })
        ]
      });
      view.collapseLowerLevels(data);
      expect(view.collapseLowerLevels.calledOnce).to.be.true;
      expect(data.get('tasks')[0].get('isExpanded')).to.be.false;
    });
    it("GROUP expanded", function () {
      var data = Em.Object.create({
        isExpanded: true,
        type: 'GROUP',
        upgradeItems: [
          Em.Object.create({
            isExpanded: true
          })
        ]
      });
      view.collapseLowerLevels(data);
      expect(view.collapseLowerLevels.calledTwice).to.be.true;
      expect(data.get('upgradeItems')[0].get('isExpanded')).to.be.false;
    });
  });

});
});

;require.register("test/views/main/admin/stack_upgrade/upgrade_task_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_task_view');

describe('App.upgradeTaskView', function () {
  var view = App.upgradeTaskView.create({
    content: Em.Object.create(),
    taskDetailsProperties: ['prop1']
  });
  view.removeObserver('content.isExpanded', view, 'doPolling');
  view.removeObserver('outsideView', view, 'doPolling');

  describe("#logTabId", function() {
    it("", function() {
      view.reopen({
        elementId: 'elementId'
      });
      expect(view.get('logTabId')).to.equal('elementId-log-tab');
    });
  });

  describe("#errorTabId", function() {
    it("", function() {
      view.reopen({
        elementId: 'elementId'
      });
      expect(view.get('errorTabId')).to.equal('elementId-error-tab');
    });
  });

  describe("#logTabIdLink", function() {
    it("", function() {
      view.reopen({
        logTabId: 'elementId-log-tab'
      });
      expect(view.get('logTabIdLink')).to.equal('#elementId-log-tab');
    });
  });

  describe("#errorTabIdLInk", function() {
    it("", function() {
      view.reopen({
        errorTabId: 'elementId-error-tab'
      });
      expect(view.get('errorTabIdLInk')).to.equal('#elementId-error-tab');
    });
  });

  describe("#copyErrLog()", function () {
    before(function () {
      sinon.stub(view, 'toggleProperty', Em.K);
    });
    after(function () {
      view.toggleProperty.restore();
    });
    it("", function () {
      view.copyErrLog();
      expect(view.toggleProperty.calledWith('errorLogOpened')).to.be.true;
    });
  });

  describe("#copyOutLog()", function () {
    before(function () {
      sinon.stub(view, 'toggleProperty', Em.K);
    });
    after(function () {
      view.toggleProperty.restore();
    });
    it("", function () {
      view.copyOutLog();
      expect(view.toggleProperty.calledWith('outputLogOpened')).to.be.true;
    });
  });

  describe("#openErrorLog()", function () {
    before(function () {
      sinon.stub(view, 'openLogWindow', Em.K);
    });
    after(function () {
      view.openLogWindow.restore();
    });
    it("", function () {
      view.set('content.stderr', 'stderr');
      view.openErrorLog();
      expect(view.openLogWindow.calledWith('stderr')).to.be.true;
    });
  });

  describe("#openOutLog()", function () {
    before(function () {
      sinon.stub(view, 'openLogWindow', Em.K);
    });
    after(function () {
      view.openLogWindow.restore();
    });
    it("", function () {
      view.set('content.stdout', 'stdout');
      view.openOutLog();
      expect(view.openLogWindow.calledWith('stdout')).to.be.true;
    });
  });

  describe("#openLogWindow()", function () {
    var mockAppendChild = {
        appendChild: Em.K
      },
      mockWindow = {
        document: {
          write: Em.K,
          close: Em.K,
          createElement: function () {
            return mockAppendChild;
          },
          createTextNode: Em.K,
          body: mockAppendChild
        }
      };
    before(function () {
      sinon.stub(window, 'open').returns(mockWindow);
      sinon.spy(mockWindow.document, 'write');
      sinon.spy(mockWindow.document, 'close');
      sinon.spy(mockWindow.document, 'createElement');
      sinon.spy(mockWindow.document, 'createTextNode');
      sinon.spy(mockAppendChild, 'appendChild');
    });
    after(function () {
      window.open.restore();
      mockWindow.document.write.restore();
      mockWindow.document.close.restore();
      mockWindow.document.createElement.restore();
      mockWindow.document.createTextNode.restore();
    });
    it("", function () {
      view.openLogWindow('log');
      expect(window.open.calledOnce).to.be.true;
      expect(mockWindow.document.createElement.calledWith('pre')).to.be.true;
      expect(mockWindow.document.createTextNode.calledWith('log')).to.be.true;
      expect(mockAppendChild.appendChild.calledTwice).to.be.true;
      expect(mockWindow.document.close.calledOnce).to.be.true;
    });
  });

  describe("#showContent", function() {
    it("outsideView = false, content.isExpanded = false", function() {
      view.set('outsideView', false);
      view.set('content.isExpanded', false);
      view.propertyDidChange('showContent');
      expect(view.get('showContent')).to.be.false;
    });
    it("outsideView = true, content.isExpanded = false", function() {
      view.set('outsideView', true);
      view.set('content.isExpanded', false);
      view.propertyDidChange('showContent');
      expect(view.get('showContent')).to.be.true;
    });
    it("outsideView = false, content.isExpanded = true", function() {
      view.set('outsideView', false);
      view.set('content.isExpanded', true);
      view.propertyDidChange('showContent');
      expect(view.get('showContent')).to.be.true;
    });
    it("outsideView = true, content.isExpanded = true", function() {
      view.set('outsideView', true);
      view.set('content.isExpanded', true);
      view.propertyDidChange('showContent');
      expect(view.get('showContent')).to.be.true;
    });
  });

});

});

;require.register("test/views/main/admin/stack_upgrade/upgrade_version_box_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_version_box_view');

describe('App.UpgradeVersionBoxView', function () {

  var view;

  beforeEach(function () {
    view = App.UpgradeVersionBoxView.create({
      controller: Em.Object.create({
        upgrade: Em.K
      }),
      content: Em.Object.create(),
      parentView: Em.Object.create({
        repoVersions: []
      })
    });
  });

  describe("#isUpgrading", function () {
    afterEach(function () {
      App.set('upgradeState', 'INIT');
    });
    it("wrong version", function () {
      App.set('upgradeState', 'IN_PROGRESS');
      view.set('controller.upgradeVersion', 'HDP-2.2.1');
      view.set('content.displayName', 'HDP-2.2.2');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.false;
    });
    it("correct version", function () {
      App.set('upgradeState', 'IN_PROGRESS');
      view.set('controller.upgradeVersion', 'HDP-2.2.2');
      view.set('content.displayName', 'HDP-2.2.2');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.true;
    });
    it("upgradeState INIT", function () {
      App.set('upgradeState', 'INIT');
      view.set('controller.upgradeVersion', 'HDP-2.2.2');
      view.set('content.displayName', 'HDP-2.2.2');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.false;
    });
    it("upgradeState INIT and wrong version", function () {
      App.set('upgradeState', 'INIT');
      view.set('controller.upgradeVersion', 'HDP-2.2.2');
      view.set('content.displayName', 'HDP-2.2.1');
      view.propertyDidChange('isUpgrading');
      expect(view.get('isUpgrading')).to.be.false;
    });
  });

  describe("#installProgress", function () {

    beforeEach(function () {
      this.mockDB = sinon.stub(App.db, 'get');
      this.mock = sinon.stub(App.router, 'get');
      App.set('testMode', false);
    });
    afterEach(function () {
      this.mockDB.restore();
      this.mock.restore();
    });

    it("request id is not set", function () {
      this.mock.returns([]);
      this.mockDB.returns(undefined);
      view.propertyDidChange('installProgress');
      expect(view.get('installProgress')).to.equal(0);
    });
    it("request absent", function () {
      this.mock.returns([]);
      this.mockDB.returns([1]);
      view.propertyDidChange('installProgress');
      expect(view.get('installProgress')).to.equal(0);
    });
    it("request present", function () {
      this.mockDB.returns([1]);
      this.mock.returns([Em.Object.create({progress: 100, id: 1})]);
      view.propertyDidChange('installProgress');
      expect(view.get('installProgress')).to.equal(100);
    });
  });

  describe("#versionClass", function () {
    it("status CURRENT", function () {
      view.set('content.status', 'CURRENT');
      view.propertyDidChange('versionClass');
      expect(view.get('versionClass')).to.equal('current-version-box');
    });
    it("status INSTALLED", function () {
      view.set('content.status', 'INSTALLED');
      view.propertyDidChange('versionClass');
      expect(view.get('versionClass')).to.equal('');
    });
  });

  describe("#isOutOfSync", function () {
    it("status OUT_OF_SYNC", function () {
      view.set('content.status', 'OUT_OF_SYNC');
      view.propertyDidChange('isOutOfSync');
      expect(view.get('isOutOfSync')).to.be.true;
    });
  });

  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.stub(App, 'tooltip').returns(1);
    });
    afterEach(function () {
      App.tooltip.restore();
    });
    it("init tooltips", function () {
      view.didInsertElement();
      expect(App.tooltip.callCount).to.equal(3);
    });
  });

  describe("#runAction()", function () {
    var hasClass = function () {
        return true;
      },
      jQueryMock;
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'upgrade').returns(1);
      jQueryMock = sinon.stub(window, '$');
    });
    afterEach(function () {
      view.get('controller').upgrade.restore();
      jQueryMock.restore();
    });
    it("action = null", function () {
      view.set('stateElement.action', null);
      view.runAction({context: null});
      expect(view.get('controller').upgrade.called).to.be.false;
    });
    it("action = 'upgrade'", function () {
      view.set('content', 'content');
      view.runAction({context: 'upgrade'});
      expect(view.get('controller').upgrade.calledWith('content')).to.be.true;
    });
    it("action is taken from stateElement", function () {
      view.setProperties({
        'content': 'content',
        'stateElement.action': 'upgrade'
      });
      view.runAction();
      expect(view.get('controller').upgrade.calledWith('content')).to.be.true;
    });
    it("link is disabled", function () {
      jQueryMock.returns({
        hasClass: hasClass,
        parent: function () {
          return {
            hasClass: Em.K
          };
        }
      });
      view.runAction({
        context: 'upgrade',
        target: {}
      });
      expect(view.get('controller').upgrade.called).to.be.false;
    });
    it("link parent element is disabled", function () {
      jQueryMock.returns({
        hasClass: Em.K,
        parent: function () {
          return {
            hasClass: hasClass
          };
        }
      });
      view.runAction({
        context: 'upgrade',
        target: {}
      });
      expect(view.get('controller').upgrade.called).to.be.false;
    });
  });
  
  describe("#getStackVersionNumber()", function(){
    it("get stack version number", function(){
      var repoRecord = Em.Object.create({
        operatingSystems: [
          Em.Object.create({
            osType: "redhat6",
            repositories: [Em.Object.create({
                "baseUrl": "111121",
                "repoId": "HDP-2.3",
                "repoName": "HDP",
                "stackVersion": "2.3",
                hasError: false
            }), Em.Object.create({
                "baseUrl": "1",
                "repoId": "HDP-UTILS-1.1.0.20",
                "repoName": "HDP-UTILS",
                "stackVersion": "2.3",
                hasError: false
              })]
           })
        ]
      });
      
      var stackVersionNumber = view.getStackVersionNumber(repoRecord);
      expect(stackVersionNumber).to.equal('2.3');
    });
  });
  
  describe("#editRepositories()", function () {
    var cases = [
      {
        isRepoUrlsEditDisabled: true,
        popupShowCallCount: 0,
        title: 'edit repo URLS disabled, popup shouldn\'t be shown'
      },
      {
        isRepoUrlsEditDisabled: false,
        popupShowCallCount: 1,
        title: 'edit repo URLS enabled, popup should be shown'
      }
    ];
    beforeEach(function () {
      sinon.stub(App.RepositoryVersion, 'find').returns(Em.Object.create({
        operatingSystems: []
      }));
      sinon.stub(App.ModalPopup, 'show', Em.K);
    });
    afterEach(function () {
      App.RepositoryVersion.find.restore();
      App.ModalPopup.show.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        view.reopen({
          isRepoUrlsEditDisabled: item.isRepoUrlsEditDisabled
        });
        view.editRepositories();
        expect(App.ModalPopup.show.callCount).to.equal(item.popupShowCallCount);
      });
    });
  });

  describe("#showHosts()", function () {
    beforeEach(function () {
      sinon.spy(App.ModalPopup, 'show');
      sinon.stub(view, 'filterHostsByStack', Em.K);
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
      view.filterHostsByStack.restore();
    });
    it("no hosts", function () {
      view.set('content', Em.Object.create({
        p1: []
      }));
      view.set('p1', []);
      view.showHosts({contexts: [
        {'property': 'p1'}
      ]});
      expect(App.ModalPopup.show.called).to.be.false;
    });
    it("one host", function () {
      view.set('content', Em.Object.create({
        p1: ['host1'],
        displayName: 'version'
      }));
      view.set('p1', ['host1']);
      var popup = view.showHosts({contexts: [
        {id: 1, 'property': 'p1'}
      ]});
      expect(App.ModalPopup.show.calledOnce).to.be.true;
      popup.onPrimary();
      expect(view.filterHostsByStack.calledWith('version', 1)).to.be.true;
    });
  });

  describe("#filterHostsByStack()", function () {
    var mock = {
      set: Em.K,
      filterByStack: Em.K
    };
    beforeEach(function () {
      sinon.stub(App.router, 'get').withArgs('mainHostController').returns(mock);
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.spy(mock, 'set');
      sinon.spy(mock, 'filterByStack');
    });
    afterEach(function () {
      App.router.get.restore();
      App.router.transitionTo.restore();
      mock.set.restore();
      mock.filterByStack.restore();
    });
    it("version and state are valid", function () {
      view.filterHostsByStack('version', 'state');
      expect(mock.set.calledWith('showFilterConditionsFirstLoad', true)).to.be.true;
      expect(mock.filterByStack.calledWith('version', 'state')).to.be.true;
      expect(App.router.transitionTo.calledWith('hosts.index')).to.be.true;
    });
    it("version is null", function () {
      view.filterHostsByStack(null, 'state');
      expect(mock.set.called).to.be.false;
      expect(mock.filterByStack.called).to.be.false;
      expect(App.router.transitionTo.called).to.be.false;
    });
    it("state is null", function () {
      view.filterHostsByStack('version', null);
      expect(mock.set.called).to.be.false;
      expect(mock.filterByStack.called).to.be.false;
      expect(App.router.transitionTo.called).to.be.false;
    });
    it("state and version are null", function () {
      view.filterHostsByStack(null, null);
      expect(mock.set.called).to.be.false;
      expect(mock.filterByStack.called).to.be.false;
      expect(App.router.transitionTo.called).to.be.false;
    });
  });

  describe('#stateElement', function () {

    var cases = [
      {
        inputData: {
          'content.status': 'CURRENT'
        },
        expected: {
          status: 'CURRENT',
          isLabel: true,
          text: Em.I18n.t('common.current'),
          class: 'label label-success'
        },
        title: 'current version'
      },
      {
        inputData: {
          'content.status': 'INIT',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INIT'
            })
          ]
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(false);
        },
        expected: {
          status: 'INIT',
          isButton: true,
          buttons: [],
          isDisabled: true
        },
        title: 'INIT state, no admin access, no requests in progress'
      },
      {
        inputData: {
          'content.status': 'INIT',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INIT'
            })
          ]
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(false);
        },
        expected: {
          status: 'INIT',
          isButton: true,
          buttons: [],
          isDisabled: true
        },
        title: 'INIT state, no admin access, request in progress, not installation'
      },
      {
        inputData: {
          'content.status': 'INSTALL_FAILED',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALL_FAILED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(false);
        },
        expected: {
          status: 'INSTALL_FAILED',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.reinstall'),
            action: 'installRepoVersionConfirmation',
            isDisabled: true
          }],
          text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
          action: 'confirmUpgrade',
          isDisabled: true
        },
        title: 'INSTALL_FAILED state, no admin access, request in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'INSTALL_FAILED',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALL_FAILED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(false);
        },
        expected: {
          status: 'INSTALL_FAILED',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.reinstall'),
            action: 'installRepoVersionConfirmation',
            isDisabled: true
          }],
          text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
          action: 'confirmUpgrade',
          isDisabled: true
        },
        title: 'INSTALL_FAILED state, no admin access, no requests in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'OUT_OF_SYNC',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'OUT_OF_SYNC'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(true);
        },
        expected: {
          status: 'OUT_OF_SYNC',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
            action: 'confirmUpgrade',
            isDisabled: false
          }],
          text: Em.I18n.t('admin.stackVersions.version.reinstall'),
          action: 'installRepoVersionConfirmation',
          isDisabled: false
        },
        title: 'OUT_OF_SYNC state, admin access, no requests in progress, no installation'
      },
      {
        inputData: {
          'content.status': 'OUT_OF_SYNC',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'OUT_OF_SYNC'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(true);
        },
        expected: {
          status: 'OUT_OF_SYNC',
          isButtonGroup: true,
          buttons: [{
            text: Em.I18n.t('admin.stackVersions.version.performUpgrade'),
            action: 'confirmUpgrade',
            isDisabled: true
          }],
          text: Em.I18n.t('admin.stackVersions.version.reinstall'),
          action: 'installRepoVersionConfirmation',
          isDisabled: true
        },
        title: 'OUT_OF_SYNC state, admin access, request in progress, no installation'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.currentVersion': {
            repository_version: '2.2.1'
          },
          'content.repositoryVersion': '2.2.0',
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.0'
        },
        expected: {
          status: 'INSTALLED',
          isLink: true,
          iconClass: 'icon-ok',
          text: Em.I18n.t('common.installed'),
          action: null
        },
        title: 'installed version, earlier than current one'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.requestInProgress': true,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALLED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.0',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(true);
        },
        expected: {
          status: 'INSTALLED',
          isButtonGroup: true,
          buttons: [
            {
              text: Em.I18n.t('admin.stackVersions.version.reinstall'),
              action: 'installRepoVersionConfirmation',
              isDisabled: true
            }
          ],
          isDisabled: true
        },
        title: 'installed version, later than current one, admin access, request in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.requestInProgress': false,
          'parentView.repoVersions': [
            Em.Object.create({
              status: 'INSTALLED'
            }),
            Em.Object.create({
              status: 'INSTALLING'
            })
          ],
          'controller.currentVersion': {
            repository_version: '2.2.0'
          },
          'content.repositoryVersion': '2.2.1',
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.0'
        },
        setup: function () {
          this.isAccessibleMock.withArgs('ADMIN').returns(true);
        },
        expected: {
          status: 'INSTALLED',
          isButtonGroup: true,
          buttons: [
            {
              text: Em.I18n.t('admin.stackVersions.version.reinstall'),
              action: 'installRepoVersionConfirmation',
              isDisabled: true
            }
          ],
          isDisabled: true
        },
        title: 'installed version, later than current one, admin access, no requests in progress, another installation running'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns(null);
        },
        expected: {
          status: 'INSTALLED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-cog',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.running')
        },
        title: 'downgrading'
      },
      {
        inputData: {
          'content.status': 'INSTALLED',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('IN_PROGRESS');
        },
        expected: {
          status: 'INSTALLED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-cog',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.running')
        },
        title: 'upgrading'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING');
        },
        expected: {
          status: 'UPGRADING',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrading, holding'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_FAILED');
        },
        expected: {
          status: 'UPGRADING',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrading, holding failed'
      },
      {
        inputData: {
          'content.status': 'UPGRADE_FAILED',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_TIMEDOUT');
        },
        expected: {
          status: 'UPGRADE_FAILED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.upgrade.pause')
        },
        title: 'upgrade failed, holding finished on timeout'
      },
      {
        inputData: {
          'content.status': 'UPGRADE_FAILED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING');
        },
        expected: {
          status: 'UPGRADE_FAILED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.pause')
        },
        title: 'downgrading, holding'
      },
      {
        inputData: {
          'content.status': 'UPGRADED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_FAILED');
        },
        expected: {
          status: 'UPGRADED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.pause')
        },
        title: 'downgrading, holding failed'
      },
      {
        inputData: {
          'content.status': 'UPGRADED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.upgradeVersion': 'HDP-2.2.1',
          'content.displayName': 'HDP-2.2.1'
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('HOLDING_TIMEDOUT');
        },
        expected: {
          status: 'UPGRADED',
          isLink: true,
          action: 'openUpgradeDialog',
          iconClass: 'icon-pause',
          text: Em.I18n.t('admin.stackVersions.version.downgrade.pause')
        },
        title: 'downgrading, holding finished on timeout'
      },
      {
        inputData: {
          'content.status': 'UPGRADING',
          'isUpgrading': true,
          'controller.isDowngrade': false,
          'controller.requestInProgress': false,
          'parentView.repoVersions': []
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('ABORTED');
        },
        expected: {
          status: 'UPGRADING',
          isButton: true,
          action: 'resumeUpgrade',
          text: Em.I18n.t('admin.stackUpgrade.dialog.resume'),
          isDisabled: false
        },
        title: 'upgrade aborted'
      },
      {
        inputData: {
          'content.status': 'UPGRADE_FAILED',
          'isUpgrading': true,
          'controller.isDowngrade': true,
          'controller.requestInProgress': true,
          'parentView.repoVersions': []
        },
        setup: function () {
          this.getMock.withArgs('upgradeState').returns('ABORTED');
        },
        expected: {
          status: 'UPGRADE_FAILED',
          isButton: true,
          action: 'resumeUpgrade',
          text: Em.I18n.t('admin.stackUpgrade.dialog.resume.downgrade'),
          isDisabled: true
        },
        title: 'downgrade aborted, request in progress'
      }
    ];

    beforeEach(function () {
      this.getMock = sinon.stub(App, 'get');
      this.isAccessibleMock = sinon.stub(App, 'isAccessible');
    });
    afterEach(function () {
      this.getMock.restore();
      this.isAccessibleMock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        if (item.setup) {
          item.setup.call(this);
        }
        view.setProperties(item.inputData);
        var result = view.get('stateElement').getProperties(Em.keys(item.expected));
        if (result.buttons) {
          result.buttons = result.buttons.toArray();
        }
        expect(result).to.eql(item.expected);
      });
    }, this);

  });

  describe('#isRepoUrlsEditDisabled', function () {

    var cases = [
      {
        status: 'INSTALLING',
        isUpgrading: false,
        isRepoUrlsEditDisabled: true,
        title: 'installing packages'
      },
      {
        status: 'UPGRADING',
        isUpgrading: true,
        isRepoUrlsEditDisabled: true,
        title: 'upgrading'
      },
      {
        status: 'INSTALLED',
        isUpgrading: true,
        isRepoUrlsEditDisabled: true,
        title: 'upgrading just started'
      },
      {
        status: 'INIT',
        isUpgrading: false,
        isRepoUrlsEditDisabled: false,
        title: 'neither upgrading nor installing packages'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        view.reopen({
          isUpgrading: item.isUpgrading
        });
        view.set('content.status', item.status);
        expect(view.get('isRepoUrlsEditDisabled')).to.equal(item.isRepoUrlsEditDisabled);
      });
    });
  });
});

});

;require.register("test/views/main/admin/stack_upgrade/upgrade_wizard_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_wizard_view');

describe('App.upgradeWizardView', function () {
  var view = App.upgradeWizardView.create({
    failedStatuses: ['FAILED']
  });
  view.reopen({
    controller: Em.Object.create({
      finalizeContext: 'Confirm Finalize',
      resolveHostsContext: 'Check Unhealthy Hosts',
      upgradeData: Em.Object.create(),
      loadUpgradeData: Em.K,
      setUpgradeItemStatus: Em.K,
      getUpgradeItem: function () {
        return {complete: Em.K};
      },
      load: Em.K
    })
  });
  view.removeObserver('App.clusterName', view, 'startPolling');
  view.removeObserver('App.clusterName', view, 'loadVersionPage');

  describe("#upgradeGroups", function () {
    it("upgradeGroups is null", function () {
      view.set('controller.upgradeData.upgradeGroups', null);
      view.propertyDidChange('upgradeGroups');
      expect(view.get('upgradeGroups')).to.be.empty;
    });
    it("upgradeGroups is valid", function () {
      view.set('controller.upgradeData.upgradeGroups', [Em.Object.create()]);
      view.propertyDidChange('upgradeGroups');
      expect(view.get('upgradeGroups')).to.not.be.empty;
    });
  });

  describe("#activeGroup", function () {
    after(function () {
      view.reopen({
        activeGroup: Em.Object.create()
      });
    });
    it("", function () {
      view.reopen({
        activeStatuses: ['IN_PROGRESS'],
        upgradeGroups: [Em.Object.create({
          status: 'IN_PROGRESS'
        })]
      });
      view.propertyDidChange('activeGroup');
      expect(view.get('activeGroup')).to.eql(Em.Object.create({
        status: 'IN_PROGRESS'
      }));
    });
  });

  describe("#overallProgress", function () {
    it("progress is 1.9", function () {
      view.set('controller.upgradeData', {
        Upgrade: {
          progress_percent: 1.9
        }
      });
      expect(view.get('overallProgress')).to.equal(1);
    });
    it("progress is 1", function () {
      view.set('controller.upgradeData', {
        Upgrade: {
          progress_percent: 1
        }
      });
      expect(view.get('overallProgress')).to.equal(1);
    });
  });

  describe("#startPolling()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'loadUpgradeData', function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      });
      sinon.stub(view.get('controller'), 'load', function() {
        return {done: Em.K};
      });
      sinon.stub(view, 'doPolling', Em.K);
      view.set('isLoaded', false);
    });
    afterEach(function () {
      view.get('controller').loadUpgradeData.restore();
      view.doPolling.restore();
      view.get('controller').load.restore();
    });
    it("clusterName is null", function () {
      App.set('clusterName', null);
      view.startPolling();
      expect(view.doPolling.called).to.be.false;
      expect(view.get('isLoaded')).to.be.false;
    });
    it("clusterName set", function () {
      App.set('clusterName', 'c1');
      view.startPolling();
      expect(view.get('controller').loadUpgradeData.calledOnce).to.be.true;
      expect(view.doPolling.calledOnce).to.be.true;
      expect(view.get('isLoaded')).to.be.true;
    });
  });

  describe("#loadVersionPage()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'load', function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      });
      view.set('isLoaded', false);
    });
    afterEach(function () {
      view.get('controller').load.restore();
    });
    it("clusterName is null", function () {
      App.set('clusterName', null);
      view.set('controller.isLoaded', false);
      view.loadVersionPage();
      expect(view.get('controller').load.called).to.be.false;
      expect(view.get('controller.isLoaded')).to.be.false;
    });
    it("controller already loaded", function () {
      App.set('clusterName', 'c1');
      view.set('controller.isLoaded', true);
      view.loadVersionPage();
      expect(view.get('controller').load.called).to.be.false;
      expect(view.get('controller.isLoaded')).to.be.true;
    });
    it("controller not loaded and clusterName present", function () {
      App.set('clusterName', 'c1');
      view.set('controller.isLoaded', false);
      view.loadVersionPage();
      expect(view.get('controller').load.calledOnce).to.be.true;
      expect(view.get('controller.isLoaded')).to.be.true;
    });
  });

  describe("#showFailedHosts()", function () {
    beforeEach(function () {
      sinon.stub(App.ModalPopup, 'show');
    });
    afterEach(function () {
      App.ModalPopup.show.restore();
    });
    it("", function () {
      view.set('controller.slaveComponentStructuredInfo', {});
      view.showFailedHosts();
      expect(App.ModalPopup.show.calledWith({
        header: Em.I18n.t('admin.stackUpgrade.failedHosts.header'),
        bodyClass: App.FailedHostsPopupBodyView,
        secondary: null,
        primary: Em.I18n.t('common.close'),
        content: {}
      })).to.be.true;
    });
  });

  describe("#willInsertElement()", function () {
    before(function () {
      sinon.stub(view, 'startPolling', Em.K);
    });
    after(function () {
      view.startPolling.restore();
    });
    it("call startPolling()", function () {
      view.willInsertElement();
      expect(view.startPolling.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function () {
    it("call startPolling()", function () {
      view.set('isLoaded', true);
      view.willDestroyElement();
      expect(view.get('isLoaded')).to.be.false;
    });
  });

  describe("#doPolling()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'loadUpgradeData', function () {
        return {
          done: function (callback) {
            callback();
          }
        }
      });
      sinon.spy(view, 'doPolling');
      this.clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      view.get('controller').loadUpgradeData.restore();
      view.doPolling.restore();
      this.clock.restore();
    });
    it("", function () {
      view.doPolling();
      this.clock.tick(App.bgOperationsUpdateInterval);
      expect(view.get('controller').loadUpgradeData.calledOnce).to.be.true;
      expect(view.doPolling.calledTwice).to.be.true;
    });
  });

  describe("#continue()", function () {
    before(function () {
      sinon.stub(view.get('controller'), 'setUpgradeItemStatus', Em.K);
    });
    after(function () {
      view.get('controller').setUpgradeItemStatus.restore();
    });
    it("", function () {
      view.continue({context: Em.Object.create({'status': 'HOLDING_FAILED'})});
      expect(view.get('controller').setUpgradeItemStatus.calledWith(Em.Object.create({'status': 'HOLDING_FAILED'}), 'FAILED')).to.be.true;
      expect(view.get('isDetailsOpened')).to.be.false;
    });
  });

  describe("#complete()", function () {
    before(function () {
      sinon.stub(view.get('controller'), 'setUpgradeItemStatus', Em.K);
    });
    after(function () {
      view.get('controller').setUpgradeItemStatus.restore();
    });
    it("", function () {
      view.complete({context: Em.Object.create({'status': 'FAILED'})});
      expect(view.get('controller').setUpgradeItemStatus.calledWith(Em.Object.create({'status': 'FAILED'}), 'COMPLETED')).to.be.true;
      expect(view.get('isManualDone')).to.be.false;
    });
  });

  describe("#retry()", function () {
    before(function () {
      sinon.stub(view.get('controller'), 'setUpgradeItemStatus', Em.K);
    });
    after(function () {
      view.get('controller').setUpgradeItemStatus.restore();
    });
    it("", function () {
      view.retry({context: Em.Object.create({'status': 'FAILED'})});
      expect(view.get('controller').setUpgradeItemStatus.calledWith(Em.Object.create({'status': 'FAILED'}), 'PENDING')).to.be.true;
      expect(view.get('isDetailsOpened')).to.be.false;
    });
  });

  describe("#manualItem", function () {
    it("no running item", function () {
      view.set('activeGroup.upgradeItems', []);
      view.propertyDidChange('manualItem');
      expect(view.get('manualItem')).to.be.undefined;
    });
    it("running item present", function () {
      view.set('activeGroup.upgradeItems', [Em.Object.create({status: 'HOLDING'})]);
      view.propertyDidChange('manualItem');
      expect(view.get('manualItem')).to.be.eql(Em.Object.create({status: 'HOLDING'}));
    });
  });

  describe("#isManualProceedDisabled", function () {
    it("requestInProgress is false", function () {
      view.set('isManualDone', true);
      view.set('controller.requestInProgress', false);
      view.propertyDidChange('isManualProceedDisabled');
      expect(view.get('isManualProceedDisabled')).to.be.false;
    });
    it("requestInProgress is true", function () {
      view.set('controller.requestInProgress', true);
      view.propertyDidChange('isManualProceedDisabled');
      expect(view.get('isManualProceedDisabled')).to.be.true;
    });

  });

  describe("#resetManualDone()", function() {
    it("", function() {
      view.set('isManualDone', true);
      view.propertyDidChange('manualItem');
      expect(view.get('isManualDone')).to.be.false;
    });
  });

  describe("#failedItem", function () {
    it("no running item", function () {
      view.set('activeGroup.upgradeItems', []);
      view.propertyDidChange('failedItem');
      expect(view.get('failedItem')).to.be.undefined;
    });
    it("running item present", function () {
      view.set('activeGroup.upgradeItems', [Em.Object.create({status: 'FAILED'})]);
      view.propertyDidChange('failedItem');
      expect(view.get('failedItem')).to.be.eql(Em.Object.create({status: 'FAILED'}));
    });
  });

  describe("#runningItem", function () {
    it("no running item", function () {
      view.set('activeGroup.upgradeItems', []);
      view.propertyDidChange('runningItem');
      expect(view.get('runningItem')).to.be.undefined;
    });
    it("running item present", function () {
      view.set('activeGroup.upgradeItems', [
        Em.Object.create({status: 'IN_PROGRESS'})
      ]);
      view.propertyDidChange('runningItem');
      expect(view.get('runningItem')).to.be.eql(Em.Object.create({status: 'IN_PROGRESS'}));
    });
  });

  describe("#noActiveItem", function () {
    beforeEach(function () {
      this.mock = sinon.stub(App, 'get');
    });
    afterEach(function () {
      this.mock.restore();
    });
    var testCases = [
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'COMPLETED'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'INIT'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'ABORTED'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: null,
          upgradeState: 'IN_PROGRESS'
        },
        result: true
      },
      {
        data: {
          failedItem: {},
          runningItem: null,
          manualItem: null,
          upgradeState: 'IN_PROGRESS'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: {},
          manualItem: null,
          upgradeState: 'IN_PROGRESS'
        },
        result: false
      },
      {
        data: {
          failedItem: null,
          runningItem: null,
          manualItem: {},
          upgradeState: 'IN_PROGRESS'
        },
        result: false
      }
    ].forEach(function (test) {
        it("failedItem = " + test.data.failedItem +
        ";runningItem = " + test.data.runningItem +
        ";manualItem = " + test.data.manualItem +
        ";upgradeState = " + test.data.upgradeState, function () {
          view.reopen(test.data);
          this.mock.withArgs('upgradeState').returns(test.data.upgradeState);
          view.propertyDidChange('noActiveItem');
          expect(view.get('noActiveItem')).to.equal(test.result);
        });
      });
  });

  describe("#isHoldingState", function () {
    var testCases = [
      {
        data: {
          failedItem: {status: 'PENDING'}
        },
        result: false
      },
      {
        data: {
          failedItem: {status: 'HOLDING_FAILED'}
        },
        result: true
      },
      {
        data: {
          failedItem: {status: 'HOLDING_TIMED_OUT'}
        },
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it('failedItem - ' + test.data.failedItem, function () {
        view.reopen({
          failedItem: test.data.failedItem
        });
        view.propertyDidChange('isHoldingState');
        expect(view.get('isHoldingState')).to.equal(test.result);
      });
    });
  });

  describe("#isDowngradeAvailable", function () {
    it("downgrade available", function () {
      view.set('controller.isDowngrade', false);
      view.set('controller.downgradeAllowed', true);
      view.propertyDidChange('isDowngradeAvailable');
      expect(view.get('isDowngradeAvailable')).to.be.true;
    });
    it("downgrade unavailable", function () {
      view.set('controller.isDowngrade', true);
      view.set('controller.downgradeAllowed', true);
      view.propertyDidChange('isDowngradeAvailable');
      expect(view.get('isDowngradeAvailable')).to.be.false;
    });
  });

  describe("#taskDetails", function () {
    it("runningItem present", function () {
      view.reopen({
        runningItem: Em.Object.create({
          tasks: [{status: "IN_PROGRESS"}]
        })
      });
      view.propertyDidChange('taskDetails');
      expect(view.get('taskDetails')).to.eql({status: "IN_PROGRESS"});
    });
    it("failedItem present", function () {
      view.reopen({
        failedItem: Em.Object.create({
          tasks: [Em.Object.create({status: "FAILED"})]
        }),
        failedStatuses: ['FAILED'],
        runningItem: null
      });
      view.propertyDidChange('taskDetails');
      expect(view.get('taskDetails').get('status')).to.equal('FAILED');
    });
    it("failedItem and runningItem are absent", function () {
      view.reopen({
        failedItem: null,
        runningItem: null
      });
      view.propertyDidChange('taskDetails');
      expect(view.get('taskDetails')).to.be.null;
    });
  });

  describe("#plainManualItem", function () {
    it("depends of manualItem.context", function () {
      view.reopen({
        manualItem: {
          context: 'context'
        }
      });
      view.propertyDidChange('plainManualItem');
      expect(view.get('plainManualItem')).to.be.true;
    });
  });

  describe("#isResolveHostsItem", function () {
    it("depends of manualItem.context", function () {
      view.reopen({
        manualItem: {
          context: 'Check Unhealthy Hosts'
        }
      });
      view.propertyDidChange('isResolveHostsItem');
      expect(view.get('isResolveHostsItem')).to.be.true;
    });
  });

  describe("#isFinalizeItem", function () {
    it("depends of manualItem.context", function () {
      view.reopen({
        manualItem: {
          context: 'Confirm Finalize'
        }
      });
      view.propertyDidChange('isFinalizeItem');
      expect(view.get('isFinalizeItem')).to.be.true;
    });
  });

  describe("#failedHostsMessage", function() {
    it("", function() {
      view.set('controller.slaveComponentStructuredInfo', {
        hosts: ['host1']
      });
      view.propertyDidChange('failedHostsMessage');
      expect(view.get('failedHostsMessage')).to.equal(Em.I18n.t('admin.stackUpgrade.failedHosts.showHosts').format(1));
    });
  });

  describe("#toggleDetails()", function () {
    before(function () {
      sinon.stub(view, 'toggleProperty', Em.K);
    });
    after(function () {
      view.toggleProperty.restore();
    });
    it("", function () {
      view.toggleDetails();
      expect(view.toggleProperty.calledWith('isDetailsOpened')).to.be.true;
    });
  });

  describe("#upgradeStatusLabel", function () {
    var testCases = [
      {
        data: {
          status: 'QUEUED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'PENDING',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'IN_PROGRESS',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress')
      },
      {
        data: {
          status: 'COMPLETED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.completed')
      },
      {
        data: {
          status: 'ABORTED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'TIMEDOUT',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'FAILED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING_FAILED',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING_TIMEDOUT',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: 'HOLDING',
          isDowngrade: false
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused')
      },
      {
        data: {
          status: '',
          isDowngrade: false
        },
        result: ''
      },
      {
        data: {
          status: 'QUEUED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'PENDING',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'IN_PROGRESS',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.inProgress.downgrade')
      },
      {
        data: {
          status: 'COMPLETED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.completed.downgrade')
      },
      {
        data: {
          status: 'ABORTED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'TIMEDOUT',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'FAILED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING_FAILED',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING_TIMEDOUT',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      },
      {
        data: {
          status: 'HOLDING',
          isDowngrade: true
        },
        result: Em.I18n.t('admin.stackUpgrade.state.paused.downgrade')
      }
    ].forEach(function (test) {
        it('status = ' + test.data.status + ", isDowngrade = " + test.data.isDowngrade, function () {
          view.set('controller.isDowngrade', test.data.isDowngrade);
          view.set('controller.isSuspended', test.data.isSuspended);
          view.set('controller.upgradeData.Upgrade.request_status', test.data.status);
          view.propertyDidChange('upgradeStatusLabel');
          expect(view.get('upgradeStatusLabel')).to.equal(test.result);
        });
      });
  });

  describe("#doUpgradeItemPolling()", function () {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'getUpgradeItem', function () {
        return {
          complete: function (callback) {
            callback();
          }
        }
      });
      sinon.spy(view, 'doUpgradeItemPolling');
      this.clock = sinon.useFakeTimers();
    });
    afterEach(function () {
      view.get('controller').getUpgradeItem.restore();
      view.doUpgradeItemPolling.restore();
      this.clock.restore();
    });
    it("running item details", function () {
      view.reopen({
        runningItem: {},
        failedItem: null
      });
      view.set('isDetailsOpened', true);
      //doUpgradeItemPolling triggered by observer
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      this.clock.tick(App.bgOperationsUpdateInterval);
      expect(view.doUpgradeItemPolling.calledTwice).to.be.true;
    });
    it("failed item details", function () {
      view.reopen({
        failedItem: {},
        runningItem: null
      });
      view.set('isDetailsOpened', true);
      view.doUpgradeItemPolling();
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      this.clock.tick(App.bgOperationsUpdateInterval);
      expect(view.doUpgradeItemPolling.calledTwice).to.be.true;
    });
    it("details not opened", function () {
      view.set('isDetailsOpened', false);
      //doUpgradeItemPolling triggered by observer
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.false;
      this.clock.tick(App.bgOperationsUpdateInterval);
      expect(view.doUpgradeItemPolling.calledOnce).to.be.true;
    });
  });

  describe('#getSkippedServiceChecks()', function () {

    var cases = [
      {
        isFinalizeItem: false,
        areSkippedServiceChecksLoaded: true,
        ajaxSendCallCount: 0,
        areSkippedServiceChecksLoadedResult: false,
        title: 'no ajax request should be sent away from Finalize step'
      },
      {
        isFinalizeItem: true,
        areSkippedServiceChecksLoaded: true,
        ajaxSendCallCount: 0,
        areSkippedServiceChecksLoadedResult: true,
        title: 'no ajax request should be sent if data is already loaded'
      },
      {
        isFinalizeItem: true,
        areSkippedServiceChecksLoaded: false,
        ajaxSendCallCount: 1,
        areSkippedServiceChecksLoadedResult: true,
        title: 'ajax request should be sent on Finalize step'
      }
    ];

    beforeEach(function () {
      view.set('controller.upgradeId', 1);
      sinon.stub(App.ajax, 'send').returns({
        complete: function (callback) {
          callback();
        }
      });
    });

    afterEach(function () {
      App.ajax.send.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('controller.areSkippedServiceChecksLoaded', item.areSkippedServiceChecksLoaded);
        view.reopen({
          isFinalizeItem: item.isFinalizeItem
        });
        view.propertyDidChange('isFinalizeItem');
        expect(App.ajax.send.callCount).to.equal(item.ajaxSendCallCount);
        expect(view.get('controller.areSkippedServiceChecksLoaded')).to.equal(item.areSkippedServiceChecksLoadedResult);
        if (item.ajaxSendCallCount) {
          expect(App.ajax.send.firstCall.args[0].data.upgradeId).to.equal(1);
        }
      });
    });

  });

  describe('#getSkippedServiceChecksSuccessCallback()', function () {

    var data = {
      items: [
        {
          upgrade_items: [
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK HDFS'
                  }
                }
              ]
            }
          ]
        },
        {
          upgrade_items: [
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK ZOOKEEPER'
                  }
                }
              ]
            },
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK YARN'
                  }
                }
              ]
            },
            {},
            {
              tasks: []
            },
            {
              tasks: [
                {
                  Tasks: null
                },
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK HIVE'
                  }
                }
              ]
            },
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: null
                  }
                },
                {
                  Tasks: {
                    command_detail: 'SERVICE_CHECK YARN'
                  }
                }
              ]
            },
            {
              tasks: [
                {
                  Tasks: {
                    command_detail: 'RESTART HDFS'
                  }
                }
              ]
            }
          ]
        }
      ]
    };

    it('should set an array of service names from tha latest service checks step', function () {
      view.getSkippedServiceChecksSuccessCallback(data);
      expect(view.get('controller.skippedServiceChecks')).to.eql(['ZooKeeper', 'YARN', 'Hive']);
    });

  });

  describe("#getSlaveComponentItem()", function() {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'getUpgradeItem', function () {
        return {
          complete: function (callback) {
            callback();
          }
        }
      });
      view.set('controller.areSlaveComponentFailuresHostsLoaded', false);
    });
    afterEach(function () {
      view.get('controller').getUpgradeItem.restore();
    });

    it("isSlaveComponentFailuresItem is false", function() {
      view.reopen({
        isSlaveComponentFailuresItem: false
      });
      view.getSlaveComponentItem();
      expect(view.get('controller.areSlaveComponentFailuresHostsLoaded')).to.be.false;
    });
    it("isSlaveComponentFailuresItem is true", function() {
      view.reopen({
        isSlaveComponentFailuresItem: true
      });
      view.getSlaveComponentItem();
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      expect(view.get('controller.areSlaveComponentFailuresHostsLoaded')).to.be.true;
    });
  });

  describe("#getServiceCheckItem()", function() {
    beforeEach(function () {
      sinon.stub(view.get('controller'), 'getUpgradeItem', function () {
        return {
          complete: function (callback) {
            callback();
          }
        }
      });
      view.set('controller.areServiceCheckFailuresServicenamesLoaded', false);
    });
    afterEach(function () {
      view.get('controller').getUpgradeItem.restore();
    });

    it("isServiceCheckFailuresItem is false", function() {
      view.reopen({
        isServiceCheckFailuresItem: false
      });
      view.getServiceCheckItem();
      expect(view.get('controller.areServiceCheckFailuresServicenamesLoaded')).to.be.false;
    });
    it("isServiceCheckFailuresItem is true", function() {
      view.reopen({
        isServiceCheckFailuresItem: true
      });
      view.getServiceCheckItem();
      expect(view.get('controller').getUpgradeItem.calledOnce).to.be.true;
      expect(view.get('controller.areServiceCheckFailuresServicenamesLoaded')).to.be.true;
    });
  });

});

});

;require.register("test/views/main/admin/stack_upgrade/version_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin/stack_upgrade/upgrade_wizard_view');

describe('App.mainAdminStackVersionsView', function () {
  var view = App.MainAdminStackVersionsView.create({
    controller: {
      currentVersion: {
        repository_version: "2.2.1.0",
        runningCheckRequests: []
      },
      load: Em.K
    }
  });

  describe("#filterBy()", function () {
    var versions = [
        Em.Object.create({
          status: "INIT",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "INSTALLING",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "INSTALLED",
          repositoryVersion: "2.2.0.1"
        }),
        Em.Object.create({
          status: "INSTALLED",
          repositoryVersion: "2.2.2.1"
        }),
        Em.Object.create({
          status: "INSTALL_FAILED",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "OUT_OF_SYNC",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "UPGRADING",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "UPGRADED",
          repositoryVersion: "2.2.1.1"
        }),
        Em.Object.create({
          status: "CURRENT",
          repositoryVersion: "2.2.1.1"
        })
      ],
      testCases = [
        {
          filter:  Em.Object.create({
            value: ''
          }),
          filteredVersions: [
            Em.Object.create({
              status: "INIT",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALLING",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALLED",
              repositoryVersion: "2.2.2.1"
            }),
            Em.Object.create({
              status: "INSTALL_FAILED",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "OUT_OF_SYNC",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "UPGRADING",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "UPGRADED",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "CURRENT",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'NOT_INSTALLED'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "INIT",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALLING",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "INSTALL_FAILED",
              repositoryVersion: "2.2.1.1"
            }),
            Em.Object.create({
              status: "OUT_OF_SYNC",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'INSTALLED'
          }),
          filteredVersions: [

          ]
        },
        {
          filter:  Em.Object.create({
            value: 'UPGRADE_READY'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "INSTALLED",
              repositoryVersion: "2.2.2.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'CURRENT'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "CURRENT",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'UPGRADING'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "UPGRADING",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          filter:  Em.Object.create({
            value: 'UPGRADED'
          }),
          filteredVersions: [
            Em.Object.create({
              status: "UPGRADED",
              repositoryVersion: "2.2.1.1"
            })
          ]
        },
        {
          noCurrentVersion: true,
          filter:  Em.Object.create({
            value: ''
          }),
          filteredVersions: versions,
          message: 'no current version'
        },
        {
          displayOlderVersions: true,
          filter:  Em.Object.create({
            value: ''
          }),
          filteredVersions: versions,
          message: 'display older versions'
        }
      ];

    afterEach(function () {
      App.get.restore();
    });

    testCases.forEach(function(t) {
      var msg = t.filter.get('value') ? t.filter.get('value') : "All";
      it(t.message || "filter By " + msg, function () {
        sinon.stub(App, 'get', function (key) {
          return key == 'supports.displayOlderVersions' ? Boolean(t.displayOlderVersions) : Em.get(App, key);
        });
        view.set('controller.currentVersion', t.noCurrentVersion ? null : {repository_version: '2.2.1.1'});
        expect(view.filterBy(versions, t.filter)).to.eql(t.filteredVersions);
      });
    });
  });

  describe("#didInsertElement()", function() {
    before(function () {
      sinon.stub(view, 'observesCategories', Em.K);
    });
    after(function () {
      view.observesCategories.restore();
    });
    it("", function() {
      view.didInsertElement();
      expect(view.observesCategories.calledOnce).to.be.true;
    });
  });

  describe("#observesCategories()", function () {
    var mock = {format: Em.K};
    before(function () {
      sinon.stub(Em.I18n, 't').returns(mock);
      sinon.stub(mock, 'format').returns('label');
      sinon.stub(view, 'filterBy').returns([]);
      sinon.stub(view, 'filterVersions');
    });
    after(function () {
      Em.I18n.t.restore();
      mock.format.restore();
      view.filterBy.restore();
      view.filterVersions.restore();
    });
    it("", function () {
      view.set('categories', [
        Em.Object.create({
          labelKey: 'labelKey',
          value: 'value',
          isSelected: false
        })
      ]);
      view.observesCategories();
      expect(view.get('categories')[0].get('label')).to.equal('label');
      expect(view.filterVersions.calledOnce).to.be.true;
    });
  });

  describe("#selectCategory()", function() {
    before(function () {
      sinon.stub(view, 'filterVersions');
    });
    after(function () {
      view.filterVersions.restore();
    });
    it("", function() {
      var event = {
        context: Em.Object.create({
          isSelected: false
        })
      };
      view.set('categories', [
        Em.Object.create({
          isSelected: true
        }),
        event.context
      ]);
      view.selectCategory(event);
      expect(view.get('categories')[0].get('isSelected')).to.be.false;
      expect(event.context.get('isSelected')).to.be.true;
      expect(view.filterVersions.calledWith(event.context)).to.be.true;
    });
  });

  describe("#filterVersions()", function() {
    before(function () {
      sinon.stub(view, 'filterBy').returns([{id: 1}]);
      sinon.stub(view, 'observesCategories', Em.K);
    });
    after(function () {
      view.filterBy.restore();
      view.observesCategories.restore();
    });
    it("", function() {
      view.set('repoVersions', [Em.Object.create({id: 1})]);
      view.filterVersions();
      expect(view.get('repoVersions')[0].get('isVisible')).to.be.true;
    });
  });

  describe("#goToVersions()", function() {
    before(function () {
      sinon.spy(App, 'showConfirmationPopup', Em.K);
      sinon.stub(window.location, 'replace', Em.K);
      var data = {
        components: [{
          'RootServiceComponents': {
            'component_version': '1.9.0'
          }
        }, {
          'RootServiceComponents': {
            'component_version': '2.1.0'
          }
        }, {
          'RootServiceComponents': {
            'component_version': '2.0.0'
          }
        }]
      };
      sinon.stub(App.ajax, 'send').returns({
        then: function(callback) {
          callback(data);
        }
      });
    });
    after(function () {
      App.showConfirmationPopup.restore();
      window.location.replace.restore();
      App.ajax.send.restore();
    });
    it("should go to link using the version retrieved by query", function() {
      var popup = view.goToVersions();
      expect(App.showConfirmationPopup.calledOnce).to.be.true;
      popup.onPrimary();
      expect(App.ajax.send.calledOnce).to.be.true;
      expect(window.location.replace.calledWith('/views/ADMIN_VIEW/2.1.0/INSTANCE/#/stackVersions')).to.be.true;
    });
  });

  describe("#willInsertElement()", function() {
    before(function () {
      sinon.stub(view, 'poll', Em.K);
    });
    after(function () {
      view.poll.restore();
    });
    it("", function() {
      view.willInsertElement();
      expect(view.poll.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function() {
    var abort = sinon.spy(),
      request = {
        abort: abort
      };
    before(function () {
      sinon.stub(window, 'clearTimeout', Em.K);
      view.set('controller.runningCheckRequests', [request, request]);
    });
    after(function () {
      window.clearTimeout.restore();
    });
    it("", function() {
      view.willDestroyElement();
      expect(window.clearTimeout.calledOnce).to.be.true;
      expect(abort.calledTwice).to.be.true;
      expect(view.get('controller.runningCheckRequests')).to.have.length(0);
    });
  });

  describe("#doPolling()", function() {
    before(function () {
      sinon.stub(window, 'setTimeout', Em.K);
    });
    after(function () {
      window.setTimeout.restore();
    });
    it("", function() {
      view.doPolling();
      expect(window.setTimeout.calledOnce).to.be.true;
    });
  });

  describe("#poll()", function() {
    beforeEach(function () {
      this.mock = sinon.stub(App.router, 'get');
      sinon.stub(view.get('controller'), 'load').returns({done: Em.K});
    });
    afterEach(function () {
      this.mock.restore();
      view.get('controller').load.restore();
    });
    it("update is working", function() {
      this.mock.returns(Em.Object.create({isWorking: true}));
      view.poll();
      expect(view.get('controller').load.calledOnce).to.be.true;
    });
    it("update is not working", function() {
      this.mock.returns(Em.Object.create({isWorking: false}));
      view.poll();
      expect(view.get('controller').load.called).to.be.false;
    });
  });
});

});

;require.register("test/views/main/admin_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/admin');

describe('App.MainAdminView', function () {

  var view;

  beforeEach(function () {
    view = App.MainAdminView.create();
  });

  describe('#categories', function () {

    var cases = [
      {
        isHadoopWindowsStack: true,
        categories: [
          {
            name: 'stackAndUpgrade',
            url: 'stackAndUpgrade.index',
            label: Em.I18n.t('admin.stackUpgrade.title')
          },
          {
            name: 'adminServiceAccounts',
            url: 'adminServiceAccounts',
            label: Em.I18n.t('common.serviceAccounts')
          }
        ],
        title: 'HDPWIN'
      },
      {
        isHadoopWindowsStack: false,
        categories: [
          {
            name: 'stackAndUpgrade',
            url: 'stackAndUpgrade.index',
            label: Em.I18n.t('admin.stackUpgrade.title')
          },
          {
            name: 'adminServiceAccounts',
            url: 'adminServiceAccounts',
            label: Em.I18n.t('common.serviceAccounts')
          },
          {
            name: 'kerberos',
            url: 'adminKerberos.index',
            label: Em.I18n.t('common.kerberos')
          }
        ],
        title: 'not HDPWIN'
      }
    ];

    afterEach(function () {
      App.get.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        sinon.stub(App, 'get').withArgs('isHadoopWindowsStack').returns(item.isHadoopWindowsStack);
        view.propertyDidChange('categories');
        expect(view.get('categories')).to.eql(item.categories);
      });
    });

  });

});
});

;require.register("test/views/main/alert_definitions_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('messages');
require('views/main/alert_definitions_view');

var view;

describe('App.MainAlertDefinitionsView', function () {

  beforeEach(function () {
    view = App.MainAlertDefinitionsView.create({});
  });

  describe('#serviceFilterView', function () {
    it('Add Ambari service to filters', function () {
      var serviceFilterClass = view.serviceFilterView;
      var content = serviceFilterClass.create({}).get('content');
      expect(content[0].label==Em.I18n.t('common.all'));
      expect(content[content.length-1].label==Em.I18n.t('app.name'));
    });
  });

  describe('#willInsertElement', function () {

    beforeEach(function(){
      sinon.stub(view, 'clearFilterConditionsFromLocalStorage', Em.K);
      sinon.stub(view, 'clearStartIndex', Em.K);
    });

    afterEach(function(){
      view.clearFilterConditionsFromLocalStorage.restore();
      view.clearStartIndex.restore();
    });

    it('should call clearFilterCondition, clearStartIndex if controller.showFilterConditionsFirstLoad is false', function () {
      view.set('controller', {showFilterConditionsFirstLoad: false, content: []});
      view.willInsertElement();
      expect(view.clearFilterConditionsFromLocalStorage.calledOnce).to.be.true;
      expect(view.clearStartIndex.calledOnce).to.be.true;
    });

    it('should not call clearFilterCondition, clearStartIndex if controller.showFilterConditionsFirstLoad is true', function () {
      view.set('controller', {showFilterConditionsFirstLoad: true, content: []});
      view.willInsertElement();
      expect(view.clearFilterConditionsFromLocalStorage.called).to.be.false;
      expect(view.clearStartIndex.called).to.be.false;
    });
  });

});

});

;require.register("test/views/main/alerts/definition_details_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view, instanceTableRow;

describe('App.MainAlertDefinitionDetailsView', function () {

  beforeEach(function () {

    view = App.MainAlertDefinitionDetailsView.create();

    instanceTableRow = view.get('instanceTableRow').create();

  });

  describe("#goToHostAlerts()", function () {
    beforeEach(function () {
      sinon.stub(App.get('router'), 'transitionTo', Em.K);
    });
    afterEach(function () {
      App.get('router').transitionTo.restore();
    });
    it("not route to host - no event", function () {
      instanceTableRow.goToHostAlerts(null);
      expect(App.get('router').transitionTo.notCalled).to.be.true;
    });
    it("not route to host - no event context", function () {
      instanceTableRow.goToHostAlerts({});
      expect(App.get('router').transitionTo.notCalled).to.be.true;
    });
    it("routes to host", function () {
      instanceTableRow.goToHostAlerts({"context": "hostname"});
      expect(App.get('router').transitionTo.calledOnce).to.be.true;
    });
  });

  describe("#openFullResponse()", function() {

    beforeEach(function() {
      sinon.stub(App.ModalPopup, 'show');
    });

    afterEach(function() {
      App.ModalPopup.show.restore();
    });

    it("App.ModalPopup.show should be called", function() {
      instanceTableRow.openFullResponse({context: Em.Object.create({text: 'text1'})});
      expect(App.ModalPopup.show.calledWith({
        header: Em.I18n.t('alerts.instance.fullLogPopup.header'),
        secondary: null,
        content: 'text1',
        bodyClass: App.SelectablePopupBodyView
      })).to.be.true;
    });
  });

});

});

;require.register("test/views/main/alerts/manage_alert_groups_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

describe('App.MainAlertsManageAlertGroupView', function () {

  beforeEach(function () {

    view = App.MainAlertsManageAlertGroupView.create({
      controller: Em.Object.create()
    });

  });

  it('#buttonObserver', function () {

    Em.A([
      {
        p: {
          isRemoveButtonDisabled: false,
          isRenameButtonDisabled: false,
          isDuplicateButtonDisabled: true
        },
        selectedAlertGroup: {default: true},
        m: 'selected alert group is default',
        e: {
          isRemoveButtonDisabled: true,
          isRenameButtonDisabled: true,
          isDuplicateButtonDisabled: false
        }
      },
      {
        p: {
          isRemoveButtonDisabled: true,
          isRenameButtonDisabled: true,
          isDuplicateButtonDisabled: true
        },
        selectedAlertGroup: {default: false},
        m: 'selected alert group is not default',
        e: {
          isRemoveButtonDisabled: false,
          isRenameButtonDisabled: false,
          isDuplicateButtonDisabled: false
        }
      },
      {
        p: {
          isRemoveButtonDisabled: true,
          isRenameButtonDisabled: true,
          isDuplicateButtonDisabled: true
        },
        selectedAlertGroup: null,
        m: 'not one alert group is selected',
        e: {
          isRemoveButtonDisabled: false,
          isRenameButtonDisabled: false,
          isDuplicateButtonDisabled: false
        }
      }
    ]).forEach(function (test) {
        it(test.m, function () {
          Em.keys(test.p).forEach(function (k) {
            view.set(k, test.p[k]);
          });
          view.set('controller.selectedAlertGroup', test.selectedAlertGroup);
          Em.keys(test.e).forEach(function (k) {
            expect(view.get(k)).to.equal(test.e[k]);
          });
        });
      });

  });

});

});

;require.register("test/views/main/alerts/manage_alert_notifications_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

var view;

describe('App.ManageAlertNotificationsView', function () {

  beforeEach(function () {

    view = App.ManageAlertNotificationsView.create({
      controller: Em.Object.create()
    });

  });

  describe('#buttonObserver', function () {

    Em.A([
      {
        selectedAlertNotification: {id: 1},
        m: 'some alert notification is selected',
        p: {
          isEditButtonDisabled: true,
          isRemoveButtonDisabled: true,
          isDuplicateButtonDisabled: true
        },
        e:  {
          isEditButtonDisabled: false,
          isRemoveButtonDisabled: false,
          isDuplicateButtonDisabled: false
        }
      },
      {
        selectedAlertNotification: null,
        m: 'some alert notification is not selected',
        p: {
          isEditButtonDisabled: false,
          isRemoveButtonDisabled: false,
          isDuplicateButtonDisabled: false
        },
        e:  {
          isEditButtonDisabled: true,
          isRemoveButtonDisabled: true,
          isDuplicateButtonDisabled: true
        }
      }
    ]).forEach(function (test) {
        it(test.m, function () {
          Em.keys(test.p).forEach(function (k) {
            view.set(k, test.p[k]);
          });
          view.set('controller.selectedAlertNotification', test.selectedAlertNotification);
          view.buttonObserver();
          Em.keys(test.e).forEach(function (k) {
            expect(view.get(k)).to.equal(test.e[k]);
          });
        });
      });

  });

  describe('#showEmailDetails', function () {

    Em.A([
      {
        selectedAlertNotification: {type: 'SNMP'},
        e: false
      },
      {
        selectedAlertNotification: {type: 'EMAIL'},
        e: true
      }
    ]).forEach(function (test, i) {
        it('test ' + (i + 1), function () {
          view.set('controller.selectedAlertNotification', test.selectedAlertNotification);
          expect(view.get('showEmailDetails')).to.equal(test.e);
        });
      });

  });

  describe('#showSNMPDetails', function () {

    Em.A([
        {
          selectedAlertNotification: {type: 'SNMP'},
          e: true
        },
        {
          selectedAlertNotification: {type: 'EMAIL'},
          e: false
        }
      ]).forEach(function (test, i) {
        it('test ' + (i + 1), function () {
          view.set('controller.selectedAlertNotification', test.selectedAlertNotification);
          expect(view.get('showSNMPDetails')).to.equal(test.e);
        });
      });

  });

});

});

;require.register("test/views/main/charts/heatmap/heatmap_host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap/heatmap_host');

describe('App.MainChartsHeatmapHostView', function() {

  var view = App.MainChartsHeatmapHostView.create({
    templateName: '',
    controller: Em.Object.create(),
    content: {}
  });

  describe('#hostTemperatureStyle', function () {
    var testCases = [
      {
        title: 'if hostToSlotMap is null then hostTemperatureStyle should be empty',
        hostName: 'host',
        controller: Em.Object.create({
          hostToSlotMap: null,
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if hostName is null then hostTemperatureStyle should be empty',
        hostName: '',
        controller: Em.Object.create({
          hostToSlotMap: {},
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slot less than 0 then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": -1
          },
          selectedMetric: {
            slotDefinitions: []
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions is null then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: null
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions length not more than slot number then hostTemperatureStyle should be empty',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [{}]
          }
        }),
        result: ''
      },
      {
        title: 'if slotDefinitions correct then hostTemperatureStyle should be "style1"',
        hostName: 'host1',
        controller: Em.Object.create({
          hostToSlotMap: {
            "host1": 1
          },
          selectedMetric: {
            slotDefinitions: [
              Em.Object.create({cssStyle: 'style0'}),
              Em.Object.create({cssStyle: 'style1'})
            ]
          }
        }),
        result: 'style1'
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content.hostName', test.hostName);
        view.set('controller', test.controller);
        expect(view.get('hostTemperatureStyle')).to.equal(test.result);
      });
    });
  });

});

});

;require.register("test/views/main/charts/heatmap/heatmap_rack_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap/heatmap_rack');

describe('App.MainChartsHeatmapRackView', function() {

  var view = App.MainChartsHeatmapRackView.create({
    templateName: ''
  });

  describe('#hostCssStyle', function () {
    var testCases = [
      {
        title: 'if hosts haven\'t been loaded yet then hostCssStyle should be have width 100%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: false
        }),
        result: "width:100%;float:left;"
      },
      {
        title: 'if hosts number is zero then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(0),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      },
      {
        title: 'if hosts number is one then hostCssStyle should be have width 99.5%',
        rack: Em.Object.create({
          hosts: new Array(1),
          isLoaded: true
        }),
        result: "width:99.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 9.5%',
        rack: Em.Object.create({
          hosts: new Array(10),
          isLoaded: true
        }),
        result: "width:9.5%;float:left;"
      },
      {
        title: 'if hosts number is ten then hostCssStyle should be have width 10%',
        rack: Em.Object.create({
          hosts: new Array(11),
          isLoaded: true
        }),
        result: "width:10%;float:left;"
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('rack', test.rack);
        expect(view.get('hostCssStyle')).to.equal(test.result);
      });
    });
  });

});

});

;require.register("test/views/main/charts/heatmap_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/charts/heatmap');

describe('App.MainChartsHeatmapView', function () {

  var view;

  beforeEach(function () {
    view = App.MainChartsHeatmapView.create({
      controller: Em.Object.create({
        clearActiveWidgetLayout: Em.K,
        loadPageData: Em.K
      })
    });
  });


  describe("#didInsertElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'loadPageData');
    });
    afterEach(function () {
      view.get('controller').loadPageData.restore();
    });
    it("", function () {
      view.didInsertElement();
      expect(view.get('controller').loadPageData.calledOnce).to.be.true;
    });
  });

  describe("#willDestroyElement()", function () {
    beforeEach(function () {
      sinon.spy(view.get('controller'), 'clearActiveWidgetLayout');
    });
    afterEach(function () {
      view.get('controller').clearActiveWidgetLayout.restore();
    });
    it("", function () {
      view.willDestroyElement();
      expect(view.get('controller').clearActiveWidgetLayout.calledOnce).to.be.true;
    });
  });

});
});

;require.register("test/views/main/dashboard/config_history_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/config_history_view');
require('utils/load_timer');

describe('App.MainConfigHistoryView', function() {
  var view = App.MainConfigHistoryView.create({
    totalCount: 0,
    filteredCount: 0
  });
  view.reopen({
    controller: Em.Object.create({
      name: 'mainConfigHistoryController11',
      paginationProps: [
        {
          name: 'displayLength'
        },
        {
          name: 'startIndex'
        }
      ],
      doPolling: Em.K,
      load: function () {
        return {done: Em.K};
      },
      colPropAssoc: []
    })
  });
  view.removeObserver('controller.resetStartIndex', view, 'resetStartIndex');

  describe("#filteredContentInfo", function () {
    it("", function () {
      view.set('filteredCount', 1);
      view.set('totalCount', 2);
      view.propertyDidChange('filteredContentInfo');
      expect(view.get('filteredContentInfo')).to.eql(Em.I18n.t('tableView.filters.filteredConfigVersionInfo').format(1, 2));
    });
  });

  describe("#serviceFilterView", function () {
    var subView = view.get('serviceFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(App.Service, 'find').returns([Em.Object.create({
        serviceName: 'S1',
        displayName: 's1'
      })])
    });
    after(function () {
      App.Service.find.restore();
    });
    it("content", function () {
      expect(subView.get('content')).to.eql([
        {
          "value": "",
          "label": Em.I18n.t('common.all')
        },
        {
          "value": "S1",
          "label": "s1"
        }
      ]);
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'select')).to.be.true;
    });
  });

  describe("#configGroupFilterView", function () {
    var subView = view.get('configGroupFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(App.ServiceConfigVersion, 'find').returns([
        Em.Object.create({groupName: 'G1'}),
        Em.Object.create({groupName: 'G1'}),
        Em.Object.create({groupName: null})
      ]);
    });
    after(function () {
      App.ServiceConfigVersion.find.restore();
    });
    it("content", function () {
      expect(subView.get('content')).to.eql([
        {
          "value": "",
          "label": Em.I18n.t('common.all')
        },
        {
          "value": "G1",
          "label": "G1"
        }
      ]);
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'select')).to.be.true;
    });
  });

  /**
   * for now we don't use this method
  describe("#modifiedFilterView", function () {
    var subView = view.get('modifiedFilterView').create({
      parentView: view,
      controller: {
        modifiedFilter: {
          actualValues: {
            startTime: 0,
            endTime: 1
          }
        }
      }
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onTimeChange()", function () {
      subView.set('column', 1);
      subView.onTimeChange();
      expect(view.updateFilter.calledWith(1, [0, 1], 'range')).to.be.true;
    });
  });*/

  describe("#authorFilterView", function () {
    var subView = view.get('authorFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'string')).to.be.true;
    });
  });

  describe("#notesFilterView", function () {
    var subView = view.get('notesFilterView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(view, 'updateFilter', Em.K);
    });
    after(function () {
      view.updateFilter.restore();
    });
    it("call onChangeValue()", function () {
      subView.set('column', 1);
      subView.set('value', 'value');
      subView.onChangeValue();
      expect(view.updateFilter.calledWith(1, 'value', 'string')).to.be.true;
    });
  });

  describe("#ConfigVersionView", function () {
    var subView = view.get('ConfigVersionView').create({
      parentView: view
    });

    before(function () {
      sinon.stub(App, 'tooltip', Em.K);
    });
    after(function () {
      App.tooltip.restore();
    });
    it("call didInsertElement()", function () {
      subView.didInsertElement();
      expect(App.tooltip.calledOnce).to.be.true;
    });
    it("call toggleShowLessStatus()", function () {
      subView.set('showLessNotes', true);
      subView.toggleShowLessStatus();
      expect(subView.get('showLessNotes')).to.be.false;
    });
  });

  describe('#didInsertElement()', function() {
    it('', function() {
      sinon.stub(view, 'addObserver', Em.K);
      sinon.spy(view.get('controller'), 'doPolling');

      view.didInsertElement();
      expect(view.addObserver.calledTwice).to.be.true;
      expect(view.get('isInitialRendering')).to.be.true;
      expect(view.get('controller.isPolling')).to.be.true;
      expect(view.get('controller').doPolling.calledOnce).to.be.true;

      view.addObserver.restore();
      view.get('controller').doPolling.restore();
    });
  });

  describe('#updateFilter()', function () {
    var cases = [
      {
        isInitialRendering: false,
        updateFilterCalled: true,
        title: 'updateFilter should be called'
      },
      {
        isInitialRendering: true,
        updateFilterCalled: false,
        title: 'updateFilter should not be called'
      }
    ];
    beforeEach(function () {
      sinon.stub(view, 'saveFilterConditions', Em.K);
      view.set('filteringComplete', true);
    });
    afterEach(function () {
      view.saveFilterConditions.restore();
    });
    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('isInitialRendering', item.isInitialRendering);
        view.updateFilter(1, 'value', 'string');
        expect(view.get('saveFilterConditions').calledWith(1, 'value', 'string')).to.equal(item.updateFilterCalled);
      });
    });
  });

  describe('#willDestroyElement()', function() {
    it('', function() {
      view.willDestroyElement();
      expect(view.get('controller.isPolling')).to.be.false;
    });
  });

  describe('#refresh()', function() {
    it('', function() {
      sinon.spy(view.get('controller'), 'load');
      view.refresh();
      expect(view.get('filteringComplete')).to.be.false;
      expect(view.get('controller').load.calledOnce).to.be.true;
      view.get('controller').load.restore();
    });
  });

  describe("#refreshDone()", function () {
    before(function () {
      sinon.stub(view, 'propertyDidChange', Em.K);
    });
    after(function () {
      view.propertyDidChange.restore();
    });
    it("", function () {
      view.set('filteringComplete', false);
      view.set('controller.resetStartIndex', true);
      view.refreshDone();
      expect(view.get('filteringComplete')).to.be.true;
      expect(view.get('controller.resetStartIndex')).to.be.false;
    });
  });

  describe("#colPropAssoc", function () {
    it("", function () {
      view.set('controller.colPropAssoc', [1]);
      view.propertyDidChange('colPropAssoc');
      expect(view.get('colPropAssoc')).to.eql([1]);
    });
  });
});

});

;require.register("test/views/main/dashboard/widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/widget');

describe('App.DashboardWidgetView', function () {
  var dashboardWidgetView = App.DashboardWidgetView.create({
    parentView: Em.Object.create({
      widgetsMapper: Em.K,
      getUserPref: function () {return {complete: Em.K}},
      postUserPref: Em.K,
      translateToReal: Em.K,
      visibleWidgets: [],
      hiddenWidgets: []
    })
  });

  describe('#viewID', function () {
    it('viewID is computed with id', function () {
      dashboardWidgetView.set('id', 5);
      expect(dashboardWidgetView.get('viewID')).to.equal('widget-5');
    });
  });

  describe('#model', function () {
    it('model_type is null', function () {
      dashboardWidgetView.set('model_type', null);
      dashboardWidgetView.propertyDidChange('model');
      expect(dashboardWidgetView.get('model')).to.eql({});
    });
    it('model_type is valid', function () {
      dashboardWidgetView.set('model_type', 's');
      dashboardWidgetView.propertyDidChange('model');
      dashboardWidgetView.set('parentView.s_model', {'s': {}});
      expect(dashboardWidgetView.get('model')).to.eql({'s': {}});
    });
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.stub(App, 'tooltip', Em.K);
    });
    after(function () {
      App.tooltip.restore();
    });
    it("call App.tooltip", function () {
      dashboardWidgetView.didInsertElement();
      expect(App.tooltip.calledOnce).to.be.true;
    });
  });

  describe("#deleteWidget()", function () {
    beforeEach(function () {
      sinon.stub(dashboardWidgetView.get('parentView'), 'widgetsMapper').returns({});
      sinon.stub(dashboardWidgetView.get('parentView'), 'getUserPref').returns({
        complete: Em.K
      });
    });
    afterEach(function () {
      dashboardWidgetView.get('parentView').widgetsMapper.restore();
      dashboardWidgetView.get('parentView').getUserPref.restore();
    });
    it("testMode is on", function () {
      App.set('testMode', true);
      dashboardWidgetView.set('id', '1');
      dashboardWidgetView.deleteWidget();
      expect(dashboardWidgetView.get('parentView').widgetsMapper.calledWith('1')).to.be.true;
      expect(dashboardWidgetView.get('parentView.visibleWidgets')).to.be.empty;
      expect(dashboardWidgetView.get('parentView.hiddenWidgets')).to.not.be.empty;
    });
    it("testMode is off", function () {
      App.set('testMode', false);
      dashboardWidgetView.set('parentView.persistKey', 'key');
      dashboardWidgetView.deleteWidget();
      expect(dashboardWidgetView.get('parentView').getUserPref.calledWith('key')).to.be.true;
    });
  });

  describe("#deleteWidgetComplete()", function () {
    before(function () {
      sinon.spy(dashboardWidgetView.get('parentView'), 'postUserPref');
      sinon.spy(dashboardWidgetView.get('parentView'), 'translateToReal');
    });
    after(function () {
      dashboardWidgetView.get('parentView').postUserPref.restore();
      dashboardWidgetView.get('parentView').translateToReal.restore();
    });
    it("", function () {
      dashboardWidgetView.set('parentView.currentPrefObject', {
        dashboardVersion: 'new',
        visible: ['1', '2'],
        hidden: [],
        threshold: 'threshold'
      });
      dashboardWidgetView.set('parentView.persistKey', 'key');
      dashboardWidgetView.deleteWidgetComplete();
      expect(dashboardWidgetView.get('parentView').postUserPref.calledWith('key', {
        dashboardVersion: 'new',
        visible: ['2'],
        hidden: ['1'],
        threshold: 'threshold'
      }));
      expect(dashboardWidgetView.get('parentView').translateToReal.calledWith({
        dashboardVersion: 'new',
        visible: ['2'],
        hidden: ['1'],
        threshold: 'threshold'
      }));
    });
  });

  describe("#editWidget()", function () {
    before(function () {
      sinon.stub(dashboardWidgetView, 'showEditDialog', Em.K);
    });
    after(function () {
      dashboardWidgetView.showEditDialog.restore();
    });
    it("call showEditDialog", function () {
      dashboardWidgetView.editWidget();
      expect(dashboardWidgetView.showEditDialog.calledOnce).to.be.true;
    });
  });

  describe("#showEditDialog()", function () {
    var obj = Em.Object.create({
      observeThresh1Value: Em.K,
      observeThresh2Value: Em.K,
      thresh1: '1',
      thresh2: '2'
    });
    before(function () {
      sinon.spy(obj, 'observeThresh1Value');
      sinon.spy(obj, 'observeThresh2Value');
      sinon.stub(dashboardWidgetView.get('parentView'), 'getUserPref').returns({
        complete: Em.K
      });
    });
    after(function () {
      obj.observeThresh1Value.restore();
      obj.observeThresh2Value.restore();
      dashboardWidgetView.get('parentView').getUserPref.restore();
    });
    it("open popup", function () {
      var popup = dashboardWidgetView.showEditDialog(obj);
      popup.onPrimary();
      expect(obj.observeThresh1Value.calledOnce).to.be.true;
      expect(obj.observeThresh2Value.calledOnce).to.be.true;
      expect(dashboardWidgetView.get('thresh1')).to.equal(1);
      expect(dashboardWidgetView.get('thresh2')).to.equal(2);
      expect(dashboardWidgetView.get('parentView').getUserPref.calledOnce).to.be.true;
    });
  });

  describe('#model', function () {
    it('model_type is null', function () {
      dashboardWidgetView.set('model_type', null);
      dashboardWidgetView.propertyDidChange('model');
      expect(dashboardWidgetView.get('model')).to.eql({});
    });
    it('model_type is valid', function () {
      dashboardWidgetView.set('model_type', 's');
      dashboardWidgetView.propertyDidChange('model');
      dashboardWidgetView.set('parentView.s_model', {'s': {}});
      expect(dashboardWidgetView.get('model')).to.eql({'s': {}});
    });
  });

  describe('#hoverContentTopClass', function () {
    var tests = [
      {
        h: ['', ''],
        e: 'content-hidden-two-line',
        m: '2 lines'
      },
      {
        h: ['', '', ''],
        e: 'content-hidden-three-line',
        m: '3 lines'
      },
      {
        h: [''],
        e: '',
        m: '1 line'
      },
      {
        h: [],
        e: '',
        m: '0 lines'
      },
      {
        h: ['', '', '', '', ''],
        e: 'content-hidden-five-line',
        m: '5 lines'
      },
      {
        h: ['', '', '', ''],
        e: 'content-hidden-four-line',
        m: '4 lines'
      },
      {
        h: ['', '', '', '', '', ''],
        e: 'content-hidden-six-line',
        m: '6 lines'
      }
    ];
    tests.forEach(function (test) {
      it(test.m, function () {
        dashboardWidgetView.set('hiddenInfo', test.h);
        expect(dashboardWidgetView.get('hoverContentTopClass')).to.equal(test.e);
      });
    });
  });

  describe("#widgetConfig", function() {
    var widget = dashboardWidgetView.get('widgetConfig').create();
    describe("#hintInfo", function() {
      it("", function() {
        widget.set('maxValue', 1);
        widget.propertyDidChange('hintInfo');
        expect(widget.get('hintInfo')).to.equal(Em.I18n.t('dashboard.widgets.hintInfo.common').format(1));
      });
    });
    describe("#observeThresh1Value", function() {
      beforeEach(function () {
        sinon.stub(widget, 'updateSlider', Em.K);
      });
      afterEach(function () {
        widget.updateSlider.restore();
      });
      var testCases = [
        {
          data: {
            thresh1: '',
            maxValue: 0
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('admin.users.editError.requiredField')
          }
        },
        {
          data: {
            thresh1: 'NaN',
            maxValue: 0
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh1: '-1',
            maxValue: 0
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh1: '2',
            maxValue: 1
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.invalid').format(1)
          }
        },
        {
          data: {
            thresh1: '1',
            thresh2: '1',
            maxValue: 2
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.smaller')
          }
        },
        {
          data: {
            thresh1: '1',
            thresh2: '0',
            maxValue: 2
          },
          result: {
            isThresh1Error: true,
            errorMessage1: Em.I18n.t('dashboard.widgets.error.smaller')
          }
        },
        {
          data: {
            thresh1: '1',
            thresh2: '2',
            maxValue: 2
          },
          result: {
            isThresh1Error: false,
            errorMessage1: ''
          }
        }
      ];
      testCases.forEach(function (test) {
        it("thresh1 - " + test.data.thresh1 + ', maxValue - ' + test.data.maxValue, function () {
          widget.set('isThresh2Error', false);
          widget.set('thresh2', test.data.thresh2 || "");
          widget.set('thresh1', test.data.thresh1);
          widget.set('maxValue', test.data.maxValue);
          widget.observeThresh1Value();
          expect(widget.get('isThresh1Error')).to.equal(test.result.isThresh1Error);
          expect(widget.get('errorMessage1')).to.equal(test.result.errorMessage1);
          expect(widget.updateSlider.called).to.be.true;
        });
      });
    });

    describe("#observeThresh2Value", function() {
      beforeEach(function () {
        sinon.stub(widget, 'updateSlider', Em.K);
      });
      afterEach(function () {
        widget.updateSlider.restore();
      });
      var testCases = [
        {
          data: {
            thresh2: '',
            maxValue: 0
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('admin.users.editError.requiredField')
          }
        },
        {
          data: {
            thresh2: 'NaN',
            maxValue: 0
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh2: '-1',
            maxValue: 0
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('dashboard.widgets.error.invalid').format(0)
          }
        },
        {
          data: {
            thresh2: '2',
            maxValue: 1
          },
          result: {
            isThresh2Error: true,
            errorMessage2: Em.I18n.t('dashboard.widgets.error.invalid').format(1)
          }
        },
        {
          data: {
            thresh2: '2',
            maxValue: 2
          },
          result: {
            isThresh2Error: false,
            errorMessage2: ''
          }
        }
      ];
      testCases.forEach(function (test) {
        it("thresh2 - " + test.data.thresh2 + ', maxValue - ' + test.data.maxValue, function () {
          widget.set('thresh2', test.data.thresh2 || "");
          widget.set('maxValue', test.data.maxValue);
          widget.observeThresh2Value();
          expect(widget.get('isThresh2Error')).to.equal(test.result.isThresh2Error);
          expect(widget.get('errorMessage2')).to.equal(test.result.errorMessage2);
          expect(widget.updateSlider.called).to.be.true;
        });
      });
    });
  });
});

});

;require.register("test/views/main/dashboard/widgets/cluster_metrics_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widgets/cluster_metrics_widget');

describe('App.ClusterMetricsDashboardWidgetView', function () {

  var view;

  beforeEach(function () {
    view = App.ClusterMetricsDashboardWidgetView.create();
  });

  describe('#exportTargetView', function () {

    var childViews = [
        {
          p0: 'v0'
        },
        {
          p1: 'v1'
        }
      ],
      title = 'should take last child view';

    beforeEach(function () {
      view.get('childViews').pushObjects(childViews);
    });

    it(title, function () {
      expect(view.get('exportTargetView')).to.eql(childViews[1]);
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/datanode_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/datanode_live');

describe('App.DataNodeUpView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true
      }
    },
    {
      data: 0,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false
      }
    }
  ];

  tests.forEach(function(test) {
    describe('', function() {
      var dataNodeUpView = App.DataNodeUpView.create({model_type:null, data: test.data, content: test.data.toString()});
      it('isRed', function() {
        expect(dataNodeUpView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(dataNodeUpView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(dataNodeUpView.get('isGreen')).to.equal(test.e.isGreen);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hawqsegment_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/hawqsegment_live');

describe('App.HawqSegmentUpView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true
      }
    },
    {
      data: 0,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false
      }
    },
    {
      data: 80,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false
      }
    }
  ];

  tests.forEach(function(test) {
    describe('', function() {
      var hawqSegmentUpView = App.HawqSegmentUpView.create({model_type:null, data: test.data, content: test.data.toString()});
      it('shows red', function() {
        expect(hawqSegmentUpView.get('isRed')).to.equal(test.e.isRed);
      });
      it('shows orange', function() {
        expect(hawqSegmentUpView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('shows green', function() {
        expect(hawqSegmentUpView.get('isGreen')).to.equal(test.e.isGreen);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_average_load_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_average_load');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseAverageLoadView', function() {

  var tests = [
    {
      model: {
        averageLoad: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        averageLoad: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        averageLoad: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        averageLoad: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable')
      }
    }
  ];

  tests.forEach(function(test) {
    describe('averageLoad - ' + test.model.averageLoad, function() {
      var hBaseAverageLoadView = App.HBaseAverageLoadView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseAverageLoadView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseAverageLoadView.get('data')).to.equal(test.model.averageLoad);
      });
      it('isRed', function() {
        expect(hBaseAverageLoadView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseAverageLoadView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseAverageLoadView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseAverageLoadView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_master_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/hbase_master_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseMasterUptimeView', function () {

  var tests = [
    {
      model: Em.Object.create({
        masterStartTime: ((new Date()).getTime() - 192.1 * 24 * 3600 * 1000)
      }),
      e: {
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model: Em.Object.create({
        masterStartTime: 0
      }),
      e: {
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model: Em.Object.create({
        masterStartTime: null
      }),
      e: {
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  beforeEach(function () {
    sinon.stub(App.router, 'get').withArgs('userSettingsController.userSettings.timezone').returns('');
  });

  afterEach(function () {
    App.router.get.restore();
  });

  tests.forEach(function (test) {
    var hBaseMasterUptimeView = App.HBaseMasterUptimeView.create({model_type: null, model: test.model});
    hBaseMasterUptimeView.calc();
    describe('#masterStartTime - ' + test.model.masterStartTime, function () {
      it('content', function () {
        expect(hBaseMasterUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function () {
        expect(hBaseMasterUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isGreen', function () {
        expect(hBaseMasterUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function () {
        expect(hBaseMasterUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/hbase_regions_in_transition_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widgets/hbase_regions_in_transition');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.HBaseRegionsInTransitionView', function() {

  var tests = [
    {
      model: {
        regionsInTransition: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1'
      }
    },
    {
      model: {
        regionsInTransition: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10'
      }
    },
    {
      model: {
        regionsInTransition: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0'
      }
    },
    {
      model: {
        regionsInTransition: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: 'null'
      }
    }
  ];

  tests.forEach(function(test) {
    describe('regionsInTransition - ' + test.model.regionsInTransition, function() {
      var hBaseRegionsInTransitionView = App.HBaseRegionsInTransitionView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(hBaseRegionsInTransitionView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(hBaseRegionsInTransitionView.get('data')).to.equal(test.model.regionsInTransition);
      });
      it('isRed', function() {
        expect(hBaseRegionsInTransitionView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(hBaseRegionsInTransitionView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(hBaseRegionsInTransitionView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(hBaseRegionsInTransitionView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/links_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('models/host_component');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/links_widget');

describe('App.LinkDashboardWidgetView', function() {

  var model = Em.Object.create({
    field: Em.Object.create({
      publicHostName: 'host1'
    })
  });
  var linkDashboardWidgetView = App.LinkDashboardWidgetView.create({
    model_type: null,
    model: model,
    port: 1234,
    modelField: 'field'
  });
  linkDashboardWidgetView.calc();
  describe('#webUrl', function() {
    it('calc', function() {
      expect(linkDashboardWidgetView.get('webUrl')).to.equal('http://host1:1234');
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_cpu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('utils/helper');
require('views/common/chart/pie');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');
require('views/main/dashboard/widgets/namenode_cpu');

describe('App.NameNodeCpuPieChartView', function() {

  var model = Em.Object.create({
    used: null,
    max: null
  });
  var nameNodeCpuPieChartView = App.NameNodeCpuPieChartView.create({
    model_type: null,
    model: model,
    modelFieldUsed: 'used',
    modelFieldMax: 'max',
    widgetHtmlId: 'fake'
  });

  nameNodeCpuPieChartView.calc();

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        cpuWio: 1,
        e: true,
        m: 'Exists'
      },
      {
        cpuWio: null,
        e: false,
        m: 'Not exists'
      },
      {
        cpuWio: undefined,
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('cpuWio', test.cpuWio);
        expect(nameNodeCpuPieChartView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function () {
    var tests = [
      {
        cpuWio: 0,
        e: ['0.0', '0.00'],
        m: 'Nothing is used'
      },
      {
        cpuWio: 100,
        e: ['100.0', '100.00'],
        m: 'All is used'
      },
      {
        cpuWio: 50,
        e: ['50.0', '50.00'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        nameNodeCpuPieChartView.set('cpuWio', test.cpuWio);
        expect(nameNodeCpuPieChartView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_rpc_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_rpc');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.NameNodeRpcView', function() {

  var tests = [
    {
      model: {
        nameNodeRpc: 1
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '1.00 ms',
        data: '1.00'
      }
    },
    {
      model: {
        nameNodeRpc: 10
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '10.00 ms',
        data: '10.00'
      }
    },
    {
      model: {
        nameNodeRpc: 0
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '0 ms',
        data: 0
      }
    },
    {
      model: {
        nameNodeRpc: null
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    describe('nameNodeRpc - ' + test.model.nameNodeRpc, function() {
      var jobTrackerRpcView = App.NameNodeRpcView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(jobTrackerRpcView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(jobTrackerRpcView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(jobTrackerRpcView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(jobTrackerRpcView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(jobTrackerRpcView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(jobTrackerRpcView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/namenode_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widgets/namenode_uptime');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widget');

describe('App.NameNodeUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        nameNodeStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        nameNodeStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var nameNodeUptimeView = App.NameNodeUptimeView.create({model_type:null, model: test.model});
    nameNodeUptimeView.calc();
    describe('nameNodeStartTime - ' + test.model.nameNodeStartTime, function() {
      it('content', function() {
        expect(nameNodeUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(nameNodeUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(nameNodeUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(nameNodeUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(nameNodeUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(nameNodeUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/node_managers_live_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/node_managers_live');

describe('App.NodeManagersLiveView', function() {

  beforeEach(function () {
    sinon.stub(App, 'get').withArgs('router.clusterController.isComponentsStateLoaded').returns(true);
  });

  afterEach(function () {
    App.get.restore();
  });

  var tests = [
    {
      model: {
        nodeManagersTotal: 3,
        nodeManagerLiveNodes: 2
      },
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false,
        content: '2/3',
        data: 67
      }
    },
    {
      model: {
        nodeManagersTotal: 2,
        nodeManagerLiveNodes: 2
      },
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '2/2',
        data: 100
      }
    },
    {
      model: {
        nodeManagersTotal: 2,
        nodeManagerLiveNodes: 0
      },
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false,
        content: '0/2',
        data: 0.00
      }
    }
  ];

  tests.forEach(function(test) {
    describe('nodeManagersTotal length - ' + test.model.nodeManagersTotal + ' | nodeManagerLiveNodes length - ' + test.model.nodeManagerLiveNodes, function() {
      var AppNodeManagersLiveView = App.NodeManagersLiveView.extend({nodeManagersLive: test.model.nodeManagerLiveNodes});
      var nodeManagersLiveView = AppNodeManagersLiveView.create({model_type:null, model: test.model});
      it('content', function() {
        expect(nodeManagersLiveView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(nodeManagersLiveView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(nodeManagersLiveView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(nodeManagersLiveView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(nodeManagersLiveView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(nodeManagersLiveView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/pie_chart_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/common/chart/pie');
require('utils/helper');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/pie_chart_widget');

describe('App.PieChartDashboardWidgetView', function() {

  var model = Em.Object.create({
    used: null,
    max: null
  });
  var pieChartDashboardWidgetView = App.PieChartDashboardWidgetView.create({
    model_type: null,
    model: model,
    modelFieldUsed: 'used',
    modelFieldMax: 'max',
    widgetHtmlId: 'fake'
  });

  pieChartDashboardWidgetView.calc();

  describe('#getUsed', function() {
    var tests = [
      {
        model: Em.Object.create({
          used: 1
        }),
        e: 1,
        m: '"Used" is set'
      },
      {
        model: Em.Object.create({
          used: null
        }),
        e: 0,
        m: '"Used" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Used" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getUsed()).to.equal(test.e);
      });
    });
  });

  describe('#getMax', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: 1,
        m: '"Max" is set'
      },
      {
        model: Em.Object.create({
          max: null
        }),
        e: 0,
        m: '"Max" is not set'
      },
      {
        model: Em.Object.create({}),
        e: 0,
        m: '"Max" is not defined'
      }
    ];
    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.getMax()).to.equal(test.e);
      });
    });
  });

  describe('#calcIsPieExists', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 1
        }),
        e: true,
        m: 'Exists'
      },
      {
        model: Em.Object.create({
          max: 0
        }),
        e: false,
        m: 'Not exists'
      },
      {
        model: Em.Object.create({}),
        e: false,
        m: 'Not exists'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcIsPieExists()).to.equal(test.e);
      });
    });
  });

  describe('calcDataForPieChart', function() {
    var tests = [
      {
        model: Em.Object.create({
          max: 10,
          used: 0
        }),
        e: ['0', '0.0'],
        m: 'Nothing is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 10
        }),
        e: ['100', '100.0'],
        m: 'All is used'
      },
      {
        model: Em.Object.create({
          max: 10,
          used: 5
        }),
        e: ['50', '50.0'],
        m: 'Half is used'
      }
    ];

    tests.forEach(function(test) {
      it(test.m, function() {
        pieChartDashboardWidgetView.set('model', test.model);
        expect(pieChartDashboardWidgetView.calcDataForPieChart()).to.eql(test.e);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/resource_manager_uptime_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('messages');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/resource_manager_uptime');

describe('App.ResourceManagerUptimeView', function() {

  var tests = [
    {
      model: Em.Object.create({
        resourceManagerStartTime: ((new Date()).getTime() - 192.1*24*3600*1000)
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false,
        content: '192.1 d',
        data: 192.1
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: 0
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    },
    {
      model:  Em.Object.create({
        resourceManagerStartTime: null
      }),
      e: {
        isRed: false,
        isOrange: false,
        isGreen: false,
        isNA: true,
        content: Em.I18n.t('services.service.summary.notAvailable'),
        data: null
      }
    }
  ];

  tests.forEach(function(test) {
    var resourceManagerUptimeView = App.ResourceManagerUptimeView.create({model_type:null, model: test.model});
    resourceManagerUptimeView.calc();
    describe('resourceManagerStartTime - ' + test.model.resourceManagerStartTime, function() {
      it('content', function() {
        expect(resourceManagerUptimeView.get('content')).to.equal(test.e.content);
      });
      it('data', function() {
        expect(resourceManagerUptimeView.get('data')).to.equal(test.e.data);
      });
      it('isRed', function() {
        expect(resourceManagerUptimeView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(resourceManagerUptimeView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(resourceManagerUptimeView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(resourceManagerUptimeView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');

describe('App.TextDashboardWidgetView', function() {

  var tests = [
    {
      data: 100,
      e: {
        isRed: false,
        isOrange: false,
        isGreen: true,
        isNA: false
      }
    },
    {
      data: 1,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: false
      }
    },
    {
      data: 50,
      e: {
        isRed: false,
        isOrange: true,
        isGreen: false,
        isNA: false
      }
    },
    {
      data: null,
      e: {
        isRed: true,
        isOrange: false,
        isGreen: false,
        isNA: true
      }
    }
  ];

  tests.forEach(function(test) {
    describe('data - ' + test.data + ' | thresh1 - 40 | thresh2 - 70', function() {
      var textDashboardWidgetView = App.TextDashboardWidgetView.create({thresh1:40, thresh2:70});
      textDashboardWidgetView.set('data', test.data);
      it('isRed', function() {
        expect(textDashboardWidgetView.get('isRed')).to.equal(test.e.isRed);
      });
      it('isOrange', function() {
        expect(textDashboardWidgetView.get('isOrange')).to.equal(test.e.isOrange);
      });
      it('isGreen', function() {
        expect(textDashboardWidgetView.get('isGreen')).to.equal(test.e.isGreen);
      });
      it('isNA', function() {
        expect(textDashboardWidgetView.get('isNA')).to.equal(test.e.isNA);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets/uptime_text_widget_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/dashboard/widget');
require('views/main/dashboard/widgets/text_widget');
require('views/main/dashboard/widgets/uptime_text_widget');

describe('App.UptimeTextDashboardWidgetView', function() {

  describe('#timeConverter', function() {
    var ts1 = 1358245370553, ts2 = 0;
    var timestamps = [
      {
        t: ts1,
        e: {
          l: 2,
          f: new Date(ts1)
        }
      },
      {
        t: ts2,
        e: {
          l: 2,
          f: new Date(ts2)
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      var uptimeTextDashboardWidgetView = App.UptimeTextDashboardWidgetView.create({thresh1:40, thresh2:70});
      it('timestamp ' + timestamp.t, function() {
        var result = uptimeTextDashboardWidgetView.timeConverter(timestamp.t);
        expect(result.length).to.equal(timestamp.e.l);
        assert.include(timestamp.e.f.toString(), result[0].toString(), timestamp.e.f + ' contains string ' + result[0]);
      });
    });
  });

  describe('#uptimeProcessing', function() {
    var timestamps = [
      {
        diff: 10*1000,
        e: {
          timeUnit: 's'
        }
      },
      {
        diff: 3600*1000,
        e: {
          timeUnit: 'hr'
        }
      },
      {
        diff: 24*3600*1000,
        e: {
          timeUnit: 'd'
        }
      },
      {
        diff: 1800*1000,
        e: {
          timeUnit: 'min'
        }
      }
    ];
    timestamps.forEach(function(timestamp) {
      var uptimeTextDashboardWidgetView = App.UptimeTextDashboardWidgetView.create({thresh1:40, thresh2:70});
      it('timestamp ' + timestamp.t + '. timeUnit should be ' + '"' + timestamp.e.timeUnit + '"', function() {
        var result = uptimeTextDashboardWidgetView.uptimeProcessing(((new Date()).getTime() - timestamp.diff));
        expect(uptimeTextDashboardWidgetView.get('timeUnit')).to.equal(timestamp.e.timeUnit);
      });
    });
  });

});

});

;require.register("test/views/main/dashboard/widgets_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('messages');
var filters = require('views/common/filter_view');
require('mixins/common/userPref');
require('mixins/common/localStorage');
require('views/main/dashboard/widgets');

describe('App.MainDashboardWidgetsView', function () {

  var view = App.MainDashboardWidgetsView.create();

  describe('#setInitPrefObject', function () {
    var host_metrics_widgets_count = 4;
    var hdfs_widgets_count = 7;
    var hbase_widgets_count = 4;
    var yarn_widgets_count = 4;
    var total_widgets_count = 20;
    var tests = Em.A([
      {
        models: {
          host_metrics_model: null,
          hdfs_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - host_metrics_widgets_count - hdfs_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'All models are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: null,
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - hdfs_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'hdfs_model, hbase_model, yarn_model are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'hbase_model, yarn_model are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: null,
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - hbase_widgets_count - yarn_widgets_count - 1,
          hiddenL: 0
        },
        m: 'hbase_model and yarn_model are null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: {},
          yarn_model: null
        },
        e: {
          visibleL: total_widgets_count - yarn_widgets_count - 1,
          hiddenL: 1
        },
        m: 'yarn_model is null'
      },
      {
        models: {
          host_metrics_model: {},
          hdfs_model: {},
          hbase_model: {},
          yarn_model: {}
        },
        e: {
          visibleL: total_widgets_count,
          hiddenL: 1
        },
        m: 'All models are not null'
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        view.set('host_metrics_model', test.models.host_metrics_model);
        view.set('hdfs_model', test.models.hdfs_model);
        view.set('hbase_model', test.models.hbase_model);
        view.set('yarn_model', test.models.yarn_model);
        view.setInitPrefObject();
        expect(view.get('initPrefObject.visible.length')).to.equal(test.e.visibleL);
        expect(view.get('initPrefObject.hidden.length')).to.equal(test.e.hiddenL);
      });
    });
  });

  describe('#persistKey', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function (k) {
        if ('loginName' === k) return 'tdk';
        return Em.get(App.router, k);
      });
    });
    afterEach(function () {
      App.router.get.restore();
    });
    it('Check it', function () {
      expect(view.get('persistKey')).to.equal('user-pref-tdk-dashboard');
    });
  });

  describe("#didInsertElement()", function () {
    before(function () {
      sinon.stub(view, 'setWidgetsDataModel', Em.K);
      sinon.stub(view, 'setInitPrefObject', Em.K);
      sinon.stub(view, 'setOnLoadVisibleWidgets', Em.K);
      sinon.stub(Em.run, 'next', Em.K);
    });
    after(function () {
      view.setWidgetsDataModel.restore();
      view.setInitPrefObject.restore();
      view.setOnLoadVisibleWidgets.restore();
      Em.run.next.restore();
    });
    it("", function () {
      view.didInsertElement();
      expect(view.setWidgetsDataModel.calledOnce).to.be.true;
      expect(view.setInitPrefObject.calledOnce).to.be.true;
      expect(view.setOnLoadVisibleWidgets.calledOnce).to.be.true;
      expect(Em.run.next.calledWith(view, 'makeSortable')).to.be.true;
      expect(view.get('isDataLoaded')).to.be.true
    });
  });

  describe("#setWidgetsDataModel()", function () {
    beforeEach(function () {
      this.model = sinon.stub(App.Service, 'find');
      this.get = sinon.stub(App, 'get');
    });
    afterEach(function () {
      this.model.restore();
      this.get.restore();
    });
    it("No host_metrics_model", function () {
      this.get.returns([]);
      this.model.returns([Em.Object.create({
        serviceName: 'S1',
        id: 'S1'
      })]);
      view.set('host_metrics_model', null);
      view.setWidgetsDataModel();
      expect(view.get('host_metrics_model')).to.be.null;
      expect(view.get('s1_model')).to.eql(Em.Object.create({
        serviceName: 'S1',
        id: 'S1'
      }));
    });
    it("host_metrics_model is present", function () {
      this.get.returns([1]);
      this.model.returns([Em.Object.create({
        serviceName: 'HDFS',
        id: 'HDFS'
      })]);
      view.set('host_metrics_model', null);
      view.setWidgetsDataModel();
      expect(view.get('host_metrics_model')).to.eql([1]);
      expect(view.get('hdfs_model.id')).to.equal('HDFS');
    });
  });

  describe("#plusButtonFilterView", function () {
    var plusButtonFilterView = view.get('plusButtonFilterView').create({
      parentView: view
    });
    plusButtonFilterView.reopen({
      visibleWidgets: [],
      hiddenWidgets: []
    });

    describe("#applyFilter()", function () {
      var widget = {checked: true};
      beforeEach(function () {
        sinon.stub(view, 'getUserPref').returns({
          complete: Em.K
        });
        sinon.stub(view, 'widgetsMapper').returns(widget);
      });
      afterEach(function () {
        view.getUserPref.restore();
        view.widgetsMapper.restore();
      });
      it("testMode is on", function () {
        App.set('testMode', true);
        plusButtonFilterView.set('hiddenWidgets', [widget]);
        plusButtonFilterView.applyFilter();
        expect(view.getUserPref.called).to.be.false;
        expect(plusButtonFilterView.get('visibleWidgets')).not.to.be.empty;
        expect(plusButtonFilterView.get('hiddenWidgets')).to.be.empty;
      });
      it("testMode is off", function () {
        App.set('testMode', false);
        plusButtonFilterView.applyFilter();
        expect(view.getUserPref.calledOnce).to.be.true;
      });
    });

    describe("#applyFilterComplete()", function () {
      var widget = {checked: true};
      beforeEach(function () {
        sinon.stub(view, 'postUserPref');
        sinon.stub(view, 'translateToReal');
      });
      afterEach(function () {
        view.postUserPref.restore();
        view.translateToReal.restore();
      });
      beforeEach(function () {
        sinon.stub(App.router, 'get', function (k) {
          if ('loginName' === k) return 'tdk';
          return Em.get(App.router, k);
        });
      });
      afterEach(function () {
        App.router.get.restore();
      });
      it("", function () {
        plusButtonFilterView.set('hiddenWidgets', [
          Em.Object.create({
            checked: true,
            id: 1,
            displayName: 'i1'
          }),
          Em.Object.create({
            checked: false,
            id: 2,
            displayName: 'i2'
          })
        ]);
        view.set('currentPrefObject', Em.Object.create({
          dashboardVersion: 'new',
          visible: [],
          hidden: [],
          threshold: 'threshold'
        }));
        view.set('persistKey', 'key');
        plusButtonFilterView.applyFilterComplete();
        expect(view.postUserPref.calledOnce).to.be.true;
        expect(view.translateToReal.getCall(0).args[0]).to.eql(Em.Object.create({
          dashboardVersion: 'new',
          visible: [1],
          hidden: [
            [2, 'i2']
          ],
          threshold: 'threshold'
        }));
        expect(plusButtonFilterView.get('hiddenWidgets.length')).to.equal(1);
      });
    });
  });

  describe("#translateToReal()", function () {
    beforeEach(function () {
      sinon.stub(view, 'widgetsMapper').returns(Em.Object.create());
      view.set('visibleWidgets', []);
      view.set('hiddenWidgets', []);
    });
    afterEach(function () {
      view.widgetsMapper.restore();
    });
    it("version is not new", function () {
      var data = {
        dashboardVersion: null,
        visible: [],
        hidden: [],
        threshold: []
      };
      view.translateToReal(data);
      expect(view.get('visibleWidgets')).to.be.empty;
      expect(view.get('hiddenWidgets')).to.be.empty;
    });
    it("version is new", function () {
      var data = {
        dashboardVersion: 'new',
        visible: [1],
        hidden: [
          ['id', 'title']
        ],
        threshold: [
          [],
          [
            ['tresh1'],
            ['tresh2']
          ]
        ]
      };
      view.translateToReal(data);
      expect(view.get('visibleWidgets')).to.not.be.empty;
      expect(view.get('hiddenWidgets')).to.not.be.empty;
    });
  });

  describe("#setOnLoadVisibleWidgets()", function () {
    beforeEach(function () {
      sinon.stub(view, 'translateToReal', Em.K);
      sinon.stub(view, 'getUserPref').returns({complete: Em.K});
    });
    afterEach(function () {
      view.translateToReal.restore();
      view.getUserPref.restore();
    });

    it("testMode is true", function () {
      App.set('testMode', true);
      view.setOnLoadVisibleWidgets();
      expect(view.translateToReal.calledOnce).to.be.true;
    });
    it("testMode is false", function () {
      App.set('testMode', false);
      view.setOnLoadVisibleWidgets();
      expect(view.getUserPref.calledOnce).to.be.true;
    });
  });

  describe("#removeWidget()", function () {
    it("", function () {
      var widget = {};
      var value = {
        visible: [widget],
        hidden: [
          [widget]
        ]
      };
      value = view.removeWidget(value, widget);
      expect(value.visible).to.be.empty;
      expect(value.hidden).to.be.empty;
    });
  });

  describe("#containsWidget()", function () {
    it("widget visible", function () {
      var widget = {};
      var value = {
        visible: [widget],
        hidden: [
          [widget]
        ]
      };
      expect(view.containsWidget(value, widget)).to.be.true;
    });
    it("widget absent", function () {
      var widget = {};
      var value = {
        visible: [],
        hidden: []
      };
      expect(view.containsWidget(value, widget)).to.be.false;
    });
    it("widget hidden", function () {
      var widget = {};
      var value = {
        visible: [],
        hidden: [
          [widget]
        ]
      };
      expect(view.containsWidget(value, widget)).to.be.true;
    });
  });

  describe("#persistKey", function () {
    before(function () {
      sinon.stub(App.router, 'get').withArgs('loginName').returns('user');
    });
    after(function () {
      App.router.get.restore();
    });
    it("", function () {
      view.propertyDidChange('persistKey');
      expect(view.get('persistKey')).to.equal('user-pref-user-dashboard');
    });
  });

  describe("#getUserPrefSuccessCallback()", function () {

    it("response is null", function () {
      view.set('currentPrefObject', null);
      view.getUserPrefSuccessCallback(null, {}, {});
      expect(view.get('currentPrefObject')).to.be.null;
    });

    it("response is correct", function () {
      view.set('currentPrefObject', null);
      view.getUserPrefSuccessCallback({}, {}, {});
      expect(view.get('currentPrefObject')).to.eql({});
    });

    it('should update missing thresholds', function () {

      view.set('currentPrefObject', null);
      view.getUserPrefSuccessCallback({
        threshold: {
          17: []
        }
      }, {}, {});
      expect(view.get('currentPrefObject.threshold')['17']).to.eql([70, 90]);

    });

  });

  describe("#resetAllWidgets()", function () {

    var cases = [
      {
        testMode: true,
        postUserPrefCallCount: 0,
        setDBPropertyCallCount: 0,
        title: 'test mode'
      },
      {
        testMode: false,
        postUserPrefCallCount: 1,
        setDBPropertyCallCount: 1,
        title: 'real cluster'
      }
    ];

    cases.forEach(function (item) {

      describe(item.title, function () {

        beforeEach(function () {
          sinon.stub(App, 'showConfirmationPopup', function (callback) {
            callback();
          });
          sinon.stub(App, 'get').withArgs('testMode').returns(item.testMode);
          sinon.stub(view, 'postUserPref', Em.K);
          sinon.stub(view, 'setDBProperty', Em.K);
          sinon.stub(view, 'translateToReal', Em.K);
          view.setProperties({
            currentTimeRangeIndex: 1,
            customStartTime: 1000,
            customEndTime: 2000
          });
          view.resetAllWidgets();
        });

        afterEach(function () {
          App.get.restore();
          App.showConfirmationPopup.restore();
          view.postUserPref.restore();
          view.setDBProperty.restore();
          view.translateToReal.restore();
        });

        it('persist reset', function () {
          expect(view.postUserPref.callCount).to.equal(item.postUserPrefCallCount);
        });
        it('local storage reset', function () {
          expect(view.setDBProperty.callCount).to.equal(item.setDBPropertyCallCount);
        });
        it('time range reset', function () {
          expect(view.get('currentTimeRangeIndex')).to.equal(0);
        });
        it('custom start time reset', function () {
          expect(view.get('customStartTime')).to.be.null;
        });
        it('custom end time reset', function () {
          expect(view.get('customEndTime')).to.be.null;
        });
        it('default settings application', function () {
          expect(view.translateToReal.callCount).to.equal(1);
        });

      });

    });
  });

  describe('#checkServicesChange', function () {

    var emptyCurrentPref = {
        visible: [],
        hidden: [],
        threshold: {}
      },
      widgetsMap = {
        hdfs_model: ['1', '2', '3', '4', '5', '10', '11'],
        host_metrics_model: ['6', '7', '8', '9'],
        hbase_model: ['12', '13', '14', '15', '16'],
        yarn_model: ['17', '18', '19', '20', '23'],
        storm_model: ['21'],
        flume_model: ['22']
      },
      emptyModelTitle = '{0} absent',
      notEmptyModelTitle = '{0} present';

    Em.keys(widgetsMap).forEach(function (item, index, array) {
      it(notEmptyModelTitle.format(item), function () {
        array.forEach(function (modelName) {
          view.set(modelName, modelName == item ? {} : null);
        });
        expect(view.checkServicesChange(emptyCurrentPref).visible).to.eql(widgetsMap[item]);
      });
    });

    Em.keys(widgetsMap).forEach(function (item, index, array) {
      it(emptyModelTitle.format(item), function () {
        var expected = [];
        array.forEach(function (modelName) {
          if (modelName == item) {
            view.set(modelName, null);
          } else {
            view.set(modelName, {});
            expected = expected.concat(widgetsMap[modelName]);
          }
        });
        expect(view.checkServicesChange({
          visible: widgetsMap[item],
          hidden: [],
          threshold: {}
        }).visible).to.eql(expected);
      });
    });

  });
});

});

;require.register("test/views/main/dashboard_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('messages');
var filters = require('views/common/filter_view');
require('views/main/dashboard');
var mainDashboardView;
describe('App.MainDashboardView', function() {

   beforeEach(function() {
     mainDashboardView = App.MainDashboardView.create();
   });

});

});

;require.register("test/views/main/host/details/host_component_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');

var hostComponentView;

describe('App.HostComponentView', function() {

  beforeEach(function() {
    sinon.stub(App.router, 'get', function (k) {
      if (k === 'mainHostDetailsController.content') return Em.Object.create({
        hostComponents: [
          {
            componentName: 'component'
          }
        ]
      });
      return Em.get(App.router, k);
    });
    hostComponentView = App.HostComponentView.create({
      startBlinking: function(){},
      doBlinking: function(){},
      getDesiredAdminState: function(){return $.ajax({});},
      content: Em.Object.create({
        componentName: 'component'
      }),
      hostComponent: Em.Object.create()
    });
  });

  afterEach(function () {
    App.router.get.restore();
  });

  describe('#disabled', function() {

    var tests = Em.A([
      {
        parentView: {content: {healthClass: 'health-status-DEAD-YELLOW'}},
        noActionAvailable: '',
        isRestartComponentDisabled: true,
        e: 'disabled'
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        noActionAvailable: '',
        isRestartComponentDisabled: true,
        e: ''
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        noActionAvailable: 'hidden',
        isRestartComponentDisabled: true,
        e: 'disabled'
      },
      {
        parentView: {content: {healthClass: 'another-class'}},
        noActionAvailable: 'hidden',
        isRestartComponentDisabled: false,
        e: ''
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          parentView: test.parentView,
          noActionAvailable: test.noActionAvailable,
          isRestartComponentDisabled: test.isRestartComponentDisabled
        });
        expect(hostComponentView.get('disabled')).to.equal(test.e);
      });
    });

  });

  describe('#isUpgradeFailed', function() {

    var tests = ['UPGRADE_FAILED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isUpgradeFailed')).to.equal(e);
      });
    });

  });

  describe('#isInstallFailed', function() {

    var tests = ['INSTALL_FAILED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInstallFailed')).to.equal(e);
      });
    });

  });

  describe('#isStart', function() {

    var tests = ['STARTED','STARTING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isStart')).to.equal(e);
      });
    });

  });

  describe('#isStop', function() {

    var tests = ['INSTALLED'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isStop')).to.equal(e);
      });
    });

  });

  describe('#isInstalling', function() {

    var tests = ['INSTALLING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInstalling')).to.equal(e);
      });
    });

  });

  describe('#isInit', function() {

    var tests = ['INIT'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInit')).to.equal(e);
      });
    });

  });

  describe('#noActionAvailable', function() {

    var tests = ['STARTING', 'STOPPING', 'UNKNOWN', 'DISABLED'];
    var testE = 'hidden';
    var defaultE = '';

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('noActionAvailable')).to.equal(e);
      });
    });

  });

  describe('#isActive', function() {

    var tests = Em.A([
      {passiveState: 'OFF', e: true},
      {passiveState: 'ON', e: false},
      {passiveState: 'IMPLIED', e: false}
    ]);

    tests.forEach(function(test) {
      it(test.workStatus, function() {
        hostComponentView.get('content').set('passiveState', test.passiveState);
        expect(hostComponentView.get('isActive')).to.equal(test.e);
      });
    });

  });

  describe('#isRestartComponentDisabled', function() {

    var tests = ['STARTED'];
    var testE = false;
    var defaultE = true;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isRestartComponentDisabled')).to.equal(e);
      });
    });

  });

  describe('#isDeleteComponentDisabled', function() {

    beforeEach(function() {
      this.mock = sinon.stub(App.StackServiceComponent, 'find');
      sinon.stub(App.HostComponent, 'getCount').returns(1);
    });
    afterEach(function() {
      this.mock.restore();
      App.HostComponent.getCount.restore();
    });

    it('delete is disabled because min cardinality 1', function() {
      this.mock.returns(Em.Object.create({minToInstall: 1}));
      hostComponentView.get('hostComponent').set('componentName', 'C1');
      hostComponentView.propertyDidChange('isDeleteComponentDisabled');
      expect(hostComponentView.get('isDeleteComponentDisabled')).to.be.true;
    });

    it('delete is disabled because min cardinality 0 and status INSTALLED', function() {
      this.mock.returns(Em.Object.create({minToInstall: 0}));
      hostComponentView.get('hostComponent').set('workStatus', 'INIT');
      hostComponentView.propertyDidChange('isDeleteComponentDisabled');
      expect(hostComponentView.get('isDeleteComponentDisabled')).to.be.false;
    });

    it('delete is enabled because min cardinality 0 and status STARTED', function() {
      this.mock.returns(Em.Object.create({minToInstall: 0}));
      hostComponentView.get('hostComponent').set('workStatus', 'STARTED');
      hostComponentView.propertyDidChange('isDeleteComponentDisabled');
      expect(hostComponentView.get('isDeleteComponentDisabled')).to.be.true;
    });
  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        componentTextStatus: 'status',
        hostComponent: null,
        e: 'status',
        m: 'get content status'
      },
      {
        componentTextStatus: 'status',
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          hostComponent: test.hostComponent,
          content: Em.Object.create()
        });
        hostComponentView.get('content').set('componentTextStatus', test.componentTextStatus);
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#workStatus', function() {

    var tests = Em.A([
      {
        workStatus: 'status',
        hostComponent: null,
        e: 'status',
        m: 'get content workStatus'
      },
      {
        workStatus: 'status',
        hostComponent: Em.Object.create({workStatus: 'new_status'}),
        e: 'new_status',
        m: 'get hostComponent workStatus'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          hostComponent: test.hostComponent,
          content: Em.Object.create()
        });
        hostComponentView.get('content').set('workStatus', test.workStatus);
        expect(hostComponentView.get('workStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.install_failed,
        passiveState: 'OFF',
        e: 'health-status-color-red icon-cog'
      },
      {
        workStatus: App.HostComponentStatus.installing,
        passiveState: 'OFF',
        e: 'health-status-color-blue icon-cog'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'ON',
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'IMPLIED',
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        e: 'health-status-started'
      }
    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.passiveState, function() {
        hostComponentView = App.HostComponentView.create({
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: Em.Object.create(),
          hostComponent: Em.Object.create()
        });
        hostComponentView.get('hostComponent').set('workStatus',test.workStatus);
        hostComponentView.get('content').set('passiveState', test.passiveState);
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#isInProgress', function() {

    var tests = ['STOPPING', 'STARTING'];
    var testE = true;
    var defaultE = false;

    App.HostComponentStatus.getStatusesList().forEach(function(status) {
      it(status, function() {
        hostComponentView.get('hostComponent').set('workStatus', status);
        var e = tests.contains(status) ? testE : defaultE;
        expect(hostComponentView.get('isInProgress')).to.equal(e);
      });
    });

  });

  describe('#statusIconClass', function() {
    var tests = Em.A([
      {s: 'health-status-started', e: App.healthIconClassGreen},
      {s: 'health-status-starting', e: App.healthIconClassGreen},
      {s: 'health-status-installed', e: App.healthIconClassRed},
      {s: 'health-status-stopping', e: App.healthIconClassRed},
      {s: 'health-status-unknown', e: App.healthIconClassYellow},
      {s: 'health-status-DEAD-ORANGE', e: App.healthIconClassOrange},
      {s: 'other', e: ''}
    ]);

    tests.forEach(function(test) {
      it(test.s, function() {
        hostComponentView.reopen({statusClass: test.s});
        expect(hostComponentView.get('statusIconClass')).to.equal(test.e);
      })
    });
  });

  describe('#slaveCustomCommands', function() {

    var content = [
      {
        componentName: 'SLAVE_COMPONENT',
        hostName: '01'
      },
      {
        componentName: 'NOT_SLAVE_COMPONENT',
        hostName: '02'
      }
    ];
    before(function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return Em.Object.create({
          componentName: 'SLAVE_COMPONENT',
          isSlave: true,
          customCommands: ['SLAVE_CUSTOM_COMMAND']
        });
      });
      sinon.stub(App.HostComponentActionMap, 'getMap', function () {
        return {
          SLAVE_CUSTOM_COMMAND: {
            customCommand: 'SLAVE_CUSTOM_COMMAND',
            cssClass: 'icon-play-circle',
            label: 'Custom Command',
            context: 'Custom Command',
            isHidden: false,
            disabled: false
          }
        }
      });
    });

    it('Should get custom commands for slaves', function() {
      hostComponentView.set('content', content);
      expect(hostComponentView.get('customCommands')).to.have.length(1);
    });

    after(function() {
      App.StackServiceComponent.find.restore();
      App.HostComponentActionMap.getMap.restore();
    });
  });

  describe('#masterCustomCommands', function() {
    var content = [
      {
        componentName: 'MASTER_COMPONENT',
        hostName: '01'
      }
    ];

    beforeEach(function () {
      sinon.stub(App.HostComponentActionMap, 'getMap', function () {
        return {
          REFRESHQUEUES: {
            action: 'refreshYarnQueues',
            customCommand: 'REFRESHQUEUES',
            context : Em.I18n.t('services.service.actions.run.yarnRefreshQueues.context'),
            label: Em.I18n.t('services.service.actions.run.yarnRefreshQueues.menu'),
            cssClass: 'icon-refresh',
            disabled: false
          }
        }
      });
    });


    //two components, one running, active one is stopped
    it('Should not get custom commands for master component if component not running', function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return Em.Object.create({
          componentName: 'MASTER_COMPONENT',
          isSlave: false,
          isMaster: true,
          isStart: false,
          customCommands: ['DECOMMISSION', 'REFRESHQUEUES']
        });
      });

      sinon.stub(App.HostComponent, 'getCount').returns(2);

      sinon.stub(hostComponentView, 'runningComponentCounter', function () {
        return 1;
      });

      hostComponentView.set('content', content);
      expect(hostComponentView.get('customCommands')).to.have.length(0);
    });

    //two components, none running
    it('Should get custom commands for master component when all components are stopped', function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return Em.Object.create({
          componentName: 'MASTER_COMPONENT',
          isSlave: false,
          isMaster: true,
          isStart: false,
          customCommands: ['DECOMMISSION', 'REFRESHQUEUES']
        });
      });

      sinon.stub(App.HostComponent, 'getCount').returns(2);

      sinon.stub(hostComponentView, 'runningComponentCounter', function () {
        return 0;
      });

      hostComponentView.set('content', content);
      expect(hostComponentView.get('customCommands')).to.have.length(1);
    });

    //two components, two running, only commission and decommission custom commands
    it('Should not show COMMISSION and DECOMMISSION on master', function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return Em.Object.create({
          componentName: 'MASTER_COMPONENT',
          isSlave: false,
          isMaster: true,
          isStart: false,
          customCommands: ['DECOMMISSION', 'RECOMMISSION']
        });
      });

      sinon.stub(App.HostComponent, 'getCount').returns(2);

      sinon.stub(hostComponentView, 'runningComponentCounter', function () {
        return 2;
      });

      hostComponentView.set('content', content);
      expect(hostComponentView.get('customCommands')).to.have.length(0);
    });

    //one component, one running, cardinality 1
    it('Should show custom command for cardinality 1', function() {
      sinon.stub(App.StackServiceComponent, 'find', function() {
        return Em.Object.create({
          isSlave: false,
          cardinality: '1',
          isMaster: true,
          isStart: true,
          customCommands: ['DECOMMISSION', 'REFRESHQUEUES']
        });
      });

      sinon.stub(App.HostComponent, 'getCount').returns(1);

      sinon.stub(hostComponentView, 'runningComponentCounter', function () {
        return 1;
      });

      hostComponentView.set('content', content);
      expect(hostComponentView.get('customCommands')).to.have.length(1);
    });

    afterEach(function() {
      App.HostComponentActionMap.getMap.restore();
      App.StackServiceComponent.find.restore();
      App.HostComponent.getCount.restore();
      hostComponentView.runningComponentCounter.restore();
    });
  });

  describe('#getCustomCommandLabel', function() {

    beforeEach(function () {
      sinon.stub(App.HostComponentActionMap, 'getMap', function () {
        return {
          MASTER_CUSTOM_COMMAND: {
            action: 'executeCustomCommand',
            cssClass: 'icon-play-circle',
            isHidden: false,
            disabled: false
          },
          REFRESHQUEUES: {
            action: 'refreshYarnQueues',
            customCommand: 'REFRESHQUEUES',
            context : Em.I18n.t('services.service.actions.run.yarnRefreshQueues.context'),
            label: Em.I18n.t('services.service.actions.run.yarnRefreshQueues.menu'),
            cssClass: 'icon-refresh',
            disabled: false
          }
        }
      });
    });
    afterEach(function() {
      App.HostComponentActionMap.getMap.restore();
    });

    var tests = Em.A([
      {
        msg: 'Component not present in `App.HostComponentActionMap.getMap()` should have a default valid label',
        command: 'CUSTOM',
        e: Em.I18n.t('services.service.actions.run.executeCustomCommand.menu').format('CUSTOM')
      },
      {
        msg: 'Component present in `App.HostComponentActionMap.getMap()` with no label should have a default valid label',
        command: 'MASTER_CUSTOM_COMMAND',
        e: Em.I18n.t('services.service.actions.run.executeCustomCommand.menu').format('MASTER_CUSTOM_COMMAND')
      },
      {
        msg: 'Component present in `App.HostComponentActionMap.getMap()` with label should have a custom valid label',
        command: 'REFRESHQUEUES',
        e: Em.I18n.t('services.service.actions.run.yarnRefreshQueues.menu')
      }
    ]);

    tests.forEach(function(test) {
      it(test.msg, function() {
        expect(hostComponentView.getCustomCommandLabel(test.command)).to.equal(test.e);
      })
    });
  });
});

});

;require.register("test/views/main/host/details/host_component_views/datanode_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/datanode_view');

describe('App.DataNodeComponentView', function () {
  var view = App.DataNodeComponentView.create({
    content: {
      hostName: 'host1'
    }
  });

  describe("#getDNDecommissionStatus()", function () {
    beforeEach(function () {
      this.stub = sinon.stub(App.HDFSService, 'find');
      sinon.stub(App.ajax, 'send');
    });
    afterEach(function () {
      App.ajax.send.restore();
      this.stub.restore();
    });
    it("snameNode absent and no activeNameNode", function () {
      this.stub.returns([
        Em.Object.create({
          snameNode: null,
          activeNameNode: null,
          nameNode: {hostName: 'host1'}
        })
      ]);
      view.getDNDecommissionStatus();
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        "hostName": "host1",
        "componentName": "NAMENODE"
      });
    });
    it("snameNode present and no activeNameNode", function () {
      this.stub.returns([
        Em.Object.create({
          snameNode: {},
          activeNameNode: null,
          nameNode: {hostName: 'host1'}
        })
      ]);
      view.getDNDecommissionStatus();
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        "hostName": "host1",
        "componentName": "NAMENODE"
      });
    });
    it("snameNode absent and activeNameNode valid", function () {
      this.stub.returns([
        Em.Object.create({
          snameNode: null,
          activeNameNode: {hostName: 'host2'},
          nameNode: {hostName: 'host1'}
        })
      ]);
      view.getDNDecommissionStatus();
      expect(App.ajax.send.getCall(0).args[0].data).to.eql({
        "hostName": "host2",
        "componentName": "NAMENODE"
      });
    });
  });

  describe("#getDNDecommissionStatusSuccessCallback()", function () {
    beforeEach(function () {
      sinon.stub(view, 'computeStatus', Em.K);
      view.set('decommissionedStatusObject', null);
    });
    afterEach(function () {
      view.computeStatus.restore();
    });
    it("metric null", function () {
      var data = {
        metrics: {
          dfs: {
            namenode: null
          }
        }
      };
      expect(view.getDNDecommissionStatusSuccessCallback(data)).to.equal(null);
      expect(view.computeStatus.calledOnce).to.be.false;
    });
    it("metric valid", function () {
      var data = {
        metrics: {
          dfs: {
            namenode: "status"
          }
        }
      };
      expect(view.getDNDecommissionStatusSuccessCallback(data)).to.equal("status");
      expect(view.computeStatus.calledOnce).to.be.true;
    });
  });

  describe("#getDNDecommissionStatusErrorCallback()", function () {
    it("reset to null", function () {
      expect(view.getDNDecommissionStatusErrorCallback()).to.be.null;
      expect(view.get('decommissionedStatusObject')).to.be.null;
    });
  });

  describe("#loadComponentDecommissionStatus()", function () {
    before(function () {
      sinon.stub(view, 'getDNDecommissionStatus', Em.K);
    });
    after(function () {
      view.getDNDecommissionStatus.restore();
    });
    it("call getDNDecommissionStatus()", function () {
      view.loadComponentDecommissionStatus();
      expect(view.getDNDecommissionStatus.calledOnce).to.be.true;
    });
  });

  describe("#setDesiredAdminState()", function () {
    before(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    after(function () {
      view.setStatusAs.restore();
    });
    it("call getDNDecommissionStatus()", function () {
      view.setDesiredAdminState('status');
      expect(view.setStatusAs.calledWith('status')).to.be.true;
    });
  });

  describe("#computeStatus()", function () {
    beforeEach(function () {
      sinon.stub(view, 'getDesiredAdminState', Em.K);
      sinon.stub(view, 'setStatusAs', Em.K);
      this.stub = sinon.stub(App, 'get');
    });
    afterEach(function () {
      view.getDesiredAdminState.restore();
      view.setStatusAs.restore();
      this.stub.restore();
    });
    var testCases = [
      {
        title: 'No live nodes',
        data: {
          curObj: {},
        },
        result: {
          getDesiredAdminStateCalled: true,
          status: "",
          setStatusAsCalled: false
        }
      },
      {
        title: 'Live nodes In Service',
        data: {
          "curObj": {
            "LiveNodes": {
              "host1": {
                "adminState": "In Service"
              }
            }
          }
        },
        result: {
          getDesiredAdminStateCalled: false,
          status: "INSERVICE",
          setStatusAsCalled: true
        }
      },
      {
        title: 'Live nodes In Progress',
        data: {
          "curObj": {
            "LiveNodes": {
              "host1": {
                "adminState": "Decommission In Progress"
              }
            }
          }
        },
        result: {
          getDesiredAdminStateCalled: false,
          status: "DECOMMISSIONING",
          setStatusAsCalled: true
        }
      },
      {
        title: 'Live nodes Decommissioned',
        data: {
          "curObj": {
            "LiveNodes": {
              "host1": {
                "adminState": "Decommissioned"
              }
            }
          }
        },
        result: {
          getDesiredAdminStateCalled: false,
          status: "DECOMMISSIONED",
          setStatusAsCalled: true
        }
      }
    ];
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.computeStatus(test.data.curObj);
        expect(view.getDesiredAdminState.called).to.equal(test.result.getDesiredAdminStateCalled);
        expect(view.setStatusAs.calledWith(test.result.status)).to.equal(test.result.setStatusAsCalled);
      });
    }, this);
    it("data is null", function () {
      view.computeStatus(null);
      expect(view.getDesiredAdminState.called).to.be.false;
      expect(view.setStatusAs.called).to.be.false;
    });
  });

});

});

;require.register("test/views/main/host/details/host_component_views/decommissionable_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host_component');
require('views/main/host/details/host_component_view');
require('mixins');
require('mixins/main/host/details/host_components/decommissionable');

var hostComponentView;

describe('App.Decommissionable', function() {

  beforeEach(function() {
    sinon.stub(App.router, 'get', function (k) {
      if (k === 'mainHostDetailsController.content') return Em.Object.create({
        hostComponents: [
          {
            componentName: 'component'
          }
        ]
      });
      return Em.get(App.router, k);
    });
  });

  afterEach(function () {
    App.router.get.restore();
  });

  describe('#componentTextStatus', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: null,
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'status',
        m: 'get content status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: false,
        isComponentDecommissioning: false,
        e: 'new_status',
        m: 'get hostComponent status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: true,
        e: Em.I18n.t('hosts.host.decommissioning'),
        m: 'get decommissioning status'
      },
      {
        content: Em.Object.create({componentTextStatus: 'status'}),
        hostComponent: Em.Object.create({componentTextStatus: 'new_status'}),
        isComponentRecommissionAvailable: true,
        isComponentDecommissioning: false,
        e: Em.I18n.t('hosts.host.decommissioned'),
        m: 'get decommissioned status'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable, {
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          content: test.content,
          hostComponent: test.hostComponent,
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          isComponentDecommissioning: test.isComponentDecommissioning
        });
        expect(hostComponentView.get('componentTextStatus')).to.equal(test.e);
      });
    });

  });

  describe('#statusClass', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.install_failed,
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-red icon-cog'
      },
      {
        workStatus: App.HostComponentStatus.installing,
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-color-blue icon-cog'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'ON',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'IMPLIED',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: false,
        e: 'health-status-started'
      },
      {
        workStatus: 'STARTED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        workStatus: 'STARTING',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      },
      {
        workStatus: 'INSTALLED',
        passiveState: 'OFF',
        isComponentRecommissionAvailable: true,
        e: 'health-status-DEAD-ORANGE'
      }

    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.passiveState + ' ' + test.isComponentRecommissionAvailable?'true':'false', function() {
        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isComponentRecommissionAvailable: test.isComponentRecommissionAvailable,
          content: Em.Object.create()
        });
        hostComponentView.get('content').setProperties({
          workStatus: test.workStatus,
          passiveState: test.passiveState
        });
        expect(hostComponentView.get('statusClass')).to.equal(test.e);
      });
    });

  });

  describe('#isInProgress', function() {

    var tests = Em.A([
      {
        workStatus: App.HostComponentStatus.stopping,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: App.HostComponentStatus.starting,
        isDecommissioning: false,
        e: true
      },
      {
        workStatus: 'other_status',
        isDecommissioning: false,
        e: false
      },
      {
        workStatus: 'other_status',
        isDecommissioning: true,
        e: true
      }
    ]);

    tests.forEach(function(test) {
      it(test.workStatus + ' ' + test.isDecommissioning?'true':'false', function() {

        hostComponentView = App.HostComponentView.create(App.Decommissionable,{
          startBlinking: function(){},
          doBlinking: function(){},
          getDesiredAdminState: function(){return $.ajax({});},
          isDecommissioning: test.isDecommissioning,
          content: Em.Object.create({workStatus: test.workStatus})
        });

        expect(hostComponentView.get('isInProgress')).to.equal(test.e);
      });
    });

  });

  describe("#getDesiredAdminState()", function() {
    beforeEach(function () {
      sinon.stub(App.ajax, 'send', Em.K);
    });
    afterEach(function () {
      App.ajax.send.restore();
    });
    it("content is null", function() {
      hostComponentView = Em.View.create(App.Decommissionable, {
        content: null
      });
      hostComponentView.getDesiredAdminState();
      expect(App.ajax.send.called).to.be.false;
    });
    it("content is correct", function() {
      hostComponentView = Em.View.create(App.Decommissionable, {
        content: Em.Object.create({
          hostName: 'host1',
          componentName: 'C1'
        })
      });
      hostComponentView.getDesiredAdminState();
      expect(App.ajax.send.calledWith({
        name: 'host.host_component.slave_desired_admin_state',
        sender: hostComponentView,
        data: {
          hostName: 'host1',
          componentName: 'C1'
        },
        success: 'getDesiredAdminStateSuccessCallback',
        error: 'getDesiredAdminStateErrorCallback'
      })).to.be.true;
    });
  });
});

});

;require.register("test/views/main/host/details/host_component_views/nodemanager_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/nodemanager_view');

describe('App.NodeManagerComponentView', function () {
  var view = App.NodeManagerComponentView.create({
    content: {
      service: {
        hostComponents: [
          Em.Object.create({
            componentName: 'RESOURCEMANAGER'
          })
        ]
      },
      hostName: 'host1'
    }
  });

  describe("#setDesiredAdminState()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
      sinon.stub(view, 'getDecommissionStatus', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
      view.getDecommissionStatus.restore();
    });
    it("state INSERVICE", function () {
      view.setDesiredAdminState('INSERVICE');
      expect(view.setStatusAs.calledWith('INSERVICE')).to.be.true;
    });
    it("state DECOMMISSIONED", function () {
      view.setDesiredAdminState('DECOMMISSIONED');
      expect(view.getDecommissionStatus.calledOnce).to.be.true;
    });
  });

  describe("#setDecommissionStatus()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
    });
    it("rm_metrics null", function () {
      view.setDecommissionStatus({rm_metrics: null});
      expect(view.setStatusAs.calledWith('DECOMMISSIONED')).to.be.true;
    });
    it("RM contains host", function () {
      var curObj =  {rm_metrics: {
        cluster: {
          nodeManagers: [{
            HostName: 'host1'
          }]
        }
      }};
      view.setDecommissionStatus(curObj);
      expect(view.setStatusAs.calledWith('DECOMMISSIONING')).to.be.true;
    });
    it("RM does not contain host", function () {
      var curObj =  {rm_metrics: {
        cluster: {
          nodeManagers: []
        }
      }};
      view.setDecommissionStatus(curObj);
      expect(view.setStatusAs.calledWith('DECOMMISSIONED')).to.be.true;
    });
  });
});

});

;require.register("test/views/main/host/details/host_component_views/regionserver_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/regionserver_view');

describe('App.RegionServerComponentView', function () {
  var view = App.RegionServerComponentView.create();

  describe("#setDesiredAdminState()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
    });
    it("INSERVICE state)", function () {
      view.setDesiredAdminState('INSERVICE');
      expect(view.setStatusAs.calledWith('INSERVICE')).to.be.true;
    });
    it("DECOMMISSIONED state)", function () {
      view.setDesiredAdminState('DECOMMISSIONED');
      expect(view.setStatusAs.calledWith('RS_DECOMMISSIONED')).to.be.true;
    });
  });
});

});

;require.register("test/views/main/host/details/host_component_views/tasktracker_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details/host_component_views/tasktracker_view');

describe('App.TaskTrackerComponentView', function () {
  var view = App.TaskTrackerComponentView.create({
    content: {
      hostName: 'host1'
    }
  });

  describe("#setDesiredAdminState()", function () {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
      sinon.stub(view, 'getDecommissionStatus', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
      view.getDecommissionStatus.restore();
    });
    it("INSERVICE state)", function () {
      view.setDesiredAdminState('INSERVICE');
      expect(view.setStatusAs.calledWith('INSERVICE')).to.be.true;
    });
    it("DECOMMISSIONED state)", function () {
      view.setDesiredAdminState('DECOMMISSIONED');
      expect(view.getDecommissionStatus.calledOnce).to.be.true;
    });
  });

  describe("#setDecommissionStatus()", function() {
    beforeEach(function () {
      sinon.stub(view, 'setStatusAs', Em.K);
    });
    afterEach(function () {
      view.setStatusAs.restore();
    });
    it("data is null", function() {
      view.setDecommissionStatus(null);
      expect(view.setStatusAs.called).to.be.false;
    });
    it("AliveNodes is null", function() {
      view.setDecommissionStatus({"AliveNodes": null});
      expect(view.setStatusAs.called).to.be.false;
    });
    it("AliveNodes contain current host", function() {
      view.setDecommissionStatus({"AliveNodes": [
        {
          "hostname": "host1"
        }
      ]});
      expect(view.setStatusAs.calledWith("DECOMMISSIONING")).to.be.true;
    });
    it("AliveNodes does not contain current host", function() {
      view.setDecommissionStatus({"AliveNodes": []});
      expect(view.setStatusAs.calledWith('DECOMMISSIONED')).to.be.true;
    });
  });
});

});

;require.register("test/views/main/host/details_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/details');

var view,
  activeCases = [
    {
      passiveState: 'ON',
      isActive: false,
      label: 'Off'
    },
    {
      passiveState: 'OFF',
      isActive: true,
      label: 'On'
    }
  ];

describe('App.MainHostDetailsView', function () {

  beforeEach(function () {
    view = App.MainHostDetailsView.create({
       content: Em.Object.create({
          hostComponents: []
       })
    });
  });

  describe('#content', function () {
    it('should take content from controller', function () {
      view.set('content', {
        property: 'value'
      });
      expect(view.get('content.property')).to.equal('value');
    });
  });

  describe('#clients', function () {
    it('should take clients from content', function () {
      view.set('content', {
        hostComponents: [
          {
            isClient: true
          },
          {
            isClient: false
          }
        ]
      });
      expect(view.get('clients')).to.have.length(1);
      view.get('content.hostComponents').pushObject({
        isClient: true
      });
      expect(view.get('clients')).to.have.length(2);
    });
  });

  describe('#isActive', function () {
    activeCases.forEach(function (item) {
      it('should be ' + item.isActive, function () {
        view.set('controller', {
          content: {
            passiveState: item.passiveState
          }
        });
        expect(view.get('isActive')).to.equal(item.isActive);
      });
    });
  });

  describe('#maintenance', function () {
    activeCases.forEach(function (item) {
      it('passive state label should contain ' + item.label, function () {
        view.set('controller', {
          content: {
            passiveState: item.passiveState
          }
        });
        expect(view.get('maintenance').findProperty('action', 'onOffPassiveModeForHost').label).to.contain(item.label);
      });
    });
  });

  describe('#clientsWithConfigs', function() {
    beforeEach(function () {
      view.set('content', {
        hostComponents: [
          Em.Object.create({
            isClient: true,
            service: Em.Object.create({
              serviceName: 'WITH_CONFIGS'
            })
          }),
          Em.Object.create({
            isClient: true,
            service: Em.Object.create({
              serviceName: 'WITHOUT_CONFIGS'
            })
          }),
          Em.Object.create({
            isClient: false,
            service: Em.Object.create({
              serviceName: 'SAMPLE_SERVICE'
            })
          })
        ]
      });

      App.set('services', {
        noConfigTypes: ['WITHOUT_CONFIGS', 'WITHOUT_CONFIGS_2']
      });
    });

    afterEach(function () {
      App.set('services', Em.K);
    });

    it('should get only clients with configs', function() {
      expect(view.get('clientsWithConfigs')).to.have.length(1);
      console.log(view.get('content.hostComponents'));
      view.get('content.hostComponents').pushObject(Em.Object.create({
        isClient: true,
        service: Em.Object.create({
          serviceName: 'WITHOUT_CONFIGS_2'
        })
      }));
      expect(view.get('clientsWithConfigs')).to.have.length(1);
      view.get('content.hostComponents').pushObject(Em.Object.create({
        isClient: true,
        service: Em.Object.create({
          serviceName: 'WITH_CONFIGS_2'
        })
      }));
      expect(view.get('clientsWithConfigs')).to.have.length(2);
    });
  });

  describe('#didInsertElement()', function () {
    beforeEach(function () {
      sinon.stub(App.router, 'get', function () {
        return {
          updateHost: function (callback) {
            callback();
          }
        }
      });
      sinon.stub(App.router, 'transitionTo', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
    });
    afterEach(function () {
      App.router.transitionTo.restore();
      App.router.get.restore();
      App.tooltip.restore();
    });
    it('host loaded', function () {
      view.set('content.isLoaded', true);
      view.didInsertElement();
      expect(App.router.get.calledWith('updateController')).to.be.true;
      expect(App.tooltip.calledOnce).to.be.true;
      expect(App.router.transitionTo.calledWith('main.hosts.index')).to.be.false;
    });
    it('host is not loaded', function () {
      view.set('content.isLoaded', false);
      view.didInsertElement();
      expect(App.router.get.calledWith('updateController')).to.be.true;
      expect(App.tooltip.calledOnce).to.be.true;
      expect(App.router.transitionTo.calledWith('main.hosts.index')).to.be.true;
    });
  });
});

});

;require.register("test/views/main/host/host_alerts_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/host_alerts_view');

var view;

describe('App.MainHostAlertsView', function () {

  beforeEach(function () {
    view = App.MainHostAlertsView.create({
      controller: Em.Object.create()
    });
  });

  describe('#content', function () {
    var cases = [
      {
        m: 'return empty array',
        c: null,
        r: []
      },
      {
        m: 'return empty array',
        c: undefined,
        r: []
      },
      {
        m: 'sort CRITICAL and WARNING to be first',
        c: [
            Em.Object.create({
              state: 'OK'
            }),
            Em.Object.create({
              state: 'WARNING'
            }),
            Em.Object.create({
              state: 'CRITICAL'
            }),
            Em.Object.create({
              state: 'OK'
            })
        ],
        r: [
          Em.Object.create({
            state: 'CRITICAL'
          }),
          Em.Object.create({
            state: 'WARNING'
          }),
          Em.Object.create({
            state: 'OK'
          }),
          Em.Object.create({
            state: 'OK'
          })
        ]
      },
      {
        m: 'sort CRITICAL and WARNING to be first',
        c: [
          Em.Object.create({
            state: 'OTHER'
          }),
          Em.Object.create({
            state: 'WARNING'
          }),
          Em.Object.create({
            state: 'OK'
          }),
          Em.Object.create({
            state: 'CRITICAL'
          })
        ],
        r: [
          Em.Object.create({
            state: 'CRITICAL'
          }),
          Em.Object.create({
            state: 'WARNING'
          }),
          Em.Object.create({
            state: 'OTHER'
          }),
          Em.Object.create({
            state: 'OK'
          })
        ]
      }
    ];

    cases.forEach(function(test){
      it('should ' + test.m, function () {
        view.set('controller.content', test.c);
        expect(view.get('content')).eql(test.r);
      });
    });

  });

});

});

;require.register("test/views/main/host/menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var view;

describe('App.MainHostMenuView', function () {

  beforeEach(function () {
    view = App.MainHostMenuView.create({});
  });

  describe('#content', function () {

    afterEach(function () {
      App.get.restore();
    });

    Em.A([
        {
          stackVersionsAvailable: true,
          stackUpgrade: true,
          m: '`versions` is visible',
          e: false
        },
        {
          stackVersionsAvailable: true,
          stackUpgrade: false,
          m: '`versions` is invisible (1)',
          e: true
        },
        {
          stackVersionsAvailable: false,
          stackUpgrade: true,
          m: '`versions` is invisible (2)',
          e: true
        },
        {
          stackVersionsAvailable: false,
          stackUpgrade: false,
          m: '`versions` is invisible (3)',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          var stub = sinon.stub(App, 'get');
          stub.withArgs('stackVersionsAvailable').returns(test.stackVersionsAvailable);
          stub.withArgs('supports.stackUpgrade').returns(test.stackUpgrade);
          view.propertyDidChange('content');
          expect(view.get('content').findProperty('name', 'versions').get('hidden')).to.equal(test.e);
        });
      });

  });

});
});

;require.register("test/views/main/host/metrics/disk_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/host/metrics/disk');

describe('App.ChartHostMetricsDisk', function () {

  var view;

  beforeEach(function () {
    view = App.ChartHostMetricsDisk.create();
  });

  describe('#getData', function () {

    var cases = [
      {
        data: {},
        result: {},
        title: 'no metrics data'
      },
      {
        data: {
          metrics: null
        },
        result: {
          metrics: null
        },
        title: 'malformed metrics data'
      },
      {
        data: {
          metrics: {}
        },
        result: {
          metrics: {}
        },
        title: 'no metrics data'
      },
      {
        data: {
          metrics: {
            part_max_used: 0,
            disk: {}
          }
        },
        result: {
          metrics: {
            part_max_used: 0,
            disk: {
              part_max_used: 0
            }
          }
        },
        title: 'part_max_used = 0'
      },
      {
        data: {
          metrics: {
            part_max_used: 1,
            disk: {}
          }
        },
        result: {
          metrics: {
            part_max_used: 1,
            disk: {
              part_max_used: 1
            }
          }
        },
        title: 'part_max_used != 0'
      },
      {
        data: {
          metrics: {
            part_max_used: 1
          }
        },
        result: {
          metrics: {
            part_max_used: 1
          }
        },
        title: 'no metrics.disk data'
      },
      {
        data: {
          metrics: {
            part_max_used: 1,
            disk: null
          }
        },
        result: {
          metrics: {
            part_max_used: 1,
            disk: null
          }
        },
        title: 'malformed metrics.disk data'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        view.getData(item.data);
        expect(item.data).to.eql(item.result);
      });
    });

  });

});

});

;require.register("test/views/main/host/stack_versions_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');

describe('App.MainHostStackVersionsView', function() {
  var view = App.MainHostStackVersionsView.create({
    filteredCount: 0,
    totalCount: 0,
    host: {
      id: 1,
      stackVersions: []
    }
  });

  describe("#host", function () {
    before(function () {
      sinon.stub(App.router, 'get').returns(Em.Object.create({
        id: 1
      }));
      sinon.stub(view, 'filter').returns([Em.Object.create({
        id: 1
      })]);
    });
    after(function () {
      App.router.get.restore();
      view.filter.restore();
    });
    it("", function () {
      view.propertyDidChange('host');
      expect(view.get('host.id')).to.equal(1);
    });
  });

  describe("#content", function () {
    before(function () {
      sinon.stub(view, 'get').returns([Em.Object.create({
        id: 1
      })]);
      sinon.stub(view, 'filter').returns([Em.Object.create({
        id: 1
      })]);
    });
    after(function () {
      view.get.restore();
      view.filter.restore();
    });
    it("", function () {
      view.propertyDidChange('content');
      expect(view.get('content')).to.eql([Em.Object.create({
        id: 1
      })]);
    });
  });

  describe("#filteredContentInfo", function () {
    it("", function () {
      view.set('filteredCount', 1);
      view.set('totalCount', 2);
      view.propertyDidChange('filteredContentInfo');
      expect(view.get('filteredContentInfo')).to.eql(Em.I18n.t('hosts.host.stackVersions.table.filteredInfo').format(1, 2));
    });
  });
});

});

;require.register("test/views/main/host/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('models/host');
require('models/service');
require('models/host_component');
require('mappers/server_data_mapper');
require('views/main/host/summary');

var mainHostSummaryView;
var extendedMainHostSummaryView = App.MainHostSummaryView.extend({content: {}, addToolTip: function(){}, installedServices: []});
var modelSetup = require('test/init_model_test');

describe('App.MainHostSummaryView', function() {

  beforeEach(function() {
    modelSetup.setupStackServiceComponent();
    mainHostSummaryView = extendedMainHostSummaryView.create({});
  });

  afterEach(function(){
    modelSetup.cleanStackServiceComponent();
  });

  describe('#sortedComponents', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['A', 'C', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: ['A', 'C', 'D', 'B']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: ['B', 'A', 'C', 'D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: []
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        test.content.get('hostComponents').forEach(function(component) {
          component.set('id', component.get('componentName'));
        });
        mainHostSummaryView.set('sortedComponents', []);
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.sortedComponentsFormatter();
        expect(mainHostSummaryView.get('sortedComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe('#clients', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters, slaves and clients',
        e: ['D']
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters and slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: true, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of masters',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: true, componentName: 'D'})
          ])
        }),
        m: 'List of slaves',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: []
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'B'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'A'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C'}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D'})
          ])
        }),
        m: 'List of clients',
        e: ['B', 'A', 'C', 'D']
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('clients').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe('#areClientWithStaleConfigs', function() {

    var tests = Em.A([
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'Some clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: false}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: false})
          ])
        }),
        m: 'No clients with stale configs',
        e: false
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'D', staleConfigs: true}),
            Em.Object.create({isMaster: false, isSlave: false, componentName: 'C', staleConfigs: true})
          ])
        }),
        m: 'All clients with stale configs',
        e: true
      },
      {
        content: Em.Object.create({
          hostComponents: Em.A([])
        }),
        m: 'Empty list',
        e: false
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('areClientWithStaleConfigs')).to.equal(test.e);
      });
    });

  });

  describe('#isAddComponent', function() {

    var tests = Em.A([
      {content: {healthClass: 'health-status-DEAD-YELLOW', hostComponents: Em.A([])}, e: false},
      {content: {healthClass: 'OTHER_VALUE', hostComponents: Em.A([])}, e: true}
    ]);

    tests.forEach(function(test) {
      it(test.content.healthClass, function() {
        mainHostSummaryView.set('content', test.content);
        expect(mainHostSummaryView.get('isAddComponent')).to.equal(test.e);
      });
    });

  });

  describe('#addableComponents', function() {

    var tests = Em.A([
      {
        installableClientComponents: [{}, {}],
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            }),
            Em.Object.create({
              componentName: 'DATANODE'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['MAPREDUCE2_CLIENT', 'NODEMANAGER', 'YARN_CLIENT'],
        m: 'some components are already installed'
      },
      {
        installableClientComponents: [],
        content: Em.Object.create({
          hostComponents: Em.A([
            Em.Object.create({
              componentName: 'HDFS_CLIENT'
            }),
            Em.Object.create({
              componentName: 'YARN_CLIENT'
            }),
            Em.Object.create({
              componentName: 'MAPREDUCE2_CLIENT'
            }),
            Em.Object.create({
              componentName: 'NODEMANAGER'
            })
          ])
        }),
        services: ['HDFS', 'YARN', 'MAPREDUCE2'],
        e: ['DATANODE'],
        m: 'all clients and some other components are already installed'
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        mainHostSummaryView.reopen({installableClientComponents: test.installableClientComponents});
        mainHostSummaryView.set('content', test.content);
        mainHostSummaryView.set('installedServices', test.services);
        expect(mainHostSummaryView.get('addableComponents').mapProperty('componentName')).to.eql(test.e);
      });
    });

  });

  describe("#clientsWithCustomCommands", function() {
    before(function() {
      sinon.stub(App.StackServiceComponent, 'find', function(component) {
        var customCommands = [];

        if (component == 'WITH_CUSTOM_COMMANDS') {
          customCommands = ['CUSTOMCOMMAND'];
        }

        var obj = Em.Object.create({
          customCommands: customCommands,
          filterProperty: function () {
            return {
              mapProperty: Em.K
            };
          }
        });
        return obj;
      });
    });

    after(function() {
      App.StackServiceComponent.find.restore();
    });
    var content = Em.Object.create({
      hostComponents: Em.A([
        Em.Object.create({
          componentName: 'WITH_CUSTOM_COMMANDS',
          displayName: 'WITH_CUSTOM_COMMANDS',
          hostName: 'c6401',
          service: Em.Object.create({
            serviceName: 'TESTSRV'
          })
        }),
        Em.Object.create({
          componentName: 'WITHOUT_CUSTOM_COMMANDS',
          displayName: 'WITHOUT_CUSTOM_COMMANDS',
          hostName: 'c6401',
          service: Em.Object.create({
            serviceName: 'TESTSRV'
          })
        })
      ])
    });

    it("Clients with custom commands only", function() {
      mainHostSummaryView.set('content', content);
      expect(mainHostSummaryView.get('clientsWithCustomCommands').length).to.eql(1);
      expect(mainHostSummaryView.get('clientsWithCustomCommands')).to.have.deep.property('[0].commands[0].command', 'CUSTOMCOMMAND');
    });
  });

  describe('#areClientsNotInstalled', function () {

    var cases = [
      {
        clients: [
          {
            isInstallFailed: true
          }
        ],
        installableClientComponents: [],
        areClientsNotInstalled: true,
        title: 'some clients failed to install, no clients to add'
      },
      {
        clients: [
          {
            isInstallFailed: false
          }
        ],
        installableClientComponents: [{}],
        areClientsNotInstalled: true,
        title: 'no clients failed to install, some clients to add'
      },
      {
        clients: [
          {
            isInstallFailed: true
          }
        ],
        installableClientComponents: [{}],
        areClientsNotInstalled: true,
        title: 'some clients failed to install, some clients to add'
      },
      {
        clients: [
          {
            isInstallFailed: false
          }
        ],
        installableClientComponents: [],
        areClientsNotInstalled: false,
        title: 'no clients failed to install, no clients to add'
      }
    ];

    cases.forEach(function (item) {
      it(item.title, function () {
        mainHostSummaryView.reopen({
          clients: item.clients,
          installableClientComponents: item.installableClientComponents
        });
        expect(mainHostSummaryView.get('areClientsNotInstalled')).to.equal(item.areClientsNotInstalled);
      });
    });

  });

  describe('#notInstalledClientComponents', function () {

    it('should concat not added clients and the ones that failed to install', function () {
      mainHostSummaryView.reopen({
        clients: [
          Em.Object.create({
            componentName: 'c0',
            workStatus: 'INIT'
          }),
          Em.Object.create({
            componentName: 'c1',
            workStatus: 'INSTALL_FAILED'
          }),
          Em.Object.create({
            componentName: 'c2',
            workStatus: 'INSTALLED'
          })
        ],
        installableClientComponents: [
          Em.Object.create({
            componentName: 'c3'
          })
        ]
      });
      expect(mainHostSummaryView.get('notInstalledClientComponents')).to.eql([
        Em.Object.create({
          componentName: 'c0',
          workStatus: 'INIT'
        }),
        Em.Object.create({
          componentName: 'c1',
          workStatus: 'INSTALL_FAILED'
        }),
        Em.Object.create({
          componentName: 'c3'
        })
      ]);
    });

  });
});

});

;require.register("test/views/main/host_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/host');

describe('App.MainHostView', function () {

  var view;

  beforeEach(function () {
    view = App.MainHostView.create({
      controller: App.MainHostController.create()
    });
  });

  describe('#didInsertElement', function () {

    var cases = [
        {
          methodName: 'clearFiltersObs',
          propertyToChange: 'controller.clearFilters',
          callCount: 2
        },
        {
          methodName: 'toggleAllHosts',
          propertyToChange: 'selectAllHosts',
          callCount: 1
        },
        {
          methodName: 'updatePagination',
          propertyToChange: 'displayLength',
          callCount: 1
        },
        {
          methodName: 'updatePaging',
          propertyToChange: 'filteredCount',
          callCount: 2
        }
      ],
      title = '{0} changed';

    beforeEach(function () {
      cases.forEach(function (item) {
        sinon.stub(view, item.methodName, Em.K);
      });
    });

    afterEach(function () {
      cases.forEach(function (item) {
        view[item.methodName].restore();
      });
    });

    cases.forEach(function (item) {
      it(title.format(item.propertyToChange), function () {
        view.didInsertElement();
        view.propertyDidChange(item.propertyToChange);
        expect(view[item.methodName].callCount).to.equal(item.callCount);
      });
    });

  });

  describe('#HostView', function () {

    var hostView;

    beforeEach(function () {
      hostView = view.HostView.create({
        content: {
          hostName: null
        },
        controller: App.MainHostController.create()
      });
    });

    describe('#displayComponents', function () {

      var cases = [
        {
          hostComponents: [
            {
              displayName: 'c0'
            },
            {
              displayName: 'c1'
            }
          ],
          showHostsTableListPopupCallCount: 1,
          title: 'should display host components in modal popup'
        },
        {
          hostComponents: [],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup'
        }
      ];

      beforeEach(function () {
        sinon.stub(App, 'showHostsTableListPopup', Em.K);
      });

      afterEach(function () {
        App.showHostsTableListPopup.restore();
      });

      cases.forEach(function (item) {
        it(item.title, function () {
          hostView.set('content', {
            hostName: 'h',
            hostComponents: item.hostComponents
          });
          hostView.displayComponents();
          expect(App.showHostsTableListPopup.callCount).to.equal(item.showHostsTableListPopupCallCount);
          if (item.showHostsTableListPopupCallCount) {
            expect(App.showHostsTableListPopup.calledWith(Em.I18n.t('common.components'), 'h', ['c0', 'c1'])).to.be.true;
          }
        });
      });

    });

    describe('#displayVersions', function () {

      var cases = [
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'v0',
              status: 'CURRENT',
              isVisible: true
            }),
            Em.Object.create({
              displayName: 'v1',
              status: 'OUT_OF_SYNC',
              isVisible: true
            }),
            Em.Object.create({
              displayName: 'v2',
              status: 'INSTALL_FAILED',
              isVisible: false
            })
          ],
          showHostsTableListPopupCallCount: 1,
          title: 'should display stack versions in modal popup'
        },
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'v0',
              status: 'CURRENT',
              isVisible: true
            }),
            Em.Object.create({
              displayName: 'v2',
              status: 'INSTALL_FAILED',
              isVisible: false
            })
          ],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup if there\'s only one visible stack version'
        },
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'v2',
              status: 'INSTALL_FAILED',
              isVisible: false
            })
          ],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup if there are no visible stack versions available'
        },
        {
          stackVersions: [],
          showHostsTableListPopupCallCount: 0,
          title: 'should not display modal popup if there are no stack versions available'
        }
      ];

      beforeEach(function () {
        sinon.stub(App, 'showHostsTableListPopup', Em.K);
      });

      afterEach(function () {
        App.showHostsTableListPopup.restore();
      });

      cases.forEach(function (item) {
        it('should display stack versions in modal popup', function () {
          hostView.set('content', {
            hostName: 'h',
            stackVersions: item.stackVersions
          });
          hostView.displayVersions();
          expect(App.showHostsTableListPopup.callCount).to.equal(item.showHostsTableListPopupCallCount);
          if (item.showHostsTableListPopupCallCount) {
            expect(App.showHostsTableListPopup.calledWith(Em.I18n.t('common.versions'), 'h', [
              {
                name: 'v0',
                status: 'Current'
              },
              {
                name: 'v1',
                status: 'Out Of Sync'
              }
            ])).to.be.true;
          }
        });
      });

    });

    describe('#currentVersion', function () {

      var cases = [
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'HDP-2.2.0.0-2000'
            }),
            Em.Object.create({
              displayName: 'HDP-2.2.0.0-1000',
              isCurrent: true
            })
          ],
          currentVersion: 'HDP-2.2.0.0-1000',
          title: 'current version specified explicitly'
        },
        {
          stackVersions: [
            Em.Object.create({
              displayName: 'HDP-2.2.0.0-2000'
            }),
            Em.Object.create({
              displayName: 'HDP-2.3.0.0-1000'
            })
          ],
          currentVersion: 'HDP-2.2.0.0-2000',
          title: 'current version not specified explicitly'
        },
        {
          stackVersions: [Em.Object.create()],
          currentVersion: undefined,
          title: 'version display name isn\'t defined'
        },
        {
          stackVersions: [null],
          currentVersion: '',
          title: 'no version data available'
        },
        {
          stackVersions: [],
          currentVersion: '',
          title: 'no versions available'
        }
      ];

      cases.forEach(function (item) {
        it(item.title, function () {
          hostView.set('content.stackVersions', item.stackVersions);
          expect(hostView.get('currentVersion')).to.equal(item.currentVersion);
        });
      });

    });

  });

});

});

;require.register("test/views/main/menu_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/menu');

var mainMenuView = App.MainMenuView.create();
describe('App.MainMenuView', function () {

  describe('#itemViewClass', function () {

    beforeEach(function () {
      mainMenuView.reopen({
        content: [
          mainMenuView.get('itemViewClass').create({
            content: {
              routing: 'dashboard'
            }
          }),
          mainMenuView.get('itemViewClass').create({
            content: {
              routing: 'admin'
            }
          })
        ]
      });
    });

    describe('#dropdownCategories', function () {

      var cases = [
        {
          itemName: 'dashboard',
          dropdownCategories: [],
          title: 'not Admin item'
        },
        {
          itemName: 'admin',
          isHadoopWindowsStack: true,
          dropdownCategories: [
            {
              name: 'stackAndUpgrade',
              url: 'stack',
              label: Em.I18n.t('admin.stackUpgrade.title')
            },
            {
              name: 'adminServiceAccounts',
              url: 'serviceAccounts',
              label: Em.I18n.t('common.serviceAccounts')
            }
          ],
          title: 'Admin item, HDPWIN'
        },
        {
          itemName: 'admin',
          isHadoopWindowsStack: false,
          dropdownCategories: [
            {
              name: 'stackAndUpgrade',
              url: 'stack',
              label: Em.I18n.t('admin.stackUpgrade.title')
            },
            {
              name: 'adminServiceAccounts',
              url: 'serviceAccounts',
              label: Em.I18n.t('common.serviceAccounts')
            },
            {
              name: 'kerberos',
              url: 'kerberos/',
              label: Em.I18n.t('common.kerberos')
            }
          ],
          title: 'Admin item, not HDPWIN'
        }
      ];

      afterEach(function () {
        App.get.restore();
      });

      cases.forEach(function (item) {
        it(item.title, function () {
          sinon.stub(App, 'get').withArgs('isHadoopWindowsStack').returns(item.isHadoopWindowsStack);
          var menuItem = mainMenuView.get('content').findProperty('content.routing', item.itemName);
          menuItem.propertyDidChange('dropdownCategories');
          expect(menuItem.get('dropdownCategories')).to.eql(item.dropdownCategories);
        });
      });

    });

  });

});

});

;require.register("test/views/main/service/info/config_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/configs');

describe('App.MainServiceInfoConfigsView', function() {

  var view = App.MainServiceInfoConfigsView.create({
    controller: Em.Object.create()
  });

  describe('#updateComponentInformation', function() {

    var testCases = [
      {
        title: 'if components absent then counters should be 0',
        content: {
          restartRequiredHostsAndComponents: {}
        },
        result: {
          componentsCount: 0,
          hostsCount: 0
        }
      },
      {
        title: 'if host doesn\'t have components then hostsCount should be 1 and componentsCount should be 0',
        content: {
          restartRequiredHostsAndComponents: {
            host1: []
          }
        },
        result: {
          componentsCount: 0,
          hostsCount: 1
        }
      },
      {
        title: 'if host has 1 component then hostsCount should be 1 and componentsCount should be 1',
        content: {
          restartRequiredHostsAndComponents: {
            host1: [{}]
          }
        },
        result: {
          componentsCount: 1,
          hostsCount: 1
        }
      }
    ];
    testCases.forEach(function(test) {
      it(test.title, function() {
        view.set('controller.content', test.content);
        view.updateComponentInformation();
        expect(view.get('componentsCount')).to.equal(test.result.componentsCount);
        expect(view.get('hostsCount')).to.equal(test.result.hostsCount);
      });
    });
  });

});

});

;require.register("test/views/main/service/info/metrics/ambari_metrics/regionserver_base_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/metrics/ambari_metrics/regionserver_base');

describe('App.ChartServiceMetricsAMS_RegionServerBaseView', function () {

  var regionServerView = App.ChartServiceMetricsAMS_RegionServerBaseView.extend({
    id: "service-metrics-ambari-metrics-region-server-test",
    title: 'test-title',
    ajaxIndex: 'service.metrics.ambari_metrics.region_server.regions',
    displayName: 'test-display-name',
    regionServerName: 'test'
  }).create();

  it('#transformData should transform data for regionserver requests', function () {
    var jsonData = {
      "metrics": {
        "hbase": {
          "regionserver": {
            "test": [[11.0, 1424948261], [11.0, 1424948306], [11.0, 1424948321]]
          }
        }
      }
    };
    var result = regionServerView.transformToSeries(jsonData);
    expect(result[0].name === regionServerView.displayName).to.be.true;
    expect(result[0].data.length === jsonData.metrics.hbase.regionserver['test'].length).to.be.true;
    expect(result[0].data[0]).to.have.property('y').to.equal(11);
    expect(result[0].data[0]).to.have.property('x').to.equal(1424948261);
  });
});
});

;require.register("test/views/main/service/info/metrics/flume/flume_agent_metrics_section_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/service/info/metrics/flume/flume_agent_metrics_section');

describe('App.FlumeAgentMetricsSectionView', function () {

  var view;

  beforeEach(function () {
    view = App.FlumeAgentMetricsSectionView.create();
  });

  describe('#id', function () {
    it('should be set depending on index', function () {
      view.set('index', 1);
      expect(view.get('id')).to.equal('metric1');
    });
  });

  describe('#toggleIndex', function () {
    it('should be set depending on id', function () {
      view.reopen({
        id: 'metric1'
      });
      expect(view.get('toggleIndex')).to.equal('#metric1');
    });
  });

  describe('#header', function () {
    it('should be set depending on metric type and host name', function () {
      view.setProperties({
        metricTypeKey: 'sinkName',
        metricViewData: {
          agent: {
            hostName: 'h0'
          }
        }
      });
      expect(view.get('header')).to.equal(Em.I18n.t('services.service.info.metrics.flume.sinkName').
        format(Em.I18n.t('common.metrics')) + ' - h0');
    });
  });

});

});

;require.register("test/views/main/service/info/summary_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/main/service/info/summary');
var batchUtils = require('utils/batch_scheduled_requests');

describe('App.MainServiceInfoSummaryView', function() {

  var view = App.MainServiceInfoSummaryView.create({
    monitorsLiveTextView: Em.View.create(),
    controller: Em.Object.create({
      content: Em.Object.create({
        id: 'HDFS',
        serviceName: 'HDFS',
        hostComponents: []
      }),
      getActiveWidgetLayout: Em.K
    }),
    alertsController: Em.Object.create(),
    service: Em.Object.create()
  });

  describe('#servers', function () {
    it('services shouldn\'t have servers except FLUME and ZOOKEEPER', function () {
      expect(view.get('servers')).to.be.empty;
    });

    it('if one server exists then first server should have isComma and isAnd property false', function () {
      view.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(view.get('servers').objectAt(0).isComma).to.equal(false);
      expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
    });

    it('if more than one servers exist then first server should have isComma - true and isAnd - false', function () {
      view.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(view.get('servers').objectAt(0).isComma).to.equal(true);
      expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
      expect(view.get('servers').objectAt(1).isComma).to.equal(false);
      expect(view.get('servers').objectAt(1).isAnd).to.equal(false);
    });

    it('if more than two servers exist then second server should have isComma - false and isAnd - true', function () {
      view.set('controller.content', Em.Object.create({
        id: 'ZOOKEEPER',
        serviceName: 'ZOOKEEPER',
        hostComponents: [
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          }),
          Em.Object.create({
            displayName: '',
            isMaster: true
          })
        ]
      }));
      expect(view.get('servers').objectAt(0).isComma).to.equal(true);
      expect(view.get('servers').objectAt(0).isAnd).to.equal(false);
      expect(view.get('servers').objectAt(1).isComma).to.equal(false);
      expect(view.get('servers').objectAt(1).isAnd).to.equal(true);
      expect(view.get('servers').objectAt(2).isComma).to.equal(false);
      expect(view.get('servers').objectAt(2).isAnd).to.equal(false);
    });

  });

  describe('#hasAlertDefinitions', function () {

    beforeEach(function () {
      sinon.stub(App.AlertDefinition, 'find', function () {
        return [
          {
            serviceName: 'HDFS'
          },
          {
            serviceName: 'YARN'
          }
        ];
      });
    });

    afterEach(function () {
      App.AlertDefinition.find.restore();
    });

    it('should return true if at least one alert definition for this service exists', function () {
      view.set('controller.content', Em.Object.create({
        serviceName: 'HDFS'
      }));
      expect(view.get('hasAlertDefinitions')).to.be.true;

      it('should return false if there is no alert definition for this service', function () {
        view.set('controller.content', Em.Object.create({
          serviceName: 'ZOOKEEPER'
        }));
        expect(view.get('hasAlertDefinitions')).to.be.false;
      });
    })
  });

  describe('#didInsertElement', function () {

    var cases = [
      {
        serviceName: 'STORM',
        isStormMetricsSupported: false,
        isConstructGraphObjectsCalled: false,
        title: 'Storm, metrics not supported'
      },
      {
        serviceName: 'STORM',
        isStormMetricsSupported: true,
        isConstructGraphObjectsCalled: true,
        title: 'Storm, metrics supported'
      },
      {
        serviceName: 'HDFS',
        isConstructGraphObjectsCalled: true,
        title: 'not Storm'
      }
    ];

    beforeEach(function () {
      sinon.stub(view, 'constructGraphObjects', Em.K);
      this.mock = sinon.stub(App, 'get');
    });

    afterEach(function () {
      view.constructGraphObjects.restore();
      this.mock.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.set('controller.content.serviceName', item.serviceName);
        this.mock.withArgs('isStormMetricsSupported').returns(item.isStormMetricsSupported);
        view.didInsertElement();
        expect(view.constructGraphObjects.calledOnce).to.equal(item.isConstructGraphObjectsCalled);
      });
    });

  });

  describe.skip('#setTimeRange', function () {

    var cases = [
      {
        currentTimeRangeIndex: 0,
        isServiceMetricLoaded: false,
        graphIds: [],
        title: 'no event passed'
      },
      {
        event: {},
        currentTimeRangeIndex: 0,
        isServiceMetricLoaded: false,
        graphIds: [],
        title: 'no event context passed'
      },
      {
        event: {
          context: {
            index: 1
          }
        },
        currentTimeRangeIndex: 1,
        isServiceMetricLoaded: false,
        graphIds: [],
        title: 'no service name set'
      },
      {
        event: {
          context: {
            index: 2
          }
        },
        serviceName: 'HDFS',
        currentTimeRangeIndex: 2,
        isServiceMetricLoaded: true,
        graphIds: [
          [
            'service-metrics-hdfs-space-utilization', 'service-metrics-hdfs-file-operations',
            'service-metrics-hdfs-block-status', 'service-metrics-hdfs-io', 'service-metrics-hdfs-rpc'
          ],
          [
            'service-metrics-hdfs-gc', 'service-metrics-hdfs-jvm-heap', 'service-metrics-hdfs-jvm-threads'
          ]
        ]
      },
      {
        event: {
          context: {
            index: 3
          }
        },
        serviceName: 'YARN',
        currentTimeRangeIndex: 3,
        isServiceMetricLoaded: true,
        graphIds: [
          [
            'service-metrics-yarn-queue-allocated', 'service-metrics-yarn-queue-memory-resource',
            'service-metrics-yarn-queue-allocated-container', 'service-metrics-yarn-node-manager-statuses',
            'service-metrics-yarn-apps-current-states'
          ],
          [
            'service-metrics-yarn-apps-finished-states', 'service-metrics-yarn-rpc', 'service-metrics-yarn-gc',
            'service-metrics-yarn-jvm-threads', 'service-metrics-yarn-jvm-heap'
          ]
        ]
      },
      {
        event: {
          context: {
            index: 4
          }
        },
        serviceName: 'HBASE',
        currentTimeRangeIndex: 4,
        isServiceMetricLoaded: true,
        graphIds: [
          [
            'service-metrics-hbase-cluster-requests', 'service-metrics-hbase-regionserver-rw-requests',
            'service-metrics-hbase-regionserver-regions', 'service-metrics-hbase-regionserver-queuesize',
            'service-metrics-hbase-hlog-split-time'
          ],
          [
            'service-metrics-hbase-hlog-split-size'
          ]
        ]
      },
      {
        event: {
          context: {
            index: 5
          }
        },
        serviceName: 'AMBARI_METRICS',
        currentTimeRangeIndex: 5,
        isServiceMetricLoaded: true,
        graphIds: [
          [
            'service-metrics-ambari-metrics-master-average-load',
            'service-metrics-ambari-metrics-region-server-store-files',
            'service-metrics-ambari-metrics-region-server-regions',
            'service-metrics-ambari-metrics-region-server-requests',
            'service-metrics-ambari-metrics-region-server-block-cache-hit-percent'
          ],
          [
            'service-metrics-ambari-metrics-region-server-compaction-queue-size'
          ]
        ]
      },
      {
        event: {
          context: {
            index: 6
          }
        },
        serviceName: 'FLUME',
        currentTimeRangeIndex: 6,
        isServiceMetricLoaded: true,
        graphIds: [
          [
            'service-metrics-flume-channel-size-mma', 'service-metrics-flume-channel-size-sum',
            'service-metrics-flume-incoming_mma', 'service-metrics-flume-incoming_sum',
            'service-metrics-flume-outgoing_mma'
          ],
          [
            'service-metrics-flume-outgoing_sum'
          ]
        ]
      },
      {
        event: {
          context: {
            index: 7
          }
        },
        serviceName: 'STORM',
        currentTimeRangeIndex: 7,
        isServiceMetricLoaded: true,
        graphIds: [
          [
            'service-metrics-storm-supervisor-allocated', 'service-metrics-storm-executors',
            'service-metrics-storm-topologies', 'service-metrics-storm-tasks'
          ]
        ]
      },
      {
        event: {
          context: {
            index: 8
          }
        },
        serviceName: 'KAFKA',
        chunkSize: 4,
        currentTimeRangeIndex: 8,
        isServiceMetricLoaded: true,
        graphIds: [
          [
            'service-metrics-kafka-broker-topic-metrics', 'service-metrics-kafka-controller-metrics',
            'service-metrics-kafka-controler-status-metrics', 'service-metrics-kafka-replica-manager-metrics'
          ],
          [
            'service-metrics-kafka-log-metrics', 'service-metrics-kafka-replica-fetcher-metrics'
          ]
        ]
      }
    ];

    beforeEach(function () {
      sinon.stub(view, 'postUserPref', Em.K);
      view.setProperties({
        chunkSize: 5,
        currentTimeRangeIndex: 0,
        isServiceMetricLoaded: false,
        serviceMetricGraphs: []
      });
    });

    afterEach(function () {
      view.postUserPref.restore();
    });

    cases.forEach(function (item) {
      it(item.serviceName || item.title, function () {
        view.set('chunkSize', Em.isNone(item.chunkSize) ? 5 : item.chunkSize);
        view.set('service.serviceName', item.serviceName);
        view.setTimeRange(item.event);
        var graphIndices = [],
          graphIds = view.get('serviceMetricGraphs').map(function (graphs) {
          return graphs.map(function (graph) {
            var graphView = graph.create();
            graphIndices.push(graphView.get('currentTimeIndex'));
            return graphView.get('id');
          });
        });
        expect(view.get('currentTimeRangeIndex')).to.equal(item.currentTimeRangeIndex);
        expect(view.get('isServiceMetricLoaded')).to.equal(item.isServiceMetricLoaded);
        if (item.event && item.event.context && item.serviceName) {
          expect(graphIndices.uniq()).to.eql([item.currentTimeRangeIndex]);
        }
        expect(graphIds).to.eql(item.graphIds);
      });
    });

  });

  describe("#restartAllStaleConfigComponents", function () {
    it("trigger restartAllServiceHostComponents", function () {
      var view = App.MainServiceInfoSummaryView.create({
        controller: Em.Object.create({
          content: {
            serviceName: "HDFS"
          },
          getActiveWidgetLayout: Em.K
        }),
        service: Em.Object.create({
          displayName: 'HDFS'
        })
      });
      sinon.stub(batchUtils, "restartAllServiceHostComponents", Em.K);
      view.restartAllStaleConfigComponents().onPrimary();
      expect(batchUtils.restartAllServiceHostComponents.calledOnce).to.equal(true);
      batchUtils.restartAllServiceHostComponents.restore();
    });
    it("trigger check last check point warning before triggering restartAllServiceHostComponents", function () {
      var view = App.MainServiceInfoSummaryView.create({
        controller: Em.Object.create({
          content: {
            serviceName: "HDFS",
            hostComponents: [{
              componentName: 'NAMENODE',
              workStatus: 'STARTED'
            }],
            restartRequiredHostsAndComponents: {
              "host1": ['NameNode'],
              "host2": ['DataNode', 'ZooKeeper']
            }
          },
          getActiveWidgetLayout: Em.K
        }),
        service: Em.Object.create({
          displayName: 'HDFS'
        })
      });
      var mainServiceItemController = App.MainServiceItemController.create({});
      sinon.stub(mainServiceItemController, 'checkNnLastCheckpointTime', function() {
        return true;
      });
      sinon.stub(App.router, 'get', function(k) {
        if ('mainServiceItemController' === k) {
          return mainServiceItemController;
        }
        return Em.get(App.router, k);
      });
      view.restartAllStaleConfigComponents();
      expect(mainServiceItemController.checkNnLastCheckpointTime.calledOnce).to.equal(true);
      mainServiceItemController.checkNnLastCheckpointTime.restore();
      App.router.get.restore();
    });
  });
});
});

;require.register("test/views/main/service/item_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/main/service/item');

var view;

describe('App.MainServiceItemView', function () {

  describe('#mastersExcludedCommands', function () {

    view = App.MainServiceItemView.create({
      controller: Em.Object.create({
        content: Em.Object.create({
          hostComponents: []
        })
      })
    });

    var nonCustomAction = ['RESTART_ALL', 'RUN_SMOKE_TEST', 'REFRESH_CONFIGS', 'ROLLING_RESTART', 'TOGGLE_PASSIVE', 'TOGGLE_NN_HA', 'TOGGLE_RM_HA', 'MOVE_COMPONENT', 'DOWNLOAD_CLIENT_CONFIGS', 'MASTER_CUSTOM_COMMAND'];
    var keys = Object.keys(view.mastersExcludedCommands);
    var mastersExcludedCommands = [];
    for (var i = 0; i < keys.length; i++) {
      mastersExcludedCommands[i] = view.mastersExcludedCommands[keys[i]];
    }
    var allMastersExcludedCommands = mastersExcludedCommands.reduce(function (previous, current) {
      return previous.concat(current);
    });
    var actionMap = App.HostComponentActionMap.getMap(view);

    var customActionsArray = [];
    for (var iter in actionMap) {
      customActionsArray.push(actionMap[iter]);
    }
    var customActions = customActionsArray.mapProperty('customCommand').filter(function (action) {
      return !nonCustomAction.contains(action);
    }).uniq();

    // remove null and undefined from the list
    customActions = customActions.filter(function (value) {
      return value != null;
    });

    customActions.forEach(function (action) {
      it(action + ' should be present in App.MainServiceItemView mastersExcludedCommands object', function () {
        expect(allMastersExcludedCommands).to.contain(action);
      });
    });
  });

  describe('#observeMaintenance', function () {

    var cases = [
      {
        isMaintenanceSet: true,
        isServicesInfoLoaded: true,
        observeMaintenanceOnceCallCount: 0,
        title: 'actions array set, services info loaded'
      },
      {
        isMaintenanceSet: true,
        isServicesInfoLoaded: false,
        observeMaintenanceOnceCallCount: 0,
        title: 'actions array set, services info not loaded'
      },
      {
        isMaintenanceSet: false,
        isServicesInfoLoaded: true,
        observeMaintenanceOnceCallCount: 1,
        title: 'actions array not set, services info loaded'
      },
      {
        isMaintenanceSet: false,
        isServicesInfoLoaded: false,
        observeMaintenanceOnceCallCount: 0,
        title: 'actions array not set, services info not loaded'
      }
    ];

    beforeEach(function () {
      sinon.stub(view, 'observeMaintenanceOnce', Em.K);
    });

    afterEach(function () {
      view.observeMaintenanceOnce.restore();
    });

    cases.forEach(function (item) {
      it(item.title, function () {
        view.setProperties({
          'isMaintenanceSet': item.isMaintenanceSet,
          'controller.isServicesInfoLoaded': item.isServicesInfoLoaded
        });
        view.observeMaintenance();
        expect(view.observeMaintenanceOnce.callCount).to.equal(item.observeMaintenanceOnceCallCount);
      });
    });

  });

  describe('#observeMaintenanceOnce', function () {

    var mastersExcludedCommands = {
        NAMENODE: ["DECOMMISSION", "REBALANCEHDFS"],
        RESOURCEMANAGER: ["DECOMMISSION", "REFRESHQUEUES"],
        HBASE_MASTER: ["DECOMMISSION"],
        KNOX_GATEWAY: ["STARTDEMOLDAP", "STOPDEMOLDAP"]
      },
      hasConfigTab = true,
      testCases = [
        {
          serviceName: "HDFS",
          displayName: "HDFS",
          isSingleNode: true,
          serviceTypes: ["HA_MODE"],
          slaveComponents: [
            Em.Object.create({
              componentName: 'DATANODE',
              totalCount: 1
            })
          ],
          clientComponents: [
            Em.Object.create({
              componentName: 'HDFS_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'NAMENODE',
              isMaster: true,
              isSlave: false
            }),
            Em.Object.create({
              componentName: 'SECONDARY_NAMENODE',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "HDFS", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart DataNodes", "cssClass": "icon-time", "disabled": false, "context": "DATANODE"},
            {"action": "reassignMaster", "context": "NAMENODE", "label": "Move NameNode", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "reassignMaster", "context": "SECONDARY_NAMENODE", "label": "Move SNameNode", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "enableHighAvailability", "label": "Enable NameNode HA", "cssClass": "icon-arrow-up", "isHidden": false, "disabled": true},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for HDFS", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "rebalanceHdfsNodes", "customCommand": "REBALANCEHDFS", "context": "Rebalance HDFS", "label": "Rebalance HDFS", "cssClass": "icon-refresh", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, hasSubmenu: false, submenuOptions: []}
          ]
        },
        {
          serviceName: "ZOOKEEPER",
          displayName: "ZooKeeper",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [
            Em.Object.create({
              componentName: 'ZOOKEEPER_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'ZOOKEEPER_SERVER',
              isMaster: true,
              isSlave: false
            })
          ],
          controller: [
            {'addDisabledTooltipZOOKEEPER_SERVER': ''},
            {'isAddDisabled-ZOOKEEPER_SERVER': 'disabled'}
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "ZOOKEEPER", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for ZooKeeper", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"cssClass": "icon-plus", "label": "Add ZooKeeper Server", "service": "ZOOKEEPER", "component": "ZOOKEEPER_SERVER", "action": "addZOOKEEPER_SERVER", "disabled": "disabled", tooltip: ''},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "YARN",
          displayName: "YARN",
          serviceTypes: ['HA_MODE'],
          slaveComponents: [
            Em.Object.create({
              componentName: 'NODEMANAGER',
              totalCount: 1
            })
          ],
          clientComponents: [
            Em.Object.create({
              componentName: 'YARN_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'APP_TIMELINE_SERVER',
              isMaster: true,
              isSlave: false
            }),
            Em.Object.create({
              componentName: 'RESOURCEMANAGER',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "refreshYarnQueues", "customCommand": "REFRESHQUEUES", "context": "Refresh YARN Capacity Scheduler", "label": "Refresh YARN Capacity Scheduler", "cssClass": "icon-refresh", "disabled": false},
            {"action": "restartAllHostComponents", "context": "YARN", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart NodeManagers", "cssClass": "icon-time", "disabled": false, "context": "NODEMANAGER"},
            {"action": "reassignMaster", "context": "APP_TIMELINE_SERVER", "label": "Move App Timeline Server", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "reassignMaster", "context": "RESOURCEMANAGER", "label": "Move ResourceManager", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "enableRMHighAvailability", "label": "Enable ResourceManager HA", "cssClass": "icon-arrow-up", "isHidden": false, disabled: false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for YARN", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "MAPREDUCE2",
          displayName: "MapReduce2",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [
            Em.Object.create({
              componentName: 'MAPREDUCE2_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'HISTORYSERVER',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "MAPREDUCE2", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for MapReduce2", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "KAFKA",
          displayName: "Kafka",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [],
          hostComponents: [
            Em.Object.create({
              componentName: 'KAFKA_BROKER',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "KAFKA", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Kafka", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "FLUME",
          displayName: "Flume",
          serviceTypes: [],
          clientComponents: [],
          slaveComponents: [
            Em.Object.create({
              componentName: 'FLUME_HANDLER',
              totalCount: 1
            })
          ],
          hostComponents: [
          ],
          controller: [
            {'addDisabledTooltipFLUME_HANDLER': ''},
            {'isAddDisabled-FLUME_HANDLER': ''}
          ],
          result: [
            {"action": "refreshConfigs", "label": "Refresh configs", "cssClass": "icon-refresh", "disabled": false},
            {"action": "restartAllHostComponents", "context": "FLUME", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart Flumes", "cssClass": "icon-time", "disabled": false, "context": "FLUME_HANDLER"},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Flume", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"cssClass": "icon-plus", "label": "Add Flume Component", "service": "FLUME", "component": "FLUME_HANDLER", "action": "addFLUME_HANDLER", "disabled": '', tooltip: ''},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "HBASE",
          displayName: "HBase",
          serviceTypes: [],
          slaveComponents: [
            Em.Object.create({
              componentName: 'HBASE_REGIONSERVER',
              totalCount: 1
            })
          ],
          clientComponents: [
            Em.Object.create({
              componentName: 'HBASE_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'HBASE_MASTER',
              isMaster: true,
              isSlave: false
            })
          ],
          controller: [
            {'addDisabledTooltipHBASE_MASTER': ''},
            {'isAddDisabled-HBASE_MASTER': ''}
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "HBASE", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "rollingRestart", "label": "Restart RegionServers", "cssClass": "icon-time", "disabled": false, "context": "HBASE_REGIONSERVER"},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for HBase", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"cssClass": "icon-plus", "label": "Add HBase Master", "service": "HBASE", "component": "HBASE_MASTER", "action": "addHBASE_MASTER", "disabled": '', tooltip: ''},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "OOZIE",
          displayName: "Oozie",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [
            Em.Object.create({
              componentName: 'OOZIE_CLIENT',
              totalCount: 1
            })
          ],
          hostComponents: [
            Em.Object.create({
              componentName: 'OOZIE_SERVER',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "OOZIE", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "reassignMaster", "context": "OOZIE_SERVER", "label": "Move Oozie Server", "cssClass": "icon-share-alt", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Oozie", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": false, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "KNOX",
          displayName: "Knox",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [],
          hostComponents: [
            Em.Object.create({
              componentName: 'KNOX_GATEWAY',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "KNOX", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Knox", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "startLdapKnox", "customCommand": "STARTDEMOLDAP", "context": "Start Demo LDAP",  "label": "Start Demo LDAP", "cssClass": "icon-play-sign", "disabled": false},
            {"action": "stopLdapKnox", "customCommand": "STOPDEMOLDAP", "context": "Stop Demo LDAP", "label": "Stop Demo LDAP", "cssClass": "icon-stop", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        },
        {
          serviceName: "STORM",
          displayName: "Storm",
          serviceTypes: [],
          slaveComponents: [],
          clientComponents: [],
          hostComponents: [
            Em.Object.create({
              componentName: 'NIMBUS',
              isMaster: true,
              isSlave: false
            })
          ],
          result: [
            {"action": "restartAllHostComponents", "context": "STORM", "label": "Restart All", "cssClass": "icon-repeat", "disabled": false},
            {"action": "runSmokeTest", "label": "Run Service Check", "cssClass": "icon-thumbs-up-alt", "disabled": false},
            {"action": "turnOnOffPassive", "context": "Turn On Maintenance Mode for Storm", "label": "Turn On Maintenance Mode", "cssClass": "icon-medkit", "disabled": false},
            {"action": "downloadClientConfigs", "label": "Download Client Configs", "cssClass": "icon-download-alt", "isHidden": true, "disabled": false, "hasSubmenu": false, "submenuOptions": []}
          ]
        }
      ];

    beforeEach(function () {

      view = App.MainServiceItemView.create({});

      sinon.stub(App, 'get', function (k) {
        switch (k) {
          case 'isSingleNode':
            return (view.get('controller.content.serviceName') == 'HDFS');
          case 'supports.autoRollbackHA':
          case 'isRMHaEnabled':
          case 'isHaEnabled':
            return false;
          case 'components.rollinRestartAllowed':
            return ["DATANODE", "JOURNALNODE", "ZKFC", "NODEMANAGER", "GANGLIA_MONITOR", "HBASE_REGIONSERVER", "SUPERVISOR", "FLUME_HANDLER"];
          case 'components.reassignable':
            return ["NAMENODE", "SECONDARY_NAMENODE", "APP_TIMELINE_SERVER", "RESOURCEMANAGER", "WEBHCAT_SERVER", "OOZIE_SERVER"];
          case 'services.supportsServiceCheck':
            return ["HDFS", "MAPREDUCE2", "YARN", "HIVE", "HBASE", "PIG", "SQOOP", "OOZIE", "ZOOKEEPER", "FALCON", "STORM", "FLUME", "SLIDER", "KNOX", "KAFKA"];
          case 'components.addableToHost':
            return ["DATANODE", "HDFS_CLIENT", "MAPREDUCE2_CLIENT", "NODEMANAGER", "YARN_CLIENT", "TEZ_CLIENT", "GANGLIA_MONITOR", "HCAT", "HIVE_CLIENT", "HIVE_METASTORE", "HIVE_SERVER", "WEBHCAT_SERVER", "HBASE_CLIENT", "HBASE_MASTER", "HBASE_REGIONSERVER", "PIG", "SQOOP", "OOZIE_CLIENT", "OOZIE_SERVER", "ZOOKEEPER_CLIENT", "ZOOKEEPER_SERVER", "FALCON_CLIENT", "SUPERVISOR", "FLUME_HANDLER", "METRICS_MONITOR", "KAFKA_BROKER", "KERBEROS_CLIENT", "KNOX_GATEWAY", "SLIDER", "SPARK_CLIENT"];
          default:
            return Em.get(App, k);
        }
      });

      sinon.stub(App.HostComponent, 'find', function () {
        return [
          Em.Object.create({
            hostName: 'host1',
            componentName: 'NAMENODE'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'SECONDARY_NAMENODE'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'APP_TIMELINE_SERVER'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'RESOURCEMANAGER'
          }),
          Em.Object.create({
            hostName: 'host1',
            componentName: 'OOZIE_SERVER'
          })
        ];
      });

      sinon.stub(App.StackServiceComponent, 'find', function () {
        switch (arguments[0]) {
          case 'NAMENODE':
            return Em.Object.create({ customCommands: ["DECOMMISSION", "REBALANCEHDFS"] });
          case 'RESOURCEMANAGER':
            return Em.Object.create({ customCommands: ["DECOMMISSION", "REFRESHQUEUES"] });
          case 'HBASE_MASTER':
            return Em.Object.create({ customCommands: ["DECOMMISSION"] });
          case 'KNOX_GATEWAY':
            return Em.Object.create({ customCommands: ["STARTDEMOLDAP", "STOPDEMOLDAP"] });
          case 'HISTORYSERVER':
          case 'SECONDARY_NAMENODE':
          case 'ZOOKEEPER_SERVER':
          case 'APP_TIMELINE_SERVER':
          case 'KAFKA_BROKER':
          case 'OOZIE_SERVER':
          case 'NIMBUS':
            return Em.Object.create({ customCommands: [] });
          default:
            return [
              Em.Object.create({
                customCommands: ["DECOMMISSION", "REBALANCEHDFS"],
                componentName: 'NAMENODE'
              }),
              Em.Object.create({
                customCommands: ["STARTDEMOLDAP", "STOPDEMOLDAP"],
                componentName: 'KNOX_GATEWAY'
              })
            ];
        }
      });
    });

    afterEach(function () {
      App.get.restore();
      App.HostComponent.find.restore();
      App.StackServiceComponent.find.restore();
    });

    testCases.forEach(function (testCase) {

      it('Maintenance for ' + testCase.serviceName + ' service', function () {
        view.reopen({
          controller: Em.Object.create({
            content: Em.Object.create({
              hostComponents: testCase.hostComponents,
              slaveComponents: testCase.slaveComponents,
              clientComponents: testCase.clientComponents,
              serviceName: testCase.serviceName,
              displayName: testCase.displayName,
              serviceTypes: testCase.serviceTypes,
              passiveState: 'OFF'
            }),
            isSeveralClients: false,
            clientComponents: [],
            isStopDisabled: false
          }),
          mastersExcludedCommands: mastersExcludedCommands,
          hasConfigTab: hasConfigTab
        });
        if (testCase.controller) {
          testCase.controller.forEach(function (item) {
            Object.keys(item).forEach(function (key) {
              view.set('controller.' + key, item[key]);
            });
          });
        }
        view.observeMaintenanceOnce();
        expect(view.get('maintenance')).to.eql(testCase.result);
        var oldMaintenance = JSON.parse(JSON.stringify(view.get('maintenance')));
        view.set('controller.content.passiveState', 'ON');
        view.observeMaintenanceOnce();
        expect(view.get('maintenance')).to.not.eql(oldMaintenance);
        expect(view.get('isMaintenanceSet')).to.be.true;
      });

    });
  });

  describe('#clearIsMaintenanceSet', function () {
    it('isMaintenanceSet should be false', function () {
      view.set('isMaintenanceSet', true);
      view.clearIsMaintenanceSet();
      expect(view.get('isMaintenanceSet')).to.be.false;
    });
  });
});


});

;require.register("test/views/main/service/services/ranger_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('/views/main/service/services/ranger');

describe('App.MainDashboardServiceRangerView', function () {

  var view;

  beforeEach(function () {
    view = App.MainDashboardServiceRangerView.create({
      controller: App.MainServiceInfoSummaryController.create()
    });
  });

  describe('#didInsertElement', function () {

    beforeEach(function () {
      sinon.stub(App.updater, 'run', Em.K);
      sinon.stub(App.updater, 'immediateRun', Em.K);
    });

    afterEach(function () {
      App.updater.run.restore();
      App.updater.immediateRun.restore();
    });

    it('should run updater', function () {
      view.didInsertElement();
      expect(App.updater.run.calledOnce).to.be.true;
      expect(App.updater.immediateRun.calledOnce).to.be.true;
    });
  });

  describe('#willDestroyElement', function () {
    it('should not run updater if not on Ranger summary page', function () {
      view.willDestroyElement();
      expect(view.get('controller.isRangerUpdateWorking')).to.be.false;
    });
  });

});
});

;require.register("test/views/main/service/widgets/create/expression_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');


describe('App.WidgetWizardExpressionView', function () {
  var view = App.WidgetWizardExpressionView.create({
    expression: {
      data: []
    },
    controller: Em.Object.create({
      updateExpressions: Em.K
    })
  });

  describe("#validate()", function() {
    var testCases = [
      {
        data: [],
        result: false
      },
      {
        data: [
          {isMetric: true, name:'1'}
        ],
        result: false
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'}
        ],
        result: false
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '-'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: false
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '-'},
          {isMetric: true, name:'1'},
          {name: ')'},
          {name: '*'},
          {isMetric: true, name:'1'}
        ],
        result: false
      },
      {
        data: [
          {name: '('},
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '-'},
          {isMetric: true, name:'1'},
          {name: ')'},
          {name: '*'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: false
      },
      {
        data: [
          {name: '-'}
        ],
        result: true
      },
      {
        data: [
          {name: '-'},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '+'}
        ],
        result: true
      },
      {
        data: [
          {name: '*'},
          {isMetric: true, name:'1'},
          {name: '+'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '('}
        ],
        result: true
      },
      {
        data: [
          {name: ')'},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {name: '('}
        ],
        result: true
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '('}
        ],
        result: true
      },
      {
        data: [
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'}
        ],
        result: true
      },
      {
        data: [
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: true
      },
      {
        data: [
          {name: '('},
          {name: '('},
          {isMetric: true, name:'1'},
          {name: '+'},
          {isMetric: true, name:'1'},
          {name: ')'}
        ],
        result: true
      }
    ];
    testCases.forEach(function (test) {
      it(test.data.mapProperty('name').join("") + " - isInvalid = " + test.result, function () {
        view.set('expression.data', test.data);
        expect(view.get('isInvalid')).to.equal(test.result);
      });
    }, this);
  });
});

});

;require.register("test/views/wizard/step0_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step0_view');

var view, controller = Em.Object.create({
  clusterNameError: '',
  loadStep: Em.K
});

describe('App.WizardStep0View', function () {

  beforeEach(function () {
    view = App.WizardStep0View.create({'controller': controller});
  });

  describe('#onError', function () {
    it('should be true if clusterNameError appears', function () {
      controller.set('clusterNameError', 'ERROR');
      expect(view.get('onError')).to.equal(true);
    });
    it('should be false if clusterNameError doesn\'t appears', function () {
      controller.set('clusterNameError', '');
      expect(view.get('onError')).to.equal(false);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      sinon.spy(view.get('controller'), 'loadStep');
    });
    afterEach(function () {
      App.popover.restore();
      view.get('controller').loadStep.restore();
    });
    it('should call loadStep', function () {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
  });

});

describe('App.WizardStep0ViewClusterNameInput', function () {

  beforeEach(function() {
    view = App.WizardStep0ViewClusterNameInput.create({
      parentView: Em.Object.create({
        controller: Em.Object.create({
          submit: Em.K
        })
      })
    });
  });

  describe('#keyPress', function() {
    it('should return true if pressed not Enter', function() {
      expect(view.keyPress({keyCode: 1})).to.equal(true);
    });
    it('should submit form if Enter pressed', function() {
      sinon.spy(view.get('parentView.controller'), 'submit');
      expect(view.keyPress({keyCode: 13})).to.equal(false);
      expect(view.get('parentView.controller').submit.calledOnce).to.equal(true);
      view.get('parentView.controller').submit.restore();
    });
  });

});
});

;require.register("test/views/wizard/step10_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step10_view');
var view;
describe('App.WizardStep10View', function() {
  beforeEach(function() {
    view = App.WizardStep10View.create({
      controller: App.WizardStep10Controller.create()
    });
  });
  describe('didInsertElement', function() {
    it('should call loadStep', function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });
});

});

;require.register("test/views/wizard/step1_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step1_view');

var view;
var controller;

describe('App.WizardStep1View', function () {

  describe('#operatingSystems', function () {
    beforeEach(function () {
      sinon.stub(App.Stack, 'find', function () {
        return [
          Ember.Object.create({
            id: 'HDP-1.3',
            stackName: 'HDP',
            stackVersion: '1.3',
            active: true,
            operatingSystems: [
              Ember.Object.create({
                id: 'HDP-1.3-redhat5',
                osType: 'redhat5',
                isSelected: false,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat5-HDP-1.3',
                    isSelected: false
                  }),
                  Ember.Object.create({
                    id: 'redhat5-HDP-UTILS-1.1.0.19',
                    isSelected: false
                  })
                ]
              }),
              Ember.Object.create({
                id: 'HDP-1.3-redhat6',
                osType: 'redhat6',
                isSelected: false,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat6-HDP-1.3',
                    isSelected: false
                  }),
                  Ember.Object.create({
                    id: 'redhat6-HDP-UTILS-1.1.0.19',
                    isSelected: false
                  })
                ]
              })
            ],
            isSelected: false
          }),
          Ember.Object.create({
            id: 'HDP-2.1',
            stackName: 'HDP',
            stackVersion: '2.1',
            active: true,
            operatingSystems: [
              Ember.Object.create({
                id: 'HDP-2.1-redhat5',
                osType: 'redhat5',
                isSelected: true,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat5-HDP-2.1',
                    isSelected: true,
                    baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0",
                    latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0"
                  }),
                  Ember.Object.create({
                    id: 'redhat5-HDP-UTILS-1.1.0.19',
                    isSelected: true,
                    baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5",
                    latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5"
                  })
                ]
              }),
              Ember.Object.create({
                id: 'HDP-2.1-redhat6',
                osType: 'redhat6',
                isSelected: true,
                repositories: [
                  Ember.Object.create({
                    id: 'redhat6-HDP-2.1',
                    isSelected: true,
                    baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0",
                    latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0"
                  }),
                  Ember.Object.create({
                    id: 'redhat6-HDP-UTILS-1.1.0.19',
                    isSelected: true,
                    baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6",
                    latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6"
                  })
                ]
              })
            ],
            repositories: [
              Ember.Object.create({
                id: 'redhat5-HDP-2.1',
                isSelected: true,
                baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0",
                latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos5/2.x/updates/2.1.5.0"
              }),
              Ember.Object.create({
                id: 'redhat5-HDP-UTILS-1.1.0.19',
                isSelected: true,
                baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5",
                latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos5"
              }),
              Ember.Object.create({
                id: 'redhat6-HDP-2.1',
                isSelected: true,
                baseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0",
                latestBaseUrl: "http://public-repo-1.hortonworks.com/HDP/centos6/2.x/updates/2.1.5.0"
              }),
              Ember.Object.create({
                id: 'redhat6-HDP-UTILS-1.1.0.19',
                isSelected: true,
                baseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6",
                latestBaseUrl: "http://s3.amazonaws.com/dev.hortonworks.com/HDP-UTILS-1.1.0.19/repos/centos6"
              })
            ],
            isSelected: true
          })
        ];
      });
    });

    afterEach(function () {
      App.Stack.find.restore();
    });

    it('should create empty array if there is no stacks', function () {
      controller = App.WizardStep1Controller.create({
        content: {
          stacks: []
        },
        selectedStack: []
      });
      view = App.WizardStep1View.create();
      view.reopen({
        controller: controller
      });
      expect(view.get('allRepositories.length')).to.equal(0);
      expect(view.get('operatingSystems.length')).to.equal(0);
    });

    it('should create repo groups from repo list', function () {
      controller = App.WizardStep1Controller.create({
        content: {
          stacks: App.Stack.find()
        }
      });
      view = App.WizardStep1View.create({'controller': controller});
      view.set('$', function () {
        return Em.Object.create({hide: Em.K, toggle: Em.K});
      });
      var repositories = view.get('allRepositories');
      expect(view.get('operatingSystems.length')).to.equal(2);
      expect(view.get('operatingSystems')[0].get('osType')).to.equal('redhat5');
      expect(view.get('operatingSystems')[1].get('osType')).to.equal('redhat6');
      expect(view.get('operatingSystems')[0].get('isSelected')).to.be.true;
      expect(view.get('operatingSystems')[1].get('isSelected')).to.be.true;
      expect(view.get('operatingSystems')[0].get('repositories')).to.eql([repositories[0], repositories[1]]);
      expect(view.get('operatingSystems')[1].get('repositories')).to.eql([repositories[2], repositories[3]]);
    });
  });

  describe('#invalidFormatUrlExist', function () {

    controller = App.WizardStep1Controller.create({
      content: {
        stacks: App.Stack.find()
      }
    });
    view = App.WizardStep1View.create();
    view.reopen({
      controller: controller
    });
    view.set('$', function () {
      return Em.Object.create({hide: Em.K, toggle: Em.K});
    });

    it(view.get('allRepositories').mapProperty('invalidFormatError').join(', '), function () {
      expect(view.get('invalidFormatUrlExist')).to.equal(false);
    });
  });

  describe('#isNoOsChecked', function () {
    view = App.WizardStep1View.create();

    var tests = Em.A([
      {
        operatingSystems: [
          {'isSelected': false},
          {'isSelected': false}
        ],
        e: true
      },
      {
        operatingSystems: [
          {'isSelected': true},
          {'isSelected': false}
        ],
        e: false
      },
      {
        operatingSystems: [
          {'isSelected': true},
          {'isSelected': true}
        ],
        e: false
      }
    ]);

    tests.forEach(function (test) {
      it(test.operatingSystems.mapProperty('isSelected').join(', '), function () {
        var operatingSystems = view.get('operatingSystems');
        Ember.set(operatingSystems[0], 'isSelected', test.operatingSystems[0].isSelected);
        Ember.set(operatingSystems[1], 'isSelected', test.operatingSystems[1].isSelected);
        expect(view.get('isNoOsChecked')).to.equal(test.e);
      });
    });
  });

  describe('#stacks', function () {

    var tests = Em.A([
      {
        m: 'Stack with 2 HDP',
        stacks: [
          Em.Object.create({isSelected: true, id: 'HDP-2.0.1'}),
          Em.Object.create({isSelected: false, id: 'HDP-1.3.3'})
        ],
        e: {
          names: ['HDP 2.0.1', 'HDP 1.3.3'],
          selected: [true, false]
        }
      },
      {
        m: 'No HDP',
        stacks: [],
        e: {
          names: [],
          selected: []
        }
      }
    ]);

    tests.forEach(function (test) {
      it(test.m, function () {
        view.set('controller.content.stacks', test.stacks);
        var stacks = view.get('stacks');
        expect(stacks.mapProperty('name')).to.eql(test.e.names);
        expect(stacks.mapProperty('isSelected')).to.eql(test.e.selected);
      });
    });

  });

  describe('#isSubmitDisabled', function () {

    var tests = Em.A([
      {
        invalidFormatUrlExist: false,
        isNoOsChecked: false,
        invalidUrlExist: false,
        checkInProgress: false,
        e: false
      },
      {
        invalidFormatUrlExist: true,
        isNoOsChecked: false,
        invalidUrlExist: false,
        checkInProgress: false,
        e: true
      },
      {
        invalidFormatUrlExist: false,
        isNoOsChecked: true,
        invalidUrlExist: false,
        checkInProgress: false,
        e: true
      },
      {
        invalidFormatUrlExist: false,
        isNoOsChecked: false,
        invalidUrlExist: true,
        checkInProgress: false,
        e: true
      },
      {
        invalidFormatUrlExist: true,
        isNoOsChecked: false,
        invalidUrlExist: true,
        checkInProgress: false,
        e: true
      },
      {
        invalidFormatUrlExist: true,
        isNoOsChecked: true,
        invalidUrlExist: false,
        checkInProgress: false,
        e: true
      },
      {
        invalidFormatUrlExist: false,
        isNoOsChecked: true,
        invalidUrlExist: true,
        checkInProgress: false,
        e: true
      },
      {
        invalidFormatUrlExist: true,
        isNoOsChecked: true,
        invalidUrlExist: true,
        checkInProgress: false,
        e: true
      },
      {
        invalidFormatUrlExist: true,
        isNoOsChecked: false,
        invalidUrlExist: false,
        checkInProgress: true,
        e: true
      }
    ]);

    tests.forEach(function (test) {
      it(test.invalidFormatUrlExist.toString() + ' ' + test.isNoOsChecked.toString() + ' ' + test.invalidUrlExist.toString()+ ' ' + test.checkInProgress.toString(), function () {
        view = App.WizardStep1View.create();
        view.reopen({
          invalidFormatUrlExist: test.invalidFormatUrlExist,
          isNoOsChecked: test.isNoOsChecked,
          invalidUrlExist: test.invalidUrlExist
        });
        view.set('controller', {});
        view.set('controller.content', {});
        view.set('controller.content.isCheckInProgress', test.checkInProgress);
        expect(view.get('isSubmitDisabled')).to.equal(test.e);
      });
    });
  });

  describe('#showErrorsWarningCount', function() {
    var tests = [
      {
        isSubmitDisabled: true,
        totalErrorCnt: 0,
        e: false
      },
      {
        isSubmitDisabled: true,
        totalErrorCnt: 1,
        e: true
      },
      {
        isSubmitDisabled: false,
        totalErrorCnt: 0,
        e: false
      }
    ];
    tests.forEach(function(test) {
      it(test.isSubmitDisabled.toString() + ' ' + test.totalErrorCnt.toString(), function () {
        var view = App.WizardStep1View.create();
        view.reopen({
          isSubmitDisabled: test.isSubmitDisabled,
          totalErrorCnt: test.totalErrorCnt
        });
        expect(view.get('showErrorsWarningCount')).to.equal(test.e);
      })
    });
  });

  describe('#invalidUrlExist', function () {
    var tests = Em.A([
      {
        allRepositories: [Em.Object.create({validation: 'icon-exclamation-sign'})],
        m: 'invalidCnt: 1, validation: icon-exclamation-sign',
        e: true
      },
      {
        allRepositories: [Em.Object.create({validation: ''})],
        m: 'invalidCnt: 1, validation: ""',
        e: false
      },
      {
        allRepositories: [Em.Object.create({validation: ''})],
        m: 'invalidCnt: 0, validation: ""',
        e: false
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        view = App.WizardStep1View.create();
        view.reopen({
          allRepositories: test.allRepositories
        });
        expect(view.get('invalidUrlExist')).to.equal(test.e);
      });
    });
  });

  describe('#totalErrorCnt', function () {
    var tests = Em.A([
      {
        allRepositories: [
          {}
        ],
        m: 'isNoOsChecked',
        isNoOsChecked: true,
        e: 1
      },
      {
        allRepositories: [
          {'invalidFormatError': true},
          {'invalidFormatError': true}
        ],
        isNoOsChecked: false,
        m: 'two with empty-error',
        e: 2
      },
      {
        allRepositories: [
          {'validation': 'icon-exclamation-sign'},
          {'validation': 'icon-exclamation-sign'}
        ],
        isNoOsChecked: false,
        m: 'two with validation="icon-exclamation-sign"',
        e: 2
      },
      {
        allRepositories: [
          {'invalidFormatError': true, 'validation': 'icon-exclamation-sign'},
          {'invalidFormatError': true, 'validation': 'icon-exclamation-sign'}
        ],
        isNoOsChecked: false,
        m: 'two with empty-error, two with validation="icon-exclamation-sign"',
        e: 4
      },
      {
        allRepositories: [
          {}
        ],
        isNoOsChecked: false,
        m: 'no errors/warnings etc',
        e: 0
      }
    ]);
    tests.forEach(function (test) {
      it(test.m, function () {
        view = App.WizardStep1View.create();
        view.reopen({
          isNoOsChecked: test.isNoOsChecked,
          allRepositories: test.allRepositories
        });
        expect(view.get('totalErrorCnt')).to.equal(test.e);
      });
    });
  });

  describe('#didInsertElement', function () {
    it('should create tooltip', function () {
      sinon.stub($.fn, 'tooltip', Em.K);
      view.set('isRLCollapsed', false);
      view.didInsertElement();
      expect($.fn.tooltip.calledOnce).to.equal(true);
      $.fn.tooltip.restore();
    });
  });

  describe('#stackRadioButton', function () {

    var v;
    beforeEach(function () {
      v = view.get('stackRadioButton').create({
        content: Em.Object.create({
          name: ''
        }),
        controller: Em.Object.create({
          content: Em.Object.create({
            stacks: []
          })
        })
      });
    });

    describe('#isSelected', function () {
      it('should be equal content.isSelected', function () {
        v.set('content.isSelected', true);
        expect(v.get('checked')).to.equal(true);
        v.set('content.isSelected', false);
        expect(v.get('checked')).to.equal(false);
      });
    });

    describe('#click', function () {
      it('should select proper stack', function () {
        v.set('controller.content.stacks', Em.A([Em.Object.create({id: 'n-1'}), Em.Object.create({id: 'n-2'}), Em.Object.create({id: 'n-3'})]));
        v.set('content.name', 'n 2');
        v.click();
        expect(v.get('controller.content.stacks').getEach('isSelected')).to.eql([false, true, false]);
      });
    });

  });

  describe('#popoverView', function () {

    var v;
    beforeEach(function () {
      v = view.get('popoverView').create();
      sinon.stub(App, 'popover', Em.K);
      view = App.WizardStep1View.create({'controller': controller});
      view.set('$', function () {
        return Em.Object.create({hide: Em.K, toggle: Em.K});
      });
    });

    afterEach(function () {
      App.popover.restore();
    });

    describe('#didInsertElement', function () {
      it('should create popover', function () {
        v.didInsertElement();
        expect(App.popover.calledOnce).to.equal(true);
      });
    });

  });

  describe('#onToggleBlock', function () {

    it('should toggle isRLCollapsed', function () {
      view.set('isRLCollapsed', true);
      view.onToggleBlock();
      expect(view.get('isRLCollapsed')).to.equal(false);
      view.onToggleBlock();
      expect(view.get('isRLCollapsed')).to.equal(true);
    });
  });

  describe('#updateByCheckbox', function () {

    var operatingSystems = [
      Em.Object.create({
        name: 'redhat5',
        isSelected: false,
        repositories: [Em.Object.create({
          id: 'id',
          osType: 'redhat5',
          baseUrl: 'baseUrl',
          latestBaseUrl: 'latestBaseUrl',
          validation: '',
          isSelected: false
        })
        ]
      })
    ];

    var controller = {
      content: {
        stacks: [
          Em.Object.create({
            isSelected: true,
            operatingSystems: [
              Em.Object.create({
                id: 'id',
                osType: 'redhat5',
                baseUrl: 'baseUrl',
                latestBaseUrl: 'latestBaseUrl',
                validation: '',
                isSelected: false
              })
            ]
          })
        ]
      },
      selectedStack: Em.Object.create({
        isSelected: true,
        operatingSystems: [
          Em.Object.create({
            id: 'id',
            osType: 'redhat5',
            baseUrl: 'baseUrl',
            latestBaseUrl: 'latestBaseUrl',
            validation: '',
            isSelected: true
          })
        ]
      }),
      skipValidationChecked: true
    };

    it('target group isn\'t isSelected', function () {
      view.reopen({
        operatingSystems: operatingSystems,
        controller: controller
      });
      view.updateByCheckbox();
      var targetGroup = view.get('operatingSystems.firstObject.repositories.firstObject');
      expect(targetGroup.get('baseUrl')).to.equal('latestBaseUrl');
      expect(targetGroup.get('latestBaseUrl')).to.equal('latestBaseUrl');
      expect(targetGroup.get('validation')).to.be.empty;

    });

    it('target group is isSelected, skipValidationisSelected = true', function () {
      controller.content.stacks[0].operatingSystems[0].selected = true;
      operatingSystems[0].set('isSelected', true);
      view.reopen({
        operatingSystems: operatingSystems,
        controller: controller
      });
      view.updateByCheckbox();
      var targetGroup = view.get('operatingSystems.firstObject.repositories.firstObject');
      expect(targetGroup.get('validation')).to.be.empty;
    });
  });

  describe('#clearGroupLocalRepository', function () {
    var context = {'group-number': 0, id: 'HDP-redhat5', repoId: 'HDP-redhat5', baseUrl: 'baseUrl', validation: 'validation'};
    it('should empty base url and validation', function () {
      var event = {context: Em.Object.create(context, {isSelected: true})};
      view.clearGroupLocalRepository(event);
      expect(event.context.get('baseUrl')).to.be.empty;
      expect(event.context.get('validation')).to.be.empty;
    });
    it('should do nothing if corresponding OS is not selected', function () {
      var event = {context: Em.Object.create(context, {isSelected: false})};
      view.clearGroupLocalRepository(event);
      expect(event.context.get('baseUrl')).to.equal('baseUrl');
      expect(event.context.get('validation')).to.equal('validation');
    });
  });

  describe('#undoGroupLocalRepository', function () {
    it('should reset base url and validation', function () {
      var event = {context: Em.Object.create({'group-number': 0, id: 'HDP-redhat5', repoId: 'HDP-redhat5', latestBaseUrl: 'latestBaseUrl', validation: 'validation'})};
      view.undoGroupLocalRepository(event);
      expect(event.context.get('baseUrl')).to.equal(event.context.get('latestBaseUrl'));
      expect(event.context.get('validation')).to.be.empty;
    });
  });

  describe('#editLocalRepository', function () {

    it('should update repository', function () {
      view.reopen({
        allRepositories: [
          Em.Object.create({
            isSelected: true,
            baseUrl: 'b1',
            validation: 'icon-exclamation-sign'
          })
        ]
      });
      view.editLocalRepository();
      var repository = view.get('allRepositories.firstObject');
      expect(repository.get('lastBaseUrl')).to.equal(repository.get('baseUrl'));
      expect(repository.get('validation')).to.be.empty;
    });
  });
});
});

;require.register("test/views/wizard/step2_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step2_view');

var view, controller = Em.Object.create({
  clusterNameError: ''
});

describe('App.WizardStep0View', function () {

  beforeEach(function() {
    view = App.WizardStep2View.create({'controller': controller});
  });

  describe('#sshKeyState', function() {
    it('should be equal to controller.content.installOptions.manualInstall', function() {
      controller.set('content', {installOptions: {manualInstall: false}});
      expect(view.get('sshKeyState')).to.equal(false);
      controller.toggleProperty('content.installOptions.manualInstall');
      expect(view.get('sshKeyState')).to.equal(true);
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function () {
      sinon.stub(App, 'popover', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
      view.set('controller.hostsError', 'some text');
      view.set('controller.sshKeyError', 'some text');
    });
    afterEach(function () {
      App.popover.restore();
      App.tooltip.restore();
    });
    it('should clean hostsError', function () {
      view.didInsertElement();
      expect(view.get('controller.hostsError')).to.be.null;
    });
    it('should clean sshKeyError', function () {
      view.didInsertElement();
      expect(view.get('controller.sshKeyError')).to.be.null;
    });
    it('should create popover', function () {
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
    });
    it('should create tooltip', function () {
      view.didInsertElement();
      expect(App.tooltip.calledOnce).to.equal(true);
    });
  });

  describe('#providingSSHKeyRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('providingSSHKeyRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.useSsh', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', false);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(true);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', true);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(false);
      });
    });

  });

  describe('#manualRegistrationRadioButton', function() {
    var v;

    beforeEach(function() {
      v = view.get('manualRegistrationRadioButton').create({
        controller: Em.Object.create({
          content: {
            installOptions: {
              useSsh: true,
              manualInstall: true
            }
          }
        })
      });
    });

    describe('#checked', function() {
      it('should be equal to controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        expect(v.get('checked')).to.equal(false);
        v.set('controller.content.installOptions.manualInstall', true);
        expect(v.get('checked')).to.equal(true);
      });
    });

    describe('#click', function() {
      it('should update controller.content.installOptions.useSsh', function () {
        v.set('controller.content.installOptions.useSsh', true);
        v.click();
        expect(v.get('controller.content.installOptions.useSsh')).to.equal(false);
      });
      it('should update controller.content.installOptions.manualInstall', function () {
        v.set('controller.content.installOptions.manualInstall', false);
        v.click();
        expect(v.get('controller.content.installOptions.manualInstall')).to.equal(true);
      });
    });

  });

  describe('#textFieldView', function() {
    var v;

    beforeEach(function() {
      v = view.get('textFieldView').create();
    });

    describe('#disabled', function() {
      it('should be inverted to isEnabled', function () {
        v.set('isEnabled', false);
        expect(v.get('disabled')).to.equal(true);
        v.set('isEnabled', true);
        expect(v.get('disabled')).to.equal(false);
      });
    });

  });

});

describe('App.SshKeyFileUploader', function() {

  beforeEach(function() {
    view = App.SshKeyFileUploader.create();
  });

});

});

;require.register("test/views/wizard/step3/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostLogPopupBody_view');
var view;
describe('App.WizardStep3HostLogPopupBody', function() {

  beforeEach(function() {
    view = App.WizardStep3HostLogPopupBody.create({
      parentView: Em.Object.create({
        host: Em.Object.create()
      })
    });
  });

  describe('#textArea', function() {

    var v;

    beforeEach(function() {
      v = view.get('textArea').create();
    });

    describe('#value', function() {
      it('should be equal to content', function() {
        var c = 'Relax, you are doing fine';
        v.set('content', c);
        expect(v.get('value')).to.equal(c);
      });
    });

  });

  describe('#bootLog', function() {
    it('should be equal to parentView.host.bootLog', function() {
      var log = 'i wanna play a game';
      view.set('parentView.host.bootLog', log);
      expect(view.get('bootLog')).to.equal(log);
    });
  });

});
});

;require.register("test/views/wizard/step3/hostWarningPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
var lazyloading = require('utils/lazy_loading');
require('views/wizard/step3/hostWarningPopupBody_view');
var view;

describe('App.WizardStep3HostWarningPopupBody', function() {

  beforeEach(function() {
    view = App.WizardStep3HostWarningPopupBody.create({
      didInsertElement: Em.K,
      $: function() {
        return Em.Object.create({
          toggle: Em.K
        })
      }
    });
  });

  describe('#onToggleBlock', function() {
    it('should toggle', function() {
      var context = Em.Object.create({isCollapsed: false});
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(true);
      view.onToggleBlock({context: context});
      expect(context.get('isCollapsed')).to.equal(false);
    });
  });

  describe('#showHostsPopup', function() {
    it('should call App.ModalPopup.show', function() {
      sinon.stub(App.ModalPopup, 'show', Em.K);
      view.showHostsPopup({context: []});
      expect(App.ModalPopup.show.calledOnce).to.equal(true);
      App.ModalPopup.show.restore();
    });
  });

  describe('#categoryWarnings', function() {
    it('should return empty array', function() {
      var warningsByHost = null;
      view.reopen({warningsByHost: warningsByHost});
      expect(view.get('categoryWarnings')).to.eql([]);
    });
    it('should return filtered warnings', function() {
      var warningsByHost = [
        {name: 'c', warnings: [{}, {}, {}]},
        {name: 'd', warnings: [{}]}
      ];
      view.reopen({warningsByHost: warningsByHost, category: 'c'});
      expect(view.get('categoryWarnings.length')).to.equal(3);
    });
  });

  describe('#warningHostsNamesCount', function() {
    it('should parse warnings', function() {
      view.set('bodyController', Em.Object.create({
        repoCategoryWarnings: [
          {hostsNames: ['h1', 'h4']}
        ],
        thpCategoryWarnings: [
          {hostsNames: ['h2', 'h3']}
        ],
        jdkCategoryWarnings: [
          {hostsNames: ['h3', 'h5']}
        ],
        hostCheckWarnings: [
          {hostsNames: ['h1', 'h2']}
        ],
        diskCategoryWarnings: [
          {hostsNames: ['h2', 'h5']}
        ],
        warningsByHost: [
          {},
          { name: 'h1', warnings: [{}, {}, {}] },
          { name: 'h2', warnings: [{}, {}, {}] },
          { name: 'h3', warnings: [] }
        ]
      }));
      expect(view.warningHostsNamesCount()).to.equal(5);
    });
  });

  describe('#hostSelectView', function() {

    var v;

    beforeEach(function() {
      v = view.get('hostSelectView').create();
    });

    describe('#click', function() {
      Em.A([
          {
            isLoaded: false,
            isLazyLoading: true,
            e: true
          },
          {
            isLoaded: true,
            isLazyLoading: true,
            e: false
          },
          {
            isLoaded: false,
            isLazyLoading: false,
            e: false
          },
          {
            isLoaded: true,
            isLazyLoading: false,
            e: false
          }
        ]).forEach(function (test) {
          it('isLoaded: ' + test.isLoaded.toString() + ', isLazyLoading: ' + test.isLazyLoading.toString(), function () {
            v.reopen({
              isLoaded: test.isLoaded,
              isLazyLoading: test.isLazyLoading
            });
            sinon.spy(lazyloading, 'run');
            v.click();
            if (test.e) {
              expect(lazyloading.run.calledOnce).to.equal(true);
            }
            else {
              expect(lazyloading.run.called).to.equal(false);
            }
            lazyloading.run.restore();
          });
        });
    });

  });

  describe('#contentInDetails', function() {
    var content = [
      {category: 'firewall', warnings: [{name: 'n1'}, {name: 'n2'}, {name: 'n3'}]},
      {category: 'fileFolders', warnings: [{name: 'n4'}, {name: 'n5'}, {name: 'n6'}]},
      {category: 'reverseLookup', warnings: [{name: 'n19', hosts: ["h1"], hostsLong: ["h1"]}]},
      {
        category: 'process',
        warnings: [
          {name: 'n7', hosts:['h1', 'h2'], hostsLong:['h1', 'h2'], user: 'u1', pid: 'pid1'},
          {name: 'n8', hosts:['h2'], hostsLong:['h2'], user: 'u2', pid: 'pid2'},
          {name: 'n9', hosts:['h3'], hostsLong:['h3'], user: 'u1', pid: 'pid3'}
        ]
      },
      {category: 'package', warnings: [{name: 'n10'}, {name: 'n11'}, {name: 'n12'}]},
      {category: 'service', warnings: [{name: 'n13'}, {name: 'n14'}, {name: 'n15'}]},
      {category: 'user', warnings: [{name: 'n16'}, {name: 'n17'}, {name: 'n18'}]},
      {category: 'jdk', warnings: []},
      {category: 'disk', warnings: []},
      {category: 'repositories', warnings: []},
      {category: 'hostNameResolution', warnings: []},
      {category: 'thp', warnings: []}
    ];
    beforeEach(function() {
      view.reopen({content: content, warningsByHost: [], hostNamesWithWarnings: ['c', 'd']});
    });
    it('should map hosts', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('c d')).to.equal(true);
    });
    it('should map firewall warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n1<br>n2<br>n3')).to.equal(true);
    });
    it('should map fileFolders warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n4 n5 n6')).to.equal(true);
    });
    it('should map process warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('(h1,u1,pid1)')).to.equal(true);
      expect(newContent.contains('(h2,u1,pid1)')).to.equal(true);
      expect(newContent.contains('(h2,u2,pid2)')).to.equal(true);
      expect(newContent.contains('(h3,u1,pid3)')).to.equal(true);
    });
    it('should map package warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n10 n11 n12')).to.equal(true);
    });
    it('should map service warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n13 n14 n15')).to.equal(true);
    });
    it('should map user warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('n16 n17 n18')).to.equal(true);
    });
    it('should map reverse lookup warnings', function() {
      var newContent = view.get('contentInDetails');
      expect(newContent.contains('h1')).to.equal(true);
    });
  });

  describe('#content', function () {

    it('should return array with warning objects', function () {
      view.set('bodyController', Em.Object.create({
        hostCheckWarnings: [
          {
            hosts: ['h0', 'h1', 'h2', 'h3', 'h4', 'h5', 'h5', 'h7', 'h8', 'h9', 'h10']
          }
        ],
        repoCategoryWarnings: [
          {
            hosts: ['h11', 'h12']
          }
        ],
        diskCategoryWarnings: [
          {
            hosts: ['h13']
          }
        ],
        jdkCategoryWarnings: [
          {
            hosts: ['h14']
          }
        ],
        thpCategoryWarnings: [
          {
            hosts: ['h15']
          }
        ]
      }));
      view.reopen({
        categoryWarnings: [
          {
            category: 'firewall',
            hosts: ['h16']
          },
          {
            category: 'firewall',
            hosts: ['h17']
          },
          {
            category: 'processes',
            hosts: ['h18']
          },
          {
            category: 'packages',
            hosts: ['h19']
          },
          {
            category: 'fileFolders',
            hosts: ['h20']
          },
          {
            category: 'services',
            hosts: ['h21']
          },
          {
            category: 'users',
            hosts: ['h22']
          },
          {
            category: 'misc',
            hosts: ['h23']
          },
          {
            category: 'alternatives',
            hosts: ['h24']
          },
          {
            category: 'reverseLookup',
            hosts: ['h25']
          },
          {
            category: 'reverseLookup',
            hosts: ['h26']
          },
          {
            category: 'reverseLookup',
            hosts: ['h27']
          },
          {
            category: 'reverseLookup',
            hosts: ['h28']
          },
          {
            category: 'reverseLookup',
            hosts: ['h29']
          },
          {
            category: 'reverseLookup',
            hosts: ['h30']
          },
          {
            category: 'reverseLookup',
            hosts: ['h31']
          },
          {
            category: 'reverseLookup',
            hosts: ['h32']
          },
          {
            category: 'reverseLookup',
            hosts: ['h33']
          },
          {
            category: 'reverseLookup',
            hosts: ['h34']
          },
          {
            category: 'reverseLookup',
            hosts: ['h35', 'h36']
          }
        ]
      });
      var content = view.get('content');
      expect(content.mapProperty('isCollapsed').uniq()).to.eql([true]);
      expect(content.findProperty('category', 'hostNameResolution').get('warnings')[0].hostsList).
        to.equal('h0<br>h1<br>h2<br>h3<br>h4<br>h5<br>h5<br>h7<br>h8<br>h9<br> ' + Em.I18n.t('installer.step3.hostWarningsPopup.moreHosts').format(1));
      expect(content.findProperty('category', 'repositories').get('warnings')[0].hostsList).to.equal('h11<br>h12');
      expect(content.findProperty('category', 'disk').get('warnings')[0].hostsList).to.equal('h13');
      expect(content.findProperty('category', 'jdk').get('warnings')[0].hostsList).to.equal('h14');
      expect(content.findProperty('category', 'thp').get('warnings')[0].hostsList).to.equal('h15');
      expect(content.findProperty('category', 'firewall').get('warnings').mapProperty('hostsList')).to.eql(['h16', 'h17']);
      expect(content.findProperty('category', 'process').get('warnings')[0].hostsList).to.equal('h18');
      expect(content.findProperty('category', 'package').get('warnings')[0].hostsList).to.equal('h19');
      expect(content.findProperty('category', 'fileFolders').get('warnings')[0].hostsList).to.equal('h20');
      expect(content.findProperty('category', 'service').get('warnings')[0].hostsList).to.equal('h21');
      expect(content.findProperty('category', 'user').get('warnings')[0].hostsList).to.equal('h22');
      expect(content.findProperty('category', 'misc').get('warnings')[0].hostsList).to.equal('h23');
      expect(content.findProperty('category', 'alternatives').get('warnings')[0].hostsList).to.equal('h24');
      expect(content.findProperty('category', 'reverseLookup').get('warnings').mapProperty('hostsList')).to.eql([
        'h25', 'h26', 'h27', 'h28', 'h29', 'h30', 'h31', 'h32', 'h33', 'h34', 'h35<br>h36'
      ]);
    });

  });

});
});

;require.register("test/views/wizard/step3/hostWarningPopupFooter_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step3/hostWarningPopupFooter_view');
var view;

describe('App.WizardStep3HostWarningPopupFooter', function() {

  beforeEach(function() {
    view = App.WizardStep3HostWarningPopupFooter.create();
    view.reopen({footerController: Em.Object.create()});
  });

  describe('#progressWidth', function() {
    it('based on footerController.checksUpdateProgress', function() {
      view.set('footerController.checksUpdateProgress', 42);
      expect(view.get('progressWidth')).to.equal('width:42%');
    });
  });

  describe('#isUpdateInProgress', function() {
    var tests = Em.A([
      {checksUpdateProgress: 0, e: false},
      {checksUpdateProgress: 100, e: false},
      {checksUpdateProgress: 50, e: true}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateProgress, function() {
        view.set('footerController.checksUpdateProgress', test.checksUpdateProgress);
        expect(view.get('isUpdateInProgress')).to.equal(test.e);
      });
    });
  });

  describe('#updateStatusClass', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: 'text-success'},
      {checksUpdateStatus: 'FAILED', e: 'text-error'},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatusClass')).to.be.null;
        }
        else {
          expect(view.get('updateStatusClass')).to.equal(test.e);
        }
      })
    });
  });

  describe('#updateStatus', function() {
    var tests = Em.A([
      {checksUpdateStatus: 'SUCCESS', e: Em.I18n.t('installer.step3.warnings.updateChecks.success')},
      {checksUpdateStatus: 'FAILED', e: Em.I18n.t('installer.step3.warnings.updateChecks.failed')},
      {checksUpdateStatus: 'PANIC', e: null}
    ]);
    tests.forEach(function(test) {
      it(test.checksUpdateStatus, function() {
        view.set('footerController.checksUpdateStatus', test.checksUpdateStatus);
        if (Em.isNone(test.e)) {
          expect(view.get('updateStatus')).to.be.null;
        }
        else {
          expect(view.get('updateStatus')).to.equal(test.e);
        }
      })
    });
  });

});
});

;require.register("test/views/wizard/step3_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('messages');
require('views/wizard/step3_view');
var v;
describe('App.WizardStep3View', function () {

  var view = App.WizardStep3View.create({
    monitorStatuses: function () {
    },
    content: [
      Em.Object.create({
        name: 'host1',
        bootStatus: 'PENDING',
        isChecked: false
      }),
      Em.Object.create({
        name: 'host2',
        bootStatus: 'PENDING',
        isChecked: true
      }),
      Em.Object.create({
        name: 'host3',
        bootStatus: 'PENDING',
        isChecked: true
      })
    ],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });

  describe('#watchSelection', function () {
    it('2 of 3 hosts selected', function () {
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(2);
    });
    it('all hosts selected', function () {
      view.selectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(false);
      expect(view.get('selectedHostsCount')).to.equal(3);
    });
    it('none hosts selected', function () {
      view.unSelectAll();
      view.watchSelection();
      expect(view.get('noHostsSelected')).to.equal(true);
      expect(view.get('selectedHostsCount')).to.equal(0);
    });
  });

  describe('#selectAll', function () {
    it('select all hosts', function () {
      view.selectAll();
      expect(view.get('content').everyProperty('isChecked', true)).to.equal(true);
    });
  });

  describe('#unSelectAll', function () {
    it('unselect all hosts', function () {
      view.unSelectAll();
      expect(view.get('content').everyProperty('isChecked', false)).to.equal(true);
    });
  });

  var testCases = Em.A([
    {
      title: 'none hosts',
      content: [],
      result: {
        "ALL": 0,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts RUNNING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'RUNNING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 3,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERING',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERING'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 3,
        "REGISTERED": 0,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 3,
        "FAILED": 0
      }
    },
    {
      title: 'all hosts FAILED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'FAILED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 0,
        "REGISTERED": 0,
        "FAILED": 3
      }
    },
    {
      title: 'first host is FAILED, second is RUNNING, third is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'FAILED'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'RUNNING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 1,
        "REGISTERING": 0,
        "REGISTERED": 1,
        "FAILED": 1
      }
    },
    {
      title: 'two hosts is REGISTERING, one is REGISTERED',
      content: [
        Em.Object.create({
          name: 'host1',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host2',
          bootStatus: 'REGISTERING'
        }),
        Em.Object.create({
          name: 'host3',
          bootStatus: 'REGISTERED'
        })
      ],
      result: {
        "ALL": 3,
        "RUNNING": 0,
        "REGISTERING": 2,
        "REGISTERED": 1,
        "FAILED": 0
      }
    }
  ]);

  describe('#countCategoryHosts', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content', test.content);
        view.countCategoryHosts();
        view.get('categories').forEach(function (category) {
          expect(category.get('hostsCount')).to.equal(test.result[category.get('hostsBootStatus')])
        })
      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostsBootStatus'), function () {
            view.set('content', test.content);
            view.reopen({
              selectedCategory: category
            });
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostsBootStatus')])
          });
        });
      });
    }, this);
  });

  describe('#monitorStatuses', function() {
    var tests = Em.A([
      {
        controller: Em.Object.create({bootHosts: Em.A([])}),
        m: 'Empty hosts list',
        e: {status: 'alert-warn', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: false}),
        m: 'isWarningsLoaded false',
        e: {status: 'alert-info', linkText: ''}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, isHostHaveWarnings: true}),
        m: 'isWarningsLoaded true, isHostHaveWarnings true',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, repoCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, repoCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: ['']}),
        m: 'isWarningsLoaded true, diskCategoryWarnings not empty',
        e: {status: 'alert-warn', linkText: Em.I18n.t('installer.step3.warnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty',
        e: {status: 'alert-success', linkText: Em.I18n.t('installer.step3.noWarnings.linkText')}
      },
      {
        controller: Em.Object.create({bootHosts: Em.A([{bootStatus: 'FAILED'}]), isWarningsLoaded: true, diskCategoryWarnings: [], repoCategoryWarnings: []}),
        m: 'isWarningsLoaded true, diskCategoryWarnings is empty, repoCategoryWarnings is empty, all failed',
        e: {status: 'alert-warn', linkText: ''}
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          controller: test.controller
        });
        v.monitorStatuses();
        expect(v.get('status')).to.equal(test.e.status);
        expect(v.get('linkText')).to.equal(test.e.linkText);
      });
    });
  });

  describe('#retrySelectedHosts', function() {
    it('should set active category "All"', function() {
      view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
      view.retrySelectedHosts();
      expect(view.get('categories').findProperty('hostsBootStatus', 'ALL').get('isActive')).to.equal(true);
    });
  });

  describe('#selectCategory', function() {
    var tests = Em.A(['ALL','RUNNING','REGISTERING','REGISTERED','FAILED']);
    tests.forEach(function(test) {
      it('should set active category "' + test + '"', function() {
        view.set('controller', Em.Object.create({retrySelectedHosts: Em.K, registeredHosts: []}));
        view.selectCategory({context:Em.Object.create({hostsBootStatus:test})});
        expect(view.get('categories').findProperty('hostsBootStatus', test).get('isActive')).to.equal(true);
      });
    });
  });

  describe('#countCategoryHosts', function() {
    it('should set host count for each category', function() {
      view.set('content', Em.A([
        Em.Object.create({bootStatus: 'RUNNING'}),
        Em.Object.create({bootStatus: 'REGISTERING'}),
        Em.Object.create({bootStatus: 'REGISTERED'}),
        Em.Object.create({bootStatus: 'FAILED'})
      ]));
      view.countCategoryHosts();
      expect(view.get('categories').mapProperty('hostsCount')).to.eql([4,1,1,1,1]);
    });
  });

  describe('#hostBootStatusObserver', function() {
    it('should call "Em.run.once" three times', function() {
      sinon.spy(Em.run, 'once');
      view.hostBootStatusObserver();
      expect(Em.run.once.calledThrice).to.equal(true);
      expect(Em.run.once.firstCall.args[1]).to.equal('countCategoryHosts');
      expect(Em.run.once.secondCall.args[1]).to.equal('filter');
      expect(Em.run.once.thirdCall.args[1]).to.equal('monitorStatuses');
      Em.run.once.restore();
    });
  });

  describe('#watchSelection', function() {
    describe('should set "pageChecked"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),m:'false if empty "pageContent"', e: false},
        {pageContent: Em.A([{isChecked: false}]),m:'false if not-empty "pageContent" and not all "isChecked" true', e: false},
        {pageContent: Em.A([{isChecked: true}]),m:'true if not-empty "pageContent" and all "isChecked" true', e: false}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.watchSelection();
          expect(view.get('pageChecked')).to.equal(test.e);
        });
      });
    });
    describe('should set "noHostsSelected" and "selectedHostsCount"', function() {
      var tests = Em.A([
        {pageContent: Em.A([]),content:Em.A([]),m:' - "true", "0" if content is empty',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: false})]),m:' - "true", "0" if no one isChecked',e:{selectedHostsCount: 0, noHostsSelected: true}},
        {pageContent: Em.A([]),content:Em.A([Em.Object.create({isChecked: true}),Em.Object.create({isChecked: false})]),m:' - "false", "1" if one isChecked',e:{selectedHostsCount: 1, noHostsSelected: false}}
      ]);
      tests.forEach(function(test) {
        it(test.m, function() {
          view.set('pageContent', test.pageContent);
          view.set('content', test.content);
          view.watchSelection();
          expect(view.get('noHostsSelected')).to.equal(test.e.noHostsSelected);
          expect(view.get('selectedHostsCount')).to.equal(test.e.selectedHostsCount);
        });
      });
    });
  });

  describe('#watchSelectionOnce', function() {
    it('should call "Em.run.once" one time', function() {
      sinon.spy(Em.run, 'once');
      view.watchSelectionOnce();
      expect(Em.run.once.calledOnce).to.equal(true);
      expect(Em.run.once.firstCall.args[1]).to.equal('watchSelection');
      Em.run.once.restore();
    });
  });

  describe('#selectedCategory', function() {
    it('should equal category with isActive = true', function() {
      view.get('categories').findProperty('hostsBootStatus', 'FAILED').set('isActive', true);
      expect(view.get('selectedCategory.hostsBootStatus')).to.equal('FAILED');
    });
  });

  describe('#onPageChecked', function() {
    var tests = Em.A([
      {
        selectionInProgress: true,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'shouldn\'t do nothing if selectionInProgress is true',
        e: [true, false]
      },
      {
        selectionInProgress: false,
        pageContent: [Em.Object.create({isChecked: true}), Em.Object.create({isChecked: false})],
        pageChecked: true,
        m: 'should set each isChecked to pageChecked value',
        e: [true, true]
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        v = App.WizardStep3View.create({
          'pageContent': test.pageContent,
          'pageChecked': test.pageChecked,
          'selectionInProgress': test.selectionInProgress
        });
        v.onPageChecked();
        expect(v.get('pageContent').mapProperty('isChecked')).to.eql(test.e);
      });
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      v = App.WizardStep3View.create({
        controller: Em.Object.create({
          loadStep: Em.K
        })
      });
      sinon.spy(v.get('controller'), 'loadStep');
    });
    afterEach(function() {
      v.get('controller').loadStep.restore();
    });
    it('should call loadStep', function() {
      v.didInsertElement();
      expect(v.get('controller').loadStep.calledOnce).to.equal(true);
    });
  });

  describe('#categoryObject', function() {
    var o;
    beforeEach(function() {
      v = App.WizardStep3View.create();
      o = v.get('categoryObject').create();
    });

    describe('#label', function() {
      it('should use value and hostCount', function() {
        o.setProperties({
          value: 'abc',
          hostsCount: 3
        });
        expect(o.get('label')).to.equal('abc (3)');
      });
    });

    describe('#itemClass', function() {
      it('should depends on isActive', function() {
        o.set('isActive', true);
        expect(o.get('itemClass')).to.equal('active');
        o.set('isActive', false);
        expect(o.get('itemClass')).to.equal('');
      });
    });

  });

});

var wView;
describe('App.WizardHostView', function() {

  beforeEach(function() {
    wView = App.WizardHostView.create({
      hostInfo: {},
      controller: Em.Object.create({
        removeHost: Em.K,
        retryHost: Em.K
      })
    });
    sinon.spy(wView.get('controller'), 'retryHost');
    sinon.spy(wView.get('controller'), 'removeHost');
  });

  afterEach(function() {
    wView.get('controller').retryHost.restore();
    wView.get('controller').removeHost.restore();
  });

  describe('#retry', function() {
    it('should call controller.retryHost', function() {
      wView.retry();
      expect(wView.get('controller').retryHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').retryHost.calledOnce).to.equal(true);
    });
  });

  describe('#remove', function() {
    it('should call controller.removeHost', function() {
      wView.remove();
      expect(wView.get('controller').removeHost.calledWith({})).to.equal(true);
      expect(wView.get('controller').removeHost.calledOnce).to.equal(true);
    });
  });

});

});

;require.register("test/views/wizard/step5_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('views/wizard/step5_view');
var view;

describe('App.WizardStep5View', function() {

  beforeEach(function() {
    view = App.WizardStep5View.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#didInsertElement', function() {
    it('should call controller.loadStep', function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });

  describe('#shouldUseInputs', function() {
    it('should based on hosts count', function() {
      view.set('controller.hosts', d3.range(0, 25).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.false;
      view.set('controller.hosts', d3.range(0, 26).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.true;
      view.set('controller.hosts', d3.range(0, 24).map(function() {return {};}));
      expect(view.get('shouldUseInputs')).to.be.false;
    });
  });

});

describe('App.SelectHostView', function() {
  var models = require('test/init_model_test');

  beforeEach(function() {
    view = App.SelectHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#change', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
      sinon.stub(view, 'changeHandler', Em.K);
      models.setupStackServiceComponent();
    });

    afterEach(function() {
      view.initContent.restore();
      view.changeHandler.restore();
      models.cleanStackServiceComponent();
    });

    it('should call initContent', function() {
      view.change();
      expect(view.initContent.calledOnce).to.be.true;
    });
  });

  describe('#didInsertElement', function() {

    it('should set value', function() {
      view.set('value', '');
      view.set('component', {selectedHost: 'h1'});
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', serviceComponentId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1 info');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.calledWith('ZOOKEEPER_SERVER', 'h1', 1));
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

});

describe('App.InputHostView', function() {

  beforeEach(function() {
    view = App.InputHostView.create({
      controller: App.WizardStep5Controller.create({}),
      $: function() {return {typeahead: function(){return {on: Em.K}}}},
      updateErrorStatus: Em.K
    });
  });

  describe('#didInsertElement', function() {

    beforeEach(function() {
      sinon.stub(view, 'initContent', Em.K);
      view.set('content', [Em.Object.create({host_name: 'h1', host_info: 'h1 info'})]);
      view.set('component', {selectedHost: 'h1'});
    });

    afterEach(function() {
      view.initContent.restore();
    });

    it('should call initContent', function() {
      view.didInsertElement();
      expect(view.initContent.calledOnce).to.equal(true);
    });

    it('should set selectedHost host_name to value', function() {
      view.set('value', '');
      view.didInsertElement();
      expect(view.get('value')).to.equal('h1');
    });

  });

  describe('#changeHandler', function() {

    beforeEach(function() {
      view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
      view.set('component', {component_name: 'ZOOKEEPER_SERVER', serviceComponentId: 1});
      view.set('controller.hosts', [Em.Object.create({host_info: 'h1 info', host_name: 'h1'})]);
      view.set('value', 'h1');
      view.set('controller.rebalanceComponentHostsCounter', 0);
      view.set('controller.componentToRebalance', '');
      sinon.stub(view.get('controller'), 'assignHostToMaster', Em.K);
      sinon.stub(view.get('controller'), 'updateIsHostNameValidFlag', Em.K);
      sinon.stub(view, 'shouldChangeHandlerBeCalled', function() {return true;});
    });

    afterEach(function() {
      view.get('controller').assignHostToMaster.restore();
      view.get('controller').updateIsHostNameValidFlag.restore();
      view.shouldChangeHandlerBeCalled.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('state', 'destroyed');
      expect(view.get('controller').assignHostToMaster.called).to.be.false;
    });

    it('should call assignHostToMaster', function() {
      view.changeHandler();
      expect(view.get('controller').assignHostToMaster.calledWith('ZOOKEEPER_SERVER', 'h1', 1));
    });

    it('should increment rebalanceComponentHostsCounter if component it is multiple', function() {
      view.set('component', {component_name: 'ZOOKEEPER_SERVER'});
      view.changeHandler();
      expect(view.get('controller.rebalanceComponentHostsCounter')).to.equal(1);
    });

    it('should set componentToRebalance', function() {
      view.changeHandler();
      expect(view.get('controller.componentToRebalance')).to.equal('ZOOKEEPER_SERVER');
    });

  });

  describe('#getAvailableHosts', function() {
    var tests = Em.A([
      {
        hosts: Em.A([]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Empty hosts',
        e: []
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'c1',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'c2', selectedHost: 'h1'})
        ]),
        m: 'Two hosts',
        e: ['h1', 'h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'ZOOKEEPER_SERVER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'ZOOKEEPER_SERVER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, ZOOKEEPER_SERVER',
        e: ['h2']
      },
      {
        hosts: Em.A([
          Em.Object.create({host_name: 'h1'}),
          Em.Object.create({host_name: 'h2'})
        ]),
        selectedHost: 'h2',
        componentName: 'HBASE_MASTER',
        selectedServicesMasters: Em.A([
          Em.Object.create({component_name: 'HBASE_MASTER', selectedHost: 'h1'})
        ]),
        m: 'Two hosts, HBASE_MASTER',
        e: ['h2']
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.hosts', test.hosts);
        view.get('controller').reopen({multipleComponents: ['HBASE_MASTER', 'ZOOKEEPER_SERVER']});
        view.set('component', {component_name: test.componentName});
        view.set('controller.selectedServicesMasters', test.selectedServicesMasters);
        var r = view.getAvailableHosts();
        expect(r.mapProperty('host_name')).to.eql(test.e);
      });
    });
  });

  describe('#rebalanceComponentHostsOnce', function() {
    var tests = Em.A([
      {
        componentName: 'c1',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName not equal to componentToRebalance',
        e: {
          initContent: false
        }
      },
      {
        componentName: 'c2',
        componentToRebalance: 'c2',
        content: [{}],
        m: 'componentName equal to componentToRebalance',
        e: {
          initContent: true
        }
      }
    ]);

    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('content', test.content);
        view.set('component', {component_name: test.componentName});
        view.set('controller.componentToRebalance', test.componentToRebalance);
        sinon.stub(view, 'initContent', Em.K);
        view.rebalanceComponentHostsOnce();
        expect(view.initContent.calledOnce).to.equal(test.e.initContent);
        view.initContent.restore();
      });
    });
  });

  describe('#initContent', function() {
    var tests = Em.A([
      {
        hosts: 25,
        m: 'not lazy loading, 25 hosts, no selected host',
        e: 25
      },
      {
        hosts: 25,
        h: 4,
        m: 'not lazy loading, 25 hosts, one selected host',
        e: 25
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.reopen({getAvailableHosts: function() {return d3.range(0, test.hosts).map(function(indx){return Em.Object.create({host_name: indx})});}});
        if (test.h) {
          view.set('selectedHost', test.h);
        }
        view.initContent();
        expect(view.get('content.length')).to.equal(test.e);
      });
    });
  });

  describe('#change', function() {

    beforeEach(function() {
      sinon.stub(view, 'changeHandler', Em.K);
    });

    afterEach(function() {
      view.changeHandler.restore();
    });

    it('shouldn\'t do nothing if view is destroyed', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.set('state', 'destroyed');
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(false);
    });

    it('should toggle hostNameCheckTrigger', function() {
      view.set('controller.hostNameCheckTrigger', false);
      view.change();
      expect(view.get('controller.hostNameCheckTrigger')).to.equal(true);
    });

  });

});

describe('App.RemoveControlView', function() {

  beforeEach(function() {
    view = App.RemoveControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {
    beforeEach(function() {
      sinon.stub(view.get('controller'), 'removeComponent', Em.K);
    });
    afterEach(function() {
      view.get('controller').removeComponent.restore();
    });
    it('should call removeComponent', function() {
      view.set('serviceComponentId', 1);
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').removeComponent.calledWith('c1', 1)).to.equal(true);
    });
  });

});

describe('App.AddControlView', function() {

  beforeEach(function() {
    view = App.AddControlView.create({
      controller: App.WizardStep5Controller.create({})
    });
  });

  describe('#click', function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'addComponent', Em.K);
    });

    afterEach(function() {
      view.get('controller').addComponent.restore();
    });

    it('should call addComponent', function() {
      view.set('componentName', 'c1');
      view.click();
      expect(view.get('controller').addComponent.calledWith('c1')).to.equal(true);
    });

  });

});

});

;require.register("test/views/wizard/step6_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step6_view');
var view;

describe('App.WizardStep6View', function() {

  beforeEach(function() {
    view = App.WizardStep6View.create({
      controller: App.WizardStep6Controller.create()
    });
  });

  describe('#content', function() {
    it('should be same to controller.hosts', function() {
      view.set('content', []);
      var d = [{}, {}];
      view.set('controller.hosts', d);
      expect(view.get('content')).to.eql(d);
    });
  });

  describe('#filteredContent', function() {
    it('should be same to content', function() {
      view.set('content', []);
      var d = [{}, {}];
      view.set('controller.hosts', d);
      expect(view.get('filteredContent')).to.eql(d);
    });
  });

  describe('#didInsertElement', function() {

    beforeEach(function() {
      sinon.stub(view.get('controller'), 'loadStep', Em.K);
      sinon.stub(App, 'tooltip', Em.K);
      sinon.stub(view, 'setLabel', Em.K);
    });

    afterEach(function() {
      view.get('controller').loadStep.restore();
      App.tooltip.restore();
      view.setLabel.restore();
    });

    it('should call loadStep', function() {
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
    });

    it('should call setLabel if not controller.isMasters', function() {
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(view.setLabel.calledOnce).to.equal(true);
    });

  });

  describe('#setLabel', function() {
    var tests = Em.A([
      {
        clients: [{display_name: 'c1'}],
        m: 'One client',
        e: 'c1'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}],
        m: 'Two clients',
        e: 'c1 and c2.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}],
        m: 'Three clients',
        e: 'c1, c2 and c3.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}],
        m: 'Four clients',
        e: 'c1, c2, c3 and c4.'
      },
      {
        clients: [{display_name: 'c1'}, {display_name: 'c2'}, {display_name: 'c3'}, {display_name: 'c4'}, {display_name: 'c5'}],
        m: 'Five clients',
        e: 'c1, c2, c3, c4 and c5.'
      }
    ]);
    tests.forEach(function(test) {
      it(test.m, function() {
        view.set('controller.content', {clients: test.clients});
        view.setLabel();
        expect(view.get('label').endsWith(test.e)).to.equal(true);
      });
    });
  });

});

describe('App.WizardStep6HostView', function() {

  beforeEach(function() {
    view = App.WizardStep6HostView.create({
      controller: App.WizardStep6Controller.create()
    });
  });

  describe('#didInsertElement', function() {
    beforeEach(function() {
      sinon.stub(App, 'popover', Em.K);
    });
    afterEach(function() {
      App.popover.restore();
    });
    it('should create popover if not controller.isMasters', function() {
      sinon.stub(view.get('controller'), 'getMasterComponentsForHost', function() {return [{}, {}];});
      view.set('controller.isMasters', false);
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
      view.get('controller').getMasterComponentsForHost.restore();
    });
    it('should create popover even if controller.getMasterComponentsForHost is an empty array', function() {
      sinon.stub(view.get('controller'), 'getMasterComponentsForHost', function() {return [];});
      view.set('controller.isMasters', true);
      view.didInsertElement();
      expect(App.popover.calledOnce).to.equal(true);
      view.get('controller').getMasterComponentsForHost.restore();
    });
  });

});
});

;require.register("test/views/wizard/step8_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */


var App = require('app');
require('utils/helper');
require('utils/string_utils');
require('views/wizard/step8_view');
var view;

describe('App.WizardStep8View', function() {

  beforeEach(function() {
    view = App.WizardStep8View.create();
  });

  describe('#didInsertElement', function() {
    it('should call loadStep', function() {
      view.set('controller', Em.Object.create({
        loadStep: Em.K
      }));
      sinon.spy(view.get('controller'), 'loadStep');
      view.didInsertElement();
      expect(view.get('controller').loadStep.calledOnce).to.equal(true);
      view.get('controller').loadStep.restore();
    });
  });

  describe('#printReview', function() {
    it('should call jqprint', function() {
      sinon.stub($.fn, 'jqprint', Em.K);
      view.printReview();
      expect($.fn.jqprint.calledOnce).to.equal(true);
      $.fn.jqprint.restore();
    });
  });

});
});

;require.register("test/views/wizard/step9/hostLogPopupBody_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9/hostLogPopupBody_view');
var view;

describe('App.WizardStep9HostLogPopupBodyView', function() {

  beforeEach(function() {
    view = App.WizardStep9HostLogPopupBodyView.create({
      parentView: Em.Object.create({
        host: Em.Object.create()
      })
    });
  });

  describe('#isHeartbeatLost', function() {
    it('should depends on parentView.host.status', function() {
      view.set('parentView.host.status', 'success');
      expect(view.get('isHeartbeatLost')).to.equal(false);
      view.set('parentView.host.status', 'heartbeat_lost');
      expect(view.get('isHeartbeatLost')).to.equal(true);
    });
  });

  describe('#isNoTasksScheduled', function() {
    it('should be same to parentView.host.isNoTasksForInstall', function() {
      view.set('parentView.host.isNoTasksForInstall', true);
      expect(view.get('isNoTasksScheduled')).to.equal(true);
      view.set('parentView.host.isNoTasksForInstall', false);
      expect(view.get('isNoTasksScheduled')).to.equal(false);
    });
  });

  describe('#visibleTasks', function() {
    Em.A([
        {
          value: 'pending',
          f: ['pending', 'queued']
        },
        {
          value: 'in_progress',
          f: ['in_progress']
        },
        {
          value: 'failed',
          f: ['failed']
        },
        {
          value: 'completed',
          f: ['completed']
        },
        {
          value: 'aborted',
          f: ['aborted']
        },
        {
          value: 'timedout',
          f: ['timedout']
        },
        {
          value: 'all'
        }
      ]).forEach(function(test) {
        it(test.value, function() {
          view.reopen({
            category: Em.Object.create({value: test.value}),
            tasks: Em.A([
              {status: 'pending', isVisible: false},
              {status: 'queued', isVisible: false},
              {status: 'in_progress', isVisible: false},
              {status: 'failed', isVisible: false},
              {status: 'completed', isVisible: false},
              {status: 'aborted', isVisible: false},
              {status: 'timedout', isVisible: false}
            ])
          });
          view.visibleTasks();
          var visibleTasks = view.get('tasks').filter(function(task) {
            if (test.f) {
              return test.f.contains(task.status);
            }
            return true;
          });
          expect(visibleTasks.everyProperty('isVisible', true)).to.equal(true);
        });
    });
  });

  describe('#backToTaskList', function() {
    it('should call destroyClipBoard', function() {
      sinon.stub(view, 'destroyClipBoard', Em.K);
      view.backToTaskList();
      expect(view.destroyClipBoard.calledOnce).to.equal(true);
      view.destroyClipBoard.restore();
    });
    it('should set isLogWrapHidden to true', function() {
      view.set('isLogWrapHidden', false);
      view.backToTaskList();
      expect(view.get('isLogWrapHidden')).to.equal(true);
    });
  });

  describe('#getStartedTasks', function() {
    it('should return tasks with some status', function() {
      var logTasks = Em.A([
        {Tasks: {}}, {Tasks: {status: 's'}}, {Tasks: {status: null}}, {Tasks: {status: 'v'}}
      ]);
      expect(view.getStartedTasks({logTasks: logTasks}).length).to.equal(2);
    });
  });

  describe('#openedTask', function() {
    it('should return currently open task', function() {
      var task = Em.Object.create({id: 2});
      view.reopen({
        tasks: Em.A([
          Em.Object.create({id: 1}),
          Em.Object.create({id: 3}),
          task,
          Em.Object.create({id: 4})
        ])
      });
      view.set('parentView.c', {currentOpenTaskId: 2});
      expect(view.get('openedTask.id')).to.equal(2);
    });
  });

  describe('#tasks', function() {
    var testTask = {
      Tasks: {
        status: 'init',
        id: 1,
        request_id: 2,
        role: 'PIG',
        stderr: 'stderr',
        stdout: 'stdout',
        host_name: 'host1',
        command: 'Cmd',
        command_detail: 'TEST SERVICE/COMPONENT_DESCRIPTION'
      }
    };

    it('should map tasks', function() {
      view.set('parentView.host.logTasks', [testTask]);
      var t = view.get('tasks');
      expect(t.length).to.equal(1);
      var first = t[0];
      expect(first.get('id')).to.equal(1);
      expect(first.get('requestId')).to.equal(2);
      expect(first.get('command')).to.equal('cmd');
      expect(first.get('commandDetail')).to.equal(' Test Component Description');
      expect(first.get('role')).to.equal('Pig');
      expect(first.get('stderr')).to.equal('stderr');
      expect(first.get('stdout')).to.equal('stdout');
      expect(first.get('isVisible')).to.equal(true);
      expect(first.get('hostName')).to.equal('host1');
    });

    it('should set cog icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'pending';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cog');
    });

    it('should set cog icon (2)', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'queued';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cog');
    });

    it('should set cogs icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'in_progress';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-cogs');
    });

    it('should set ok icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'completed';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-ok');
    });

    it('should set icon-exclamation-sign icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'failed';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-exclamation-sign');
    });

    it('should set minus icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'aborted';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-minus');
    });

    it('should set time icon', function() {
      var t = Em.copy(testTask);
      t.Tasks.status = 'timedout';
      view.set('parentView.host.logTasks', [t]);
      var first = view.get('tasks')[0];
      expect(first.get('icon')).to.equal('icon-time');
    });

  });

  describe('#toggleTaskLog', function() {
    it('isLogWrapHidden is true', function() {
      var taskInfo = {
        id: 1,
        requestId: 2
      };
      view.set('isLogWrapHidden', true);
      view.set('parentView.c', Em.Object.create({loadCurrentTaskLog: Em.K}));
      sinon.spy(view.get('parentView.c'), 'loadCurrentTaskLog');
      view.toggleTaskLog({context: taskInfo});
      expect(view.get('isLogWrapHidden')).to.equal(false);
      expect(view.get('parentView.c.currentOpenTaskId')).to.equal(taskInfo.id);
      expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(taskInfo.requestId);
      expect(view.get('parentView.c').loadCurrentTaskLog.calledOnce).to.equal(true);
      view.get('parentView.c').loadCurrentTaskLog.restore();
    });
    it('isLogWrapHidden is false', function() {
      var taskInfo = {};
      view.set('isLogWrapHidden', false);
      view.set('parentView.c', Em.Object.create({loadCurrentTaskLog: Em.K}));
      view.toggleTaskLog({context: taskInfo});
      expect(view.get('isLogWrapHidden')).to.equal(true);
      expect(view.get('parentView.c.currentOpenTaskId')).to.equal(0);
      expect(view.get('parentView.c.currentOpenTaskRequestId')).to.equal(0);
    });
  });

});
});

;require.register("test/views/wizard/step9_view_test", function(exports, require, module) {
/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

var App = require('app');
require('views/wizard/step9_view');

var v;
describe('App.WizardStep9View', function () {
  beforeEach(function () {
    v = App.WizardStep9View.create({
      controller: App.WizardStep9Controller.create()
    });
  });
  var view = App.WizardStep9View.create({
    onStatus: function () {
    },
    content: [],
    pageContent: function () {
      return this.get('content');
    }.property('content')
  });
  var testCases = [
    {
      title: 'none hosts',
      content: [],
      result: {
        "all": 0,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts inProgress',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'info'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'pending'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 3,
        "warning": 0,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts warning',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'warning'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 3,
        "success": 0,
        "failed": 0
      }
    },
    {
      title: 'all hosts success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 3,
        "failed": 0
      }
    },
    {
      title: 'all hosts failed',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'heartbeat_lost'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 0,
        "success": 0,
        "failed": 3
      }
    },
    {
      title: 'first host is failed, second is warning, third is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'failed'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'success'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'warning'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 0,
        "warning": 1,
        "success": 1,
        "failed": 1
      }
    },
    {
      title: 'two hosts is inProgress, one is success',
      content: [
        Em.Object.create({
          name: 'host1',
          status: 'pending'
        }),
        Em.Object.create({
          name: 'host2',
          status: 'in_progress'
        }),
        Em.Object.create({
          name: 'host3',
          status: 'success'
        })
      ],
      result: {
        "all": 3,
        "inProgress": 2,
        "warning": 0,
        "success": 1,
        "failed": 0
      }
    }
  ];

  describe('#countCategoryHosts', function () {
    testCases.forEach(function (test) {
      it(test.title, function () {
        view.set('content', test.content);
        view.countCategoryHosts();
        view.get('categories').forEach(function (category) {
          expect(category.get('hostsCount')).to.equal(test.result[category.get('hostStatus')])
        })
      });
    }, this);
  });

  describe('#doFilter', function () {
    testCases.forEach(function (test) {
      describe(test.title, function () {
        view.get('categories').forEach(function (category) {
          it('. Selected category - ' + category.get('hostStatus'), function () {
            view.set('content', test.content);
            view.reopen({selectedCategory: category});
            view.doFilter();
            expect(view.get('filteredContent').length).to.equal(test.result[category.get('hostStatus')])
          });
        })
      });
    }, this);
  });

  describe('#isStepCompleted', function () {
    it('should be true if progress is 100', function () {
      v.set('controller.progress', '100');
      expect(v.get('isStepCompleted')).to.equal(true);
    });
    it('should be false if progress isn\'t 100', function () {
      v.set('controller.progress', '50');
      expect(v.get('isStepCompleted')).to.equal(false);
    });
  });

  describe('#content', function () {
    it('should be equal to controller.hosts', function () {
      sinon.stub(v, 'hostStatusObserver', Em.K);
      var hosts = [
        {},
        {},
        {}
      ];
      v.set('controller.hosts', hosts);
      expect(v.get('content')).to.eql(hosts);
      v.hostStatusObserver.restore();
    });
  });

  describe('#categoryObject', function () {
    it('label should contains value and hostsCount', function () {
      var value = 'v',
        hostsCount = 10,
        o = v.get('categoryObject').create({value: value, hostsCount: hostsCount});
      expect(o.get('label')).to.equal(value + ' (' + hostsCount + ')');
    });
    it('itemClass should depends on isActive', function () {
      var o = v.get('categoryObject').create();
      o.set('isActive', false);
      expect(o.get('itemClass')).to.equal('');
      o.set('isActive', true);
      expect(o.get('itemClass')).to.equal('active');
    });
  });

  describe('#isHostHeartbeatLost', function () {
    Em.A([
        {
          hostsWithHeartbeatLost: [],
          m: 'should be false if hostsWithHeartbeatLost is empty',
          e: false
        },
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          m: 'should be true if hostsWithHeartbeatLost contains some values',
          e: true
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          expect(v.get('isHostHeartbeatLost')).to.equal(test.e);
        })
      });
  });

  describe('#barWidth', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('barWidth')).to.equal('width: ' + w + '%;');
    });
  });

  describe('#progressMessage', function () {
    it('should depends on controller.progress', function () {
      var w = '25';
      v.set('controller.progress', w);
      expect(v.get('progressMessage').contains(w)).to.equal(true);
    });
  });

  describe('#showAllHosts', function () {
    it('should set active to category with all hosts', function () {
      v.get('categories').findProperty('hostStatus', 'inProgress').set('isActive', true);
      v.showAllHosts();
      var allCategory = v.get('categories').findProperty('hostStatus', 'all');
      expect(allCategory.get('isActive')).to.equal(true);
      expect(v.get('categories').without(allCategory).everyProperty('isActive', false)).to.equal(true);
    });
  });

  describe('#didInsertElement', function () {
    beforeEach(function () {
      sinon.stub(v, 'onStatus', Em.K);
      sinon.stub(v.get('controller'), 'navigateStep', Em.K);
    });
    afterEach(function () {
      v.onStatus.restore();
      v.get('controller').navigateStep.restore();
    });
    it('should call onStatus', function () {
      v.didInsertElement();
      expect(v.onStatus.calledOnce).to.equal(true);
    });
    it('should call navigateStep', function () {
      v.didInsertElement();
      expect(v.get('controller').navigateStep.calledOnce).to.equal(true);
    });
  });

  describe('#selectCategory', function () {
    it('should set isActive true to selected category', function () {
      var event = {context: Em.Object.create({hostStatus: 'inProgress'})},
        c = v.get('categories').findProperty('hostStatus', 'inProgress');
      c.set('isActive', false);
      v.selectCategory(event);
      expect(c.get('isActive')).to.equal(true);
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          status: 'success',
          e: {
            barColor: 'progress-success',
            resultMsg: Em.I18n.t('installer.step9.status.success'),
            resultMsgColor: 'alert-success'
          }
        },
        {
          status: 'info',
          e: {
            barColor: 'progress-info',
            resultMsg: ''
          }
        },
        {
          status: 'warning',
          e: {
            barColor: 'progress-warning',
            resultMsg: Em.I18n.t('installer.step9.status.warning'),
            resultMsgColor: 'alert-warning'
          }
        },
        {
          status: 'failed',
          e: {
            barColor: 'progress-danger',
            resultMsgColor: 'alert-error'
          }
        }
      ]).forEach(function (test) {
        it(test.status, function () {
          v.set('controller.status', test.status);
          v.onStatus();
          Em.keys(test.e).forEach(function (k) {
            expect(v.get(k)).to.equal(test.e[k]);
          });
        });
      });
    Em.A([
        {
          hostsWithHeartbeatLost: [
            {},
            {}
          ],
          startCallFailed: false,
          m: 'heartbeat lost for 2 hosts',
          resultMsg: Em.I18n.t('installer.step9.status.hosts.heartbeat_lost').format(2)
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: true,
          m: 'heartbeat not lost, startCallFailed true',
          resultMsg: Em.I18n.t('installer.step9.status.start.services.failed')
        },
        {
          hostsWithHeartbeatLost: [],
          startCallFailed: false,
          m: 'heartbeat not lost, startCallFailed false',
          resultMsg: Em.I18n.t('installer.step9.status.failed')
        }
      ]).forEach(function (test) {
        it(test.m, function () {
          v.set('controller.hostsWithHeartbeatLost', test.hostsWithHeartbeatLost);
          v.set('controller.startCallFailed', test.startCallFailed);
          v.set('controller.status', 'failed');
          v.onStatus();
          expect(v.get('resultMsg')).to.equal(test.resultMsg);
        });
      });
  });

  describe('#hostWithInstallFailed', function () {
    it('popup property failedHosts should be equal to hostsWithHeartbeatLost', function () {
      var hostsWithHeartbeatLost = [
        {},
        {}
      ];
      v.set('controller.hostsWithHeartbeatLost', hostsWithHeartbeatLost);
      var body = v.hostWithInstallFailed().get('bodyClass').create();
      expect(body.get('failedHosts')).to.eql(hostsWithHeartbeatLost);
    });
  });

});

var hv;
describe('App.HostStatusView', function () {
  beforeEach(function () {
    hv = App.HostStatusView.create();
  });
  var tests = [
    {
      p: 'isFailed',
      tests: [
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isSuccess',
      tests: [
        {
          obj: {
            status: 'success',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    },
    {
      p: 'isWarning',
      tests: [
        {
          obj: {
            status: 'warning',
            progress: 100
          },
          e: true
        },
        {
          obj: {
            status: 'warning',
            progress: 99
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 100
          },
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: 99
          },
          e: false
        }
      ]
    }
  ];
  tests.forEach(function (test) {
    describe(test.p, function () {
      test.tests.forEach(function (t) {
        var hostStatusView = App.HostStatusView.create();
        it('obj.progress = ' + t.obj.progress + '; obj.status = ' + t.obj.status, function () {
          hostStatusView.set('obj', t.obj);
          expect(hostStatusView.get(test.p)).to.equal(t.e);
        });
      });
    });
  });

  describe('#barWidth', function () {
    it('should depends of obj.progress', function () {
      hv.set('obj', {progress: '25'});
      expect(hv.get('barWidth')).to.equal('width: 25%;');
    });
  });

  describe('#didInsertElement', function () {
    it('should call onStatus', function () {
      sinon.stub(hv, 'onStatus', Em.K);
      hv.didInsertElement();
      expect(hv.onStatus.calledOnce).to.equal(true);
      hv.onStatus.restore();
    });
  });

  describe('#onStatus', function () {
    Em.A([
        {
          obj: {
            status: 'info'
          },
          e: {
            barColor: 'progress-info'
          }
        },
        {
          obj: {
            status: 'warning'
          },
          e: {
            barColor: 'progress-warning'
          }
        },
        {
          obj: {
            status: 'warning',
            progress: '100'
          },
          e: {
            barColor: 'progress-warning',
            'obj.message': Em.I18n.t('installer.step9.host.status.warning')
          }
        },
        {
          obj: {
            status: 'failed'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.status.failed')
          }
        },
        {
          obj: {
            status: 'heartbeat_lost'
          },
          e: {
            barColor: 'progress-danger'
          }
        },
        {
          obj: {
            status: 'heartbeat_lost',
            progress: '100'
          },
          e: {
            barColor: 'progress-danger',
            'obj.message': Em.I18n.t('installer.step9.host.heartbeat_lost')
          }
        }
      ]).forEach(function (test) {
        it(JSON.stringify(test.obj), function () {
          hv.set('obj', test.obj);
          hv.onStatus();
          Em.keys(test.e).forEach(function (k) {
            expect(hv.get(k)).to.equal(test.e[k]);
          });
        });
      });
    Em.A([
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '35',
          e: true
        },
        {
          obj: {
            status: 'success',
            progress: '100'
          },
          progress: '34',
          e: false
        },
        {
          obj: {
            status: 'success',
            progress: '99'
          },
          progress: '35',
          e: false
        },
        {
          obj: {
            status: 'failed',
            progress: '100'
          },
          progress: '35',
          e: false
        }
      ]).forEach(function (test) {
        it(JSON.stringify(test.obj) + ' ' + test.progress, function() {
          hv.set('barColor', '');
          hv.set('obj', test.obj);
          hv.set('obj.message', '');
          hv.set('controller', {progress: test.progress});
          hv.onStatus();
          expect(hv.get('obj.message') === Em.I18n.t('installer.step9.host.status.success')).to.equal(test.e);
          expect(hv.get('barColor') === 'progress-success').to.equal(test.e);
        });
      });
  });

  describe('#hostLogPopup', function() {
    describe('#onClose', function() {
      beforeEach(function() {
        hv.set('controller', {currentOpenTaskId: 123});
        hv.set('obj', Em.Object.create());
      });
      it('popup should clear currentOpenTaskId', function() {
        hv.hostLogPopup().onClose();
        expect(hv.get('controller.currentOpenTaskId')).to.equal(0);
      });
      it('onClose popup should hide popup', function() {
        var p = hv.hostLogPopup();
        sinon.spy(p, 'hide');
        p.onClose();
        expect(p.hide.calledOnce).to.equal(true);
      });
    });
  });

});

});

;